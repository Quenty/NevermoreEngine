"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[39125],{40294:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"architecture/patterns","title":"Core Patterns","description":"Beyond ServiceBag, Nevermore uses several patterns that appear throughout the codebase. Understanding these makes it much easier to read and write Nevermore code.","source":"@site/docs/architecture/patterns.md","sourceDirName":"architecture","slug":"/architecture/patterns","permalink":"/NevermoreEngine/docs/architecture/patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/Quenty/NevermoreEngine/edit/main/docs/architecture/patterns.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Core Patterns","sidebar_position":3},"sidebar":"defaultSidebar","previous":{"title":"Design","permalink":"/NevermoreEngine/docs/architecture/design"},"next":{"title":"Contributing","permalink":"/NevermoreEngine/docs/build"}}');var r=t(74848),a=t(28453);const i={title:"Core Patterns",sidebar_position:3},c="Core Patterns",o={},d=[{value:"Maid",id:"maid",level:2},{value:"BaseObject",id:"baseobject",level:2},{value:"Binder",id:"binder",level:2},{value:"Rx (Observables)",id:"rx-observables",level:2},{value:"Brio",id:"brio",level:2},{value:"Blend",id:"blend",level:2},{value:"AdorneeData",id:"adorneedata",level:2},{value:"TieDefinition",id:"tiedefinition",level:2},{value:"How the patterns fit together",id:"how-the-patterns-fit-together",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"core-patterns",children:"Core Patterns"})}),"\n",(0,r.jsxs)(n.p,{children:["Beyond ",(0,r.jsx)(n.a,{href:"/NevermoreEngine/docs/architecture/servicebag",children:"ServiceBag"}),", Nevermore uses several patterns that appear throughout the codebase. Understanding these makes it much easier to read and write Nevermore code."]}),"\n",(0,r.jsx)(n.h2,{id:"maid",children:"Maid"}),"\n",(0,r.jsx)(n.p,{children:"A resource cleanup manager that tracks tasks \u2014 functions, connections, Instances, threads \u2014 and cleans them all up at once. Central to Nevermore's lifecycle model."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local maid = Maid.new()\n\n-- Track a connection\nmaid:GiveTask(workspace.ChildAdded:Connect(function(child)\n\tprint("Child:", child.Name)\nend))\n\n-- Track a cleanup function\nmaid:GiveTask(function()\n\tprint("Cleaning up!")\nend)\n\n-- Named tasks auto-replace: assigning a new value cleans the old one\nmaid._character = workspace:FindFirstChild("OldCharacter")\nmaid._character = workspace:FindFirstChild("NewCharacter") -- OldCharacter destroyed\n\nmaid:DoCleaning() -- Disconnects, destroys, and runs everything\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key API:"})," ",(0,r.jsx)(n.code,{children:"Maid.new()"}),", ",(0,r.jsx)(n.code,{children:":GiveTask(task)"}),", ",(0,r.jsx)(n.code,{children:":Add(task)"}),", ",(0,r.jsx)(n.code,{children:"maid[key] = task"})," (named), ",(0,r.jsx)(n.code,{children:":DoCleaning()"})," / ",(0,r.jsx)(n.code,{children:":Destroy()"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"When to use:"})," Any time you create connections, spawn threads, or instantiate objects that need cleanup. Almost every class uses one."]}),"\n",(0,r.jsx)(n.h2,{id:"baseobject",children:"BaseObject"}),"\n",(0,r.jsxs)(n.p,{children:["A lightweight base class that gives you a ",(0,r.jsx)(n.code,{children:"_maid"})," and optional ",(0,r.jsx)(n.code,{children:"_obj"})," reference for free. Nearly all Nevermore classes inherit from it."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local MyClass = setmetatable({}, BaseObject)\nMyClass.ClassName = "MyClass"\nMyClass.__index = MyClass\n\nfunction MyClass.new(obj)\n\tlocal self = setmetatable(BaseObject.new(obj), MyClass)\n\n\tself._maid:GiveTask(workspace.ChildAdded:Connect(function(child)\n\t\tprint("Child added:", child)\n\tend))\n\n\treturn self\nend\n\nlocal instance = MyClass.new()\ninstance:Destroy() -- Cleans up the maid and everything it tracks\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key API:"})," ",(0,r.jsx)(n.code,{children:"BaseObject.new(obj?)"}),", ",(0,r.jsx)(n.code,{children:"self._maid"}),", ",(0,r.jsx)(n.code,{children:"self._obj"}),", ",(0,r.jsx)(n.code,{children:":Destroy()"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"When to use:"})," As the base class for any object that manages resources. Prefer this over writing your own constructor/destructor boilerplate."]}),"\n",(0,r.jsx)(n.h2,{id:"binder",children:"Binder"}),"\n",(0,r.jsxs)(n.p,{children:["Automatically instantiates and manages a class for every Roblox Instance tagged with a specific ",(0,r.jsx)(n.a,{href:"https://create.roblox.com/docs/reference/engine/classes/CollectionService",children:"CollectionService"})," tag. When a tag is added, the class is created; when removed, it's destroyed."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local MyEffect = setmetatable({}, BaseObject)\nMyEffect.ClassName = "MyEffect"\nMyEffect.__index = MyEffect\n\nfunction MyEffect.new(instance, serviceBag)\n\tlocal self = setmetatable(BaseObject.new(instance), MyEffect)\n\n\tself._serviceBag = assert(serviceBag, "No serviceBag")\n\n\t-- React to the tagged instance\n\tself._maid:GiveTask(instance:GetPropertyChangedSignal("Color"):Connect(function()\n\t\tprint("Color changed on", instance.Name)\n\tend))\n\n\treturn self\nend\n\n-- In a BinderProvider or service:\nlocal binder = Binder.new("MyEffect", require("MyEffect"), serviceBag)\nbinder:Start()\n\n-- Tag an instance to bind it\nbinder:Bind(workspace.SomePart)\n\n-- Query bound classes\nlocal effect = binder:Get(workspace.SomePart)\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key API:"})," ",(0,r.jsx)(n.code,{children:"Binder.new(tag, class, ...)"}),", ",(0,r.jsx)(n.code,{children:":Start()"}),", ",(0,r.jsx)(n.code,{children:":Bind(instance)"}),", ",(0,r.jsx)(n.code,{children:":Get(instance)"}),", ",(0,r.jsx)(n.code,{children:":GetAll()"}),", ",(0,r.jsx)(n.code,{children:":GetClassAddedSignal()"}),", ",(0,r.jsx)(n.code,{children:":ObserveBrio(instance)"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"When to use:"})," When behavior should be attached to tagged Roblox Instances \u2014 NPCs, buttons, damage zones, visual effects, etc. The constructor receives ",(0,r.jsx)(n.code,{children:"(instance, serviceBag)"})," so bound classes have full access to dependency injection."]}),"\n",(0,r.jsx)(n.h2,{id:"rx-observables",children:"Rx (Observables)"}),"\n",(0,r.jsx)(n.p,{children:"A reactive stream library inspired by RxJS. Observables emit values over time; operators transform, filter, and combine them."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Create and transform\nRx.of(1, 2, 3):Pipe({\n\tRx.map(function(x) return x * 2 end),\n\tRx.where(function(x) return x > 2 end),\n}):Subscribe(function(value)\n\tprint(value) --\x3e 4, 6\nend)\n\n-- Combine multiple sources\nRx.combineLatest({\n\thealth = Rx.fromSignal(humanoid:GetPropertyChangedSignal("Health")),\n\tmaxHealth = Rx.fromSignal(humanoid:GetPropertyChangedSignal("MaxHealth")),\n}):Subscribe(function(data)\n\tprint(data.health, data.maxHealth)\nend)\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key creation:"})," ",(0,r.jsx)(n.code,{children:"Rx.of(...)"}),", ",(0,r.jsx)(n.code,{children:"Rx.fromSignal(signal)"}),", ",(0,r.jsx)(n.code,{children:"Rx.fromPromise(promise)"}),", ",(0,r.jsx)(n.code,{children:"Rx.combineLatest({...})"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Key operators (pass to ",(0,r.jsx)(n.code,{children:":Pipe()"}),"):"]})," ",(0,r.jsx)(n.code,{children:"Rx.map(fn)"}),", ",(0,r.jsx)(n.code,{children:"Rx.where(predicate)"}),", ",(0,r.jsx)(n.code,{children:"Rx.flatMap(fn)"}),", ",(0,r.jsx)(n.code,{children:"Rx.switchMap(fn)"}),", ",(0,r.jsx)(n.code,{children:"Rx.tap(fn)"}),", ",(0,r.jsx)(n.code,{children:"Rx.cache()"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"When to use:"})," For event-driven, time-varying data \u2014 combining multiple signals, filtering events, transforming streams. Prefer over manually wiring up connections when the logic involves more than one source."]}),"\n",(0,r.jsx)(n.h2,{id:"brio",children:"Brio"}),"\n",(0,r.jsx)(n.p,{children:"A lifetime-scoped wrapper for a value. When the Brio is killed, consumers know the value is no longer valid. Prevents use-after-free bugs in reactive streams."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local brio = Brio.new(workspace.SomePart)\n\nbrio:GetDiedSignal():Connect(function()\n\tprint("Resource is no longer valid")\nend)\n\nif not brio:IsDead() then\n\tlocal part = brio:GetValue()\n\tprint(part.Name)\nend\n\nbrio:Kill() --\x3e "Resource is no longer valid"\n-- brio:GetValue() would now error\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key API:"})," ",(0,r.jsx)(n.code,{children:"Brio.new(...)"}),", ",(0,r.jsx)(n.code,{children:":GetValue()"}),", ",(0,r.jsx)(n.code,{children:":IsDead()"}),", ",(0,r.jsx)(n.code,{children:":Kill()"})," / ",(0,r.jsx)(n.code,{children:":Destroy()"}),", ",(0,r.jsx)(n.code,{children:":GetDiedSignal()"}),", ",(0,r.jsx)(n.code,{children:":ToMaid()"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"When to use:"})," When emitting objects from Observables that have a limited lifetime. Binder's ",(0,r.jsx)(n.code,{children:":ObserveBrio()"})," returns ",(0,r.jsx)(n.code,{children:"Observable<Brio<T>>"})," \u2014 this is the canonical use case. Essential for safely passing resources through reactive pipelines."]}),"\n",(0,r.jsx)(n.h2,{id:"blend",children:"Blend"}),"\n",(0,r.jsx)(n.p,{children:"Declarative UI framework that combines Rx observables with Roblox Instance creation. Properties can be static values or observables \u2014 when the observable emits, the UI updates automatically."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local visibility = Blend.State(0)\n\nlocal gui = Blend.New "ScreenGui" {\n\tParent = playerGui,\n\n\tBlend.New "Frame" {\n\t\tSize = UDim2.fromScale(1, 1),\n\t\tBackgroundTransparency = visibility, -- Reactively bound\n\n\t\tBlend.New "TextLabel" {\n\t\t\tText = "Hello",\n\t\t\tSize = UDim2.fromOffset(200, 50),\n\t\t},\n\t},\n}\n\nmaid:GiveTask(gui:Subscribe())\n\n-- Changing state automatically updates the Frame\nvisibility.Value = 0.5\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key API:"})," ",(0,r.jsx)(n.code,{children:"Blend.New(className)({props})"}),", ",(0,r.jsx)(n.code,{children:"Blend.State(value)"}),", ",(0,r.jsx)(n.code,{children:"Blend.Computed(sources..., fn)"}),", ",(0,r.jsx)(n.code,{children:"Blend.mount(instance, props)"}),", ",(0,r.jsx)(n.code,{children:"Blend.Children"}),", ",(0,r.jsx)(n.code,{children:"Blend.OnEvent(event)"}),", ",(0,r.jsx)(n.code,{children:"Blend.OnChange(property)"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"When to use:"})," Building UI that needs to react to state changes. Replaces manual property updates and event wiring. Use ",(0,r.jsx)(n.code,{children:"Blend.State"})," for mutable values and ",(0,r.jsx)(n.code,{children:"Blend.Computed"})," for derived values."]}),"\n",(0,r.jsx)(n.h2,{id:"adorneedata",children:"AdorneeData"}),"\n",(0,r.jsx)(n.p,{children:"Bridges Instance attributes and Lua data tables. Define a schema once (with defaults and validation), then read, write, and reactively observe those attributes on any Instance. Solves the problem of keeping attribute names, defaults, and validation in sync across your codebase."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Define the schema (typically in its own module)\nlocal MyData = AdorneeData.new({\n\tIsEnabled = true,       -- boolean, default true\n\tSpeed = 20,             -- number, default 20\n\tLabel = "default",      -- string, default "default"\n})\n\n-- Initialize attributes on an instance (sets defaults if not already present)\nMyData:InitAttributes(someInstance)\n\n-- Read all attributes as a table\nlocal data = MyData:Get(someInstance)\nprint(data.IsEnabled, data.Speed) --\x3e true, 20\n\n-- Write attributes\nMyData:Set(someInstance, { Speed = 50 })\n\n-- Create a reactive wrapper \u2014 each field becomes a ValueObject\nlocal wrapper = MyData:Create(someInstance)\nwrapper.Speed.Value = 100                          -- write\nprint(wrapper.IsEnabled.Value)                     -- read\n\nmaid:GiveTask(wrapper.Speed:Observe():Subscribe(function(speed)\n\tprint("Speed changed to", speed)               -- reacts to attribute changes\nend))\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key API:"})," ",(0,r.jsx)(n.code,{children:"AdorneeData.new(prototype)"}),", ",(0,r.jsx)(n.code,{children:":Get(instance)"}),", ",(0,r.jsx)(n.code,{children:":Set(instance, data)"}),", ",(0,r.jsx)(n.code,{children:":InitAttributes(instance)"}),", ",(0,r.jsx)(n.code,{children:":Create(instance)"})," (reactive wrapper), ",(0,r.jsx)(n.code,{children:":Observe(instance)"}),", ",(0,r.jsx)(n.code,{children:":IsData(data)"})," / ",(0,r.jsx)(n.code,{children:":IsStrictData(data)"})," (validation)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"When to use:"})," When you need replicated configuration on Instances \u2014 physics parameters, toggles, tuning values. Attributes replicate automatically over the network; AdorneeData wraps them with defaults, validation, and Rx observability. Common in ragdoll, rogue-properties, and other systems that configure Instances at runtime."]}),"\n",(0,r.jsx)(n.h2,{id:"tiedefinition",children:"TieDefinition"}),"\n",(0,r.jsx)(n.p,{children:"Declares a loose-coupling interface contract that can be implemented via nested Instances. Enables cross-realm (client/server) communication without direct module references. The most advanced pattern \u2014 prefer Binder for simpler cases."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Define the interface\nlocal DoorDef = TieDefinition.new("Door", {\n\tOpen = TieDefinition.Types.METHOD,\n\tClose = TieDefinition.Types.METHOD,\n\tIsOpen = TieDefinition.Types.PROPERTY,\n})\n\n-- Implement it on an Instance (server)\nlocal doorImpl = {\n\tOpen = function() ... end,\n\tClose = function() ... end,\n\tIsOpen = false,\n}\nDoorDef:Implement(doorInstance, doorImpl)\n\n-- Consume it (client or server)\nlocal door = DoorDef:Find(doorInstance)\nif door then\n\tdoor:Open()\nend\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key API:"})," ",(0,r.jsx)(n.code,{children:"TieDefinition.new(name, members)"}),", ",(0,r.jsx)(n.code,{children:":Implement(instance, table)"}),", ",(0,r.jsx)(n.code,{children:":Find(instance)"}),", ",(0,r.jsx)(n.code,{children:":Observe(instance)"}),", ",(0,r.jsx)(n.code,{children:"TieDefinition.Types.METHOD | SIGNAL | PROPERTY"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"When to use:"})," When you need optional or pluggable interfaces \u2014 particularly across client/server boundaries or for plugin systems where the implementer shouldn't need to know about the consumer."]}),"\n",(0,r.jsx)(n.h2,{id:"how-the-patterns-fit-together",children:"How the patterns fit together"}),"\n",(0,r.jsx)(n.p,{children:"These patterns compose naturally:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Maid + BaseObject"})," \u2014 The foundation. Every class extends BaseObject to get automatic cleanup."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Binder + BaseObject"})," \u2014 Create a class extending BaseObject, bind it to tagged Instances via Binder."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rx + Maid"})," \u2014 Subscribe to observables, store subscriptions in maids for cleanup."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Brio in Observables"})," \u2014 When emitting objects with lifetimes from Rx streams, wrap them in Brio."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Blend + Rx"})," \u2014 Blend properties accept observables directly, making UI reactive."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ServiceBag + Binder"})," \u2014 Services create and manage binders; binders receive ServiceBag for dependency injection."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"AdorneeData + Binder"})," \u2014 Binder creates a class per tagged Instance; AdorneeData reads/observes configuration attributes on that Instance."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var s=t(96540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);