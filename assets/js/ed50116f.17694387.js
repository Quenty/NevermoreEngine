"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4322],{10329:e=>{e.exports=JSON.parse('{"functions":[{"name":"isObservable","desc":"Returns whether or not a value is an observable.","params":[{"name":"item","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":73,"path":"src/rx/src/Shared/Observable.lua"}},{"name":"new","desc":"Constructs a new Observable\\n\\n```lua\\nlocal function observeAllChildren(parent)\\n\\treturn Observable.new(function(sub)\\n\\t\\tlocal maid = Maid.new()\\n\\n\\t\\tfor _, item in pairs(parent:GetChildren()) do\\n\\t\\t\\tsub:Fire(item)\\n\\t\\tend\\n\\t\\tmaid:GiveTask(parent.ChildAdded:Connect(function(child)\\n\\t\\t\\tsub:Fire(child)\\n\\t\\tend))\\n\\n\\t\\treturn maid\\n\\tend)\\nend\\n\\n-- Prints out all current children, and whenever a new\\n-- child is added to workspace\\nlocal maid = Maid.new()\\nmaid:GiveTask(observeAllChildren(workspace):Subscribe(print))\\n```","params":[{"name":"onSubscribe","desc":"","lua_type":"(subscription: Subscription<T>) -> MaidTask"}],"returns":[{"desc":"","lua_type":"Observable<T>"}],"function_type":"static","source":{"line":105,"path":"src/rx/src/Shared/Observable.lua"}},{"name":"Pipe","desc":"Transforms the observable with the following transformers\\n\\n```lua\\nRx.of(1, 2, 3):Pipe({\\n\\tRx.map(function(result)\\n\\t\\treturn result + 1\\n\\tend);\\n\\tRx.map(function(value)\\n\\t\\treturn (\\"%0.2f\\"):format(value)\\n\\tend);\\n}):Subscribe(print)\\n\\n--\x3e 2.00\\n--\x3e 3.00\\n--\x3e 4.00\\n```","params":[{"name":"transformers","desc":"","lua_type":"{ (observable: Observable<T>) -> Observable<T> }"}],"returns":[{"desc":"","lua_type":"Observable<T>"}],"function_type":"method","source":{"line":134,"path":"src/rx/src/Shared/Observable.lua"}},{"name":"Subscribe","desc":"Subscribes immediately, fireCallback may return a maid (or a task a maid can handle)\\nto clean up","params":[{"name":"fireCallback","desc":"","lua_type":"function?"},{"name":"failCallback","desc":"","lua_type":"function?"},{"name":"completeCallback","desc":"","lua_type":"function?"}],"returns":[{"desc":"","lua_type":"MaidTask"}],"function_type":"method","source":{"line":156,"path":"src/rx/src/Shared/Observable.lua"}}],"properties":[],"types":[],"name":"Observable","desc":"Observables are like an [signal](/api/Signal), except they do not execute code\\nuntil the observable is subscribed to. This follows the standard\\nRx API surface for an observable.\\n\\nObservables use a [Subscription](/api/Subscription) to emit values.\\n\\n```lua\\n-- Constucts an observable which will emit a, b, c via a subscription\\nlocal observable = Observable.new(function(sub)\\n\\tprint(\\"Connected\\")\\n\\tsub:Fire(\\"a\\")\\n\\tsub:Fire(\\"b\\")\\n\\tsub:Fire(\\"c\\")\\n\\tsub:Complete() -- ends stream\\nend)\\n\\nlocal sub1 = observable:Subscribe() --\x3e Connected\\nlocal sub2 = observable:Subscribe() --\x3e Connected\\nlocal sub3 = observable:Subscribe() --\x3e Connected\\n\\nsub1:Destroy()\\nsub2:Destroy()\\nsub3:Destroy()\\n```\\n\\nNote that emitted values may be observed like this\\n\\n```lua\\nobservable:Subscribe(function(value)\\n\\tprint(\\"Got \\", value)\\nend)\\n\\n--\x3e Got a\\n--\x3e Got b\\n--\x3e Got c\\n```\\n\\nNote that also, observables return a [MaidTask](/api/MaidTask) which\\nshould be used to clean up the resulting subscription.\\n\\n```lua\\nmaid:GiveTask(observable:Subscribe(function(value)\\n\\t-- do work here!\\nend))\\n```\\n\\nObservables over signals are nice because observables may be chained and manipulated\\nvia the Pipe operation.\\n\\n:::tip\\nYou should always clean up the subscription using a [Maid](/api/Maid), otherwise\\nyou may memory leak.\\n:::","source":{"line":57,"path":"src/rx/src/Shared/Observable.lua"}}')}}]);