"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[15377],{46045:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"conventions/luau","title":"Luau Conventions","description":"This guide covers how to write Luau code in this project. All code uses --!strict mode, and every file follows consistent patterns for class structure, typing, and naming. These conventions are shared with the Raven companion repo.","source":"@site/docs/conventions/luau.md","sourceDirName":"conventions","slug":"/conventions/luau","permalink":"/NevermoreEngine/docs/conventions/luau","draft":false,"unlisted":false,"editUrl":"https://github.com/Quenty/NevermoreEngine/edit/main/docs/conventions/luau.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Luau Conventions","sidebar_position":1},"sidebar":"defaultSidebar","previous":{"title":"Conventions","permalink":"/NevermoreEngine/docs/conventions/"},"next":{"title":"TypeScript Conventions","permalink":"/NevermoreEngine/docs/conventions/typescript"}}');var i=s(74848),r=s(28453);const l={title:"Luau Conventions",sidebar_position:1},c="Luau Conventions",a={},d=[{value:"Why strict typing?",id:"why-strict-typing",level:2},{value:"Class structure",id:"class-structure",level:2},{value:"1. File header and requires",id:"1-file-header-and-requires",level:3},{value:"2. Class table setup",id:"2-class-table-setup",level:3},{value:"3. Export type declaration",id:"3-export-type-declaration",level:3},{value:"4. Constructor",id:"4-constructor",level:3},{value:"5. Methods \u2014 use dot syntax",id:"5-methods--use-dot-syntax",level:3},{value:"6. Binder return",id:"6-binder-return",level:3},{value:"Common type imports",id:"common-type-imports",level:2},{value:"Naming conventions",id:"naming-conventions",level:2},{value:"Coding conventions",id:"coding-conventions",level:2},{value:"When to use <code>:: any</code> casts",id:"when-to-use--any-casts",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"luau-conventions",children:"Luau Conventions"})}),"\n",(0,i.jsxs)(n.p,{children:["This guide covers how to write Luau code in this project. All code uses ",(0,i.jsx)(n.code,{children:"--!strict"})," mode, and every file follows consistent patterns for class structure, typing, and naming. These conventions are shared with the Raven companion repo."]}),"\n",(0,i.jsx)(n.h2,{id:"why-strict-typing",children:"Why strict typing?"}),"\n",(0,i.jsxs)(n.p,{children:["Luau's type inference doesn't handle metatables well. When you write ",(0,i.jsx)(n.code,{children:"setmetatable({}, MyClass)"}),", Luau can't automatically infer the fields you'll assign to ",(0,i.jsx)(n.code,{children:"self"})," in the constructor. Without explicit type annotations, the type checker either flags legitimate code or loses track of types entirely."]}),"\n",(0,i.jsx)(n.p,{children:"The project uses an explicit typing pattern that tells the type checker exactly what fields exist on each class. This is more verbose than untyped Lua, but it catches real bugs \u2014 misspelled field names, wrong argument types, missing nil checks \u2014 at edit time instead of at runtime in a live game."}),"\n",(0,i.jsx)(n.h2,{id:"class-structure",children:"Class structure"}),"\n",(0,i.jsx)(n.p,{children:"Every class follows this structure:"}),"\n",(0,i.jsx)(n.h3,{id:"1-file-header-and-requires",children:"1. File header and requires"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'--!strict\n--[=[\n    @class MyClass\n]=]\n\nlocal require = require(script.Parent.loader).load(script)\n\n-- Requires are auto-sorted by stylua\nlocal BaseObject = require("BaseObject")\nlocal ServiceBag = require("ServiceBag")\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"require(script.Parent.loader).load(script)"})," line enables the custom module resolution system. Every file needs it."]}),"\n",(0,i.jsx)(n.h3,{id:"2-class-table-setup",children:"2. Class table setup"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local MyClass = setmetatable({}, BaseObject)\nMyClass.ClassName = "MyClass"\nMyClass.__index = MyClass\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ClassName"})," is a static field used for debugging and identification. Always matches the class name."]}),"\n",(0,i.jsx)(n.h3,{id:"3-export-type-declaration",children:"3. Export type declaration"}),"\n",(0,i.jsx)(n.p,{children:"Place this after the class table setup, before the constructor. It tells the type checker what fields exist on instances of this class:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"export type MyClass =\n    typeof(setmetatable(\n        {} :: {\n            _obj: Instance,\n            _serviceBag: ServiceBag.ServiceBag,\n            _enabled: ValueObject.ValueObject<boolean>,\n            -- list ALL instance fields with their types\n        },\n        {} :: typeof({ __index = MyClass })\n    ))\n    & BaseObject.BaseObject  -- intersection with parent type\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"& ParentClass.ParentClass"})," intersection gives you access to inherited fields like ",(0,i.jsx)(n.code,{children:"_maid"})," and ",(0,i.jsx)(n.code,{children:"_obj"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"4-constructor",children:"4. Constructor"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function MyClass.new(obj: Instance, serviceBag: ServiceBag.ServiceBag): MyClass\n    local self: MyClass = setmetatable(BaseObject.new(obj) :: any, MyClass)\n\n    self._serviceBag = assert(serviceBag, "No serviceBag")\n    -- Initialize fields...\n\n    return self\nend\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:":: any"})," cast on ",(0,i.jsx)(n.code,{children:"setmetatable"})," is necessary because Luau can't verify the metatable transformation preserves the type. This is one of the few places ",(0,i.jsx)(n.code,{children:":: any"})," is acceptable."]}),"\n",(0,i.jsx)(n.h3,{id:"5-methods--use-dot-syntax",children:"5. Methods \u2014 use dot syntax"}),"\n",(0,i.jsxs)(n.p,{children:["Strict mode requires explicit ",(0,i.jsx)(n.code,{children:"self"})," typing. Use dot syntax (not colon syntax) for method definitions:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Correct: dot syntax with explicit self type\nfunction MyClass.GetEnabled(self: MyClass): boolean\n    return self._enabled.Value\nend\n\n-- Wrong: colon syntax loses self type in strict mode\nfunction MyClass:GetEnabled(): boolean\n    return self._enabled.Value  -- type error: _enabled not known\nend\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Callers still use colon syntax (",(0,i.jsx)(n.code,{children:"myObj:GetEnabled()"}),"). Only the definition changes."]}),"\n",(0,i.jsx)(n.h3,{id:"6-binder-return",children:"6. Binder return"}),"\n",(0,i.jsx)(n.p,{children:"When a class is bound to Roblox instances via a tag:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'return Binder.new("MyTag", MyClass :: any) :: Binder.Binder<MyClass>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:":: any"})," on the class and the ",(0,i.jsx)(n.code,{children:":: Binder.Binder<MyClass>"})," on the return give the binder system proper generic typing."]}),"\n",(0,i.jsx)(n.h2,{id:"common-type-imports",children:"Common type imports"}),"\n",(0,i.jsx)(n.p,{children:"These are the types you'll use most often:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Package"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ServiceBag.ServiceBag"})}),(0,i.jsx)(n.td,{children:"ServiceBag"}),(0,i.jsx)(n.td,{children:"Dependency injection container"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Observable.Observable<T>"})}),(0,i.jsx)(n.td,{children:"Rx"}),(0,i.jsx)(n.td,{children:"Reactive observable stream"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Brio.Brio<T>"})}),(0,i.jsx)(n.td,{children:"Brio"}),(0,i.jsx)(n.td,{children:"Value with lifecycle (value + cleanup)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Maid.Maid"})}),(0,i.jsx)(n.td,{children:"Maid"}),(0,i.jsx)(n.td,{children:"Resource cleanup tracker"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ValueObject.ValueObject<T>"})}),(0,i.jsx)(n.td,{children:"ValueObject"}),(0,i.jsx)(n.td,{children:"Reactive value container"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Signal.Signal<T>"})}),(0,i.jsx)(n.td,{children:"Signal"}),(0,i.jsx)(n.td,{children:"Event signal"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"BaseObject.BaseObject"})}),(0,i.jsx)(n.td,{children:"BaseObject"}),(0,i.jsx)(n.td,{children:"Base class type"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Binder.Binder<T>"})}),(0,i.jsx)(n.td,{children:"Binder"}),(0,i.jsx)(n.td,{children:"Tag-based instance binder"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"AttributeValue.AttributeValue<T>"})}),(0,i.jsx)(n.td,{children:"AttributeValue"}),(0,i.jsx)(n.td,{children:"Attribute-backed reactive value"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"naming-conventions",children:"Naming conventions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Private fields"}),": ",(0,i.jsx)(n.code,{children:"_"})," prefix (",(0,i.jsx)(n.code,{children:"self._maid"}),", ",(0,i.jsx)(n.code,{children:"self._enabled"}),", ",(0,i.jsx)(n.code,{children:"self._processAsync"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Public signals"}),": PascalCase (",(0,i.jsx)(n.code,{children:"self.HumanoidEntered"}),", ",(0,i.jsx)(n.code,{children:"self.PlayerCount"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Methods"}),": PascalCase (",(0,i.jsx)(n.code,{children:"GetEnabled"}),", ",(0,i.jsx)(n.code,{children:"ObservePlayersBrio"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Observable methods"}),": ",(0,i.jsx)(n.code,{children:"Observe*"})," prefix, often with ",(0,i.jsx)(n.code,{children:"Brio"})," suffix (",(0,i.jsx)(n.code,{children:"ObservePlayersBrio"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ClassName"}),": Always matches the class name exactly"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"coding-conventions",children:"Coding conventions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Require pattern"}),": ",(0,i.jsx)(n.code,{children:"local require = require(script.Parent.loader).load(script)"})," at the top of every file"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Requires sorted"}),": stylua sorts requires alphabetically (",(0,i.jsx)(n.code,{children:"[sort_requires] enabled = true"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Assert serviceBag"}),": ",(0,i.jsx)(n.code,{children:'self._serviceBag = assert(serviceBag, "No serviceBag")'})," in constructors"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Moonwave docstrings"}),": ",(0,i.jsx)(n.code,{children:"--[=[ @class ClassName ]=]"})," at the top of each file"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Conventional commits"}),": ",(0,i.jsx)(n.code,{children:"feat(scope):"}),", ",(0,i.jsx)(n.code,{children:"fix(scope):"}),", ",(0,i.jsx)(n.code,{children:"chore(scope):"}),", etc."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Commit messages describe impact, not reasoning"}),": Keep them short. e.g. ",(0,i.jsx)(n.code,{children:"fix(localizedtextutils): make translationArgs optional"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Squash before pushing"}),": Rebase and squash into a single cohesive commit before pushing"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"when-to-use--any-casts",children:["When to use ",(0,i.jsx)(n.code,{children:":: any"})," casts"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:":: any"})," is a last resort. Acceptable uses:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"setmetatable(ParentClass.new(obj) :: any, MyClass)"})," \u2014 metatable transformation in constructors"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'Binder.new("Tag", MyClass :: any)'})," \u2014 binder registration"]}),"\n",(0,i.jsxs)(n.li,{children:["Rx ",(0,i.jsx)(n.code,{children:"Pipe"})," chains where intermediate types can't be inferred"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Signal.new() :: any"})," \u2014 when the signal type would be too complex to annotate inline"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Prefer fixing upstream types"})," over casting. If a type is wrong, fix it in the source package."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>c});var t=s(96540);const i={},r=t.createContext(i);function l(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);