"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[49937],{2278:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"gotchas/tooling","title":"Tooling Gotchas","description":"Would this save someone real debugging time? If you wouldn\'t warn a teammate about it, don\'t add it here.","source":"@site/docs/gotchas/tooling.md","sourceDirName":"gotchas","slug":"/gotchas/tooling","permalink":"/NevermoreEngine/docs/gotchas/tooling","draft":false,"unlisted":false,"editUrl":"https://github.com/Quenty/NevermoreEngine/edit/main/docs/gotchas/tooling.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Tooling Gotchas","sidebar_position":1},"sidebar":"defaultSidebar","previous":{"title":"Gotchas","permalink":"/NevermoreEngine/docs/gotchas/"},"next":{"title":"Troubleshooting","permalink":"/NevermoreEngine/docs/gotchas/troubleshooting"}}');var o=t(74848),i=t(28453);const r={title:"Tooling Gotchas",sidebar_position:1},l="Tooling Gotchas",a={},c=[{value:"Lune",id:"lune",level:2},{value:"Symlinks",id:"symlinks",level:2},{value:"Linter CLI Tools",id:"linter-cli-tools",level:2},{value:"Rojo",id:"rojo",level:2}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"tooling-gotchas",children:"Tooling Gotchas"})}),"\n",(0,o.jsx)(n.admonition,{title:"Before adding an entry",type:"tip",children:(0,o.jsx)(n.p,{children:"Would this save someone real debugging time? If you wouldn't warn a teammate about it, don't add it here."})}),"\n",(0,o.jsx)(n.p,{children:"When a section grows to 10+ items, graduate it to its own doc."}),"\n",(0,o.jsx)(n.h2,{id:"lune",children:"Lune"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:["No ",(0,o.jsx)(n.code,{children:"--"})," separator"]}),": When spawning ",(0,o.jsx)(n.code,{children:"lune run script.luau arg1 arg2"}),", do NOT use ",(0,o.jsx)(n.code,{children:"--"})," between the script path and arguments. Lune passes ",(0,o.jsx)(n.code,{children:"--"})," through to ",(0,o.jsx)(n.code,{children:"process.args"}),", shifting all arguments by one."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"DataModel attributes"}),": ",(0,o.jsx)(n.code,{children:"roblox.deserializePlace()"})," returns a DataModel. ",(0,o.jsx)(n.code,{children:"SetAttribute"})," must be called on a child service (e.g., ",(0,o.jsx)(n.code,{children:'game:GetService("Workspace")'}),"), not on the DataModel root."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ObjectValue cross-DataModel reparenting"}),": When reparenting instances from one deserialized DataModel to another (e.g., in ",(0,o.jsx)(n.code,{children:"combine-test-places.luau"}),"), ObjectValues (which are links to other instances) may or may not survive the move. Reparenting a whole subtree as a unit preserves intra-subtree ObjectValue references in practice, but this behavior is not explicitly guaranteed by Lune's ",(0,o.jsx)(n.code,{children:"@lune/roblox"})," API. If batch tests start failing with nil references, this is the first thing to investigate \u2014 the fallback is to resolve broken ObjectValues after reparenting by rebuilding them from Name/path lookups."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"symlinks",children:"Symlinks"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Each package under ",(0,o.jsx)(n.code,{children:"src/"})," has a ",(0,o.jsx)(n.code,{children:"node_modules/"})," directory that is symlinked and recursive. Regex searching or recursive file operations (",(0,o.jsx)(n.code,{children:"grep -r"}),", ",(0,o.jsx)(n.code,{children:"rg"}),", ",(0,o.jsx)(n.code,{children:"find"}),") can consume excessive memory. Always use ",(0,o.jsx)(n.code,{children:"--ignore"})," flags to exclude ",(0,o.jsx)(n.code,{children:"node_modules"}),", or use targeted file paths."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"linter-cli-tools",children:"Linter CLI Tools"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Per-package execution"}),": moonwave-extractor, selene, and other linters run via ",(0,o.jsx)(n.code,{children:"npx lerna exec --parallel"})," must be run per-package, not repo-wide. The recursive symlinked ",(0,o.jsx)(n.code,{children:"node_modules"})," under ",(0,o.jsx)(n.code,{children:"src/"})," will cause them to traverse infinitely and freeze. This is why ",(0,o.jsx)(n.code,{children:"package.json"})," uses ",(0,o.jsx)(n.code,{children:"npx lerna exec --parallel"})," rather than running the tools at the repo root. Same caution applies when debugging locally."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"CI annotations"}),": The ",(0,o.jsx)(n.code,{children:"linting.yml"})," workflow emits GitHub Actions annotations via ",(0,o.jsx)(n.code,{children:"nevermore tools post-lint-results"}),". For the luau-lsp job (which already has pnpm), annotations run in-job. For stylua/selene/moonwave (lightweight Aftman-only jobs), output is uploaded as artifacts and a separate ",(0,o.jsx)(n.code,{children:"lint-annotations"})," job processes them. GitHub caps annotations at 10 per step and 50 per run \u2014 the job summary serves as a fallback for large lint failures."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Template CI annotations"}),": Game and plugin templates use a simpler pattern \u2014 every linter job posts annotations inline via ",(0,o.jsx)(n.code,{children:"npx @quenty/nevermore-cli tools post-lint-results"}),". No artifact relay or separate ",(0,o.jsx)(n.code,{children:"lint-annotations"})," job needed, since ",(0,o.jsx)(n.code,{children:"setup-node"})," is sufficient to run ",(0,o.jsx)(n.code,{children:"npx"})," (no pnpm install required in the annotation step)."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"rojo",children:"Rojo"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Nevermore uses a custom fork of Rojo that understands symlinks and turns them into ObjectValues. This is required for development but not for consuming packages."}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Symlink deduplication"}),": When multiple ",(0,o.jsx)(n.code,{children:"$path"})," entries resolve to the same physical filesystem path (common with pnpm workspace links where ",(0,o.jsx)(n.code,{children:"src/A/node_modules/@quenty/loader"})," and ",(0,o.jsx)(n.code,{children:"src/B/node_modules/@quenty/loader"})," both symlink to ",(0,o.jsx)(n.code,{children:"src/loader"}),"), rojo only includes the content once \u2014 under whichever tree entry it processes first. The second entry's subtree silently loses those dependencies. This means you ",(0,o.jsx)(n.strong,{children:"cannot combine multiple packages into a single rojo project"})," if they share workspace-linked dependencies. The workaround is to build each package individually with rojo, then merge the outputs using Lune's ",(0,o.jsx)(n.code,{children:"@lune/roblox"})," API (reparenting whole subtrees preserves ObjectValue references within each package)."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var s=t(96540);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);