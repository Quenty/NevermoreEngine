"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[82725],{89321:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Constructs a new PlayerDataStoreManager.","params":[{"name":"robloxDataStore","desc":"","lua_type":"DataStore"},{"name":"keyGenerator","desc":"Function that takes in a player, and outputs a key","lua_type":"(player) -> string"},{"name":"skipBindingToClose","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"PlayerDataStoreManager"}],"function_type":"static","source":{"line":92,"path":"src/datastore/src/Server/PlayerDataStoreManager.lua"}},{"name":"DisableSaveOnCloseStudio","desc":"For if you want to disable saving in studio for faster close time!","params":[{"name":"self","desc":"","lua_type":"PlayerDataStoreManager"}],"returns":[],"function_type":"static","source":{"line":135,"path":"src/datastore/src/Server/PlayerDataStoreManager.lua"}},{"name":"AddRemovingCallback","desc":"Adds a callback to be called before save on removal","params":[{"name":"self","desc":"","lua_type":"PlayerDataStoreManager"},{"name":"callback","desc":"May return a promise","lua_type":"function"}],"returns":[],"function_type":"static","source":{"line":145,"path":"src/datastore/src/Server/PlayerDataStoreManager.lua"}},{"name":"RemovePlayerDataStore","desc":"Callable to allow manual GC so things can properly clean up.\\nThis can be used to pre-emptively cleanup players.","params":[{"name":"self","desc":"","lua_type":"PlayerDataStoreManager"},{"name":"player","desc":"","lua_type":"Player"}],"returns":[],"function_type":"static","source":{"line":155,"path":"src/datastore/src/Server/PlayerDataStoreManager.lua"}},{"name":"GetDataStore","desc":"Gets the datastore for a player. If it does not exist, it will create one.\\n\\n:::tip\\nReturns nil if the player is in the process of being removed.\\n:::","params":[{"name":"self","desc":"","lua_type":"PlayerDataStoreManager"},{"name":"player","desc":"","lua_type":"Player"}],"returns":[{"desc":"","lua_type":"DataStore?"}],"function_type":"static","source":{"line":169,"path":"src/datastore/src/Server/PlayerDataStoreManager.lua"}},{"name":"PromiseAllSaves","desc":"Removes all player data stores, and returns a promise that\\nresolves when all pending saves are saved.","params":[{"name":"self","desc":"","lua_type":"PlayerDataStoreManager"}],"returns":[{"desc":"","lua_type":"Promise"}],"function_type":"static","source":{"line":190,"path":"src/datastore/src/Server/PlayerDataStoreManager.lua"}}],"properties":[],"types":[],"name":"PlayerDataStoreManager","desc":"DataStore manager for player that automatically saves on player leave and game close.\\n\\n:::tip\\nConsider using [PlayerDataStoreService] instead, which wraps one PlayerDataStoreManager.\\n:::\\n\\nThis will ensure that the datastores are reused between different services and other things integrating\\nwith Nevermore.\\n\\n```lua\\nlocal serviceBag = ServiceBag.new()\\nlocal playerDataStoreService = serviceBag:GetService(require(\\"PlayerDataStoreService\\"))\\n\\nserviceBag:Init()\\nserviceBag:Start()\\n\\nlocal topMaid = Maid.new()\\n\\nlocal function handlePlayer(player: Player)\\n\\tlocal maid = Maid.new()\\n\\n\\tlocal playerMoneyValue = Instance.new(\\"IntValue\\")\\n\\tplayerMoneyValue.Name = \\"Money\\"\\n\\tplayerMoneyValue.Value = 0\\n\\tplayerMoneyValue.Parent = player\\n\\n\\tmaid:GivePromise(playerDataStoreService:PromiseDataStore(Players)):Then(function(dataStore)\\n\\t\\tmaid:GivePromise(dataStore:Load(\\"money\\", 0))\\n\\t\\t\\t:Then(function(money)\\n\\t\\t\\t\\tplayerMoneyValue.Value = money\\n\\t\\t\\t\\tmaid:GiveTask(dataStore:StoreOnValueChange(\\"money\\", playerMoneyValue))\\n\\t\\t\\tend)\\n\\tend)\\n\\n\\ttopMaid[player] = maid\\nend\\nPlayers.PlayerAdded:Connect(handlePlayer)\\nPlayers.PlayerRemoving:Connect(function(player)\\n\\ttopMaid[player] = nil\\nend)\\nfor _, player in Players:GetPlayers() do\\n\\ttask.spawn(handlePlayer, player)\\nend\\n```","realm":["Server"],"source":{"line":51,"path":"src/datastore/src/Server/PlayerDataStoreManager.lua"}}')}}]);