<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
<External>null</External>
<External>nil</External>
<Item class="Backpack" referent="RBX0">
<Properties>
<string name="Name">Nevermore</string>
</Properties>
<Item class="Backpack" referent="RBX1">
<Properties>
<string name="Name">App</string>
</Properties>
<Item class="ModuleScript" referent="RBX2">
<Properties>
<string name="Name">NevermoreEngine</string>
<ProtectedString name="Source">-- see readme.md
-- @author Quenty

local NevermoreEngine 
local Players             = game:GetService(&quot;Players&quot;)
local ReplicatedStorage   = game:GetService(&quot;ReplicatedStorage&quot;)
local MarketplaceService  = game:GetService(&apos;MarketplaceService&apos;)
local TestService         = game:GetService(&apos;TestService&apos;)
local ServerStorage      
local ServerScriptService

local Configuration = {	
	Blacklist              = &quot;128527647,129834516&quot;; -- Ban list
	ClientName             = &quot;NevermoreClient&quot;;
	CustomCharacters       = false; -- When enabled, allows the client to set Player.Character itself.
	IsClient               = script.Parent ~= nil;
	ReplicatedPackageName  = &quot;NevermoreResources&quot;;
	SoloTestMode           = (game:FindService(&quot;NetworkServer&quot;) == nil and game.PlaceId == 0); -- Are we testing in solo test mode?
	SplashScreen           = true; -- Should a splashscreen be rendered?
	CharacterRespawnTime   = 0.5; -- How long does it take for characters to respawn? Only kept updated on the server-side.
	DataSteamName          = &quot;NevermoreDataStream&quot;;
	NevermoreRequestPrefix = &quot;NevermoreEngineRequest&quot;; -- For network requests, what should it prefix it as?
	EnableFiltering        = false; -- Set Workspace.FilteringEnabled
}
Configuration.IsServer = not Configuration.IsClient

if Configuration.EnableFiltering then
	Workspace.FilteringEnabled = true
	print(&quot;**** Workspace.FilteringEnabled is enabled&quot;)
end

if Configuration.SoloTestMode then
	Configuration.PrintHeader = &quot;[NevermoreEngineSolo] - &quot;
else
	print(game:FindService(&quot;NetworkServer&quot;) == nil, game.PlaceId == 0)
	if Configuration.IsServer then
		Configuration.PrintHeader = &quot;[NevermoreEngine] - &quot;
	else
		Configuration.PrintHeader = &quot;[NevermoreEngineLocal] - &quot;
	end
end

Players.CharacterAutoLoads = false;

local RbxUtility = LoadLibrary(&quot;RbxUtility&quot;)

if not Configuration.IsClient then
	ServerStorage       = game:GetService(&quot;ServerStorage&quot;)
	ServerScriptService = game:GetService(&quot;ServerScriptService&quot;)
end

NevermoreEngine = {}

-- DEBUG -- 
-- print(&quot;script.Parent == &quot; .. tostring(script.Parent))
-- print(Configuration.PrintHeader .. &quot;Nevermore is Loadingg.&quot;)

-----------------------
-- UTILITY FUNCTIONS --
-----------------------
local function Warn(WarningText)
	--- Used to yell at the player
	-- @param WarningText The text to warn with.

	Spawn(function()
		--TestService:Warn(false, WarningText)
		error(&quot;[WARNING] - &quot; .. WarningText, 2)
	end)
end

local function WaitForChild(Parent, Name)
	--- Yields until a child is added. Warns after 5 seconds of yield.
	-- @param Parent The parent to wait for the child of
	-- @param Name The name of the child
	-- @return The child found

	local Child = Parent:FindFirstChild(Name)
	local StartTime = tick()
	local Warned = false;
	while not Child do
		wait(0)
		Child = Parent:FindFirstChild(Name)
		if not Warned and StartTime + 5 &lt;= tick() then
			Warned = true;
			Warn(Configuration.PrintHeader .. &quot; &quot; .. Name .. &quot; has not replicated after 5 seconds, may not be able to execute Nevermore.&quot;)
		end
	end
	return Child
end

local function pack(...)
	--- Packs a tuple into a table and returns it
	-- @return The packed tuple

	return {...}
end

------------------------------
-- Load Dependent Resources --
------------------------------
local NevermoreContainer, ModulesContainer, ApplicationContainer, ReplicatedPackage, DataStreamContainer, EventStreamContainer
do
	local function LoadResource(Parent, ResourceName)
		--- Loads a resource or errors. Makes sure that a resource is available.
		-- @param Parent The parent of the resource to load
		-- @param ResourceName The name of the resource attempting to load

		local Resource = Parent:FindFirstChild(ResourceName)
		if not Resource then
			error(Configuration.PrintHeader .. &quot;Failed to load required resource &apos;&quot; .. ResourceName .. &quot;&apos;, expected at &apos;&quot; .. Parent:GetFullName() .. &quot;&apos;&quot;, 2)
			return nil
		else
			return Resource
		end
	end

	if Configuration.IsServer then
		-- Load Resources --

		NevermoreContainer          = LoadResource(ServerScriptService, &quot;Nevermore&quot;)
		ModulesContainer            = LoadResource(NevermoreContainer, &quot;Modules&quot;)
		ApplicationContainer        = LoadResource(NevermoreContainer, &quot;App&quot;)

		-- Create the replicated package --
		ReplicatedPackage = ReplicatedStorage:FindFirstChild(Configuration.ReplicatedPackageName)
		if not ReplicatedPackage then
			ReplicatedPackage            = Instance.new(&quot;Backpack&quot;)
			ReplicatedPackage.Name       = Configuration.ReplicatedPackageName
			ReplicatedPackage.Parent     = ReplicatedStorage
			ReplicatedPackage.Archivable = false;		
		end
		ReplicatedPackage:ClearAllChildren()

		DataStreamContainer = ReplicatedPackage:FindFirstChild(&quot;DataStreamContainer&quot;)
		if not DataStreamContainer then
			DataStreamContainer            = Instance.new(&quot;Backpack&quot;)
			DataStreamContainer.Name       = &quot;DataStreamContainer&quot;
			DataStreamContainer.Parent     = ReplicatedPackage
			DataStreamContainer.Archivable = false;
		end

		EventStreamContainer = ReplicatedPackage:FindFirstChild(&quot;EventStreamContainer&quot;)
		if not EventStreamContainer then
			EventStreamContainer            = Instance.new(&quot;Backpack&quot;)
			EventStreamContainer.Name       = &quot;EventStreamContainer&quot;
			EventStreamContainer.Parent     = ReplicatedPackage
			EventStreamContainer.Archivable = false;
		end
	
		DataStreamContainer:ClearAllChildren()		
	else
		-- Handle replication for clients

		-- Load Resource Package --
		ReplicatedPackage    = WaitForChild(ReplicatedStorage, Configuration.ReplicatedPackageName)
		DataStreamContainer  = WaitForChild(ReplicatedPackage, &quot;DataStreamContainer&quot;)
		EventStreamContainer = WaitForChild(ReplicatedPackage, &quot;EventStreamContainer&quot;)
	end
end

--print(Configuration.PrintHeader .. &quot;Loaded dependent resources module&quot;)
------------------------
-- RESOURCE MANAGMENT --
------------------------
local NetworkingRemoteFunction
local ResouceManager = {} do
	--- Handles resource loading and replication
	local ResourceCache = {}
	local MainResourcesServer, MainResourcesClient

	if Configuration.IsServer then
		MainResourcesServer = {} -- Resources to load.
		MainResourcesClient = {}
	else
		MainResourcesClient = {}
	end

	local function GetDataStreamObject(Name, Parent)
		--- Products a new DataStream object if it doesn&apos;t already exist, otherwise
		--  return&apos;s the current datastream.
		-- @param Name The Name of the DataStream
		-- @param [Parent] The parent to add to

		Parent = Parent or DataStreamContainer

		local DataStreamObject = Parent:FindFirstChild(Name)
		if not DataStreamObject then
			if Configuration.IsServer then
				DataStreamObject            = Instance.new(&quot;RemoteFunction&quot;)
				DataStreamObject.Name       = Name;
				DataStreamObject.Archivable = false;
				DataStreamObject.Parent     = Parent
			else
				DataStreamObject = WaitForChild(Parent, Name) -- Client side, we must wait.&apos;
			end
		end
		return DataStreamObject
	end
	ResouceManager.GetDataStreamObject = GetDataStreamObject

	local function GetEventStreamObject(Name, Parent)
		--- Products a new EventStream object if it doesn&apos;t already exist, otherwise
		--  return&apos;s the current datastream. 
		-- @param Name The Name of the EventStream
		-- @param [Parent] The parent to add to

		Parent = Parent or EventStreamContainer

		local DataStreamObject = Parent:FindFirstChild(Name)
		if not DataStreamObject then
			if Configuration.IsServer then
				DataStreamObject            = Instance.new(&quot;RemoteEvent&quot;)
				DataStreamObject.Name       = Name;
				DataStreamObject.Archivable = false;
				DataStreamObject.Parent     = Parent
			else
				DataStreamObject = WaitForChild(Parent, Name) -- Client side, we must wait.
			end
		end
		return DataStreamObject
	end
	ResouceManager.GetEventStreamObject = GetEventStreamObject

	if Configuration.IsClient then
		NetworkingRemoteFunction = WaitForChild(DataStreamContainer, Configuration.DataSteamName)
	else
		NetworkingRemoteFunction = GetDataStreamObject(Configuration.DataSteamName, DataStreamContainer)
	end

	local function IsMainResource(Item)
		--- Finds out if an Item is considered a MainResource
		-- @return Boolean is a main resource

		if Item:IsA(&quot;Script&quot;) then
			if not Item.Disabled then
				-- If an item is not disabled, then it&apos;s disabled, but yell at 
				-- the user.

				if Item.Name:lower():match(&quot;\.main$&quot;) == nil then
					error(Configuration.PrintHeader .. Item:GetFullName() .. &quot; is not disabled, and does not end with .Main.&quot;)
				end

				return true
			end
			return Item.Name:lower():match(&quot;\.main$&quot;) ~= nil -- Check to see if it ends
			                                                  -- in .main, ignoring caps
		else
			return false;
		end
	end

	local function GetLoadablesForServer()
		--- Get&apos;s the loadable items for the server, that should be insta-ran
		-- @return A table full of the resources to be loaded

		return MainResourcesServer
	end
	ResouceManager.GetLoadablesForServer = GetLoadablesForServer

	local function GetLoadablesForClient()
		--- Get&apos;s the loadable items for the Client, that should be insta-ran
		-- @return A table full of the resources to be loaded
		
		return MainResourcesClient
	end
	ResouceManager.GetLoadablesForClient = GetLoadablesForClient

	local PopulateResourceCache
	if Configuration.IsClient then
		function PopulateResourceCache()
			--- Populates the resource cache. For the client.
			-- Should only be called once. Used internally. 

			local Populate
			function Populate(Parent)
				for _, Item in pairs(Parent:GetChildren()) do
					if (Item:IsA(&quot;LocalScript&quot;) or Item:IsA(&quot;ModuleScript&quot;)) then
						ResourceCache[Item.Name] = Item;

						if IsMainResource(Item) then
							MainResourcesClient[#MainResourcesClient+1] = Item;
						end
					else
						Populate(Item)
					end
				end
			end

			Populate(ReplicatedPackage)
		end
	else -- Configuration.IsServer then
		function PopulateResourceCache()
			--- Populates the resource cache. For the server. Also populates
			-- the replication cache. Used internally. 
			-- Should be called once. 

			--[[local NevermoreModule = script:Clone()
			NevermoreModule.Archivable = false;
			NevermoreModule.Parent = ReplicatedStorage--]]

			local Populate
			function Populate(Parent)
				for _, Item in pairs(Parent:GetChildren()) do
					if Item:IsA(&quot;Script&quot;) or Item:IsA(&quot;ModuleScript&quot;) then -- Will catch LocalScripts as they inherit from script
						if ResourceCache[Item.Name] then
							error(Configuration.PrintHeader .. &quot;There are two Resources called &apos;&quot; .. Item:GetFullName() ..&quot;&apos;. Nevermore failed to populate the cache..&quot;, 2)
						else
							if Item:IsA(&quot;LocalScript&quot;) or Item:IsA(&quot;ModuleScript&quot;) then
								-- Clone the item into the replication packet for
								-- replication. However, we do not clone server scripts.

								local ItemClone      = Item:Clone()
								ItemClone.Archivable = false;
								ItemClone.Parent     = ReplicatedPackage

								if Item:IsA(&quot;ModuleScript&quot;) then
									ResourceCache[Item.Name] = ItemClone;
								elseif IsMainResource(Item) then
									MainResourcesClient[#MainResourcesClient+1] = Item
								end
							else -- Do not replicate local scripts
								if IsMainResource(Item) then
									MainResourcesServer[#MainResourcesServer+1] = Item
								end
								ResourceCache[Item.Name] = Item								
							end
						end					
					else
						Populate(Item)
						--error(Configuration.PrintHeader .. &quot;The resource &apos;&quot; .. Item:GetFullName() ..&quot;&apos; is not a LocalScript, Script, or ModuleScript, and cannot be included. Nevermore failed to populate the cache..&quot;, 2)
					end
				end
			end

			Populate(ModulesContainer)
		end
	end
	ResouceManager.PopulateResourceCache = PopulateResourceCache

	local function GetResource(ResourceName)
		--- This script will load another script, module script, et cetera, if it is 
		--  available.  It will return the resource in question.
		-- @param ResourceName The name of the resource 
		-- @return The found resource

		local ResourceFound = ResourceCache[ResourceName]

		if ResourceFound then
			return ResourceFound
		else
			error(Configuration.PrintHeader .. &quot;The resource &apos;&quot; .. ResourceName .. &quot;&apos; does not exist, cannot load&quot;, 2)
		end
	end
	ResouceManager.GetResource = GetResource

	local function LoadScript(ScriptName)
		--- Runs a script, and can be called multiple times if the script is not
		--  a modular script. 
		-- @param ScriptName The name of the script to load.
		
		local ScriptToLoad = GetResource(ScriptName)
		if ScriptToLoad and ScriptToLoad:IsA(&quot;Script&quot;) then
			local NewScript = ScriptToLoad:Clone()
			NewScript.Disabled = true;

			--[[if Configuration.SoloTestMode then
				if NewScript:IsA(&quot;LocalScript&quot;) then
					NewScript.Parent = Players.LocalPlayer:FindFirstChild(&quot;PlayerGui&quot;)
				else
					NewScript.Parent = script;
				end
			else
				NewScript.Parent = script;
			end--]]
			if Configuration.IsServer then
				NewScript.Parent = NevermoreContainer;
			else
				NewScript.Parent = Players.LocalPlayer:FindFirstChild(&quot;Backpack&quot;)
			end

			Spawn(function()
				wait(0)
				NewScript.Disabled = false;
			end)
		else
			error(Configuration.PrintHeader .. &quot;The script &apos;&quot; .. ScriptName .. &quot;&apos; is a &apos;&quot;.. (ScriptToLoad and ScriptToLoad.ClassName or &quot;nil value&quot;) .. &quot;&apos; and cannot be loaded&quot;, 2)
		end
	end
	ResouceManager.LoadScript = LoadScript

	if Configuration.IsServer then
		local function LoadScriptOnClient(Script, Client)
			--- Runs a script on the client. Used internally.
			-- @param Script The script to load. Should be a script object
			-- @param Client The client to run the script on. Should be a Player
			--               object

			if Script and Script:IsA(&quot;LocalScript&quot;) then
				local NewScript = Script:Clone()
				NewScript.Disabled = true;
				NewScript.Parent = Client:FindFirstChild(&quot;Backpack&quot;)

				Spawn(function()
					wait(0)
					NewScript.Disabled = false;
				end)
			else
				error(Configuration.PrintHeader .. &quot;The script &apos;&quot; .. tostring(Script) .. &quot;&apos; is a &apos;&quot; .. (Script and Script.ClassName or &quot;nil value&quot;) .. &quot;&apos; and cannot be loaded&quot;, 2)
			end
		end
		ResouceManager.LoadScriptOnClient = LoadScriptOnClient

		local function ExecuteExecutables()
			--- Executes all the executable scripts on the server.

			for _, Item in pairs(GetLoadablesForServer()) do
				LoadScript(Item.Name)
			end
		end
		ResouceManager.ExecuteExecutables = ExecuteExecutables
	end

	local NativeImports

	local function ImportLibrary(LibraryDefinition, Environment, Prefix)
		--- Imports a library into a given environment, potentially adding a PreFix 
		--  into any of the values of the library,
		--  incase that&apos;s wanted. :)
		-- @param LibraryDefinition Table, the libraries definition
		-- @param Environment Another table, probably received by getfenv() in Lua 5.1, and __ENV in Lua 5.2
		-- @Param [Prefix] Optional string that will be prefixed to each function imported into the environment.

		if type(LibraryDefinition) ~= &quot;table&quot; then
			error(Configuration.PrintHeader .. &quot;The LibraryDefinition argument must be a table, got &apos;&quot; .. tostring(LibraryDefinition) .. &quot;&apos;&quot;, 2)
		elseif type(Environment) ~= &quot;table&quot; then
			error(Configuration.PrintHeader .. &quot;The Environment argument must be a table, got &apos;&quot; .. tostring(Environment) .. &quot;&apos;&quot;, 2)
		else
			Prefix = Prefix or &quot;&quot;;

			for Name, Value in pairs(LibraryDefinition) do
				if Environment[Prefix .. Name] == nil and not NativeImports[Name] then
					Environment[Prefix .. Name] = LibraryDefinition[Name]
				elseif not NativeImports[Name] then
					error(Configuration.PrintHeader .. &quot;Failed to import function &apos;&quot; .. (Prefix .. Name) .. &quot;&apos; as it already exists in the environment&quot;, 2)
				end
			end
		end
	end
	ResouceManager.ImportLibrary = ImportLibrary

	-- List of functions to import into each library. In this case, only the 
	-- environmental import functions and added to each library. 
	NativeImports = {
		import = ImportLibrary;
		Import = ImportLibrary;
	}

	local function LoadLibrary(LibraryName)
		--- Load&apos;s a modular script and packages it as a library. 
		-- @param LibraryName A string of the resource that ist the LibraryName

		-- print(Configuration.PrintHeader .. &quot;Loading Library &quot; .. LibraryName)

		local ModularScript = GetResource(LibraryName)

		if ModularScript then
			if ModularScript:IsA(&quot;ModuleScript&quot;) then
				-- print(Configuration.PrintHeader .. &quot;Loading Library &quot; .. ModularScript:GetFullName())
				local LibraryDefinition = require(ModularScript)

				if type(LibraryDefinition) == &quot;table&quot; then
					-- Import native definitions
					for Name, Value in pairs(NativeImports) do
						if LibraryDefinition[Name] == nil then
							LibraryDefinition[Name] = Value
						end
					end
				else
					error(Configuration.PrintHeader .. &quot; Library &apos;&quot; .. LibraryName .. &quot;&apos; did not return a table, returned a &apos;&quot; .. type(LibraryDefinition) .. &quot;&apos; value, &apos;&quot; .. tostring(LibraryDefinition) .. &quot;&apos;&quot;)
				end

				return LibraryDefinition
			else
				error(Configuration.PrintHeader .. &quot; The resource &quot; .. LibraryName 
					.. &quot; is not a ModularScript, as expected, it is a &quot; 
					.. ModularScript.ClassName, 2
				)
			end
		else
			error(Configuration.PrintHeader .. &quot; Could not identify a library known as &apos;&quot; .. LibraryName .. &quot;&apos;&quot;, 2)
		end
	end
	ResouceManager.LoadLibrary = LoadLibrary
end

--print(Configuration.PrintHeader .. &quot;Loaded resource manager module&quot;)

-----------------------------
-- NETWORKING STREAM SETUP --
-----------------------------
local Network = {} -- API goes in here
--[[
Contains the following API:

Network.GetDataStream
Network.GetDataStream

--]]
do
	--- Handles networking and PlayerLoading
	local DataStreamMain
	local GetDataStream
	local DataStreamCache = {}
	-- setmetatable(DataStreamCache, {__mode = &quot;v&quot;});

	local function GetCachedDataStream(RemoteFunction)
		--- Creates a datastream filter that will take requests and 
		--  filter them out. 
		-- @param RemoteFunction A remote function to connect to

		-- Execute on the server:
		--- Execute ( Player Client , [...] )
		-- Execute on the client:
		--- Execute ( [...] )
		if DataStreamCache[RemoteFunction] then
			if Configuration.IsClient then
				DataStreamCache[RemoteFunction].ReloadConnection()
			end
			return DataStreamCache[RemoteFunction]
		else
			local DataStream = {}
			local RequestTagDatabase = {}

			-- Set request handling, for solo test mode. The problem here is that Server and Client scripts share the same
			-- code base, because both load the same engine in replicated storage. 
			local function Send(...)
				-- print(Configuration.PrintHeader .. &quot; Sending SoloTestMode&quot;)
				-- print(...)

				local Arguments = {...}
				local PossibleClient = Arguments[1]
				if PossibleClient and type(PossibleClient) == &quot;userdata&quot; and PossibleClient:IsA(&quot;Player&quot;) then
					local Request = Arguments[2]
					if type(Request) == &quot;string&quot; then 
						local OtherArguments = {}
						for Index=3, #Arguments do
							OtherArguments[#OtherArguments+1] = Arguments[Index]
						end

						return RemoteFunction:InvokeClient(PossibleClient, Request:lower(), unpack(OtherArguments))
					else
						error(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request) .. &quot;&apos; received. Resolved into &apos;&quot; .. tostring(Request) .. &quot;&apos;&quot;)
						return nil
					end
				elseif type(PossibleClient) == &quot;string&quot; then
					local Request = PossibleClient

					if type(Request) == &quot;string&quot; then 
						local OtherArguments = {}
						for Index=2, #Arguments do
							OtherArguments[#OtherArguments+1] = Arguments[Index]
						end
						
						-- print(&quot;Invoke server&quot;)
						return RemoteFunction:InvokeServer(Request:lower(), unpack(OtherArguments))
					else
						error(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request) .. &quot;&apos; received. Resolved into &apos;&quot; .. tostring(Request) .. &quot;&apos;&quot;)
						return nil
					end
				else
					error(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request))
				end
			end

			local function SpawnSend(...)
				--- Sends the data, but doesn&apos;t wait for a response or return one. 

				local Data = {...}
				Spawn(function()
					Send(unpack(Data))
				end)
			end

			if Configuration.IsServer or Configuration.SoloTestMode then
				function RemoteFunction.OnServerInvoke(Client, Request, ...)
					--- Handles incoming requests
					-- @param Client The client the request is being sent to
					-- @param Request The request string that is being sent
					-- @param [...] The extra parameters of the request
					-- @return The results, if successfully executed

					if type(Request) == &quot;string&quot; then 
						-- print(Configuration.PrintHeader .. &quot;Server request received&quot;)
						-- print(...)

						if Client == nil then
							if Configuration.SoloTestMode then
								Client = Players.LocalPlayer
							else
								error(Configuration.PrintHeader .. &quot;No client provided&quot;)
							end
						end

						local RequestExecuter = RequestTagDatabase[Request:lower()]
						local RequestArguments = {...}
						if RequestExecuter then
							--[[local Results
							Results = pack(RequestExecuter(Client, unpack(RequestArguments)))
							return unpack(Results)--]]

							return RequestExecuter(Client, unpack(RequestArguments))
						else
							-- Warn(Configuration.PrintHeader .. &quot;Unregistered request called, request tag &apos;&quot; .. Request .. &quot;&apos;.&quot;)
							return nil
						end
					else
						error(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request) .. &quot;&apos; received. Resolved into &apos;&quot; .. tostring(Request) .. &quot;&apos;&quot;)
						return nil
					end
				end

				if not Configuration.SoloTestMode then
					function Send(Client, Request, ...)
						--- Sends a request to the client
						-- @param Client Player object, the client to send the request too
						-- @param Request the request to send it too.
						-- @return The results / derived data from the feedback

						-- DEBUG --
						--print(Configuration.PrintHeader .. &quot; Sending Request &apos;&quot; .. Request .. &quot;&apos; to Client &apos;&quot; .. tostring(Client) .. &quot;&apos;.&quot;)
						
						return RemoteFunction:InvokeClient(Client, Request:lower(), ...)
					end
				end
			end	
			if Configuration.IsClient or Configuration.SoloTestMode then -- Handle clientside streaming.
				-- We do this for solotest mode, to connect the OnClientInvoke and the OnServerInvoke 
				

				function DataStream.ReloadConnection()
					--- Reloads the OnClientInvoke event, which gets disconnected when scripts die on the client.
					-- However, this fixes it, because those scripts have to request the events every time. 

					--[[
						-- Note: When using RemoteFunctions, in a module script, on ROBLOX, and you load the ModuleScript
						with a LOCAL SCRIPT. When this LOCAL SCRIPT is killed, your OnClientInvoke function will be GARBAGE
						COLLECTED. You must thus, reload the OnClientInvoke function everytime the local script is loaded.

					--]]

					function RemoteFunction.OnClientInvoke(Request, ...)
						--- Handles incoming requests
						-- @param Request The request string that is being sent
						-- @param [...] The extra parameters of the request
						-- @return The results, if successfully executed


						if type(Request) == &quot;string&quot; then 
							-- print(Configuration.PrintHeader .. &quot;Client request received&quot;)
							-- print(...)

							local RequestExecuter = RequestTagDatabase[Request:lower()]
							local RequestArguments = {...}
							if RequestExecuter then
								Spawn(function()
									RequestExecuter(unpack(RequestArguments))
								end)
							else
								-- Warn(Configuration.PrintHeader .. &quot;Unregistered request called, request tag &apos;&quot; .. Request .. &quot;&apos;.&quot;)
							end
						else
							error(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request) .. &quot;&apos; received. Resolved into &apos;&quot; .. tostring(Request) .. &quot;&apos;&quot;)
						end
					end
				end

				--- Reload the initial connection.
				DataStream.ReloadConnection()

				if not Configuration.SoloTestMode then
					function Send(Request, ...)
						--- Sends a request to the server
						-- @param Request the request to send it too.
						-- @return The results / derived data from the feedback

						return RemoteFunction:InvokeServer(Request:lower(), ...)
					end
				end
			end
			DataStream.Send = Send
			DataStream.send = Send
			DataStream.Call = Send
			DataStream.call = Send
			DataStream.SpawnSend = SpawnSend
			DataStream.spawnSend = SpawnSend
			DataStream.spawn_send = SpawnSend

			local function RegisterRequestTag(RequestTag, Execute)
				--- Registers a request when sent
				-- @param RequestTag The tag that is expected
				-- @param Execute The functon to execute. It will be sent
				--                all remainig arguments.
				-- Request tags are not case sensitive

				--if not RequestTagDatabase[RequestTag:lower()] then
				RequestTagDatabase[RequestTag:lower()] = Execute;
				--else
					--error(Configuration.PrintHeader .. &quot;The request tag &quot; .. RequestTag:lower() .. &quot; is already registered.&quot;)
				--end
			end
			DataStream.RegisterRequestTag = RegisterRequestTag
			DataStream.registerRequestTag = RegisterRequestTag

			local function UnregisterRequestTag(RequestTag)
				--- Unregisters the request from the tag
				-- @param RequestTag String the tag to reregister
				RequestTagDatabase[RequestTag:lower()] = nil;
			end
			DataStream.UnregisterRequestTag = UnregisterRequestTag
			DataStream.unregisterRequestTag = UnregisterRequestTag

			DataStreamCache[RemoteFunction] = DataStream
			return DataStream
		end
	end

	local function GetCachedEventStream(RemoteEvent)
		-- Like GetCachedDataStream, but with RemoteEvents
		-- @param RemoteEvent The remote event to get the stream for. 

		if DataStreamCache[RemoteEvent] then
			if Configuration.IsClient then
				DataStreamCache[RemoteEvent].ReloadConnection()
			end
			return DataStreamCache[RemoteEvent]
		else
			local DataStream = {}
			local RequestTagDatabase = {}

			local function Fire(...)
				local Arguments = {...}
				local PossibleClient = Arguments[1]
				if PossibleClient and type(PossibleClient) == &quot;userdata&quot; and PossibleClient:IsA(&quot;Player&quot;) then
					local Request = Arguments[2]
					if type(Request) == &quot;string&quot; then 
						local OtherArguments = {}
						for Index=3, #Arguments do
							OtherArguments[#OtherArguments+1] = Arguments[Index]
						end

						return RemoteEvent:FireClient(PossibleClient, Request:lower(), unpack(OtherArguments))
					else
						error(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request) .. &quot;&apos; received. Resolved into &apos;&quot; .. tostring(Request) .. &quot;&apos;&quot;)
						return nil
					end
				elseif type(PossibleClient) == &quot;string&quot; then
					local Request = PossibleClient

					if type(Request) == &quot;string&quot; then 
						local OtherArguments = {}
						for Index=2, #Arguments do
							OtherArguments[#OtherArguments+1] = Arguments[Index]
						end
						
						return RemoteEvent:FireServer(Request:lower(), unpack(OtherArguments))
					else
						error(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request) .. &quot;&apos; received. Resolved into &apos;&quot; .. tostring(Request) .. &quot;&apos;&quot;)
						return nil
					end
				else
					error(Configuration.PrintHeader .. &quot;Invalid request DataType to the DataStream, DataType &apos;&quot; .. type(Request))
				end
			end

			local function FireAllClients(Request, ...)
				if type(Request) == &quot;string&quot; then
					RemoteEvent:FireAllClients(Request, ...)
				else
					error(Configuration.PrintHeader .. &quot;Invalid reques DataType  to the DataStream, DataType &apos;&quot; .. type(Request))
				end
			end

			if Configuration.IsServer or Configuration.SoloTestMode then
				RemoteEvent.OnServerEvent:connect(function(Client, Request, ...)
					--- Handles incoming requests
					-- @param Client The client the request is being sent to
					-- @param Request The request string that is being sent
					-- @param [...] The extra parameters of the request
					-- @return The results, if successfully executed

					if type(Request) == &quot;string&quot; then 
						if Client == nil then
							if Configuration.SoloTestMode then
								Client = Players.LocalPlayer
							else
								error(Configuration.PrintHeader .. &quot;No client provided&quot;)
							end
						end

						local RequestExecuter = RequestTagDatabase[Request:lower()]
						local RequestArguments = {...}
						if RequestExecuter then
							RequestExecuter(Client, unpack(RequestArguments))
						else
							-- Warn(Configuration.PrintHeader .. &quot;Unregistered request called, request tag &apos;&quot; .. Request .. &quot;&apos;.&quot;)
						end
					else
						error(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request) .. &quot;&apos; received. Resolved into &apos;&quot; .. tostring(Request) .. &quot;&apos;&quot;)
					end
				end)

				if not Configuration.SoloTestMode then
					function Fire(Client, Request, ...)
						--- Sends a request to the client
						-- @param Client Player object, the client to send the request too
						-- @param Request the request to send it too.
						-- @return The results / derived data from the feedback
				
						RemoteEvent:FireClient(Client, Request:lower(), ...)
					end
				end
			end	
			if Configuration.IsClient or Configuration.SoloTestMode then -- Handle clientside streaming.
				-- We do this for solotest mode, to connect the OnClientInvoke and the OnServerInvoke 
				
				local Event 
				function DataStream.ReloadConnection()
					--- Reloads the OnClientInvoke event, which gets disconnected when scripts die on the client.
					-- However, this fixes it, because those scripts have to request the events every time. 

					if Event then
						Event:disconnect()
					end

					Event = RemoteEvent.OnClientEvent:connect(function(Request, ...)
						--- Handles incoming requests
						-- @param Request The request string that is being sent
						-- @param [...] The extra parameters of the request
						-- @return The results, if successfully executed

						if type(Request) == &quot;string&quot; then 
							local RequestExecuter = RequestTagDatabase[Request:lower()]
							local RequestArguments = {...}
							if RequestExecuter then
								Spawn(function()
									RequestExecuter(unpack(RequestArguments))
								end)
							else
								-- Warn(Configuration.PrintHeader .. &quot;Unregistered request called, request tag &apos;&quot; .. Request .. &quot;&apos;.&quot;)
							end
						else
							error(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request) .. &quot;&apos; received. Resolved into &apos;&quot; .. tostring(Request) .. &quot;&apos;&quot;)
						end
					end)
				end

				--- Reload the initial connection.
				DataStream.ReloadConnection()

				if not Configuration.SoloTestMode then
					function Fire(Request, ...)
						--- Sends a request to the server
						-- @param Request the request to send it too.
						-- @return The results / derived data from the feedback

						RemoteEvent:FireServer(Request:lower(), ...)
					end
				end
			end
			DataStream.Fire = Fire
			DataStream.fire = Fire
			DataStream.FireAllClients = FireAllClients
			DataStream.fireAllClients = FireAllClients

			local function RegisterRequestTag(RequestTag, Execute)
				--- Registers a request when sent
				-- @param RequestTag The tag that is expected
				-- @param Execute The functon to execute. It will be sent
				--                all remainig arguments.
				-- Request tags are not case sensitive

				RequestTagDatabase[RequestTag:lower()] = Execute;
			end
			DataStream.RegisterRequestTag = RegisterRequestTag
			DataStream.registerRequestTag = RegisterRequestTag

			local function UnregisterRequestTag(RequestTag)
				--- Unregisters the request from the tag
				-- @param RequestTag String the tag to reregister

				RequestTagDatabase[RequestTag:lower()] = nil;
			end
			DataStream.UnregisterRequestTag = UnregisterRequestTag
			DataStream.unregisterRequestTag = UnregisterRequestTag

			DataStreamCache[RemoteEvent] = DataStream
			return DataStream
		end
	end

	local DataStreamMain = GetCachedDataStream(NetworkingRemoteFunction)

	local function GetDataStream(DataStreamName)
		--- Get&apos;s a dataStream channel
		-- @param DataSteamName The channel to log in to. 
		-- @return The main datastream, if no DataSteamName is provided

		if DataStreamName then
			return GetCachedDataStream(ResouceManager.GetDataStreamObject(DataStreamName, DataStreamContainer))
		else
			error(&quot;[NevermoreEngine] - Paramter DataStreamName was nil&quot;)
		end
	end
	Network.GetDataStream = GetDataStream

	local function GetEventStream(EventStreamName)
		--- Get&apos;s an EventStream chanel
		-- @param DataSteamName The channel to log in to. 
		-- @return The main datastream, if no DataSteamName is provided

		if EventStreamName then
			return GetCachedEventStream(ResouceManager.GetEventStreamObject(EventStreamName, EventStreamContainer))
		else
			error(&quot;[NevermoreEngine] - Paramter EventStreamName was nil&quot;)
		end
	end
	Network.GetEventStream = GetEventStream

	local function GetMainDatastream()
		--- Return&apos;s the main datastream, used internally for networking

		return DataStreamMain
	end
	Network.GetMainDatastream = GetMainDatastream

	if Configuration.IsServer then
		local function CheckIfPlayerIsBlacklisted(Player, BlackList)
			--- Checks to see if a player is blacklisted from the server
			-- @param Player The player to check for
			-- @param Blacklist The string blacklist
			-- @return Boolean is blacklisted

			for Id in string.gmatch(BlackList, &quot;%d+&quot;) do
				local ProductInformation = (MarketplaceService:GetProductInfo(Id))
				if ProductInformation then
					if string.match(ProductInformation[&quot;Description&quot;], Player.Name..&quot;;&quot;) then
						return true;
					end
				end
			end
			for Name in string.gmatch(BlackList, &quot;[%a%d]+&quot;) do
				if Player.Name:lower() == Name:lower() then
					return true;
				end
			end
			return false;
		end

		local function CheckPlayer(player)
			--- Makes sure a player has all necessary components.
			-- @return Boolean If the player has all the right components

			return player and player:IsA(&quot;Player&quot;) 
				and player:FindFirstChild(&quot;Backpack&quot;) 
				and player:FindFirstChild(&quot;StarterGear&quot;)
				-- and player.PlayerGui:IsA(&quot;PlayerGui&quot;) -- PlayerGui does not replicate to other clients.
		end

		local function CheckCharacter(player)
			--- Make sure that a character has all necessary components
			--  @return Boolean If the player has all the right components

			local character = player.Character;
			return character
				and character:FindFirstChild(&quot;Humanoid&quot;) 
				and character:FindFirstChild(&quot;Torso&quot;)
				and character:FindFirstChild(&quot;Head&quot;)
				and character.Humanoid:IsA(&quot;Humanoid&quot;)
				and character.Head:IsA(&quot;BasePart&quot;)
				and character.Torso:IsA(&quot;BasePart&quot;)
		end

		local function GenerateInitialSplashScreen(Player)
			--- Generates the initial SplashScreen for the player.  
			-- @param Player The player to genearte the SplashScreen in.
			-- @return The generated splashsreen

			local Configuration = {
				BackgroundColor3       = Color3.new(237/256, 236/256, 233/256);       -- Color of background of loading screen.
				AccentColor3           = Color3.new(8/256, 130/256, 83/256);          -- Not used. 
				LogoSize               = 200;
				LogoTexture            = &quot;http://www.roblox.com/asset/?id=129733987&quot;;
				LogoSpacingUp          = 70; -- Pixels up from loading frame.
				ParticalOrbitDistance  = 50;                                         -- How far out the particals orbit
			}

			local ScreenGui = Instance.new(&quot;ScreenGui&quot;, Player:FindFirstChild(&quot;PlayerGui&quot;))
			ScreenGui.Name = &quot;SplashScreen&quot;;

			local MainFrame = Instance.new(&apos;Frame&apos;)
				MainFrame.Name             = &quot;SplashScreen&quot;;
				MainFrame.Position         = UDim2.new(0, 0, 0, -2);
				MainFrame.Size             = UDim2.new(1, 0, 1, 22); -- Sized ans positioned weirdly because ROBLOX&apos;s ScreenGui doesn&apos;t cover the whole screen.
				MainFrame.BackgroundColor3 = Configuration.BackgroundColor3;
				MainFrame.Visible          = true;
				MainFrame.ZIndex           = 9;
				MainFrame.BorderSizePixel  = 0;
				MainFrame.Parent           = ScreenGui;

			local ParticalFrame = Instance.new(&apos;Frame&apos;)
				ParticalFrame.Name            = &quot;ParticalFrame&quot;;
				ParticalFrame.Position        = UDim2.new(0.5, -Configuration.ParticalOrbitDistance, 0.7, -Configuration.ParticalOrbitDistance);
				ParticalFrame.Size            = UDim2.new(0, Configuration.ParticalOrbitDistance*2, 0, Configuration.ParticalOrbitDistance*2); -- Sized ans positioned weirdly because ROBLOX&apos;s ScreenGui doesn&apos;t cover the whole screen.
				ParticalFrame.Visible         = true;
				ParticalFrame.BackgroundTransparency = 1
				ParticalFrame.ZIndex          = 9;
				ParticalFrame.BorderSizePixel = 0;
				ParticalFrame.Parent          = MainFrame;

			local LogoLabel = Instance.new(&apos;ImageLabel&apos;)
				LogoLabel.Name            = &quot;LogoLabel&quot;;
				LogoLabel.Position        = UDim2.new(0.5, -Configuration.LogoSize/2, 0.7, -Configuration.LogoSize/2 - Configuration.ParticalOrbitDistance*2 - Configuration.LogoSpacingUp);
				LogoLabel.Size            = UDim2.new(0, Configuration.LogoSize, 0, Configuration.LogoSize); -- Sized ans positioned weirdly because ROBLOX&apos;s ScreenGui doesn&apos;t cover the whole screen.
				LogoLabel.Visible         = true;
				LogoLabel.BackgroundTransparency = 1
				LogoLabel.Image           = Configuration.LogoTexture;
				LogoLabel.ZIndex          = 9;
				LogoLabel.BorderSizePixel = 0;
				LogoLabel.Parent          = MainFrame;

			return ScreenGui
		end

		local function DumpExecutables(Player)
			--- Executes all &quot;MainResources&quot; for the player
			-- @param Player The player to load the resources on 

			print(Configuration.PrintHeader .. &quot;Loading executables onto &quot; .. tostring(Player))
			for _, Item in pairs(ResouceManager.GetLoadablesForClient()) do
				ResouceManager.LoadScriptOnClient(Item, Player)
			end
		end

		local function SetupPlayer(Player)
			--- Setups up a player
			-- @param Player The player to setup

			Spawn(function()
				-- Wait for initial load
				while not (Player and Player.Parent) do
					wait(0)
				end

				if Configuration.BlackList and CheckIfPlayerIsBlacklisted(Player, Configuration.BlackList) then
					Player:Kick()
					Warn(&quot;Kicked Player &quot; .. Player.Name .. &quot; who was blacklisted&quot;)
				else
					local PlayerSplashScreen
					local HumanoidDiedEvent

					local function SetupCharacter()
						--- Setup&apos;s up a player&apos;s character
						Spawn(function()
							if not Configuration.CustomCharacters then
								if Player and Player.Parent == Players then
									while not (Player.Character 
										and Player.Character:FindFirstChild(&quot;Humanoid&quot;) 
										and Player.Character.Humanoid:IsA(&quot;Humanoid&quot;)) 
										and Player.Parent == Players do

										wait(0) -- Wait for the player&apos;s character to load
									end

									-- Make sure the player is still in game.
									if Player.Parent == Players then
										if HumanoidDiedEvent then
											HumanoidDiedEvent:disconnect()
											HumanoidDiedEvent = nil
										end
									
										HumanoidDiedEvent = Player.Character.Humanoid.Died:connect(function()
											wait(Configuration.CharacterRespawnTime)
											Player:LoadCharacter()
										end)

										DumpExecutables(Player)
									else
										print(Configuration.PrintHeader .. &quot;is not int he game. Cannot finish load.&quot;)
									end
								else
									print(Configuration.PrintHeader .. &quot; is not in the game. Cannot load.&quot;)
								end
							end
						end)
					end

					local function LoadSplashScreen()
						--- Load&apos;s the splash screen into the player

						if Configuration.SplashScreen then
							PlayerSplashScreen = GenerateInitialSplashScreen(Player)

							if Configuration.SoloTestMode then
								Network.AddSplashToNevermore(NevermoreEngine)
							end
						end
					end

					local function InitialCharacterLoad()
						-- Makes sure the character loads, and sets up the character if it has already loaded

						if not Player.Character then -- Incase the characters do start auto-loading. 
							if PlayerSplashScreen then
								PlayerSplashScreen.Parent = nil;
							end
						
							if Configuration.CustomCharacters then
								Player:LoadCharacter()
								if not Player.Character then
									Player.CharacterAdded:wait()
								end
								Player.Character:Destroy()
							else
								Player:LoadCharacter()
							end

							if PlayerSplashScreen then
								PlayerSplashScreen.Parent = Player.PlayerGui
							end
						else
							SetupCharacter()
						end
					end

					-- WHAT MUST HAPPEN
					-- Character must be loaded at least once
					-- Nevermore must run on the client to get a splash running. However, this can be seen as optinoal. 
					-- Nevermore must load the splash into the player. 

					-- SETUP EVENT FIRST
					Player.CharacterAdded:connect(SetupCharacter)
					InitialCharacterLoad() -- Force load the character, no matter what.
					LoadSplashScreen()
				end
			end)
		end

		local function ConnectPlayers()
			--- Connects all the events and adds players into the system. 

			-- Setup all the players that joined...
			for _, Player in pairs(game.Players:GetPlayers()) do
				SetupPlayer(Player)
			end

			-- And when they are added...
			Players.PlayerAdded:connect(function(Player)
				SetupPlayer(Player)
			end)
		end
		Network.ConnectPlayers = ConnectPlayers
	end
	if Configuration.IsClient or Configuration.SoloTestMode then 
		-- Setup the Splash Screen.
		-- However, in SoloTestMode, we need to setup the splashscreen in the
		-- replicated storage module, which is technically the server module. 

		local function AnimateSplashScreen(ScreenGui)
			--- Creates a Windows 8 style loading screen, finishing the loading animation
			-- of pregenerated spash screens.
			-- @param ScreenGui The ScreenGui generated by the splash initiator. 

			-- Will only be called if SpashScreens are enabled. 

			local Configuration = {
				OrbitTime              = 5;                                           -- How long the orbit should last.
				OrbitTimeBetweenStages = 0.5;
				Texture                = &quot;http://www.roblox.com/asset/?id=129689248&quot;; -- AssetId of orbiting object (Decal)
				ParticalOrbitDistance  = 50;                                         -- How far out the particals orbit
				ParticalSize           = 10;                                          -- How big the particals are, probably should be an even number..
				ParticalCount          = 5;                                           -- How many particals to generate
				ParticleSpacingTime    = 0.25;                                         -- How long to wait between earch partical before releasing the next one
			}

			local Splash = {}

			local IsActive = true;
			local MainFrame = ScreenGui.SplashScreen
			local ParticalFrame = MainFrame.ParticalFrame
			local ParticalList = {}

			local function Destroy()
				-- Can be called to Destroy the SplashScreen. Will have the Alias
				-- ClearSplash in NevermoreEngine

				IsActive = false;
				ScreenGui:Destroy()
			end
			Splash.Destroy = Destroy

			Spawn(function()
				if IsActive then
					local function MakePartical(Parent, RotationRadius, Size, Texture)
						-- Creates a partical that will circle around the center of it&apos;s Parent.  
						-- RotationRadius is how far away it orbits
						-- Size is the size of the ball...
						-- Texture is the asset id of the texture to use... 

						-- Create a new ImageLabel to be our rotationg partical
						local Partical = Instance.new(&quot;ImageLabel&quot;)
							Partical.Name                   = &quot;Partical&quot;;
							Partical.Size                   = UDim2.new(0, Size, 0, Size);
							Partical.BackgroundTransparency = 1;
							Partical.Image                  = Texture;
							Partical.BorderSizePixel        = 0;
							Partical.ZIndex                 = 10;
							Partical.Parent                 = Parent;
							Partical.Visible                = false;

						local ParticalData = {
							Frame          = Partical;
							RotationRadius = RotationRadius;
							StartTime      = math.huge;
							Size           = Size;
							SetPosition    = function(ParticalData, CurrentPercent)
								-- Will set the position of the partical relative to CurrentPercent.  CurrentPercent @ 0 should be 0 radians.

								local PositionX = math.cos(math.pi * 2 * CurrentPercent) * ParticalData.RotationRadius
								local PositionY = math.sin(math.pi * 2 * CurrentPercent) * ParticalData.RotationRadius
								ParticalData.Frame.Position = UDim2.new(0.5 + PositionX/2,  -ParticalData.Size/2, 0.5 + PositionY/2, -ParticalData.Size/2)
								--ParticalData.Frame:TweenPosition(UDim2.new(0.5 + PositionX/2,  -ParticalData.Size/2, 0.5 + PositionY/2, -ParticalData.Size/2), &quot;Out&quot;, &quot;Linear&quot;, 0.03, true)
							end;
						}

						return ParticalData;
					end

					local function EaseOut(Percent, Amount)
						-- Just return&apos;s the EaseOut smoothed out percentage 

						return -(1 - Percent^Amount) + 1
					end

					local function EaseIn(Percent, Amount)
						-- Just return&apos;s the Easein smoothed out percentage 

						return Percent^Amount
					end

					local function EaseInOut(Percent, Amount)
						-- Return&apos;s a smoothed out percentage, using in-out.  &apos;Amount&apos; 
						-- is the powered amount (So 2 would be a quadratic EaseInOut, 
						-- 3 a cubic, and so forth.  Decimals supported)

						if Percent &lt; 0.5 then
							return ((Percent*2)^Amount)/2
						else
							return (-((-(Percent*2) + 2)^Amount))/2 + 1
						end
					end

					local function GetFramePercent(Start, Finish, CurrentPercent)
						-- Return&apos;s the  relative percentage to the overall 
						-- &apos;CurrentPercentage&apos; which ranges from 0 to 100; So in one 
						-- case, 0 to 0.07, at 50% would be 0.035;

						return ((CurrentPercent - Start) / (Finish - Start))
					end

					local function GetTransitionedPercent(Origin, Target, CurrentPercent)
						-- Return&apos;s the Transitional percentage (How far around the 
						-- circle the little ball is), when given a Origin ((In degrees)
						-- and a Target (In degrees), and the percentage transitioned 
						-- between the two...)

						return (Origin + ((Target - Origin) * CurrentPercent)) / 360;
					end

					-- Start the beautiful update loop
					
					-- Add / Create particals
					for Index = 1, Configuration.ParticalCount do
						ParticalList[Index] = MakePartical(ParticalFrame, 1, Configuration.ParticalSize, Configuration.Texture)
					end

					local LastStartTime       = 0; -- Last time a partical was started
					local ActiveParticalCount = 0;
					local NextRunTime         = 0 -- When the particals can be launched again...

					while IsActive do
						local CurrentTime = tick();
						for Index, Partical in ipairs(ParticalList) do
							-- Calculate the CurrentPercentage from the time and 
							local CurrentPercent = ((CurrentTime - Partical.StartTime) / Configuration.OrbitTime);

							if CurrentPercent &lt; 0 then 
								if LastStartTime + Configuration.ParticleSpacingTime &lt;= CurrentTime and ActiveParticalCount == (Index - 1) and NextRunTime &lt;= CurrentTime then
									-- Launch Partical...

									Partical.Frame.Visible = true;
									Partical.StartTime     = CurrentTime;
									LastStartTime          = CurrentTime
									ActiveParticalCount    = ActiveParticalCount + 1;

									if Index == Configuration.ParticalCount then
										NextRunTime = CurrentTime + Configuration.OrbitTime + Configuration.OrbitTimeBetweenStages;
									end
									Partical:SetPosition(45/360)
								end
							elseif CurrentPercent &gt; 1 then
								Partical.Frame.Visible = false;
								Partical.StartTime = math.huge;
								ActiveParticalCount = ActiveParticalCount - 1;
							elseif CurrentPercent &lt;= 0.08 then
								Partical:SetPosition(GetTransitionedPercent(45, 145, EaseOut(GetFramePercent(0, 0.08, CurrentPercent), 1.2)))
							elseif CurrentPercent &lt;= 0.39 then
								Partical:SetPosition(GetTransitionedPercent(145, 270, GetFramePercent(0.08, 0.39, CurrentPercent)))
							elseif CurrentPercent &lt;= 0.49 then
								Partical:SetPosition(GetTransitionedPercent(270, 505, EaseInOut(GetFramePercent(0.39, 0.49, CurrentPercent), 1.1)))
							elseif CurrentPercent &lt;= 0.92 then
								Partical:SetPosition(GetTransitionedPercent(505, 630, GetFramePercent(0.49, 0.92, CurrentPercent)))
							elseif CurrentPercent &lt;= 1 then
								Partical:SetPosition(GetTransitionedPercent(630, 760, EaseOut(GetFramePercent(0.92, 1, CurrentPercent), 1.1)))
							end
						end
						wait()
					end
				end
			end)

			return Splash;
		end

		local function SetupSplashScreenIfEnabled()
			--- Sets up the Splashscreen if it&apos;s enabled, and returnst he disabling / removing function.
			-- @return The removing function, even if the splashscreen doesn&apos;t exist.

			local SplashEnabled = false

			local ScreenGui = Players.LocalPlayer.PlayerGui:FindFirstChild(&quot;SplashScreen&quot;)
			local SplashScreen
			if Configuration.SplashScreen and ScreenGui then
				SplashEnabled = true
				SplashScreen = AnimateSplashScreen(ScreenGui)
			else
				print(Configuration.PrintHeader .. &quot;Splash Screen could not be found, or is not enabled&quot;)
			end

			local function ClearSplash()
				-- print(Configuration.PrintHeader .. &quot;Clearing splash.&quot;)

				--- Destroys and stops all animation of the current splashscreen, if it exists.
				if SplashScreen then
					SplashEnabled = false
					SplashScreen.Destroy()
					SplashScreen = nil;
				--else
					--print(Configuration.PrintHeader .. &quot;No splash to clear.&quot;)
				end
			end

			local function GetSplashEnabled()
				return SplashEnabled
			end
			
			return ClearSplash, GetSplashEnabled
		end
		-- Network.SetupSplashScreenIfEnabled = SetupSplashScreenIfEnabled

		local function AddSplashToNevermore(NevermoreEngine)
			local ClearSplash, GetSplashEnabled = SetupSplashScreenIfEnabled()

			NevermoreEngine.ClearSplash  = ClearSplash
			NevermoreEngine.clearSplash  = ClearSplash
			NevermoreEngine.clear_splash = ClearSplash

			NevermoreEngine.GetSplashEnabled = GetSplashEnabled
			NevermoreEngine.getSplashEnabled = GetSplashEnabled
			NevermoreEngine.get_splash_enabled = GetSplashEnabled
		end
		Network.AddSplashToNevermore = AddSplashToNevermore
	end


	local function ExecuteCode(Code)
		local Execute, Error = loadstring(Code)
		if Execute then
			local RegularOutput
			local ErrorOutput = ypcall(function()
				RegularOutput = pack(Execute())
			end)
			if type(ErrorOutput) == &quot;string&quot; then
				error(ErrorOutput, 2)
				return nil
			else
				return RegularOutput
			end
		else
			error(Error, 2)
		end
	end

	if Configuration.SoloTestMode then
		function Network.CallClient(Client, Code)
			--- Executes code on the client. Will yield. Client must have required Nevermore for it to run.
			-- @param Client The client to execute the code on
			-- @param Code String of the code to be executed
			-- @return Output

			if Client == Players.LocalPlayer then
				return ExecuteCode(Code)
			else
				error(Configuration.PrintHeader .. &quot;Client was nil/not the local player for call client&quot;)
			end
		end

		Network.ExecuteCode = ExecuteCode

	elseif Configuration.IsClient then
		-- Client side networking.

		local function CallServer(Code)
			--- Executes the code on the server. 
			-- @param Code String of the code to be executed. It will yield. 

			return DataStreamMain.Send(Configuration.NevermoreRequestPrefix .. &quot;CallServer&quot;, Code)
		end
		Network.CallServer = CallServer

		local function CallClient(Client, Code)
			--- Executes code on the client. Will yield. Routes the request rhrough the server.
			-- @param Client The client to execute the code on
			-- @param Code String of the code to be executed
			-- @return Output

			if Client and Client:IsA(&quot;Player&quot;) then
				if Code and tostring(Code) then
					return DataStreamMain.Send(Configuration.NevermoreRequestPrefix .. &quot;CallClient&quot;, Client, Code)
				else
					error(Configuration.PrintHeader .. &quot; Could not execute Code sent as the code sent as a request was not a string.&quot;, 2)
				end
			else
				error(Configuration.PrintHeader .. &quot; Could not send code request because client did not exist.&quot;, 2)
			end
		end
		Network.CallClient = CallClient

		-- Setup code to for incoming client requests

		local function ExecuteCodeLocal(Code)
			if type(Code) == &quot;string&quot; then
				ExecuteCode(Code)
			else
				error(Configuration.PrintHeader .. &quot; Could not execute Code sent as the code sent as a request was not a string.&quot;, 2)
			end
		end

		DataStreamMain.RegisterRequestTag(Configuration.NevermoreRequestPrefix .. &quot;CallClient&quot;, function(Code)
			ExecuteCodeLocal(Code)
		end)
	else
		-- Serverside networking

		local function CallServer(Code, ClientRequesting)
			--- Executes the code on the server.  It will yeild. 
			-- @param [ClientRequesting] The cilent requesting the code. Optional.
			-- @param Code String of the code to be executed
			-- @return The output of the executed code. 

			if type(Code) == &quot;string&quot; then
				ExecuteCode(Code)
			else
				error(Configuration.PrintHeader .. &quot; Could not execute Code sent by &apos;&quot; .. tostring(ClientRequesting) .. &quot;&apos; as the code sent as a request was not a string.&quot;, 2)
			end
		end
		Network.CallServer = CallServerf

		DataStreamMain.RegisterRequestTag(Configuration.NevermoreRequestPrefix .. &quot;CallServer&quot;, function(Client, Code)
			return CallServer(Code, Client)
		end)

		local function CallClient(Client, Code)
			--- Executes code on the client. Will yield. Client must have required Nevermore for it to run.
			-- @param Client The client to execute the code on
			-- @param Code String of the code to be executed
			-- @return Output

			print(tostring(Client), tostring(Code))

			if type(Code) == &quot;string&quot; then
				if Client and Client:IsA(&quot;Player&quot;) then
					return DataStreamMain.Send(Client, Configuration.NevermoreRequestPrefix .. &quot;CallClient&quot;, Code)
				else
					error(Configuration.PrintHeader .. &quot; Could not send code request because client did not exist.&quot;, 2)
					return nil
				end
			else
				error(Configuration.PrintHeader .. &quot; Could not execute Code sent to client &apos;&quot; .. tostring(Client) .. &quot;&apos; as the code sent as a request was not a string.&quot;, 2)
				return nil
			end
		end
		Network.CallClient = CallClient

		-- Setup incoming requests for other clients
		DataStreamMain.RegisterRequestTag(Configuration.NevermoreRequestPrefix .. &quot;CallClient&quot;, function(Client, ClientToCall, Code)
			print(&quot;CallClient from the server came in, ClientToCall = &quot; .. tostring(ClientToCall) .. &quot; Code = &quot; .. tostring(Code))
			return CallClient(ClientToCall, Code)
		end)
	end
end

--print(Configuration.PrintHeader .. &quot;Loaded network module&quot;)

-----------------------
-- UTILITY NEVERMORE --
-----------------------
local SetRespawnTime
if Configuration.IsServer then
	local function SetRespawnTime(NewTime)
		--- Sets how long it takes for a character to respawn.
		-- @param NewTime The new time it takes for a character to respawn
		if type(NewTime) == &quot;number&quot; then
			Configuration.CharacterRespawnTime = NewTime
		else
			error(Configuration.PrintHeader .. &quot; Could not set respawn time to &apos;&quot; .. tostring(NewTime) .. &quot;&apos;, number expected, got &apos;&quot; .. type(NewTime) .. &quot;&apos;&quot;)
		end
	end

	Network.GetMainDatastream().RegisterRequestTag(Configuration.NevermoreRequestPrefix .. &quot;SetRespawnTime&quot;, function(Client, NewTime)
		SetRespawnTime(NewTime)
	end)
else
	local function SetRespawnTime(NewTime)
		--- Sends a request to the server to set the respawn time.
		-- @param NewTime The new respawn time.

		DataStreamMain.Send(Configuration.NevermoreRequestPrefix .. &quot;SetRespawnTime&quot;, NewTime)
	end
end

--print(Configuration.PrintHeader .. &quot;Loaded Nevermore Utilities&quot;)

------------------------
-- INITIATE NEVERMORE --
------------------------

--print(Configuration.PrintHeader .. &quot;Setup splashscreen&quot;)

NevermoreEngine.SetRespawnTime          = SetRespawnTime
NevermoreEngine.setRespawnTime          = SetRespawnTime
NevermoreEngine.set_respawn_time        = SetRespawnTime

NevermoreEngine.GetResource             = ResouceManager.GetResource
NevermoreEngine.getResource             = ResouceManager.GetResource
NevermoreEngine.get_resource            = ResouceManager.GetResource

NevermoreEngine.LoadScript              = ResouceManager.LoadScript
NevermoreEngine.loadScript              = ResouceManager.LoadScript
NevermoreEngine.load_script             = ResouceManager.LoadScript

NevermoreEngine.LoadLibrary             = ResouceManager.LoadLibrary
NevermoreEngine.loadLibrary             = ResouceManager.LoadLibrary
NevermoreEngine.load_library            = ResouceManager.LoadLibrary

NevermoreEngine.ImportLibrary           = ResouceManager.ImportLibrary
NevermoreEngine.importLibrary           = ResouceManager.ImportLibrary
NevermoreEngine.import_library          = ResouceManager.ImportLibrary

NevermoreEngine.Import                  = ResouceManager.ImportLibrary
NevermoreEngine.import                  = ResouceManager.ImportLibrary

-- These 2 following are used to get the raw objects. 
NevermoreEngine.GetDataStreamObject     = ResouceManager.GetDataStreamObject
NevermoreEngine.getDataStreamObject     = ResouceManager.GetDataStreamObject
NevermoreEngine.get_data_stream_object  = ResouceManager.GetDataStreamObject

NevermoreEngine.GetEventStreamObject    = ResouceManager.GetEventStreamObject
NevermoreEngine.getEventStreamObject    = ResouceManager.GetEventStreamObject
NevermoreEngine.get_event_stream_object = ResouceManager.GetEventStreamObject

NevermoreEngine.GetDataStream           = Network.GetDataStream
NevermoreEngine.getDataStream           = Network.GetDataStream
NevermoreEngine.get_data_stream         = Network.GetDataStream

NevermoreEngine.GetEventStream          = Network.GetEventStream
NevermoreEngine.getEventStream          = Network.GetEventStream
NevermoreEngine.get_event_stream        = Network.GetEventStream

NevermoreEngine.CallServer              = Network.CallServer
NevermoreEngine.CallServer              = Network.CallServer
NevermoreEngine.CallServer              = Network.CallServer

NevermoreEngine.CallClient              = Network.CallClient
NevermoreEngine.callClient              = Network.CallClient
NevermoreEngine.call_client             = Network.CallClient

NevermoreEngine.SoloTestMode            = Configuration.SoloTestMode
-- NevermoreEngine.IsServer             = Configuration.IsServer
-- NevermoreEngine.IsClient             = Configuration.IsClient

-- Internally used
NevermoreEngine.GetMainDatastream       = Network.GetMainDatastream

NevermoreEngine.NevermoreContainer      = NevermoreContainer
NevermoreEngine.nevermoreContainer      = NevermoreContainer
NevermoreEngine.nevermore_container     = NevermoreContainer

NevermoreEngine.ReplicatedPackage       = ReplicatedPackage
NevermoreEngine.replicatedPackage       = ReplicatedPackage
NevermoreEngine.replicated_package      = ReplicatedPackage

if Configuration.IsServer then
	local function Initiate()
		--print(Configuration.PrintHeader .. &quot;Nevermore is initiating.&quot;)
		--- Initiates Nevermore. This should only be called once. 
		-- Since Nevermore sets all of its executables, and executes them manually, 
		-- there is no need to wait for Nevermore when these run. 

		NevermoreEngine.Initiate = nil
		ResouceManager.PopulateResourceCache()

		if Configuration.IsServer then
			Network.ConnectPlayers()
			ResouceManager.ExecuteExecutables()
		end

		-- if Configuration.SoloTestMode then
			-- print(Configuration.PrintHeader .. &quot;SoloTestMode enabled for NevermoreEngine.&quot;)
			-- SetupSplash()
		-- end
	end
	NevermoreEngine.Initiate = Initiate
else
	ResouceManager.PopulateResourceCache()
	Network.AddSplashToNevermore(NevermoreEngine)
end	
	--print(Configuration.PrintHeader .. &quot;Nevermore is initiated successfully.&quot;

--print(Configuration.PrintHeader .. &quot;#ReturnValues = &quot;.. (#ReturnValues))

return NevermoreEngine</ProtectedString>
</Properties>
</Item>
<Item class="Script" referent="RBX3">
<Properties>
<string name="Name">NevermoreEngineLoader</string>
<ProtectedString name="Source">--- This scripts loads Nevermore from the server.
-- It also replicates the into ReplicatedStorage for internal usage. 

-----------------------
-- UTILITY FUNCTIONS --
-----------------------

local TestService       = game:GetService(&apos;TestService&apos;)
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local function Warn(WarningText)
	--- Used to yell at the player
	-- @param WarningText The text to warn with.

	Spawn(function()
		TestService:Warn(false, WarningText)
	end)
end

local function WaitForChild(Parent, Name)
	--- Yields until a child is added. Warns after 5 seconds of yield.
	-- @param Parent The parent to wait for the child of
	-- @param Name The name of the child
	-- @return The child found

	local Child = Parent:FindFirstChild(Name)
	local StartTime = tick()
	local Warned = false;
	while not Child do
		wait(0)
		Child = Parent:FindFirstChild(Name)
		if not Warned and StartTime + 5 &lt;= tick() then
			Warned = true;
			Warn(&quot;[NevermoreEngineLoader] -&quot; .. &quot; &quot; .. Name .. &quot; has not replicated after 5 seconds, may not be able to execute Nevermore.&quot;)
		end
	end
	return Child
end

-------------
-- LOADING --
-------------

-- Wait for parent to resolve
while not script.Parent do
	wait(0)
end

-- Identify the modular script
-- local NevermoreModularScript = WaitForChild(script.Parent, &quot;NevermoreEngine&quot;)

local NevermoreModularScript = ReplicatedStorage:FindFirstChild(&quot;NevermoreEngine&quot;)
if not NevermoreModularScript then
	local NevermoreModularScriptSource = WaitForChild(script.Parent, &quot;NevermoreEngine&quot;)

	NevermoreModularScript             = NevermoreModularScriptSource:Clone()
	NevermoreModularScript.Archivable  = false
end

local Nevermore = require(NevermoreModularScript)

-- Set identifier, and initiate.
Nevermore.Initiate()
NevermoreModularScript.Parent = ReplicatedStorage</ProtectedString>
<bool name="Disabled">false</bool>
</Properties>
</Item>
</Item>
<Item class="Backpack" referent="RBX4">
<Properties>
<string name="Name">Modules</string>
</Properties>
<Item class="Backpack" referent="RBX5">
<Properties>
<string name="Name">Character</string>
</Properties>
<Item class="ModuleScript" referent="RBX6">
<Properties>
<string name="Name">Character</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local RawCharacter      = LoadCustomLibrary(&quot;RawCharacter&quot;)
local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)


qSystems:Import(getfenv(0));

local safeLib = {}

--- This library handles making sure it is safe to use RawCharacter functions. 
-- @author Quenty
-- Last modified January 14th, 2013

--[[-- Change Log --

January 19th, 2014
- Updated to include output parser

--]]

for functionName, libraryItem in pairs(RawCharacter) do
	if type(functionName) ~= &quot;string&quot; then
		error(&quot;[Character] - functionName &apos;&quot;..tostring(functionName)..&quot;&apos; a &apos;&quot;..Type.GetType(functionName)..&quot;&apos; value should be a string&quot;)
	end
	if type(libraryItem) == &quot;function&quot; and functionName:lower() ~= &quot;import&quot; then
		safeLib[functionName] = function(character, ...) 
			if CheckCharacter(character) then
				libraryItem(character, ...)
			else
				error(&quot;[Character] - The character did not have a correct head, torso, or humanoid, so &apos;&quot;..functionName..&quot;&apos; could not execute&quot;)
			end
		end
	end
end

return safeLib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX7">
<Properties>
<string name="Name">CharacterAnimationService</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local qCFrame           = LoadCustomLibrary(&quot;qCFrame&quot;)

qSystems:Import(getfenv(0))

-- CharacterAnimationService.lua
-- This system handle&apos;s character animations. 
-- @author Quenty
-- Last Modified February 3rd, 2014

local lib = {}

local WEAK_MODE = {
	K = {__mode=&quot;k&quot;};
	V = {__mode=&quot;v&quot;};
	KV = {__mode=&quot;kv&quot;};
}

local Sequences = {}
lib.Sequences = Sequences

local function AddKeyFrame(self, KeyFrame)
	self.KeyFrames[KeyFrame.Time] = KeyFrame

	if KeyFrame.Time &gt; self.PlayTime then
		self.PlayTime = KeyFrame.Time
	end
end
lib.AddKeyFrame = AddKeyFrame

local function AddPose(self, Pose)
	self.Poses[#self.Poses+1] = Pose
end
lib.AddPose = AddPose

local function Sequence(Name, Looped, Priority)
	return function(NewTable)
		local NewSequence = {}
		NewSequence.Name        = Name
		NewSequence.Priority    = Priority
		NewSequence.Looped      = Looped
		NewSequence.KeyFrames   = {} -- Stored as: Value: Time | KeyFrame
		NewSequence.AddKeyFrame = AddKeyFrame
		NewSequence.PlayTime    = 0

		for _, KeyFrame in pairs(NewTable) do
			if type(KeyFrame) == &quot;function&quot; then
				NewSequence:AddKeyFrame(KeyFrame())
			else
				NewSequence:AddKeyFrame(KeyFrame)
			end
		end

		return NewSequence
	end
end
lib.Sequence = Sequence

local function Keyframe(Time)
	return function(NewTable)
		local NewKeyFrame = {}
		NewKeyFrame.Time    = Time
		NewKeyFrame.Poses   = {}
		NewKeyFrame.AddPose = AddPose

		for _, Pose in pairs(NewTable) do
			if type(Pose) == &quot;function&quot; then
				NewKeyFrame:AddPose(Pose())
			else
				NewKeyFrame:AddPose(Pose)
			end
		end

		return NewKeyFrame
	end
end
lib.Keyframe = Keyframe

local function Pose(PartName, CFrame)
	return function(NewTable)
		local NewPose = {}
		NewPose.Name = PartName;
		NewPose.CFrame = CFrame
		NewPose.Poses = {}
		NewPose.AddSubPose = AddPose

		if NewTable then
			for _, Pose in pairs(NewTable) do
				if type(Pose) == &quot;function&quot; then
					NewPose:AddSubPose(Pose())
				else
					NewPose:AddSubPose(Pose)
				end
			end
		end

		return NewPose
	end
end
lib.Pose = Pose


local function PersonifyCharacter(Character, PartSource, DoNotRemoveAnimateScript)
	local CharacterTorso = Character:FindFirstChild(&quot;Torso&quot;)
	if not CharacterTorso then 
		warn(&quot;[PersonifyCharacter] - Could not find &apos;Torso&apos; in Character, will not personify.&quot;)
	end
	if not DoNotRemoveAnimateScript and Character:FindFirstChild(&quot;Animate&quot;) and Character.Animate:IsA(&quot;Script&quot;) then
		Character.Animate:Destroy()
	end

	local function AddPart(name, P0, C0, C1)
		if PartSource[name] then
			local NewPart = PartSource[name]:Clone()
			local Weld = Instance.new(&quot;Weld&quot;)
			Weld.Name = name
			Weld.Part0 = P0
			Weld.C0 = C0
			Weld.C1 = C1
			Weld.Part1 = NewPart
			Weld.Parent = P0
			NewPart.Parent = Character
			return NewPart
		else
			error(&quot;[PersonifyCharacter] - Could not find Part &quot;..name..&quot; in PartSource &apos;&quot;..PartSource:GetFullName()..&quot;&apos;&quot;)
		end
	end

	local function MakeTransparent(PartName)
		if Character:FindFirstChild(PartName) then 
			Character[PartName].Transparency = 1 
		end
	end

	local function GetColor(PartName)
		if Character:FindFirstChild(PartName) then
			return Character[PartName].BrickColor 
		else 
			return BrickColor.new() 
		end
	end

	--
	MakeTransparent(&quot;Torso&quot;)
	MakeTransparent(&quot;Right Leg&quot;)
	MakeTransparent(&quot;Left Leg&quot;)
	MakeTransparent(&quot;Right Arm&quot;)
	MakeTransparent(&quot;Left Arm&quot;)
	--

	local BodyColors = Character:FindFirstChild(&quot;Body Colors&quot;)

	local torso         = AddPart(&quot;PTorso&quot;, CharacterTorso, CFrame.new(0, 0.5, 0), CFrame.new()); torso.BrickColor = (BodyColors and BodyColors.TorsoColor) or GetColor(&quot;Torso&quot;)
	local rightshoulder = AddPart(&quot;PRightShoulder&quot;, torso, CFrame.new(1.0, 0.25, 0), CFrame.new(0, 0.25, 0)); rightshoulder.BrickColor = (BodyColors and BodyColors.RightArmColor) or GetColor(&quot;Right Arm&quot;)
	local leftshoulder  = AddPart(&quot;PLeftShoulder&quot;, torso, CFrame.new(-1.0, 0.25, 0), CFrame.new(0, 0.25, 0)); leftshoulder.BrickColor = (BodyColors and BodyColors.LeftArmColor) or GetColor(&quot;Left Arm&quot;)
	local rightbicep    = AddPart(&quot;PRightBicep&quot;, rightshoulder, CFrame.new(0, -0.5, 0), CFrame.new(0, 0.5, 0)); rightbicep.BrickColor = (BodyColors and BodyColors.RightArmColor) or GetColor(&quot;Right Arm&quot;)
	local leftbicep     = AddPart(&quot;PLeftBicep&quot;, leftshoulder, CFrame.new(0, -0.5, 0), CFrame.new(0, 0.5, 0)); leftbicep.BrickColor = (BodyColors and BodyColors.LeftArmColor) or GetColor(&quot;Left Arm&quot;)
	--
	local hips          = AddPart(&quot;PHips&quot;, torso, CFrame.new(0, -0.25, 0), CFrame.new(0, 0.5, 0)); hips.BrickColor = (BodyColors and BodyColors.TorsoColor) or GetColor(&quot;Torso&quot;)
	local rightleg      = AddPart(&quot;PRightLeg&quot;, hips, CFrame.new(0.4, -0.5, 0), CFrame.new(0, 0.25, 0)); rightleg.BrickColor = (BodyColors and BodyColors.RightLegColor) or GetColor(&quot;Right Leg&quot;)
	local leftleg       = AddPart(&quot;PLeftLeg&quot;, hips, CFrame.new(-0.4, -0.5, 0), CFrame.new(0, 0.25, 0)); leftleg.BrickColor = (BodyColors and BodyColors.LeftLegColor) or GetColor(&quot;Left Leg&quot;)
	local rightshin     = AddPart(&quot;PRightShin&quot;, rightleg, CFrame.new(0, -0.5, 0), CFrame.new(0, 0.75, 0)); rightshin.BrickColor = (BodyColors and BodyColors.RightLegColor) or GetColor(&quot;Right Leg&quot;)
	local leftshin      = AddPart(&quot;PLeftShin&quot;, leftleg, CFrame.new(0, -0.5, 0), CFrame.new(0, 0.75, 0)); leftshin.BrickColor = (BodyColors and BodyColors.LeftLegColor) or GetColor(&quot;Left Leg&quot;)
end
lib.PersonifyCharacter = PersonifyCharacter
lib.personifyCharacter = PersonifyCharacter


--[[
local function ParsePriority(Sequence)
	-- Parse Enum to number. Simple enough.

	if Sequence.Priority == Enum.AnimationPriority.Idle then
		return 0
	elseif Sequence.Priority == Enum.AnimationPriority.Movement then
		return 1
	elseif Sequence.Priority == Enum.AnimationPriority.Action then
		return 2
	else
		error(&quot;[CharacterAnimationService] - Could not get priority&quot;)
	end
end--]]

local SlerpCFrame = qCFrame.SlerpCFrame

local MakeCharacterAnimationService = Class(function(CharacterAnimationService, Character)
	local AnimationLevelsStack = {} -- Keep a nice list of priority levels.. (There&apos;s only 3 though)
	local Sequences = {}
	setmetatable(Sequences, WEAK_MODE.K)
	local JointAndPartCache = {} -- Calling it every frame, I think it&apos;s worth it.
	setmetatable(JointAndPartCache, WEAK_MODE.K) -- Memory collection..
	local JointDataList = {}
	--setmetatable(JointDataList, WEAK_MODE.K)

	--[[
		When animating, each joint will be positioned according to a percentage between two CFrames, the &apos;Last&apos; CFrame, and the &apos;Target&apos; 
		CFrame. The problem occurs that when overriding a joint with another pose, the LastCFrame must update to the CurrentCFrame of that 
		joint, and the TargetCFrame must update to the next TargetKeyFrame.

		The `Percentage` of how far the animation is TimeElapsed / TimeTotal 
		                               (TimeCurrent - TimeStart) / (KeyFrame.Time - TimeStart)
		The TimeStart is the hardest thing to find.  It is...
			A) The interuption point in the pose, where the pose&apos;s KeyFrame starts. 
			B) When a new Pose starts.
	--]]

	local function GetTargetKeyFrameOfSequence(Sequence, StartTime, CurrentTime)

		CurrentAnimationPlayPointTime = math.abs(CurrentTime - StartTime)

		local ClosestTargetKeyFrame
		local ClosestTargetKeyFrameTime = math.huge

		for Time, KeyFrame in pairs(Sequence.KeyFrames) do
			if Time &gt;= CurrentAnimationPlayPointTime then
				local DistanceAway = Time - CurrentAnimationPlayPointTime
				if DistanceAway &lt;= ClosestTargetKeyFrameTime then
					ClosestTargetKeyFrame = KeyFrame
					ClosestTargetKeyFrameTime = DistanceAway
				end
			end
		end

		return ClosestTargetKeyFrame
	end

	local function GetJointAndPart(Parent, PartName)
		-- Used in sequencing poses... Returns the Joint, Part

		-- Parent is the Parent of the &apos;Joint&apos;, whose Part1 is the Part.

		if not JointAndPartCache[Parent]  then
			JointAndPartCache[Parent] = {}
		end
		if JointAndPartCache[Parent][PartName] and JointAndPartCache[Parent][PartName].Part1 then
			--print(&quot;[CharacterAnimationService] - Cached return&quot;)
			return JointAndPartCache[Parent][PartName], JointAndPartCache[Parent][PartName].Part1
		end

		for _, Item in pairs(Parent:GetChildren()) do
			if Item:IsA(&quot;JointInstance&quot;) then
				if Item.Part1 and Item.Part1.Name == PartName and Item.Part1:IsA(&quot;BasePart&quot;) then
					JointAndPartCache[Parent][PartName] = Item
					return Item, Item.Part1
				end
			end
		end

		return nil, nil
	end

	local RecurseUpdateJointAndKeyframe
	function RecurseUpdateJointAndKeyframe(JointsActive, Pose, Parent, ActiveAnimation)
		-- Will loop through and add to JointsActive per Joint

		local Joint, Part = GetJointAndPart(Parent, Pose.Name)
		local CurrentTime = tick()

		if Joint and Part then -- Joint/Part 
			if not JointsActive[Joint] then -- This animation&apos;s JointsActive can play....
				local PoseToJointList = ActiveAnimation.PoseToJointList
				local JointStatus = PoseToJointList[Pose]
				local JointData	= JointDataList[Part] -- Global Data...

				if not JointStatus then
					JointStatus = {};
					JointStatus.TargetCFrame = Pose.CFrame:inverse();
					--print(&quot;[CharacterAnimationService] - Calculating JointStatus for &quot;..Joint.Name..&quot;Target @ &quot;..tostring(JointStatus.TargetCFrame))

					PoseToJointList[Pose] = JointStatus;
					JointStatus.JointData = JointData;
				end

				if not JointData then
					-- print(&quot;[CharacterAnimationService] - Creating JointData for Joint &quot;..Joint.Name)
					JointData               = {}
					JointData.InitialOffset = Joint.C1
					JointData.LastKeyframe  = ActiveAnimation.TargetKeyFrame;
					JointData.LastCFrame    = Joint.C1
					JointData.StartTime     = CurrentTime
					JointData.EndTime       = ActiveAnimation.StartTime + ActiveAnimation.TargetKeyFrame.Time
					
					JointDataList[Part]     = JointData;
					JointStatus.JointData   = JointData;

				elseif JointData.LastKeyframe ~= ActiveAnimation.TargetKeyFrame then -- We are starting a new animation
					--print(&quot;[CharacterAnimationService] - CrossOver JointData for Joint &quot;..Joint.Name)
					JointData.LastKeyframe   = ActiveAnimation.TargetKeyFrame;
					JointData.LastCFrame     = Joint.C1 -- The last CFrame is the current CFrame.
					JointData.StartTime      = CurrentTime -- Reset starttime, endTime is still the same.
					JointData.EndTime        = ActiveAnimation.StartTime + ActiveAnimation.TargetKeyFrame.Time
					
					JointStatus.TargetCFrame = JointData.InitialOffset * Pose.CFrame:inverse();
					JointStatus.JointData    = JointData;
				end
				--print(&quot;Pose: &quot;..Pose.Name..&quot; CFrame Target : &quot;..tostring(Pose.CFrame)..&quot; @ &quot;..ActiveAnimation.TargetKeyFrame.Time)
				local PercentComplete = (CurrentTime - JointData.StartTime) / -- The current time elapsed so far 
					                              ((ActiveAnimation.StartTime + ActiveAnimation.TargetKeyFrame.Time) -- When the animation ends and should be at 100%...
					                              - JointData.StartTime)

				for _, NewPose in pairs(Pose.Poses) do
					RecurseUpdateJointAndKeyframe(JointsActive, NewPose, Part, ActiveAnimation)
				end

				local SmoothedPercent = PercentComplete

				--[[ EaseInOut 
				if PercentComplete &lt; 0.5 then
					SmoothedPercent = ((PercentComplete*2)^1.25)/2
				else
					SmoothedPercent = (-((-(PercentComplete*2) + 2)^1.25))/2 + 1
				end
				--]]

				--[[ QuadEaseInOut
				if PercentComplete &lt; 0.5 then
					SmoothedPercent = ((PercentComplete*2)^2)/2
				else
					SmoothedPercent = (-1*(((PercentComplete*2) - 2)^2))/2 + 1
				end
				--]]

				Joint.C1 = SlerpCFrame(JointData.LastCFrame, JointStatus.TargetCFrame, SmoothedPercent)

				JointsActive[Joint] = 	JointStatus
			end
		else
			Warn(&quot;[CharacterAnimationService] - Could not find Part/Joint for Pose &apos;&quot; .. Pose.Name .. &quot;&apos; and Parent &quot; .. Parent:GetFullName())
		end
	end

	local function StartRecurseUpdateJointAndKeyframe(JointsActive, Pose, Parent, ActiveAnimation)
		local NewParent = Parent:FindFirstChild(Pose.Name)
		if NewParent and NewParent:IsA(&quot;BasePart&quot;) then
			for _, NewPose in pairs(Pose.Poses) do
				RecurseUpdateJointAndKeyframe(JointsActive, NewPose, NewParent, ActiveAnimation)
			end
		else
			error(&quot;[CharacterAnimationService] - Could not find &quot;..Pose.Name..&quot; in Parent, as a part.&quot;)
		end
	end

	local function Step(CurrentTime)
		if Character and Character.Parent then
			--print(&quot;[CharacterAnimationService] - Step&quot;)
			local JointsActive = {}
			local CurrentTime = CurrentTime or tick()

			for Priority = 2, 0, -1 do -- Go through the AnimationLevelsStack backwards...
				local Animation = AnimationLevelsStack[Priority]
				if Animation then
					--print(&quot;[CharacterAnimationService] - Animation&quot;)
					local TargetKeyFrame = GetTargetKeyFrameOfSequence(Animation.Sequence, Animation.StartTime, CurrentTime)
					if TargetKeyFrame then
						Animation.TargetKeyFrame = TargetKeyFrame
						for _, Pose in pairs(Animation.TargetKeyFrame.Poses) do
							StartRecurseUpdateJointAndKeyframe(JointsActive, Pose, Character, Animation)
						end
					else
						if Animation.Sequence.Looped then
							--print(&quot;[CharacterAnimationService] - Looping&quot;)
							Animation.StartTime = CurrentTime;
							TargetKeyFrame = GetTargetKeyFrameOfSequence(Animation.Sequence, Animation.StartTime, CurrentTime)
							Animation.TargetKeyFrame = TargetKeyFrame
							for _, Pose in pairs(Animation.TargetKeyFrame.Poses) do
								StartRecurseUpdateJointAndKeyframe(JointsActive, Pose, Character, Animation)
							end
						else
							--print(&quot;[CharacterAnimationService] - Animation Done&quot;)
						end
					end
				end
			end
			--print(&quot;[CharacterAnimationService] - JointsActive: &quot;..#JointsActive)
			--[==[
			for Joint, JointStatus in pairs(JointsActive) do
				local JointData =  JointStatus.JointData
				local SmoothedPercent = JointStatus.PercentComplete

				--[[ EaseInOut 
				if JointStatus.PercentComplete &lt; 0.5 then
					SmoothedPercent = ((JointStatus.PercentComplete*2)^1.25)/2
				else
					SmoothedPercent = (-((-(JointStatus.PercentComplete*2) + 2)^1.25))/2 + 1
				end
				--]]

				--[[ QuadEaseInOut
				if JointStatus.PercentComplete &lt; 0.5 then
					SmoothedPercent = ((JointStatus.PercentComplete*2)^2)/2
				else
					SmoothedPercent = (-1*(((JointStatus.PercentComplete*2) - 2)^2))/2 + 1
				end
				--]]

				--JointStatus.PercentComplete = math.sin((JointStatus.PercentComplete - 0.5) * math.pi)/2 + 0.5

				Joint.C1 = SlerpCFrame(JointData.LastCFrame, JointStatus.TargetCFrame, SmoothedPercent)
				--print(Joint.Name..&quot; : Slerp @ &quot;..SmoothedPercent..&quot; Target: &quot;..tostring(JointStatus.TargetCFrame)..&quot; Last: &quot;..tostring(JointData.LastCFrame))
			end
			--]==]
			return true;
		else
			return false;
		end
	end
	CharacterAnimationService.Step = Step

	local function StopSequence(Sequence)
		-- STops a sequence if it&apos;s playing.
		local Animation = Sequences[Sequence]
		if Animation then
			if AnimationLevelsStack[Animation.Priority] == Animation then
				--print(&quot;Animation Stop&quot;)
				AnimationLevelsStack[Animation.Priority] = nil
			end
		end
	end
	CharacterAnimationService.StopSequence = StopSequence

	local function StopPriority(Priority)
		-- Stops the sequence on the priority level given.
		AnimationLevelsStack[Priority] = nil
	end
	CharacterAnimationService.StopPriority = StopPriority

	local function PlayAnimation(Sequence)
		local CurrentTime = tick()
		--print(&quot;[CharacterAnimationService] - Playing Sequence &apos;&quot;..Sequence.Name..&quot;&apos;&quot;)
		-- Adds it to the priority queue....
		if Sequences[Sequence] then
			--print(&quot;[CharacterAnimationService] - Playing cached &apos;&quot;..Sequence.Name..&quot;&apos;&quot;)

			local AnimationPlayer = Sequences[Sequence]
			AnimationPlayer.StartTime = CurrentTime;
			if AnimationLevelsStack[AnimationPlayer.Priority] ~= AnimationPlayer then -- Readd only if it&apos;s not already playing.
				--print(&quot;[CharacterAnimationService] - Reading &apos;&quot;..Sequence.Name..&quot;&apos;&quot;)
				local TargetKeyFrame = GetTargetKeyFrameOfSequence(Sequence, CurrentTime, CurrentTime)

				if TargetKeyFrame then -- TODO: Add support for 0.00 time.
					AnimationPlayer.TargetKeyFrame = TargetKeyFrame
					AnimationPlayer.StartTime = CurrentTime;
					AnimationLevelsStack[AnimationPlayer.Priority] = AnimationPlayer
					Step(CurrentTime)
				else
					error(&quot;[CharacterAnimationService] - No Keyframe to play in animation&quot;);
				end

			else
				Warn(&quot;[CharacterAnimationService] - Already playing animation...&quot;)
			end
		else
			local AnimationPlayer = { -- So it can be stopped, modified
				Priority         = Sequence.Priority;
				StartTime        = CurrentTime;
				PlayTime         = Sequence.PlayTime;
				--TargetKeyFrame = GetTargetKeyFrameOfSequence(Sequence, CurrentTime, CurrentTime)
				Sequence         = Sequence;
				PoseToJointList  = {};
			}

			local TargetKeyFrame = GetTargetKeyFrameOfSequence(Sequence, CurrentTime, CurrentTime)

			if TargetKeyFrame then -- TODO: Add support for 0.00 time.
				AnimationPlayer.TargetKeyFrame = TargetKeyFrame
				AnimationLevelsStack[Sequence.Priority] = AnimationPlayer
				Step(CurrentTime)
			else
				error(&quot;[CharacterAnimationService] - No Keyframe to play in animation&quot;);
			end

			Sequences[Sequence] = AnimationPlayer
		end
	end
	CharacterAnimationService.PlayAnimation = PlayAnimation
end)

lib.MakeCharacterAnimationService = MakeCharacterAnimationService

return lib
</ProtectedString>
</Properties>
</Item>
<Item class="Script" referent="RBX8">
<Properties>
<string name="Name">CharacterClass</string>
<ProtectedString name="Source">while not _G.NevermoreEngine do wait(0) end

local Players           = Game:GetService(&apos;Players&apos;)
local StarterPack       = Game:GetService(&apos;StarterPack&apos;)
local StarterGui        = Game:GetService(&apos;StarterGui&apos;)
local Lighting          = Game:GetService(&apos;Lighting&apos;)
local Debris            = Game:GetService(&apos;Debris&apos;)
local Teams             = Game:GetService(&apos;Teams&apos;)
local BadgeService      = Game:GetService(&apos;BadgeService&apos;)
local InsertService     = Game:GetService(&apos;InsertService&apos;)
local Terrain           = Workspace.Terrain

local NevermoreEngine   = _G.NevermoreEngine
local LoadCustomLibrary = NevermoreEngine.LoadLibrary;

local qSystems          = LoadCustomLibrary(&apos;qSystems&apos;)
local ModularSystem     = LoadCustomLibrary(&apos;ModularSystem&apos;)
local MenuSystem        = LoadCustomLibrary(&apos;MenuSystem&apos;)
local qString           = LoadCustomLibrary(&apos;qString&apos;)
local PenlightPretty    = LoadCustomLibrary(&apos;PenlightPretty&apos;)
local SoundPlayer       = LoadCustomLibrary(&apos;SoundPlayer&apos;)
local Table             = LoadCustomLibrary(&apos;Table&apos;)

qSystems:Import(getfenv(0));

--[[
Personal Notes:

I honestly don&apos;t think this system will be that easy for anyone else to use, or for me to even remember how it works.

However, it&apos;s fairly flexable, and probably overcomplicated... The main issue was in getting it so almost anything can
be modified, layers upon layers upon layers of data, that not only overwhelms me, but overwhelms users too.  In this case,
it was designed to allow the modification of a class, where you select your primary and secondary gun, and then where you
may also modify your gun in question. This is, to put it simply, a pain.

--]]

-- Command line code to help modify catagories with Header Tags.
--local Name = &quot;Hi&quot; local S = game:GetService(&quot;Selection&quot;) for _, SItem in pairs(S:Get()) do for _, I in pairs(SItem:GetChildren()) do IN = I.Name _, _, x = string.find(IN, &quot;[%w%s]+:([%w%s]+)&quot;)  if x then I.Name = Name..&quot;:&quot;..x else I.Name = Name..&quot;:&quot;..IN end end end

local lib = {}

local function ExtractNames(Name)
	-- Give a name like &apos;Catagory:Primary Weapons&apos;, it&apos;ll return `Catagory`, and `Primary Weapons`

	local Position = string.find(Name, &quot;:&quot;)
	if Position then
		local HandlerType = string.sub(Name, 0, Position-1)
		local ItemName = string.sub(Name, Position+1, #Name)
		return HandlerType, ItemName
	else
		--error(&quot;[CharacterClassSystem] - Could not exstract name for &apos;&quot; .. Name .. &quot;&apos;&quot;))
		return nil, nil
	end
end
lib.ExtractNames = ExtractNames

local GetCCCatagoryModel
function GetCCCatagoryModel(Asset)
	-- Return&apos;s the first CCCatagory it finds, or returns nil.. (Recurses up the tree structure....)

	if not Asset.Parent then
		return nil
	elseif qString.CompareCutFirst(Asset.Parent.Name, &quot;CCCatagory&quot;) then
		return Asset.Parent
	else
		return GetCCCatagoryModel(Asset.Parent)
	end
end

local GetFirstSelector
function GetFirstSelector(Model)
	-- Goes until it finds a selector, or errors, recurses through datastructure.  Would find Selector:RifleA

	for _, Item in pairs(Model:GetChildren()) do
		local HandlerName, ItemName = ExtractNames(Item.Name)

		if HandlerName == &quot;Selector&quot; then
			return Item
		elseif HandlerName then
			return GetFirstSelector(Item)
		end
	end
end
lib.GetFirstSelector = GetFirstSelector

local function ExtractNamesFromCatagoryListWithDefaults(CustomCatagories, Defaults)
	-- Returns a properly formatted name list from CustomCatagories, setting the default as either the provided one, or the first child. 
	Defaults = Defaults or {}

	local Names = {}
	for _, Item in pairs(CustomCatagories:GetChildren()) do
		local HandlerType, ItemName = ExtractNames(Item.Name)

		if Defaults[ItemName] then
			Names[ItemName] = Defaults[ItemName]
		else
			--print(&quot;[CharacterClass] - Defaults = &quot;..PenlightPretty.TableToString(Defaults))
			local FirstChild = GetFirstSelector(Item)
			if FirstChild then
				local _, FirstChildName = ExtractNames(FirstChild.Name)
				if ItemName and FirstChild and FirstChildName then
					Names[ItemName] = FirstChildName
				else
					error(&quot;[CharacterClassSystem] - Invalid ItemName or FirstChild&quot;)
				end
			else
				error(&quot;[CharacterClassSystem] - Could not get first `selector` in &quot;..Item:GetFullName())
			end
		end
	end
	return Names
end
lib.ExtractNamesFromCatagoryListWithDefaults = ExtractNamesFromCatagoryListWithDefaults

local function ExtractObjects(Objects, PremadeTable, DoNotAllowObject)
	-- Set&apos;s up tables like this: 
	--[[

	{
		[1] = Configuration `Custom Class I`
		[2] = Configuration `Sniper`
		...
	}

	--]]

	DoNotAllowObject = DoNotAllowObject or function(Item) return false end

	local Table = PremadeTable or {}
	for _, Item in pairs(Objects) do
		if (DoNotAllowObject and not DoNotAllowObject(Item)) then
			Table[#Table+1] = Item
		end
	end
	return Table
end
lib.ExtractObjects = ExtractObjects



local DeserializeWorldAssetsRecurse
function DeserializeWorldAssetsRecurse(CCCatagoryTable, RecursionModel, AcceptableHandlers)
	-- Used by DeserializeWorldAssets to recurse through Catagory&apos;s to just get selector&apos;s

	for _, Item in pairs(RecursionModel:GetChildren()) do
		local HandlerType, ItemName = ExtractNames(Item.Name)
		assert(not CCCatagoryTable[ItemName], &quot;[CharacterClassSystem] - Item &apos;&quot;..ItemName..&quot;&apos; already exists, found @ &quot;..Item:GetFullName())

		if HandlerType == &quot;Selector&quot; then
			--print(&quot;[CharacterClassSystem] - Adding Assets[CCCatagoryName][&quot;..ItemName..&quot;]&quot;)
			CCCatagoryTable[ItemName] = Item
		elseif HandlerType == &quot;Catagory&quot; then
			DeserializeWorldAssetsRecurse(CCCatagoryTable, Item, AcceptableHandlers)
		elseif AcceptableHandlers[HandlerType] then
			print(&quot;[CharacterClassSystem] - Acceptable Handler Type `&quot;..HandlerType..&quot;`&quot;)
			CCCatagoryTable[ItemName] = Item
		else
			print(&quot;[CharacterClass] - AcceptableHandlers = &quot;..PenlightPretty.TableToString(AcceptableHandlers))
			error(&quot;[CharacterClassSystem] - Invalid Formatted @ &quot;..Item:GetFullName()..&quot;, handler &apos;&quot;..HandlerType..&quot;&apos; isn&apos;t in the handler list.&quot;)
		end
	end
end

local function AppendModularSelectionsAsAsset(ModularSelections, Assets, AssetType)
	-- So we can add add customizable modulars as assets. Really, this whole system is screwed.
	Assets[AssetType] = Assets[AssetType] or {}
	local CCCatagoryTable = Assets[AssetType]

	for _, Item in pairs(ModularSelections) do
		local HandlerType, ItemName = ExtractNames(Item.Name)
		CCCatagoryTable[ItemName] = Item;
	end
end
lib.AppendModularSelectionsAsAsset = AppendModularSelectionsAsAsset

local function DeserializeWorldAssets(AssetsModel, Assets, AcceptableHandlers)
	-- Takes in a AssetsModel (setup as shown below) and spews it out in a table.
	--[[

	Lighting
		| Classes
			| CustomCatagories &lt;--- This one! 
				| CCCatagory:Auxiliary Weapon
					| Selector:AuxiTestTool
					| Selector:AuxiTestTool2
				| CCCatagory:Body Armour
					| Selector:RandomNameHere
					| Selector:RandomNameHere
				| CCCatagory:Perk I
					| Selector:RandomNameHere
					| Selector:RandomNameHere
				| CCCatagory:Perk II
					| Selector:RandomNameHere
					| Selector:RandomNameHere
				| CCCatagory:Perk III
					| Selector:RandomNameHere
					| Selector:RandomNameHere
				| CCCatagory:Primary Grenade
					| Selector:RandomNameHere
					| Selector:RandomNameHere
				| CCCatagory:Primary Weapon
					| Selector:RandomNameHere
					| Selector:RandomNameHere

	And returns something like this:

	{
		[&quot;Perk I&quot;] = {
			[&quot;PerkAkljdf&quot;] = Model `PerkAkljdf`;
			[&quot;PerkAkljdf2&quot;] = Model `PerkAkljdf2`;
			[&quot;PerkAkljdf3&quot;] = Model `PerkAkljdf3`;
			...
		};
		[&quot;Perk II&quot;] = {
			[&quot;PerkAkljdf&quot;] = Model `PerkAkljdf`;
			[&quot;PerkAkljdf2&quot;] = Model `PerkAkljdf2`;
			[&quot;PerkAkljdf3&quot;] = Model `PerkAkljdf3`;
			...
		};
		...
	}

	--]]

	--print(&quot;[CharacterClassSystem] - Deserializing Assets&quot;)

	-- Generate&apos;s the asset table...
	local Assets = Assets or {}
	for _, Item in pairs(AssetsModel:GetChildren()) do
		local HandlerType, ItemName = ExtractNames(Item.Name)
		if HandlerType and ItemName then
			--print(&quot;Deserializing/Added Assets[&quot;..ItemName..&quot;]&quot;)
			Assets[ItemName] = Assets[ItemName] or {}
			if (not AcceptableHandlers[HandlerType]) and HandlerType ~= &quot;CCCatagory&quot; then
				print(&quot;[CharacterClass] - AcceptableHandlers = &quot;..PenlightPretty.TableToString(AcceptableHandlers))
				print(&quot;[CharacterClass] - (not AcceptableHandlers[ItemName]) = &quot;.. tostring(not AcceptableHandlers[ItemName]))
				print(&quot;[CharacterClass] - HandlerType ~= CCCatagory = &quot;..tostring(HandlerType ~= &quot;CCCatagory&quot;))

				error(&quot;[CharacterClassSystem] - Invalid Formatted @ &quot;..Item:GetFullName()..&quot; got &apos;&quot;..HandlerType..&quot;&apos; expected CCCatagory&quot;)
			end
			DeserializeWorldAssetsRecurse(Assets[ItemName], Item, AcceptableHandlers)
		else
			error(&quot;[CharacterClassSystem] - HandlerType or ItemName is nil, malformed asset @ &quot;..Item:GetFullName())
		end
	end
	return Assets
end
lib.DeserializeWorldAssets = DeserializeWorldAssets

local function GenerateCustomClassData(ItemTag, ItemName, Container, NumberToGenerate, CustomizationTypes)
	-- Generate&apos;s a CustomClasse&apos;s data container...
	--[[
		CustomizationType&apos;s setup like this:

		[&quot;Perk I&quot;] = &quot;PerkA.1Test&quot;; where the index is the name, and the default is the second value...
	--]]
	local CustomClasses = {}

	for ClassNumber=1, NumberToGenerate do
		local Name = ItemTag..&quot;:&quot;..ItemName..qString.GetRomanNumeral(ClassNumber)
		local ClassContainer = Container:FindFirstChild(Name) or Make &apos;Configuration&apos; {
			Name = Name;
			Parent = Container;
			Archivable = false;
		}
		for CustomizationName, CustomizationDefault in pairs(CustomizationTypes) do
			local CustomizationValue = ClassContainer:FindFirstChild(CustomizationName) or Make &apos;StringValue&apos; {
				Name = CustomizationName;
				Parent = ClassContainer;
				Value = CustomizationDefault;
				Archivable = false;
			}
		end
		CustomClasses[Name] = ClassContainer
	end

	return CustomClasses;
end
lib.GenerateCustomClassData = GenerateCustomClassData
lib.generateCustomClassData = GenerateCustomClassData

local function GetClassAsset(Assets, AssetCatagory, AssetName)
	return Assets[AssetCatagory][AssetName]
end
lib.GetClassAsset = GetClassAsset
lib.getClassAsset = GetClassAsset

local function GenerateModular(ModularContainer, CustomizationContainer, CustomizablesAvailable, CustomModularName, ModularName, Defaults)
	-- Modulars can be generated by &quot;hand&quot; for more customization/configurability, but this whole system is bonk, so...

	--[[
		Model `ModularContainer` - Container with 2 models, Templates and Options. Templates contains premade options, and Options contains a list of CCCatagories.
		CustomizationAssets
		
		Configuratin `CustomizationContainer` - object that Contains the customization data for a player. Probably should be parented to the player.
	
		Int `CustomizablesAvailable` -  How many customizable objects to generate...

		String `CustomModularName` - The header of the CustomModularName, such as &quot;Custom Class &quot;..&quot;I&quot; where &quot;I&quot; is the roman numeral (Needs to be irmpoved, bt)

		String `ModularName` - Name of the whole modular...

		Table `Defaults` - Default items selected per a customization...
		{
			[&quot;Primary Grenade&quot;] = &quot;TestGrenadeOfHippo&quot;;
			[&quot;Primary Weapon II&quot;] = &quot;Modular Gun I&quot;;
		}
	--]]

	local Options = ModularContainer:FindFirstChild(&quot;Options&quot;)
	local Templates = ModularContainer:FindFirstChild(&quot;Templates&quot;)

	if Options and Templates then
		local CustomizationTypes = ExtractNamesFromCatagoryListWithDefaults(
			Options, 
			Defaults
		)
		local CustomAssets = GenerateCustomClassData(
			ModularName,
			CustomModularName..&quot; &quot;,
			CustomizationContainer, 
			CustomizablesAvailable,
			CustomizationTypes
		)
		local AvailableClasses = ExtractObjects(
			Templates:GetChildren(), 
			Table.Copy(CustomAssets)
		)
		local Modular = {
			RenderName = ModularName;
			Available = AvailableClasses;
			Editable = CustomAssets;
			CustomizationContainer = CustomizationContainer;
			ModularContainer = ModularContainer;
			OptionsContainer = Options;
			TemplateContainer = Templates;
		}
		return Modular
	else
		error(&quot;[CharacterClass] - Could not generate modular because ModularContainer did not contain `Options` or `Templates`&quot;)
		return nil
	end	
end
lib.GenerateModular = GenerateModular
lib.generateModular = GenerateModular

local MakeCharacterClassSystem = Class &apos;CharacterClassSystem&apos; (function(CharacterClassSystem, NewMenu, ClassSelectorList, Assets)
	-- Creates a button that will work with a class System.  Data structure is extremely important:

	local Configuration = {
		CustomClassCatagoryName = &quot;CCCatagory&quot;;
		LevelId = LevelId;
	}
	CharacterClassSystem.Configuration = Configuration
	local SetupButton
	local BeingEditedStack = {} -- Stackish like system. 
	local SelectorBeingEditedStack = {} -- Stackish like system too..
	local Handlers
	--[[CharacterClassSystem.OnClassSelect = Make &apos;BindableEvent&apos; { -- Will fire when a new class is selected. Editing a class is the same as selecting one.
		Name = &quot;OnClassSelected&quot;;
		Archivable = false;
	}--]]

	--[[

	Arguments:
		MenuSystem `NewMenu`
			The MenuSystem the button will be added too. 

		table `Classes` 
			A table of all the classes available to the player, setup like this:
			
			{
				[&quot;Custom Class I&quot;] = Configuration `Custom Class I`
				[&quot;Sniper&quot;] = Configuration `Sniper`
				...
			}

			In which each `Configuration` object will have StringValues associated with every single item in
			Assets.CCCatagory (CustomClassCatagory)

		array `ClassList`
			An array filled with a specific organization for setting up a customizable class. It&apos;ll be setup like this:

			{
				[&quot;ClassName&quot;] = {
					Editable = {
						WordldObject;
						WordldObject;
						WordldObject;
						...
					};
					Available = {
						WordldObject;
						WordldObject;
						WordldObject;
						WordldObject;
						WordldObject;
						...
					};
					RenderName = &quot;Hello&quot;;
					Assignables = {
						[&quot;Primary Weapon&quot;] = true;
					}
				}
				....
			}

		
		table `Assets` 
			A table of all of assets available for customizing a class, setup like this: 

			{
				[&quot;Perk I&quot;] = {
					[&quot;PerkAkljdf&quot;] = Model `PerkAkljdf`;
					[&quot;PerkAkljdf2&quot;] = Model `PerkAkljdf2`;
					[&quot;PerkAkljdf3&quot;] = Model `PerkAkljdf3`;
					...
				};
				[&quot;Perk II&quot;] = {
					[&quot;PerkAkljdf&quot;] = Model `PerkAkljdf`;
					[&quot;PerkAkljdf2&quot;] = Model `PerkAkljdf2`;
					[&quot;PerkAkljdf3&quot;] = Model `PerkAkljdf3`;
					...
				};
				...
			}

			This can be generated from the standardized catagory system using lib.GenerateCustomClassData.  Generally, 
			this system is setup so that outside systems can get resources back. 


	-----------------
	-- MENU LEVELS --
	-----------------
	This is basically written out for myself, so I can write the system correctly.  However, 
	documentation never hurt anyone, and it certainly won&apos;t hurt you.  This is a pretty complicated 
	system. 

	The first level selected is the class level, handled by the &apos;Class&apos; handler.  This level allows the
	user to select the class they want.  Clearly, it wouldn&apos;t get more complicated then this unless we
	wanted to allow extreme customization, which is, of course, what we want to do.

	The next level is accessed when the user clicks on the &apos;edit&apos; button on a Class.  This can only be
	clicked if the class being edited is part of a configuration. Of course At this point, fun things
	start to happen.  

	We first add a record to the Stack. 

	--]]


	local function GetAsset(AssetCatagory, AssetName)
		-- Return&apos;s the asset in Assets. 
		if not Assets[AssetCatagory] then
			print(&quot;Assets = &quot;..PenlightPretty.TableToString(Assets))
			error(&quot;[CharacterClassSystem] - Could not find Assets[&quot; .. AssetCatagory .. &quot;]&quot;)
		end
		return Assets[AssetCatagory][AssetName]
	end
	CharacterClassSystem.GetAsset = GetAsset

	local function GetClassSelectorList(ClassName)
		-- return&apos;s the class with the name of `ClassName` or nil from ClassSelectorList 

		return ClassSelectorList[ClassName]
	end

	local function GetAssetCatagory(AssetCatagory)
		-- Return&apos;s the table of assets. 

		return Assets[AssetCatagory]
	end

	local function GetHandler(HandlerName)
		-- Return&apos;s a &apos;HandlerClass&apos; for a specific name..

		local Handler = Handlers[HandlerName]
		if Handler then
			return Handler
		else
			error(&quot;[CharacterClassSystem] - Could not find Handler for &apos;&quot; .. HandlerName .. &quot;&apos;&quot;)
			return nil
		end
	end

	local function GetFirstItemWithoutHandler(Bin, SearchingForItemName)
		-- Return&apos;s an item from the bin with the name of &apos;SearchingForItemName&apos;, but ignoring handlers. So...
		-- if &apos;SearchingForItemName&apos; is &apos;HarryPotter&apos;, and in the bin, there&apos;s an item called &apos;Catagory:HarryPotter&apos;, it&apos;ll
		-- return that guy. 

		for _, Item in pairs(Bin:GetChildren()) do
			local Position = string.find(Name, Configuration.Seperator)
			if Position then
				local ItemName = string.sub(Position+1, #Name)
				if ItemName == SearchingForItemName then
					return Item
				end
			else
				error(&quot;[CharacterClassSystem] - Could not extract name for &apos;&quot; .. Item.Name .. &quot;&apos;&quot;)
			end
		end
	end

	local function GenerateMenu(MenusList, WorldObject, Name)
		-- Returns a menu, DoSetupButtons

		if MenusList[WorldObject] then
			return MenusList[WorldObject], false
		else
			local CatagoryMenu = MenuSystem.MakeListMenuLevel(Name)
			CatagoryMenu.ButtonEnter:connect(function(Button)
				SoundPlayer.PlaySound(&quot;Tick&quot;, 0.5)
			end)
			MenusList[WorldObject] = CatagoryMenu
			return CatagoryMenu, true
		end
	end

	--[==[local function SelectItem(ItemName)
		-- Set&apos;s the BeingEditedStack[#BeingEditedStack].Configuration

		--[[

			Semi-Pseudo code notes:

			MenuLayers = {
				[0] = Home
				[1] = Class - Select this (Go to 0) - Can also be edited
				[2] = CCCatagory - Select this TO be edited
				[3] = Catagory
				[4] = CustomGun - Select this (Go to 2) - 
				[5] = CustomGunPart  - Select this (Go to 4)
			}

			When you select an item, the item being edited stays the same. 
			When you select something to be edited, it&apos;ll change values inside of the edit item. 
			When you finish editing, then it&apos;ll go back to the previous edited item.  

			So we can kindly disregard anything but the top &apos;Edited&apos; thing, because it&apos;s considered a seperate modular. 

		--]]

		local LastEdited = BeingEditedStack[#BeingEditedStack]
		local EditValue = LastEdited.Configuration:FindFirstChild(ItemName)

		if not EditValue then
			error(&quot;[CharacterClassSystem] - Could not find &apos;&quot; .. ItemName .. &quot;&apos; in the configuration of &quot;..LastEdited.WorldObject:GetFullName())
		elseif not EditValue:IsA(&quot;StringValue&quot;) then
			error(&quot;[CharacterClassSystem] - Malformed EditValue @ &quot;..EditValue:GetFullName());
		else
			EditValue.Value = ItemName
		end
	end
	--]==]

	local function SetupConnectionsOnSelector(Button, ClassName, AssignValue)
		-- Set&apos;s up a selector for a button (So you might select your class, or your gun, or something.)
		-- The main different between this and a standard handler is that it&apos;s editing a external change, 
		-- versus an interal one.  

		-- ClassName - Name of what&apos;s being edited, probably `Classes` or `Guns`
		-- AssignValue - The value it&apos;ll set to whatever is selected...

		local Class = GetClassSelectorList(ClassName)

		if Class then
			local ClassSelectionMenu = MenuSystem.MakeListMenuLevel(Class.RenderName)


			for _, Item in pairs(Class.Available) do -- For each of the availible classes, such as &quot;Sniper&quot;, &quot;Custom I&quot; do
				if Item and Item:IsA(&quot;Configuration&quot;) then -- Make sure it can be editable/saved in..
					local HandlerName, ItemName = ExtractNames(Item.Name) -- Find out what they&apos;re saving. :D
					if HandlerName and ItemName then 
						local Button = ClassSelectionMenu:AddMenuButton(ItemName)
						SetupButton(Button, Item, NewMenu)
					else
						error(&quot;[CharacterClassSystem] - HanderName is &apos;&quot; .. tostring(HandlerName) .. &quot;&apos; and ItemName is &apos;&quot; .. tostring(ItemName) .. &quot;&apos;, one is nil/false, error for &quot;..Item:GetFullName())
					end
				end
			end

			Button.OnClick:connect(function()
				print(&quot;[CharacterClassSystem] - Click on class button for class &apos;&quot;..ClassName..&quot;&apos;&quot;)
				BeingEditedStack[#BeingEditedStack+1] = { -- Ok. My datastructures are screwed up. :/
					ClassSelector = true;
					AssignValue = AssignValue; -- String value that&apos;ll get changed to the newly selected item.
					Level = NewMenu.CurrentLevel+1;
				}

				SelectorBeingEditedStack[#SelectorBeingEditedStack + 1] = {
					Class = Class;
					Name = ClassName;
					Level = NewMenu.CurrentLevel+1;
				}

				NewMenu:AddMenuLayer(ClassSelectionMenu)
			end)
		else
			error(&quot;[CharacterClassSystem] - Could not get selector class &apos;&quot; .. tostring(ClassName) ..&quot;&apos; so could not setup connections on button...&quot;)
		end
	end
	CharacterClassSystem.SetupConnectionsOnSelector = SetupConnectionsOnSelector


	Handlers = {
		Class = {
			-- The class Handler is the first level of handlers. 
			Menus = {}; -- *Cringes*
			OnClick = function(CharacterClassSystem, Handler, Menu, WorldObject)
				-- Reset when they select a class...  Also fire off the change, so the parent class can
				-- identify the new class...

				if not BeingEditedStack[#BeingEditedStack] then
					error(&quot;BeingEditedStack[#BeingEditedStack] should not be nil, expected ClassSelector&quot;)
				elseif not BeingEditedStack[#BeingEditedStack].ClassSelector then
					error(&quot;[CharacterClassSystem] - ClassSelector expected in BeingEditedStack[&quot; .. #BeingEditedStack ..&quot; failed to receive it.&quot;)
				end

				
				local HandlerName, ItemName = ExtractNames(WorldObject.Name)
				local SelectorClass = SelectorBeingEditedStack[#SelectorBeingEditedStack]
				local BeingEdited = BeingEditedStack[#BeingEditedStack]
				if ItemName then
					BeingEdited.AssignValue.Value = ItemName
					if SelectorBeingEditedStack[#SelectorBeingEditedStack-1] then
						Menu:SetLevel(SelectorBeingEditedStack[#SelectorBeingEditedStack-1].Level)
					else
						Menu:GoToHome()
					end
				else
					error(&quot;[CharacterClassSystem] [Class] - Could not extract the name of WorldObject,&quot;)
				end
			end;
			OnEdit = function(CharacterClassSystem, Handler, Menu, WorldObject)
				print(&quot;[CharacterClassSystem] [Class] - Editing &apos;&quot;..WorldObject.Name..&quot;&apos;&quot;)

				-- Editing a custom class. :D The WorldObject, will be organized like this:
				--[[

					Configuration `Custom Class I`
						| StringValue `Primary Weapon`    -- Pointer
						| StringValue `Secondary Weapon`  -- Pointer too... 
						| StringValue `Perk I`
						| StringValue `Perk II`
						| StringValue `Perk III`
						| StringValue `Primary Grenade`
						| StringValue `Body Armour`
				--]]

				--[[if #BeingEditedStack &gt;= 1 then 
					error(&quot;[CharacterClassSystem] - Stack should have nothing being edited in it right now&quot;)
				end--]]
				--BeingEditedStack = {}

				local HandlerName, ItemName = ExtractNames(WorldObject.Name)
				BeingEditedStack[#BeingEditedStack+1] = {
					WorldObject = WorldObject;
					Configuration = WorldObject; -- The configuration where the next layer will dictate.  (The next selected item)
					Level = Menu.CurrentLevel+1;
					Type = Handler.Name;
					Name = ItemName;
					ClassSelector = false;
				}
				
				local CatagoryMenu, DoSetupButtons = GenerateMenu(Handler.Menus, WorldObject, ItemName)
				if DoSetupButtons then
					print(&quot;[CharacterClassSystem] - Setting up buttons for Class &quot;..WorldObject.Name..&quot; WorldObject:GetChildren() = &quot;..(#WorldObject:GetChildren()))
					for _, Item in pairs(WorldObject:GetChildren()) do
						print(&quot;[CharacterClassSystem] - Adding Button for CCCatagory &quot; .. Item:GetFullName())
						local AssetCatagoryName = Item.Name
						local AssetName = Item.Value
						local AssetsModel = GetAsset(AssetCatagoryName, AssetName) -- Get the CCCatagory:AssetName
						if AssetsModel then
							local CCCatagory = GetCCCatagoryModel(AssetsModel)
							if CCCatagory then
								local Button = MenuSystem.MakeMenuButton(Item.Name)
								SetupButton(Button, CCCatagory, Menu)

								CatagoryMenu:AddRawButton(Button)
							elseif 
							else
								error(&quot;[CharacterClassSystem] - Default Asset&apos;s doesn&apos;t seem to be a descendent of a CCCatagory, unable to setup button.&quot;)
							end
						else
							print(&quot;[CharacterClassSystem] - Assets = &quot; .. PenlightPretty.TableToString(Assets))
							error(&quot;[CharacterClassSystem] - No asset in &apos;Assets[&quot;..AssetCatagoryName..&quot;]&apos; available, could not find &apos;&quot;..AssetName..&quot;&apos; in it&quot;)
						end
					end
				end
				Menu:AddMenuLayer(CatagoryMenu)
			end;
			CanEdit = function(CharacterClassSystem, Handler, Menu, WorldObject)
				-- Returns whether or not the class can be edited.

				for _, Class in pairs(ClassSelectorList) do
					for _, Item in pairs(Class.Editable) do
						if Item == WorldObject then
							--print(&quot;[CharacterClassSystem] - Approved &quot;..WorldObject:GetFullName() .. &quot; for editing.&quot;)
							return true
						end
					end
				end
				--print(&quot;[CharacterClassSystem] - Rejected &quot;..WorldObject:GetFullName() .. &quot; for editing.&quot;)
				return false
			end;
		};
		CCCatagory = { -- Exactly like a catagory, except it set&apos;s the LastEdited too. The configuration will be the same. 
			Menus = {};
			OnClick = function(CharacterClassSystem, Handler, Menu, WorldObject)
				-- Will be clicked after BeingEditedStack[1] or higher has been set.  

				if #BeingEditedStack &lt;= 0 then -- Make sure there&apos;s something _to_ edit.
					error(&quot;[CharacterClassSystem] [CCCatagory] - Stack should have a &apos;Class&apos; being edited in it...&quot;)
				elseif BeingEditedStack[#BeingEditedStack].ClassSelector then -- Make sure we&apos;re editing the right thing..
					error(&quot;[CharacterClassSystem] [CCCatagory] - Editing ClassSelector, which can&apos;t have Catagories, BeingEditedStack[#BeingEditedStack].ClassSelector = true&quot;)
				end

				local _, ItemName = ExtractNames(WorldObject.Name)

				print(&quot;[CharacterClassSystem] [CCCatagory] - Editing &quot; .. ItemName ..&quot; CCCatagroy&quot;)

				BeingEditedStack[#BeingEditedStack + 1] = {
					WorldObject = WorldObject;
					Configuration = BeingEditedStack[#BeingEditedStack].Configuration;
					Level = Menu.CurrentLevel + 1;
					Type = Handler.Name;
					Name = ItemName;
				}

				local CatagoryMenu, DoSetupButtons = GenerateMenu(Handler.Menus, WorldObject, ItemName)

				print(&quot;[CharacterClassSystem] [CCCatagory] - #BeingEditedStack = &quot; .. (#BeingEditedStack))
				if DoSetupButtons then
					for _, Item in pairs(WorldObject:GetChildren()) do -- For each item in the CCCatagory (Model) do
						print(&quot;[CharacterClassSystem] [CCCatagory] - Generating button for &quot;..Item.Name)
						local HandlerType, LocalItemName = ExtractNames(Item.Name)
						local HandlerTypeLower = HandlerType:lower()

						print(&quot;[CharacterClassSystem] - ClassSelectorList[&quot;..HandlerType..&quot;] = &quot;..tostring(ClassSelectorList[HandlerType]))
						if GetClassSelectorList(HandlerType) then
							print(&quot;[CharacterClassSystem] [CCCatagory]- Generating Button for new CatagorySelector `&quot;..LocalItemName..&quot;`&quot;)
							local Value = BeingEditedStack[#BeingEditedStack-1].Configuration:FindFirstChild(ItemName)
							-- We can do the above line because we know that BeingEditedStack[#BeingEditedStack-1] has to be a ClassSelector

							if Value then
								local Button = MenuSystem.MakeMenuButton(LocalItemName)
								SetupConnectionsOnSelector(Button, HandlerType, Value)
								CatagoryMenu:AddRawButton(Button)
							else
								error(&quot;[CharacterClassSystem] [CCCatagory] - Could not get Value from... @ &quot;..BeingEditedStack[#BeingEditedStack-1].Configuration:GetFullName())
							end
						elseif (HandlerTypeLower == &quot;selector&quot; or HandlerTypeLower == &quot;catagory&quot;) then
							local Button = MenuSystem.MakeMenuButton(LocalItemName)
							SetupButton(Button, Item, Menu)
							CatagoryMenu:AddRawButton(Button)
						else
							error(&quot;[CharacterClassSystem] [CCCatagory] - Invalid Item/Malformatted Item @ &quot;..Item:GetFullName())
						end
					end
				end
				Menu:AddMenuLayer(CatagoryMenu)
				print(&quot;[CharacterClassSystem] [CCCatagory] - Opened new CCCCatagory... Class &apos;&quot;..WorldObject.Name..&quot;&apos;&quot;)
			end;
		};
		Catagory = { -- Used in &quot;Editing&quot; only. 
			Menus = {};
			OnClick = function(CharacterClassSystem, Handler, Menu, WorldObject)
				local HandlerType, ItemName = ExtractNames(WorldObject.Name)
				local CatagoryMenu, DoSetupButtons = GenerateMenu(Handler.Menus, WorldObject, ItemName)

				if #BeingEditedStack &lt;= 0 then -- Make sure there&apos;s something _to_ edit.
					error(&quot;[CharacterClassSystem] [Catagory] - Stack should have a &apos;Class&apos; being edited in it...&quot;)
				elseif BeingEditedStack[#BeingEditedStack].ClassSelector then -- Make sure we&apos;re editing the right thing..
					error(&quot;[CharacterClassSystem] [Catagory] - Editing ClassSelector, which can&apos;t have Catagories, BeingEditedStack[#BeingEditedStack].ClassSelector = true&quot;)
				end

				if DoSetupButtons then
					for _, Item in pairs(WorldObject:GetChildren()) do
						local LocalHandlerType, LocalItemName = ExtractNames(Item.Name)
						LocalHandlerType = LocalHandlerType:lower()
						if (LocalHandlerType == &quot;selector&quot; or LocalHandlerType == &quot;catagory&quot;) then -- Got to make sure it&apos;s either a Selector or another Catagory...
							local Button = MenuSystem.MakeMenuButton(LocalItemName)
							SetupButton(Button, Item, Menu)
							CatagoryMenu:AddRawButton(Button)
						elseif GetClassSelectorList(LocalHandlerType) then -- Customization time -  Rock&apos;en roll
							local Value = BeingEditedStack[#BeingEditedStack-1].Configuration:FindFirstChild(ItemName)

							local Button = MenuSystem.MakeMenuButton(LocalItemName)
							if Value then
								local Button = MenuSystem.MakeMenuButton(LocalItemName)
								SetupConnectionsOnSelector(Button, HandlerType, Value)
								CatagoryMenu:AddRawButton(Button)
							else
								error(&quot;[CharacterClassSystem] [CCCatagory] - Could not get Value from... @ &quot;..BeingEditedStack[#BeingEditedStack-1].Configuration:GetFullName())
							end
						else
							error(&quot;[CharacterClassSystem] [Catagory] - Invalid Item/Malformatted Item @ &quot;..Item:GetFullName())
						end
					end
				end
				Menu:AddMenuLayer(CatagoryMenu)
				print(&quot;[CharacterClassSystem] [Catagory] - Opened new Catagory... Class &apos;&quot;..WorldObject.Name..&quot;&apos;&quot;)
			end;
		};
		Selector = {
			OnClick = function(CharacterClassSystem, Handler, Menu, WorldObject)
				-- When something is selected, go back to the last catagory / being edited stack node, of course, after changing the value inside of it. 
				
				if #BeingEditedStack &lt;= 0 then -- Make sure there&apos;s something _to_ edit.
					error(&quot;[CharacterClassSystem] [Selector] - Stack should have a &apos;Class&apos; being edited in it...&quot;)
				elseif BeingEditedStack[#BeingEditedStack].ClassSelector then -- Make sure we&apos;re editing the right thing..
					error(&quot;[CharacterClassSystem] [Selector] - Editing ClassSelector, which can&apos;t have selectors, BeingEditedStack[#BeingEditedStack].ClassSelector = true&quot;)
				end

				local BeingEdited = BeingEditedStack[#BeingEditedStack]
				local Value = BeingEdited.Configuration:FindFirstChild(BeingEdited.Name)

				local HandlerType, ItemName = ExtractNames(WorldObject.Name)

				if Value then
					Value.Value = ItemName;
					print(&quot;[CharacterClassSystem] [Selector] - Set &quot;..Value:GetFullName())
				else
					error(&quot;[CharacterClassSystem] [Selector] - Could not get &apos;&quot; .. BeingEdited.Type .. &quot;&apos; @ &quot;..BeingEdited.Configuration:GetFullName() .. &quot; on selector&quot;)
				end
				print(&quot;[CharacterClassSystem] [Selector] - BeingedEdited.Level = &quot;..tostring(BeingEdited.Level) .. &quot; and Menu.CurrentLevel = &quot; .. tostring(Menu.CurrentLevel))
				Menu.SetLevel(BeingEdited.Level-1) 
			end;
		};
	}
	Handlers.ModularGun = Handlers.Class 
	Handlers.PlayerClass = Handlers.Class

	for HandlerName, Handler in pairs(Handlers) do
		-- Just add the HandlerName into the item for reference.
		Handler.Name = HandlerName
	end

	function SetupButton(Button, WorldItem, Menu)
		-- Setup&apos;s a standard button to connections so it can 
		-- be hooked up to a Handler when it&apos;s clicked..

		local HandlerName, ItemName = ExtractNames(WorldItem.Name)
		if HandlerName and ItemName then
			print(&quot;[CharacterClassSystem] - Setting up &quot;..WorldItem:GetFullName())
			local Handler = GetHandler(HandlerName)

			if not Handler then
				error(&quot;[CharacterClassSystem] - Could not find handler for &apos;&quot; .. tostring(HandlerName) .. &quot;&apos;&quot;)
			else
				local EditButton

				if Handler.OnEdit then
					if Handler.CanEdit then
						print(&quot;[CharacterClassSystem] - Rendering edit button&quot;)

						EditButton = Make &apos;TextButton&apos; {
							Name = &quot;EditButton&quot;;
							Size = UDim2.new(0.3, 0, 1, 0);
							Position = UDim2.new(0.7, 0, 0, 0);
							Text = &quot;Edit&quot;;
							ZIndex = 5;
							FontSize = &quot;Size8&quot;;
							TextColor3 = Color3.new(1,1,1);
							BackgroundTransparency = 1;
							Parent = Button.Gui;
							Visible = false
						}

						EditButton.MouseButton1Down:connect(function()
							Handler.OnEdit(CharacterClassSystem, Handler, Menu, WorldItem)
						end)
					end
				end

				Button.OnClick:connect(function()
					print(&quot;[CharacterClassSystem] - Click on &quot; .. WorldItem.Name)
					if Handler.OnClick then
						Handler.OnClick(CharacterClassSystem, Handler, Menu, WorldItem)
					end
				end)

				if EditButton and Handler.CanEdit(CharacterClassSystem, Handler, Menu, WorldItem) then
					Button.OnEnter:connect(function()
						--print(&quot;[CharacterClassSystem] - Showing edit button&quot;)
						EditButton.Visible = true
						EditButton.Parent = Button.Gui;
					end)

					Button.OnLeave:connect(function()
						if EditButton then
							--print(&quot;[CharacterClassSystem] - Hiding edit button&quot;)
							EditButton.Visible = false
						end
					end)
				end
			end
		else
			error(&quot;[CharacterClassSystem] - HanderName = &apos;&quot; .. tostring(HandlerName) .. &quot;&apos; and ItemName = &apos;&quot; .. tostring(ItemName) .. &quot;&apos;, one is nil/false, error for &quot;..WorldItem:GetFullName())
		end
	end


	--[[NewMenu.GoingHome:connect(function()
		for i=1, #BeingEditedStack do
			BeingEditedStack:Pop();
		end
		print(&quot;[CharacterClassSystem] - #BeingEditedStack = &quot;..(#BeingEditedStack)))
	end)--]]

	NewMenu.LevelUpper:connect(function(Level) -- Remove / Pop the editing items when we go backwards.
		-- Level is the new level that will be appearing shortly

		if #BeingEditedStack &gt;= 1 then
			for Index = #BeingEditedStack, 1, -1 do
				if Level &lt; (BeingEditedStack[Index].Level) then
					print(&quot;[CharacterClassSystem] - LevelUpper - Popping BeingEditedStack &quot; .. Index  .. &quot; Level (&quot;..Level..&quot;) &lt;= BeingEditedStack[Index].Level (&quot;..BeingEditedStack[Index].Level..&quot;)&quot;)
					BeingEditedStack[#BeingEditedStack] = nil
				end
			end
		end

		if #SelectorBeingEditedStack &gt;= 1 then
			for Index = #SelectorBeingEditedStack, 1, -1 do
				if Level &lt; (SelectorBeingEditedStack[#SelectorBeingEditedStack].Level) then
					print(&quot;[CharacterClassSystem] - LevelUpper - Popping SelectorBeingEditedStack &quot; .. Index  .. &quot; Level (&quot;..Level..&quot;) &lt;= SelectorBeingEditedStack[Index].Level (&quot;..SelectorBeingEditedStack[Index].Level..&quot;)&quot;)
					SelectorBeingEditedStack[#SelectorBeingEditedStack] = nil
				end
			end
		end

		print(&quot;[CharacterClassSystem] - LevelUpper - #BeingEditedStack = &quot;..(#BeingEditedStack))
		print(&quot;[CharacterClassSystem] - LevelUpper - #SelectorBeingEditedStack = &quot;..(#SelectorBeingEditedStack))
	end)

	
end)
lib.MakeCharacterClassSystem = MakeCharacterClassSystem

NevermoreEngine.RegisterLibrary(&apos;CharacterClass&apos;, lib);</ProtectedString>
<bool name="Disabled">true</bool>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX9">
<Properties>
<string name="Name">CharacterState</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local qCFrame           = LoadCustomLibrary(&quot;qCFrame&quot;)

qSystems:Import(getfenv(0))

-- CharacterState.lua
-- This system handle&apos;s character states, such as running, falling, etc.. 
-- @author Quenty
-- Last Modified February 3rd, 2014

--[[
February 4th, 2014
- Fixed fall state where raycast ignored invisible parts.

February 3rd, 2014
- Updated to new Nevermore System
--]]

local lib = {}

local MakeCharacterState = Class(function(CharacterState, Character)
	local Humanoid = Character:FindFirstChild(&quot;Humanoid&quot;)
	local Torso    = Character:FindFirstChild(&quot;Torso&quot;)

	local PreviousState
	local CurrentState
	local CurrentStateChange = CreateSignal()
	CharacterState.CurrentStateChange = CurrentStateChange
	local States = {}

	local function LastPointSinceAction(self)
		return tick() - self.LastPoint;
	end

	local function TimeSinceStateStart(self)
		return tick() - self.PointStart;
	end

	local function AddState(Name, CheckDuring)
		local NewState = {}
		NewState.Name                 = Name
		NewState.CheckDuring          = CheckDuring
		-- NewState.Started              = CreateSignal()
		-- NewState.Stopped              = CreateSignal()
		NewState.LastPoint            = 0;
		NewState.PointStart           = 0;
		NewState.LastPointSinceAction = LastPointSinceAction
		NewState.TimeSinceStateStart  = TimeSinceStateStart

		States[Name] = NewState;
		return NewState;
	end

	local function SetState(Name)
		-- CurrentState.Stopped:fire()
		-- CurrentState.Started:fire()
		if not States[Name] then
			error(&quot;[CharacterState] - State &apos;&quot;..Name..&quot;&apos; does not exist. &quot;)
		elseif CurrentState and CurrentState.Name ~= Name then
			PreviousState = CurrentState
			CurrentState = States[Name];
			CurrentState.LastPoint = tick()
			CurrentState.PointStart = tick()
			CurrentStateChange:fire(Name)
		end
	end
	CharacterState.SetState = SetState

	-- States --

	local function CharacterIsFalling(CharacterData, Torso)
		return CharacterData.OnGround.DistanceOff &gt; 1.3 and Torso.Velocity.Y &lt; -1
	end

	local function CharacterIsIdle(Torso)
		return (Torso.Velocity - Vector3.new(0, Torso.Velocity.y, 0)).magnitude &lt;= 1
	end

	CurrentState = AddState(&quot;Idle&quot;, function(Character, CharacterData, Torso, PreviousState)
		if CharacterIsFalling(CharacterData, Torso) then
			SetState(&apos;Fall&apos;)
		elseif not CharacterIsIdle(Torso) then
			SetState(&quot;Walking&quot;)
		end
	end)

	AddState(&quot;Walking&quot;, function(Character, CharacterData, Torso, PreviousState)
		if CharacterIsFalling(CharacterData, Torso) then
			SetState(&apos;Fall&apos;)
		elseif CharacterIsIdle(Torso) then
			SetState(&quot;Idle&quot;)
		end
	end)

	-- Crouching --

	AddState(&quot;Crouch&quot;, function(Character, CharacterData, Torso, PreviousState)
		-- When the character is moving and crouching...

		if CharacterIsFalling(CharacterData, Torso)  then
			SetState(&apos;Fall&apos;)
		elseif CharacterIsIdle(Torso) then
			SetState(&quot;IdleCrouch&quot;)
		end
	end)

	AddState(&quot;IdleCrouch&quot;, function(Character, CharacterData, Torso, PreviousState)
		-- When the character is just crouching

		if CharacterIsFalling(CharacterData, Torso) then
			SetState(&apos;Fall&apos;)
		elseif not CharacterIsIdle(Torso) then
			SetState(&quot;Crouch&quot;)
		end
	end)

	AddState(&quot;Strone&quot;, function(Character, CharacterData, Torso, PreviousState)
		-- When the character is moving and crouching...

		if CharacterIsFalling(CharacterData, Torso)  then
			SetState(&apos;Fall&apos;)
		elseif CharacterIsIdle(Torso) then
			SetState(&quot;IdleStrone&quot;)
		end
	end)

	AddState(&quot;IdleStrone&quot;, function(Character, CharacterData, Torso, PreviousState)
		-- When the character is just crouching

		if CharacterIsFalling(CharacterData, Torso) then
			SetState(&apos;Fall&apos;)
		elseif not CharacterIsIdle(Torso) then
			SetState(&quot;Strone&quot;)
		end
	end)

	AddState(&quot;Running&quot;, function(Character, CharacterData, Torso, PreviousState)
		-- When the character is just crouching

		if CharacterIsFalling(CharacterData, Torso) then
			SetState(&apos;Fall&apos;)
		elseif CharacterIsIdle(Torso) then
			SetState(&quot;Idle&quot;)
		end
	end)

	AddState(&quot;Jump&quot;, function(Character, CharacterData, Torso, PreviousState)
		if PreviousState:LastPointSinceAction() &gt; 1 then -- If we&apos;re jumping for more than 1 second, we&apos;re falling.
			SetState(&quot;Fall&quot;)
		elseif CharacterData.OnGround.DistanceOff &lt; 0.5 and States.Jump:LastPointSinceAction() &gt; 0.3 then
			SetState(&quot;EndJump&quot;)
		end
	end)

	AddState(&quot;Fall&quot;, function(Character, CharacterData, Torso, PreviousState)
		if CharacterData.OnGround:LastPointSinceAction() &lt; 0.1 and States.Fall:TimeSinceStateStart() &gt; 0.2 then
			SetState(&quot;EndFall&quot;)
		end
	end)

	AddState(&quot;EndFall&quot;, function(Character, CharacterData, Torso, PreviousState)
		if States.Fall:LastPointSinceAction() &lt; 0.1 then
			if (Torso.Velocity - Vector3.new(0, Torso.Velocity.y, 0)).magnitude &lt;= 1 then
				SetState(&quot;Idle&quot;)
			else
				SetState(&quot;Walking&quot;)
			end
		end
	end)

	AddState(&quot;EndJump&quot;, function(Character, CharacterData, Torso, PreviousState)
		if States.Jump:LastPointSinceAction() &lt; 0.1 then
			if (Torso.Velocity - Vector3.new(0, Torso.Velocity.y, 0)).magnitude &lt;= 1 then
				SetState(&quot;Idle&quot;)
			else
				SetState(&quot;Walking&quot;)
			end
		end
	end)

	AddState(&quot;ClimbLadder&quot;, function(Character, CharacterData, Torso, PreviousState)
		if CharacterData.OnGround.DistanceOff &lt; 1.3 then
			SetState(&quot;ClimbStairs&quot;)
		elseif CharacterData.PositiveTorsoVelocity:LastPointSinceAction() &gt; 0.2 then
			SetState(&quot;Walking&quot;)
		end
	end)

	AddState(&quot;ClimbStairs&quot;, function(Character, CharacterData, Torso, PreviousState)
		if CharacterData.OnGround.DistanceOff &gt; 1.3 then
			SetState(&quot;ClimbLadder&quot;)
		elseif CharacterData.PositiveTorsoVelocity:LastPointSinceAction() &gt; 0.2 then
			SetState(&quot;Walking&quot;)
		end
	end)

	AddState(&quot;Seated&quot;, function(Character, CharacterData, Torso, PreviousState)
		if not Character.Humanoid.Sit then
			SetState(&quot;Walking&quot;)
		end
	end)


	------

	local CharacterData = {
		OnGround = {
			DistanceOff = 0;
			LastPoint = 0;
			LastPointSinceAction = LastPointSinceAction;
		};
		OffGround = {
			LastPoint = 0;
			LastPointSinceAction = LastPointSinceAction;
		};
		PositiveTorsoVelocity = {
			Value = 0;
			LastPoint = 0;
			LastPointSinceAction = LastPointSinceAction;
		};
	}


	-----

	Humanoid.Jumping:connect(function()
		SetState(&quot;Jump&quot;)
	end)

	Humanoid.Seated:connect(function()
		SetState(&quot;Seated&quot;)
	end)

	Humanoid.Climbing:connect(function()
		if CharacterData.OnGround.DistanceOff &gt; 1.3 then
			SetState(&quot;ClimbLadder&quot;)
		else
			SetState(&quot;ClimbStairs&quot;)
		end
	end)

	local IgnoreList = {Character}
	setmetatable(IgnoreList, {__mode = &quot;k&quot;})
	local AdvanceRaycast = qCFrame.AdvanceRaycast

	local function Step()
		local Torso = Character.Torso
		local TorsoPosition = Torso.Position

		-- Check Distance Off Ground --
		local DistanceCheckingRay = Ray.new(Torso.Position, Vector3.new(0,-999,0))
		local Hit, Position = AdvanceRaycast(DistanceCheckingRay, IgnoreList, false, true)
		if Hit and Hit.CanCollide then
			CharacterData.LastGroundHit = Hit
			CharacterData.OnGround.DistanceOff = math.max(0, (TorsoPosition - Position).magnitude - 3)
		else
			CharacterData.OnGround.DistanceOff = 100
			CharacterData.LastGroundHit = nil
		end

		if CharacterData.OnGround.DistanceOff &gt; 1.3 then
			CharacterData.OffGround.LastPoint = tick()
		elseif CharacterData.OnGround.DistanceOff &lt; 0.5 then
			CharacterData.OnGround.LastPoint = tick()
		end
		-- Check Torso Velocity --
		CharacterData.PositiveTorsoVelocity.Value = Torso.Velocity.y
		if Torso.Velocity.y &gt; 1 then
			CharacterData.PositiveTorsoVelocity.LastPoint = tick()
		end

		-- Check States --
		CurrentState.LastPoint = tick()
		CurrentState.CheckDuring(Character, CharacterData, Torso, PreviousState)
	end
	CharacterState.Step = Step
end)

--[[
local MakeCharacterState = Class &apos;CharacterState&apos; (function(CharacterState, Character)
	local Humanoid = WaitForChild(Character, &quot;Humanoid&quot;)
	--local Torso = WaitForChild(Character, &quot;Torso&quot;)
	local CurrentState = &quot;Idle&quot;
	local StateChanged = CreateSignal()

	local function SetState(NewState, ...)
		if CurrentState ~= NewState then
			CurrentState = NewState
			StateChanged:fire(NewState, ...)
		end
	end

	Humanoid.Died:connect(function(...) SetState(&quot;Died&quot;, ...) end)
	Humanoid.Running:connect(function(...) SetState(&quot;Running&quot;, ...) end)
	Humanoid.Jumping:connect(function(...) SetState(&quot;Jumping&quot;, ...) end)
	Humanoid.Climbing:connect(function(...) SetState(&quot;Climbing&quot;, ...) end)
	Humanoid.GettingUp:connect(function(...) SetState(&quot;GettingUp&quot;, ...) end)
	Humanoid.FreeFalling:connect(function(...) SetState(&quot;FreeFalling&quot;, ...) end)
	Humanoid.FallingDown:connect(function(...) SetState(&quot;FallingDown&quot;, ...) end)
	Humanoid.Seated:connect(function(...) SetState(&quot;Seated&quot;, ...) end)
	Humanoid.PlatformStanding:connect(function(...) SetState(&quot;PlatformStanding&quot;, ...) end)
	Humanoid.Swimming:connect(function(...) SetState(&quot;Swimming&quot;, ...) end)
end)--]]
lib.MakeCharacterState = MakeCharacterState

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX10">
<Properties>
<string name="Name">RawCharacter</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local Type              = LoadCustomLibrary(&quot;Type&quot;)
local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)

qSystems:Import(getfenv(0))

-- RawCharacter.lua
-- This script handles character interaction, presuming that the character is &quot;validated&quot;
-- @author Quenty
-- Last modified January 20th, 2014

--[[--Change Log--

January 20th, 2014
- Added change log
- Added heal
- Added maxhealth
- Added remove hats method

--]]
local lib               = {}
--local safeLib           = {}
--local playerLib         = {}
local faceIndex         = {}
-- An index of faces...

faceIndex.worriedFace   = &quot;http://www.roblox.com/asset/?id=83906109&quot;;
faceIndex.scaredFace    = &quot;http://www.roblox.com/asset/?id=22823614&quot;;
faceIndex.mommyFace     = &quot;http://www.roblox.com/asset/?id=24669458&quot;;

local faceAnimations = {}
-- An array of tables of different animations for faces (sequences);

faceAnimations.mommy = {
	faceIndex.worriedFace;
	faceIndex.scaredFace;
	faceIndex.mommyFace;
}

lib.faceIndex = faceIndex
lib.faceAnimation = faceAnimations

--[[
	These presume the character is validated for the humanoid, torso, and head.
--]]

local function Kill(character)
	-- Kills the character

	character.Humanoid.Health = 0;
end
lib.kill = Kill;
lib.Kill = Kill;

local function Heal(character)
	-- Heals the character

	character.Humanoid.Health = character.Humanoid.MaxHealth;
end
lib.Heal = Heal
lib.heal = heal

local function MaxHealth(character, MaxHealth)
	-- Sets the character&apos;s MaxHealth

	character.Humanoid.MaxHealth = MaxHealth
	character.Humanoid.Health = character.Humanoid.MaxHealth;
end
lib.MaxHealth = MaxHealth
lib.maxHealth = MaxHealth

local function Explode(character)
	-- Explodes the character, and guarantees a kill

	Instance.new(&quot;Explosion&quot;, character.Torso).Position = character.Torso.Position
	Kill(character)
end
lib.explode = Explode;
lib.Explode = Explode;


local function GetFace(character)
	-- Returns the character&apos;s face, if it exists. 

	if (Character.Head:FindFirstChild(&quot;face&quot;) and Character.Head.face:IsA(&quot;decal&quot;)) then
		return Character.Head.face;
	end
	return nil
end
lib.GetFace = GetFace;
lib.getFace = GetFace;
lib.get_face = GetFace;

local function GetOrCreateFace(character)
	-- Returns the character&apos;s face, or craetes a new one

	local face = getFace(character) or create &apos;decal&apos; {
		Name = &quot;face&quot;;
		Parent = character.Head;
		Texture = &quot;http://www.roblox.com/asset/?id=20418518&quot;;
	}
	return face;
end
lib.getOrCreateFace = GetOrCreateFace;
lib.GetOrCreateFace = GetOrCreateFace;
lib.get_or_create_face = GetOrCreateFace;

local function SetFace(character, texture)
	-- Set&apos;s the character&apos;s face to the texture specified

	GetOrCreateFace(character).Texture = texture;
end
lib.setFace = SetFace
lib.SetFace = SetFace
lib.set_face = SetFace

local function PlayFaceAnimation(character, animation, timeToPlay)
	-- Play&apos;s an &quot;animation&quot; of changing faces over the specified time.  Animation should be an array of textures (strings)

	local Face = GetOrCreateFace(character)
	local animationFrames = #animation + 1

	for index, textureId in pairs(animation) do
		delay(((index/animationFrames) * timeToPlay), function()
			if Face then
				Face.Texture = textureId
			end
		end)
	end

end

local function Jump(character)
	-- Forces the player to jump

	character.Humanoid.Jump = true;
	character.Humanoid.Jump = false;
end
lib.jump = Jump;
lib.Jump = Jump;

local function RemoveVelocity(character)
	CallOnChildren(character, function(Object)
		if Object:IsA(&quot;BasePart&quot;) then
			Object.Velocity = Vector3.new(0, 0, 0);
			Object.RotVelocity = Vector3.new(0, 0, 0);
		end
	end)
end
lib.RemoveVelocity = RemoveVelocity
lib.removeVelocity = RemoveVelocity
lib.remove_velocity = RemoveVelocity

local function Unstick(character)
	if character.Humanoid.Sit then
		character.Humanoid.Sit = false
	end
end
lib.Unstick = Unstick
lib.unstick = unstick;

local function Dehat(character)
	--- Remove&apos;s a character&apos;s hats

	CallOnChildren(character, function(Item)
		if Item:IsA(&quot;Hat&quot;) then
			Item:Destroy()
		end
	end)
end
lib.Dehat = Dehat
lib.dehat = Dehat

local function Damage(character, value)
	-- Damages the player&apos;s character absolutely.  Won&apos;t go below 0. 

	character.Humanoid.Health = math.max(0, character.Humanoid.Health - value)
end
lib.damage = Damage;
lib.Damage = Damage;


local function SetFace(character, faceId)
	-- Set&apos;s the character&apos;s face to a new faceID

	GetOrCreateFace(character).Texture = faceId;
end
lib.setFace = SetFace;
lib.SetFace = SetFace;
lib.set_face = SetFace;

local function GetFaceTexture(character)
	-- Returns the current faces texture

	return GetOrCreateFace(character).Texture
end
lib.getFaceTexture = GetFaceTexture;
lib.GetFaceTexture = GetFaceTexture;
lib.get_face_texture = GetFaceTexture;


local function GiveForceField(character)
	-- Give&apos;s a character a force field

	Instance.new(&quot;ForceField&quot;, character)
end
lib.GiveForceField = GiveForceField;
lib.giveForceField = GiveForceField;
lib.give_force_field = GiveForceField;

local function RemoveForceField(character)
	-- Remove&apos;s a character&apos;s forcefield 

	for _, Item in pairs(character:GetChildren()) do
		if Item:IsA(&quot;ForceField&quot;) then
			Item:Destroy()
		end	
	end
end
lib.RemoveForceField = RemoveForceField
lib.removeForceField = RemoveForceField
lib.remove_force_field = RemoveForceField

local function Cape(Player, Color)
	-- VerifyArg(Color, &quot;BrickColor&quot;, &quot;Color&quot;, true)

	local function CreateCapeModel()
		local Character = Player.Character;

		Color = Color or Character.Torso.BrickColor

		local CapeModel = Instance.new(&quot;Model&quot;, Character);
		CapeModel.Name = &quot;QuentyCapeModel&quot;

		local NeckPiece = Make &apos;Part&apos; {
			Parent = CapeModel;
			FormFactor = &quot;Custom&quot;;
			Name = &quot;NeckPiece&quot;;
			BrickColor = Color;
			CanCollide = false;
			TopSurface = &quot;Smooth&quot;;
			BottomSurface = &quot;Smooth&quot;;
		}
		NeckPiece.Size = Vector3.new(2, 0.2, 1);

		local NeckWeld = Make &apos;Weld&apos; {
			Parent = NeckPiece;
			Part0 = Character.Head;
			Part1 = NeckPiece;
			C0 = CFrame.new(0, -0.45, 0);
		}

		local Segment1 = Modify(NeckPiece:Clone(), {
			Size = Vector3.new(3, 0.2, 1);
			Parent = CapeModel;
			Name = &quot;Segment1&quot;;
		})

		local Segment1Weld = Make &apos;Weld&apos; {
			Parent = Segment1;
			Part0 = NeckPiece;
			Part1 = Segment1;
			C0 = CFrame.new(0, 0, 0.45);
			C1 = CFrame.new(0, 0, -0.45) * CFrame.Angles(math.rad(-80),0,0);
		}

		local Segment2 = Modify(Segment1:Clone(), {
			Parent = CapeModel;
			Name = &quot;Segment2&quot;;
		})

		local Segment2Weld = Make &apos;Weld&apos; {
			Parent = Segment2;
			Part0 = Segment1;
			Part1 = Segment2;
			C0 = CFrame.new(0, 0, 0.45);
			C1 = CFrame.new(0, 0, -0.45) * CFrame.Angles(math.rad(-5),0,0);
		}

		local Segment3 = Modify(Segment1:Clone(), {
			Parent = CapeModel;
			Name = &quot;Segment3&quot;;
		})

		local Segment3Weld = Make &apos;Weld&apos; {
			Parent = Segment3;
			Part0 = Segment2;
			Part1 = Segment3;
			C0 = CFrame.new(0, 0, 0.45);
			C1 = CFrame.new(0, 0, -0.45) * CFrame.Angles(math.rad(-2),0,0);
		}

		local Segment4 = Modify(Segment1:Clone(), {
			Parent = CapeModel;
			Name = &quot;Segment4&quot;;
		})

		local Segment4Weld = Make &apos;Weld&apos; {
			Parent = Segment4;
			Part0 = Segment3;
			Part1 = Segment4;
			C0 = CFrame.new(0, 0, 0.45);
			C1 = CFrame.new(0, 0, -0.45);
		}

		return CapeModel;
	end

	local function Flex(Cape, Values)
		local Continue = true
		local CapeChildren = Cape:GetChildren();
		for Index, Value in pairs(Values) do
			if Index ~= 1 and CapeChildren[Index] and CapeChildren[Index]:FindFirstChild(&quot;Weld&quot;) and CapeChildren[Index].Weld:IsA(&quot;Weld&quot;) then
				CapeChildren[Index].Weld.C1 = CFrame.new(0, 0, -0.45) * CFrame.Angles(math.rad(Values[Index-1]),0,0);
			elseif Index ~= 1 then
				print(&quot;CapeChildren[&quot;..Index..&quot;] did not qualify in cape...&quot;)
				Continue = false
			end
		end
		return Continue
	end

	--local Character    = Player.Character
	local Cape         = CreateCapeModel()
	Cape.Parent        = Player.Character
	local LastFirstRad = -60;
	local Ta
	local Ta1          = 5
	local PlayerName   = Player.Name

	local function StartUpdate()
		local Index = 0
		local Continue = true
		while Continue do
			if not CheckCharacter(Player) or not (Player.Character and Player.Character.Parent and Cape and Cape.Parent)  then
				print(&quot;[RawCharacter] - Cape update break for &apos;&quot;..PlayerName..&quot;&apos;&quot;);
				Continue = false;
			end
			local FirstRad = -60;
			Ta = Ta1 * Player.Character.Torso.Velocity.magnitude/16 + 1 * (math.random() + 0.5);
			if Ta &gt; 10 then
				Ta = math.random(90, 100) / 10;
			end
			FirstRad = FirstRad + (Player.Character.Torso.Velocity.magnitude) + math.sin(Index)*3*Ta;
			if FirstRad &gt; 65 then
				FirstRad = 65;
			elseif (Player.Character.Torso.Velocity.magnitude &lt; 5) then
				FirstRad = -80;
			end

			--[[
			if Player.Character.Humanoid:HasCustomStatus(&quot;Flying&quot;) then
				FirstRad = -80;
				ta = 15;
			end--]]

			FirstRad = (FirstRad + LastFirstRad)/2;
			LastFirstRad = FirstRad;
			Continue = Flex(Cape, {FirstRad, math.sin(Index+20)*-1*Ta,math.sin(Index+20)*2*Ta,math.sin(Index+20)*Ta,math.sin(Index+20)*-1*Ta})
			wait(0.05);
			Index = Index+1
		end
	end
	Spawn(function()
		StartUpdate();
	end)
end

lib.cape = Cape;
lib.Cape = Cape;

local function Decape(Player)
	for _, Item in pairs(Player.Character:GetChildren()) do
		if Item.Name == &quot;QuentyCapeModel&quot; and Item:IsA(&quot;Model&quot;) then
			Item:Destroy()
		end
	end
end
lib.Decape = Decape
lib.decape = Decape

return lib</ProtectedString>
</Properties>
</Item>
</Item>
<Item class="Backpack" referent="RBX11">
<Properties>
<string name="Name">Events</string>
</Properties>
<Item class="ModuleScript" referent="RBX12">
<Properties>
<string name="Name">EventBin</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)

qSystems:Import(getfenv(0))


-- EventBin.lua
-- A library to handle events
-- @author Anaminus, modified by Quenty
-- Last modified by Quenty, January 23rd, 2014

--[[-- Change Log --
February 3rd, 2014
- Fixed qSystem dependency

January 23rd, 2014
- Fixed bug with Nevermore being required
- Updated to new class system

January 19th, 2014
- Modified to work with Module Scripts
- Added Change Log

--]]

local lib = {}

local MakeEventBin = Class(function(this)
	--- Creates a bin that manages / stores events.

	local mEvents = {}
	function this:add(evt)
		mEvents[#mEvents+1] = evt
	end
	this.Add = this.add
	function this:clear()
		for _, evt in pairs(mEvents) do
			evt:disconnect()
		end
		mEvents = {}
	end
	this.Clear = this.clear
	function this:destroy()
		for _, evt in pairs(mEvents) do
			evt:disconnect()
		end

		for index, value in pairs(this) do
			this[index] = nil;
		end
	end
	this.Destroy = this.destroy
end)
lib.MakeEventBin = MakeEventBin
lib.makeEventBin = MakeEventBin

lib.new = MakeEventBin
lib.New = MakeEventBin

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX13">
<Properties>
<string name="Name">EventGroup</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local lib = {}

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)

qSystems:Import(getfenv(0));

-- EventBin.lua
-- A library to handle events. It is beautiful.

-- @author Anaminus, modified by Quenty
-- Last modified by Quenty, January 23rd, 2014

--[[-- Change Log --
January 23rd, 2014
- Updated to new class system

January 19th, 2014
- Modified to work with Module Scripts
- Added Change Log

--]]

--[[----------------------------------------------------------------------------
EventGroup
	Manages event connections. Added events will remain until removal. Removed events are automatically disconnected.
	Subgroups, which are EventGroups, can also be added.

	Adding an event*:
		EventGroup.EventName = (event)
	Removing (and disconnecting) an event:
		EventGroup.EventName = nil

	Adding a new subgroup (and adding event to that group)**:
		EventGroup.NewGroup.EventName = (event)
	Removing a subgroup (and removing all of the group&apos;s events):
		EventGroup.NewGroup = nil

	Getting all events:
		EventGroup(&quot;GetEvents&quot;)
	Getting all subgroups:
		EventGroup(&quot;GetGroups&quot;)
	Removing all events and subgroups:
		EventGroup(&quot;Clear&quot;)

	*If an event or group already exists with the same name, it will first be removed.
	**The group does not have to be created beforehand.
]]

local MakeEventGroup
MakeEventGroup = Class(function(def)
	local eventContainer = {}
	local groupContainer = {}

	local methods = {
		GetEvents = function(self)
			local copy = {}
			for name,event in pairs(eventContainer) do
				copy[name] = event
			end
			return copy
		end;
		GetGroups = function(self)
			local copy = {}
			for name,group in pairs(groupContainer) do
				copy[name] = group
			end
			return copy
		end;
		Clear = function(self)
			for k in pairs(eventContainer) do
				self[k] = nil
			end
			for k in pairs(groupContainer) do
				self[k] = nil
			end
		end;
	}

	setmetatable(def,{
		__index = function(t,k)
			local event = eventContainer[k]
			if event then
				return event
			else
				local group = groupContainer[k]
				if group == nil then
					group = MakeEventGroup()
					groupContainer[k] = group
				end
				return group
			end
		end;
		__newindex = function(t,k,v)
			local event = eventContainer[k]
			if event ~= nil then
				event:disconnect()
				eventContainer[k] = nil
			else
				local group = groupContainer[k]
				if group ~= nil then
					group(&quot;Clear&quot;)
					groupContainer[k] = nil
				end
			end
			if v ~= nil then
				eventContainer[k] = v
			end
		end;
		__call = function(self,name,...)
			if methods[name] then
				return methods[name](self,...)
			else
				error(&quot;EventGroup: &quot;..tostring(name)..&quot; is not a valid method&quot;, 2)
			end
		end;
	})
end)
lib.MakeEventGroup = MakeEventGroup;
lib.makeEventGroup = MakeEventGroup;

return lib</ProtectedString>
</Properties>
</Item>
<Item class="Script" referent="RBX14">
<Properties>
<string name="Name">Maid</string>
<ProtectedString name="Source">--[[Maid
Manages the cleaning of events and other things.
 
API:
	HireMaid()                        Returns a new Maid object.
 
	Maid[key] = (function)            Adds a task to perform when cleaning up.
	Maid[key] = (event connection)    Manages an event connection. Anything that isn&apos;t a function is assumed to be this.
	Maid[key] = nil                   Removes a named task. If the task is an event, it is disconnected.
 
	Maid:GiveTask(task)               Same as above, but uses an incremented number as a key.
	Maid:DoCleaning()                 Disconnects all managed events and performs all clean-up tasks.
]]
 
local index = {
	GiveTask = function(self,task)
		local n = #self.Tasks+1
		self.Tasks[n] = task
		return n
	end;
	DoCleaning = function(self)
		local tasks = self.Tasks
		for name,task in pairs(tasks) do
			if type(task) == &apos;function&apos; then
				task()
			else
				task:disconnect()
			end
			tasks[name] = nil
		end
		-- self.Tasks = {}
	end;
};
local mt = {
	__index = function(self,k)
		if index[k] then
			return index[k]
		else
			return self.Tasks[k]
		end
	end;
	__newindex = function(self,k,v)
		local tasks = self.Tasks
		if v == nil then
			-- disconnect if the task is an event
			if type(tasks[k]) ~= &apos;function&apos; then
				tasks[k]:disconnect()
			end
		elseif tasks[k] then
			-- clear previous task
			self[k] = nil
		end
		tasks[k] = v
	end;
}
 
return function()
	return setmetatable({Tasks={}},mt)
end</ProtectedString>
<bool name="Disabled">true</bool>
</Properties>
</Item>
</Item>
<Item class="Backpack" referent="RBX15">
<Properties>
<string name="Name">Inventory</string>
</Properties>
<Item class="ModuleScript" referent="RBX16">
<Properties>
<string name="Name">Box3DRender</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems                = LoadCustomLibrary(&quot;qSystems&quot;)
local qInstance               = LoadCustomLibrary(&quot;qInstance&quot;)
local PenlightPretty          = LoadCustomLibrary(&quot;PenlightPretty&quot;)
local EventGroup               = LoadCustomLibrary(&quot;EventGroup&quot;)

qSystems:Import(getfenv(0));

-- Renders BoxInventories in a pretty 3D voxel. Yay.
-- Box3Drender.lua
-- @author Quenty

--[[ Change Log

February 7rd, 2014
- Moved script from InventorySystems (renamed to BoxInventory) to Box3DRender
- Added Destroy method

--]]

local lib = {}

local MakeBox3DRender = Class(function(Box3DRender, BoxInventory)
	local Events = EventGroup.MakeEventGroup()

	local function UpdateVoxelPartPosition(VoxelGrid, Slot)
		--- adds an interface to it
		-- @pre Parent has VoxelGrid assigned.

		if Slot.VoxelGrid then -- regular VoxelGrid

			if not VoxelGrid.VoxelPart then
				VoxelGrid.VoxelPart = Make &apos;Part&apos; {
					Anchored      = false;
					Archivable    = false;
					BottomSurface = &quot;Smooth&quot;;
					BrickColor    = BrickColor.new(&quot;Bright red&quot;);
					CanCollide    = false;
					FormFactor    = &quot;Custom&quot;;
					Name          = &quot;VoxelGrid_Part_Representation&quot;;
					Parent        = Slot.VoxelGrid.VoxelPart;
					TopSurface    = &quot;Smooth&quot;;
					Transparency  = 1;
				};
				VoxelGrid.VoxelPart.Size = Vector3.new(Slot.ItemSize, Slot.ItemSize, Slot.ItemSize)
			end
			VoxelGrid.VoxelPart.Parent = Slot.VoxelGrid.VoxelPart

			local VoxelWeld = VoxelGrid.VoxelPart:FindFirstChild(&quot;Weld&quot;) or Make &apos;Weld&apos; {
				Name = &quot;Weld&quot;;
				Archivable = false;
				Parent = VoxelGrid.VoxelPart;
				--C0 = CFrame.new(0, 0, 0);
				--C1 = CFrame.new(0, 0, 0);
			};
			
			-- print(&quot;[Box3DRender] - Slot.VoxelGrid.VoxelPart = &quot;..tostring(Slot.VoxelGrid.VoxelPart))

			VoxelWeld.Part0 = VoxelGrid.VoxelPart;	
			VoxelWeld.Part1 = Slot.VoxelGrid.VoxelPart;
			VoxelWeld.C1    = CFrame.new(Slot.RelativePosition)
			
		-- else -- Storage slot.
			-- print(&quot;[Box3DRender] - Storage Slot added&quot;)
		end
	end

	local function RemoveVoxelGrid(VoxelGrid, Slot)
		if VoxelGrid.VoxelPart then
			-- print(&quot;[Box3DRender] - Removing VoxelPart&quot;)
			VoxelGrid.VoxelPart.Parent = nil; --:Destroy()
			VoxelGrid.VoxelPart = nil;
		else
			print(&quot;[Box3DRender] - No VoxelPart to destroy? Error?&quot;)
		end
	end

	local function CratePartChanged(Item, Slot)
		-- print(&quot;Crate part&apos;s position changed &quot;)

		local CrateData = Item.Interfaces.BoxInventory.CrateData;
		local SideLength = CrateData.SideLength;

		Item.Interfaces.Box3DRender = Item.Interfaces.Box3DRender or {}

		local CratePart = Item.Interfaces.Box3DRender.CratePart or Make &apos;Part&apos; { -- Rendering component.
			Anchored      = false;
			Archivable    = false;
			BottomSurface = &quot;Smooth&quot;;
			BrickColor    = CrateData.BrickColor;
			CanCollide    = false;
			FormFactor    = &quot;Custom&quot;;
			Material      = CrateData.MostCommonMaterial;
			Name          = Item.ClassName..&quot;Crate&quot;;
			Parent        = Slot.VoxelGrid.VoxelPart;
			TopSurface    = &quot;Smooth&quot;;
			Transparency  = 0;
		}
		CratePart.Size = Vector3.new(SideLength, SideLength, SideLength);
		CratePart.Parent = Slot.VoxelGrid.VoxelPart;
		
		Item.Interfaces.Box3DRender.CratePart = CratePart;

		local CrateWeld = CratePart:FindFirstChild(&quot;Weld&quot;) or Make &apos;Weld&apos; {
			Archivable = false;
			Name       = &quot;Weld&quot;;
			Parent     = CratePart;
		}

		--print(&quot;[Box3DRender] - Slot.VoxelGrid.VoxelPart = &quot;..tostring(Slot.VoxelGrid.VoxelPart))
		
		CrateWeld.Part0 = CratePart
		CrateWeld.Part1 = Slot.VoxelGrid.VoxelPart
		CrateWeld.C1 = CFrame.new(Slot.RelativePosition)
	end

	local function RemoveCrate(Item, Slot)
		local CratePart = Item.Interfaces.Box3DRender.CratePart
		if CratePart then
			CratePart:Destroy()
		end
	end

	local function Destroy()
		Events(&quot;Clear&quot;)
	end
	Box3DRender.Destroy = Destroy
	Box3DRender.destroy = Destroy

	--------------------
	-- CONNECT EVENTS --
	--------------------

	-- Incase events fire without connection...
	for _, VoxelGridSlot in pairs(BoxInventory.GetListOfVoxelGrids()) do
		UpdateVoxelPartPosition(VoxelGridSlot.Content, VoxelGridSlot)
	end
	for _, Item in pairs(BoxInventory.GetListOfItems()) do
		CratePartChanged(Item, Item.CurrentSlot)
	end

	-- Connect actual events.
	Events.VoxelGridAdded = BoxInventory.VoxelGridAdded:connect(function(VoxelGrid, Slot)
		UpdateVoxelPartPosition(VoxelGrid, Slot)
	end)

	Events.VoxelGridSlotChanged = BoxInventory.VoxelGridSlotChanged:connect(function(VoxelGrid, Slot)
		UpdateVoxelPartPosition(VoxelGrid, Slot)
	end)

	Events.ItemSlotChanged = BoxInventory.ItemSlotChanged:connect(function(Item, Slot)
		CratePartChanged(Item, Slot)
	end)

	Events.ItemAdded = BoxInventory.ItemAdded:connect(function(Item, Slot)
		CratePartChanged(Item, Slot)
	end)--]]

	Events.ItemRemoved = BoxInventory.ItemRemoved:connect(function(Item, Slot)
		RemoveCrate(Item, Slot)
	end)

	Events.VoxelGridRemoving = BoxInventory.VoxelGridRemoving:connect(function(VoxelGrid, Slot)
		RemoveVoxelGrid(VoxelGrid, Slot)
	end)
end)
lib.MakeBox3DRender = MakeBox3DRender
lib.makeBox3DRender = MakeBox3DRender

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX17">
<Properties>
<string name="Name">BoxInventory</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems                = LoadCustomLibrary(&quot;qSystems&quot;)
local qInstance               = LoadCustomLibrary(&quot;qInstance&quot;)
local Table                   = LoadCustomLibrary(&quot;Table&quot;)

qSystems:Import(getfenv(0))

local lib = {}

-- BoxInventory.lua
-- @author Quenty
-- Last Modified 
-- This system handles 3D inventory interactions (datastructure).

--[[ Change Log
February 13th, 2014
- Removed ItemSystem dependency as an argument, the BoxInventory doesn&apos;t need to know the ItemSystem.

February 7rd, 2014
- Moved 3D inventory rendering to a seperate script.
- Removed qCFrame dependency
- Removed PenlightPretty dependency
- Renamed to BoxInventory from &quot;InventorySystems&quot;
- Slight documentation added
- Change Log added
- Removed SerializerContainer support to work with New ItemSystem
- Removed DeSerailize functions

- Changed method name GetListOfItems to GetListOfSlotsWithItems 
- Added GetListOfItems function (seperate from changed method)
- Fixed glitch with SourceCFrame being nil

- Made GenerateCrateData available to the public.
- Fixed issue with removal / Container removal

February 6th, 2014
- Stabilized version

February 3rd, 2014
- Modified to work with new Nevermore
- Modified to use new ClassSystem
--]]

--[[

This is a very badly organized system to do 3D inventory stuff in a voxel grid. The first thing I should have done when writing this was
written a seperaet class to handle JUST the voxel grid. Now the voxel grids are integreated into the system, which is kind of messy.

Also, there were some bugs parsing this into ROBLOX&apos;s systems to send over remote events, you see it uses CreateInternalSignal() instead of
ROBLOX&apos;s event class.

Also, the way this works out, it&apos;s confusing conceptually, the main problems were with getting it to be sorted correctly, in the most optimal
position. That was a pain. 

--]]

----------------------
-- HELPER FUNCTIONS --
----------------------

local function GetMaxGridSizeFromSmallestSide(SmallestSide)
	local Index = 0 
	local SideSize 
	repeat 
		Index = Index + 1 
		SideSize = 2^Index 
	until SideSize &gt; SmallestSide 
	return Index
end

--[[

print(&quot; ItemSize : Volume : SideLength : GridSize : ItemSizeRecalculated&quot;)
for i=0, 10 do
i = 2^i
print(i .. &quot; : &quot; .. i^3 .. &quot; : &quot; .. SideLengthFromVolume(i^3) .. &quot; : &quot; .. ItemSizeToGridSize(i) .. &quot; : &quot; .. GridSizeToItemSize(ItemSizeToGridSize(i)))
end

 GridSize :  ItemSize : Volume     : SideLength : ItemSizeRecalculated
     1    :     1     : 1          :     1      :    1
     2    :     2     : 8          :     2      :    2
     3    :     4     : 64         :     4      :    4
     4    :     8     : 512        :     8      :    8
     5    :     16    : 4096       :     16     :    16
     6    :     32    : 32768      :     32     :    32
     7    :     64    : 262144     :     64     :    64
     8    :     128   : 2097152    :     128    :    128
     9    :     256   : 16777216   :     256    :    256
     10   :     512   : 134217728  :     512    :    512
     11   :     1024  : 1073741824 :     1024   :    1024

]]

local function ItemSizeToGridSize(ItemSize, GridSizePowerOf)
	-- From the scaled ItemSize to the linear GridSize

	GridSizePowerOf = GridSizePowerOf or 2;
	return (math.log(ItemSize) / math.log(GridSizePowerOf)) + 1;
end

local function GridSizeToItemSize(GridSize, GridSizePowerOf)
	-- Converts linear GridSize to scaled ItemSize

	GridSizePowerOf = GridSizePowerOf or 2;
	return GridSizePowerOf^(GridSize - 1)
end


local function GetSmallestSide(PartSize)
	-- Return&apos;s the smallest side in a part.

	return math.min(PartSize.X, math.min(PartSize.Y, PartSize.Z));
end

local function SideLengthFromVolume(PartVolume)
	-- Based upon volume, returns the appropriate shipping crate side length 
	-- (All shipping crates are squares)

	---[[
	local Index = 0 
	local Volume 
	repeat 
		Index = Index + 1 
		Volume = (Index)^3
	until Volume &gt; PartVolume 
	return (Index-1)
	--]]

	--return math.floor(PartVolume^(1/3) + 0.5) -- Sacrifice rounding w/ unprecise values for efficiency.
end

local function GenerateCrateData(Objects)
	-- Given a table of &apos;Objects&apos;, it&apos;ll find the most common material, average color, volume, and 
	-- the part of the most common material that is also the largest. 

	-- It is all scaled to Volume per part. 

	local VolumeListByMaterial = {};

	local PartToVolumeList = {}
	local MaterialToPartList = {};

	local WeightedColor = Vector3.new();
	local TotalVolume = 0

	-- Go through each object and calculate results cumulatively
	for _, Child in pairs(Objects) do
		if Child:IsA(&quot;BasePart&quot;) then
			local Material = Child.Material
			local Volume = Child.Size.x * Child.Size.y * Child.Size.z
			local Color = Vector3.new(Child.BrickColor.Color.r, Child.BrickColor.Color.g, Child.BrickColor.Color.b)
			VolumeListByMaterial[Material] = (VolumeListByMaterial[Material] or 0) + Volume
			WeightedColor = WeightedColor + Color*Volume;
			TotalVolume = TotalVolume + Volume;
			PartToVolumeList[Child] = Volume;
			if MaterialToPartList[Material] and PartToVolumeList[MaterialToPartList[Material]] &gt; Volume then
				MaterialToPartList[Material] = Child;
			end
		end
	end
	-- Average out the Color
	local Color = BrickColor.new(Color3.new(WeightedColor.x, WeightedColor.y, WeightedColor.z))

	-- Find the largest material possible
	local LargestMaterial = Enum.Material.Plastic;
	local LargestMaterialVolume = 0;
	for Material, Volume in pairs(VolumeListByMaterial) do
		if Volume &gt; LargestMaterialVolume then
			LargestMaterial = Material;
			LargestMaterialVolume = Volume;
		end
	end

	-- Return all values.
	local CrateData = {}
	CrateData.MostCommonMaterial = LargestMaterial;
	CrateData.BrickColor = Color;
	CrateData.Volume = TotalVolume;
	CrateData.MaterialToPartList = MaterialToPartList[LargestMaterial];
	CrateData.SideLength = SideLengthFromVolume(TotalVolume)
	CrateData.ItemSize = CrateData.SideLength -- For now, they&apos;re the same.
	CrateData.GridSize = ItemSizeToGridSize(CrateData.ItemSize); -- Scalier, what the item fits INTO. 

	return CrateData;
end
lib.GenerateCrateData = GenerateCrateData
lib.generateCrateData = GenerateCrateData

local function VoxelPairsSlot(VoxelGrid)
	-- Prefer Y, then X, then Z
	-- So first return all the content on the yLevel, that is, 1 and up...
	--- Generic ForLoop for Voxel Slot
	-- @param VoxelGrid Slot with VoxelGrid.Content as a VoxelGrid

	local Content = VoxelGrid.Content
	--assert(Content ~= nil, &quot;Content is nil, invalid Slot sent&quot;)
	local CurrentX = 1;
	local CurrentY = 1;
	local TargetY = #(Content[1]);
	local CurrentZ = 1;

	return function()
		local Slot, FaultAt
		while CurrentY &lt;= TargetY do
			Slot, FaultAt = Content:GetSlot(CurrentX, CurrentY, CurrentZ)
			if Slot then
				CurrentX = CurrentX + 1
				return Slot;
			elseif FaultAt == &quot;x&quot; then
				CurrentZ = CurrentZ + 1
				CurrentX = 1;
			elseif FaultAt == &quot;z&quot; then
				CurrentY = CurrentY + 1;
				CurrentX = 1;
				CurrentZ = 1;
			elseif FaultAt == &quot;y&quot; then
				return nil;
			end
		end
		return nil;
	end
end
lib.VoxelPairsSlot = VoxelPairsSlot
lib.voxelPairsSlot = VoxelPairsSlot

local function VoxelPairs(VoxelGrid)
	-- Prefer Y, then X, then Z
	-- So first return all the content on the yLevel, that is, 1 and up...
	--- Generic ForLoop for Voxel Slot

	local CurrentX = 1;
	local CurrentY = 1;
	local TargetY = #(VoxelGrid[1]);
	local CurrentZ = 1;

	return function()
		local Slot, FaultAt
		while CurrentY &lt;= TargetY do
			Slot, FaultAt = VoxelGrid:GetSlot(CurrentX, CurrentY, CurrentZ)
			if Slot then
				CurrentX = CurrentX + 1
				return Slot;
			elseif FaultAt == &quot;x&quot; then
				CurrentZ = CurrentZ + 1
				CurrentX = 1;
			elseif FaultAt == &quot;z&quot; then
				CurrentY = CurrentY + 1;
				CurrentX = 1;
				CurrentZ = 1;
			elseif FaultAt == &quot;y&quot; then
				return nil;
			end
		end
		return nil;
	end
end

local GetSlot = function(self, X, Y, Z)
	-- Return&apos;s the slot at X, Y, Z
	local Content = self;
	if type(X) ~= &quot;number&quot; then -- Must be Vector3
		X, Y, Z = X.x, X.y,X.z
	end

	if Content[X] ~= nil then
		if Content[X][Y] ~= nil then
			if Content[X][Y][Z] ~= nil then
				return Content[X][Y][Z];
			else
				return nil, &quot;z&quot;;
			end
		else
			return nil, &quot;y&quot;;
		end
	else
		return nil, &quot;x&quot;
	end
	return nil;
end;

local function GetRelativeSlotPosition(LocalPosition, GridSize, ItemSize)
	-- Return&apos;s relative Position from Center and Vector position and Size and Vector GridSize (X, Y, Z)

	-- GridSize is linear (And a vector)
	-- ItemSize, as always, is scalar...


	--return (LocalPosition + ((-GridSize - Vector3.new(1, 1, 1))/2)) * ItemSize -- Fun mathz!
	
	-- // ARCHIVE --
	--local RelativeToTop = ((LocalPosition - Vector3.new(1, 1, 1)) * (ItemSize/2))
	--local RelativeToCenter = (ItemSize/2) * ((GridSize - Vector3.new(1, 1, 1))/2) - RelativeToTop
	--return RelativeToCenter;
	-- // END ARCHIVE --

	local RelativeToTop = ((LocalPosition - Vector3.new(1, 1, 1)) * (ItemSize))
	local RelativeToCenter = (ItemSize) * ((GridSize - Vector3.new(1, 1, 1))/2) - RelativeToTop
	return -RelativeToCenter;
end

local function GenerateVoxelGrid(GridSize, ItemSize, Size)
	--- Generates a 3D array 
	-- @param Slot The slot that the VoxelGrid is being genearted for.

	-- GridSize is linear
	-- ItemSize, as always, is scalar...
	-- Size is a Vector

	local SizeX, SizeY, SizeZ = Size.X, Size.Y, Size.Z
	-- print(&quot;[BoxInventory] - Generating voxel grid of &quot;..SizeX..&quot;, &quot;..SizeY..&quot;, &quot;..SizeZ)
	local VoxelGrid = {}
	for X = 1, SizeX do
		VoxelGrid[X] = {};
		for Y = 1, SizeY do
			VoxelGrid[X][Y] = {};
			for Z = 1, SizeZ do
				local Slot = {
					Type          = &quot;EmptySlot&quot;;
					--Content     = {};
					ItemSize      = ItemSize;
					GridSize      = ItemSizeToGridSize(ItemSize);
					LocalPosition = Vector3.new(X, Y, Z); -- Linear
					VoxelGrid     = VoxelGrid;
					VoxelGridSlot = Slot
					--Weight      = 0; -- Used for
				};
				Slot.RelativePosition = GetRelativeSlotPosition(Slot.LocalPosition, Size, ItemSize)
				--print(&quot;[BoxInventory] - Slot.RelativePosition = &quot;..tostring(Slot.RelativePosition))
				VoxelGrid[X][Y][Z] = Slot
			end
		end
	end
	VoxelGrid.GetSlot = GetSlot;

	return VoxelGrid;
end

local function RoundNumberDown(Number, Divider)
	return math.floor((Number/Divider))*Divider
end

----------------
-- MAIN CLASS --
----------------

local MakeBoxInventory = Class(function(BoxInventory, Name)
	--- A 3D &quot;Box&quot; inventory, that revolves around packaging items into crates as representation.
	-- @param Name The Name of the BoxInventory. If no name is given, then it&apos;ll just generate one. 

	--[[
	This system needs to handle several things.  First of all, the inventory needs to be accessible as a 
	list.  This list needs to be sortable.  

	Secondly, this inventory, as the name implies, will limit objects based on their physical &apos;box&apos; size. That is
	all items will have a 3D model, and will a general Color, Volume, and Material will be 
	--]]

	local StorageSpaces = {}
	--[[
		Super complex data structure...

		StorageSpaces
			VoxelGrid
				Type = &quot;Voxel&quot;
				Size = GridSize (Linear)
				RelativePosition
				Content = {}[X][Y][Z] (Slots)
					Slot can contain...

					VoxelGrid
						...
					InventoryItem
						Interfaces
							BoxInventory
								CrateData	
							...
						Type = nil

					
		StorageSpaces[1].Content[X][Y][Z].Slot.Content[X][Y][Z].Content.Interfaces.BoxInventory.CrateData.Volume -- Potental line...

	--]]
	local Center

	BoxInventory.Name                 = Name or &quot;Inventory@&quot; .. tostring(BoxInventoryA);
	BoxInventory.LargestGridSize      = 1; -- The largest gridSize stored in the inevntory
	BoxInventory.Interfaces           = {} -- Stores internal data from interfacing programs. This is like the ItemSystem class, except other classes use it.

	-- ROBLOX Signals apparenlty don&apos;t support circular referenced items. Let&apos;s use Lua instead. 
	BoxInventory.StorageSlotAdded     = CreateSignalInternal(); 
	
	BoxInventory.ItemAdded            = CreateSignalInternal(); -- (Item, ItemSlot)
	BoxInventory.ItemRemoved          = CreateSignalInternal(); -- (Item, OldItemSlot)
	BoxInventory.ItemSlotChanged      = CreateSignalInternal(); -- (Item, NewSlot)
	
	BoxInventory.VoxelGridAdded       = CreateSignalInternal(); -- Whenever a new voxelgrid is added.
	BoxInventory.VoxelGridRemoving    = CreateSignalInternal(); -- Whenever a new voxelgrid is added. Fires before removal, probably.
	BoxInventory.VoxelGridSlotChanged = CreateSignalInternal(); -- When a VoxelGrid&apos;s slot changes.

	local StorageSpaces = StorageSpaces;

	local function AddVoxelGridToSlot(Slot, GridSize, ItemSize, Size)
		-- Add&apos;s a VoxelGrid to Slot.Content and updates relative information.
		-- @Param Size The X, Y, Z number of slots, a Vector3 Value
		-- @Pre Slot has a VoxelGrid...

		--print(&quot;[BoxInventory] - Generating voxel grid at GridSize @ &quot;.. tostring(GridSize)..&quot;, ItemSize ((2^ItemSize)=GridSize) @ &quot;..tostring(ItemSize))
		assert(ItemSize ~= nil, &quot;[BoxInventory][MakeVoxelGrid] - ItemSize is nil&quot;)
		assert(GridSize ~= nil, &quot;[BoxInventory][MakeVoxelGrid] - GridSize is nil&quot;)
		--assert(RelativePosition ~= nil, &quot;[BoxInventory][MakeVoxelGrid] - RelativePosition is nil&quot;)
		--assert(2^GridSize ~= ItemSize, &quot;2^GridSize (&quot;..(2^GridSize)..&quot;) ~= &quot;..ItemSize)

		Size = Size or Vector3.new(2, 2, 2)
		Slot.Type               = &quot;VoxelGrid&quot;;
		Slot.Content            = GenerateVoxelGrid(GridSize, ItemSize, Size); -- Convert gridsize to scalar.
		Slot.Content.ContentItemSize    = ItemSize; -- Scalar -- Size of the VoxelGrid&apos;s content&apos;s ItemSize and GridSize
		Slot.Content.ContentGridSize    = GridSize; -- Linear
		Slot.Content.AddTime = tick() -- For sorting

		--assert(Slot.Content   ~= nil, &quot;Content somehow ended up nil. FML.&quot;) 
		--Slot.RelativePosition = GetRelativeSlotPosition(Slot.LocalPosition, GridSize, ItemSize)
		Slot.Content.Slot       = Slot; -- Parent reference. Huzzah. 

		BoxInventory.VoxelGridAdded:fire(Slot.Content, Slot) -- Fire Events..

		return Slot;
	end

	local function MakeVoxelGrid(GridSize, ItemSize, Size)
		--- Makes a new VoxelGrid, aka a storage slot...
		-- @param GridSize the Size of the grid in linear form, (step based)
		-- @param ItemSize the Size of each item in the grid, which is 2^GridSize, probably
		-- @param [Size] the size of the grid, may be nil, but is in linear form, so gridsize, but can be anything. A vector3 value.

		-- GridSize is linear.
		-- ItemSize is scalar. 

		local Slot = {}
		AddVoxelGridToSlot(Slot, GridSize, ItemSize, Size)
		return Slot
	end

	local LookForEmptySlotInVoxelGridSlot
	function LookForEmptySlotInVoxelGridSlot(VoxelGrid, CrateData, DoNotRecurse)
		--- Search&apos;s for an empty slot in the voxel grid with the same size as the crate data, or recurses down...
		-- @param VoxelGrid Slot with it&apos;s Content.Type as &quot;Voxel&quot;

		if VoxelGrid.Content and VoxelGrid.Type == &quot;VoxelGrid&quot; then
			if VoxelGrid.Content.ContentGridSize == CrateData.GridSize then
				for Slot in VoxelPairsSlot(VoxelGrid) do
					if (Slot.Content == nil) then
						return Slot;
					end
				end
				return nil;
			elseif VoxelGrid.Content.ContentGridSize &gt; CrateData.GridSize then
				for Slot in VoxelPairsSlot(VoxelGrid) do
					if Slot.Content and Slot.Type == &quot;VoxelGrid&quot; then
						local RecursionResult = LookForEmptySlotInVoxelGridSlot(Slot, CrateData);
						if RecursionResult then
							return RecursionResult
						end
					elseif Slot.Content == nil and VoxelGrid.Content.ContentGridSize &gt;= 1 then -- Smallest size is 1?
						AddVoxelGridToSlot(Slot, VoxelGrid.Content.ContentGridSize - 1, GridSizeToItemSize(VoxelGrid.Content.ContentGridSize - 1))
						if not DoNotRecurse then
							local RecursionResult = LookForEmptySlotInVoxelGridSlot(Slot, CrateData);
							if RecursionResult then
								return RecursionResult
							end
						end
					end
				end
				return nil;
			else
				return nil;
			end
		else
			error(&quot;[BoxInventory] - VoxelGrid.Content is nil, or VoxelGrid.Type (&quot;..tostring(VoxelGrid.Type)..&quot;) ~= \&quot;VoxelGrid\&quot; invalid input&quot;)
		end
	end

	local function AddStorageSlot(Part)
		-- Add a brick into the storage slot...
		-- assert(Part ~= nil, &quot;[BoxInventory][AddStorageSlot] - Part is nil&quot;)

		Center = Center or Part.CFrame;

		local PartSize = Part.Size
		local SmallestSide = GetSmallestSide(PartSize)
		local GridSize = GetMaxGridSizeFromSmallestSide(SmallestSide) -- Scalier
		BoxInventory.LargestGridSize = math.max(BoxInventory.LargestGridSize, GridSize)
		local ItemSize = GridSizeToItemSize(GridSize);
		local Size = Vector3.new(
			math.floor(PartSize.X/SmallestSide), 
			math.floor(PartSize.Y/SmallestSide), 
			math.floor(PartSize.Z/SmallestSide)
		)
		
		--print(&quot;[Adding Storage Slot] - GridSize (Linear) &quot;..tostring(GridSize)..&quot;; ItemSize (Scaliar): &quot;..ItemSize..&quot;; Size = &quot;..tostring(Size))
		-- assert(PartSize ~= nil, &quot;[BoxInventory][AddStorageSlot] - PartSize is nil&quot;)
		-- assert(SmallestSide ~= nil, &quot;[BoxInventory][AddStorageSlot] - SmallestSide is nil&quot;)
		-- assert(ItemSize ~= nil, &quot;[BoxInventory][AddStorageSlot] - ItemSize is nil&quot;)
		-- assert(GridSize ~= nil, &quot;[BoxInventory][AddStorageSlot] - GridSize is nil&quot;)
		

		local StorageSlot               = MakeVoxelGrid(GridSize, ItemSize, Size);
		StorageSlot.IsStorageSlot       = true;
		StorageSlot.Content.VoxelPart   = Part;
		StorageSlot.GridSize            = GridSize;
		StorageSlot.ItemSize            = ItemSize;
		StorageSlot.RelativePosition    = Vector3.new(0, 0, 0) -- Relative to itself, it&apos;s obviously 0. 
		StorageSpaces[#StorageSpaces+1] = StorageSlot

		BoxInventory.StorageSlotAdded:fire(StorageSlot, Part)
		return StorageSlot
	end
	BoxInventory.AddStorageSlot = AddStorageSlot
	BoxInventory.addStorageSlot = AddStorageSlot

	local function GetStorageSlots()
		-- Return&apos;s storage slots
		return StorageSpaces;
	end
	BoxInventory.GetStorageSlots = GetStorageSlots
	BoxInventory.getStorageSlots = GetStorageSlots

	local function GetListOfSlotsWithItems()
		-- Return&apos;s a list of all the items in the inventory at the time...

		local List = {}
		local Recurse
		function Recurse(VoxelGrid)
			for Slot in VoxelPairsSlot(VoxelGrid) do
				if Slot.Content then
					if Slot.Type == &quot;Item&quot; then -- When it&apos;s nil, it&apos;s an object. 
						table.insert(List, Slot)
					elseif Slot.Type == &quot;VoxelGrid&quot; then
						Recurse(Slot)
					end
				end
			end
		end
		for _, VoxelGrid in pairs(StorageSpaces) do
			Recurse(VoxelGrid)
		end
		return List;
	end
	BoxInventory.GetListOfSlotsWithItems = GetListOfSlotsWithItems;
	BoxInventory.getListOfSlotsWithItems = GetListOfSlotsWithItems;

	local function GetListOfItems()
		local List = {}
		local Recurse
		function Recurse(VoxelGrid)
			for Slot in VoxelPairsSlot(VoxelGrid) do
				if Slot.Content then
					if Slot.Type == &quot;Item&quot; then -- When it&apos;s nil, it&apos;s an object. 
						table.insert(List, Slot)
					elseif Slot.Type == &quot;VoxelGrid&quot; then
						Recurse(Slot)
					end
				end
			end
		end
		for _, VoxelGrid in pairs(StorageSpaces) do
			Recurse(VoxelGrid)
		end
		return List;
	end
	BoxInventory.GetListOfItems = GetListOfItems
	BoxInventory.getListOfItems = GetListOfItems

	local function GetListOfVoxelGrids()
		-- Return&apos;s a list of VoxelGrids

		local List = {}
		local Recurse
		function Recurse(VoxelGrid)
			table.insert(List, VoxelGrid)
			for Slot in VoxelPairsSlot(VoxelGrid) do
				if Slot.Content then
					if Slot.Type == &quot;VoxelGrid&quot; then
						Recurse(Slot)
					end
				end
			end
		end
		for _, VoxelGrid in pairs(StorageSpaces) do
			Recurse(VoxelGrid)
		end
		return List;
	end
	BoxInventory.GetListOfVoxelGrids = GetListOfVoxelGrids
	BoxInventory.getListOfVoxelGrids = GetListOfVoxelGrids

	local function DeepSort()
		--- Sorts the inventory, in a specific order. 
		--[[ Should do the following, 
		
		Remove all empty VoxelGrids.
			For each voxel grid, we want to find out how many Slot children they have
			If it&apos;s 0, and none of the DEPENDING items have a child, then we can remove it. 

		Solid parts go on the bottom
	
		Initially using how many items were contained in a voxel grid + child voxel grid to sort the voxel grids.
		However, this doesn&apos;t work out too well, as we want the smaller items, that is, the ones not filled out completely
		to bubble up to the top.

		So &quot;volume&quot; would be a better way to do it, that is, the ones with the smallest volume should go up?
		]]

		local VoxelGridSlotsByGridSize          = {} -- Contains VoxelGrids (Slots) by GridSize
		local VoxelGridParentsByContentGridSize = {} -- Contains VoxelGrids (Slots) by what GridSize their content is. 
		local ItemSlotsByGridSize               = {} -- Contains Items (Slots). Array. 
		local LargestContentGridSize            = 1;

		local RecursePopulateLists
		function RecursePopulateLists(VoxelGridSlot)
			--- This looks like gibberish to me now. 
			-- Oh gosh.

			local ItemVolumeSum = 0;

			for Slot in VoxelPairsSlot(VoxelGridSlot) do
				if Slot.Type == &quot;VoxelGrid&quot; then
					ItemVolumeSum = ItemVolumeSum  + RecursePopulateLists(Slot, FunctionToExecute) 

					local SlotContentGridSize = Slot.Content.ContentGridSize
					local SlotGridSize = Slot.GridSize

					if SlotContentGridSize &gt; LargestContentGridSize then -- Update largestest GridSize
						LargestContentGridSize = SlotContentGridSize
					end

					VoxelGridSlotsByGridSize[SlotGridSize] = VoxelGridSlotsByGridSize[SlotGridSize] or {}
					local VoxelGridSlots = VoxelGridSlotsByGridSize[SlotGridSize]

					VoxelGridSlots[#VoxelGridSlots + 1] = Slot

					VoxelGridParentsByContentGridSize[SlotContentGridSize] = VoxelGridParentsByContentGridSize[SlotContentGridSize] or {}
					local VoxelGridParents = VoxelGridParentsByContentGridSize[SlotContentGridSize]
					VoxelGridParents[#VoxelGridParents + 1] = Slot
				elseif Slot.Type == &quot;Item&quot; then
					local SlotGridSize = Slot.GridSize

					ItemSlotsByGridSize[SlotGridSize] = ItemSlotsByGridSize[SlotGridSize] or {}
					local ItemSlots = ItemSlotsByGridSize[SlotGridSize]

					ItemSlots[#ItemSlots + 1] = Slot

					ItemVolumeSum = ItemVolumeSum + Slot.ItemSize^3;
				end
			end

			VoxelGridSlot.Content.ItemVolumeSum = ItemVolumeSum;
			return ItemVolumeSum;
		end

		for _, StorageSlot in ipairs(StorageSpaces) do
			RecursePopulateLists(StorageSlot)
			VoxelGridParentsByContentGridSize[StorageSlot.Content.ContentGridSize] = VoxelGridParentsByContentGridSize[StorageSlot.Content.ContentGridSize] or {}
			local VoxelGridParents = VoxelGridParentsByContentGridSize[StorageSlot.Content.ContentGridSize]
			VoxelGridParents[StorageSlot] = true
		end

		-- Sort backwards, because ChildCount changes, so sorting the VoxelGrids changes. :/
		for GridSize = 1, LargestContentGridSize do
			if VoxelGridParentsByContentGridSize[GridSize] then -- Make sure slots holding this level exist.
				-- For each slot we want to sort into new positions
				-- And then remove the inactive slots.

				local VoxelGridContentSlots = VoxelGridParentsByContentGridSize[GridSize]
				local VoxelGridSlots        = VoxelGridSlotsByGridSize[GridSize]
				local ItemSlots             = ItemSlotsByGridSize[GridSize]
				local Slots                 = {}

				if ItemSlots then
					-- Sort slots...
					table.sort(ItemSlots, function(ItemA, ItemB)
						local BoxInventoryA = ItemA.Content.Interfaces.BoxInventory
						local BoxInventoryB = ItemB.Content.Interfaces.BoxInventory

						if BoxInventoryA.CrateData.Volume == BoxInventoryB.CrateData.Volume then
							return BoxInventoryA.AddTime &lt; BoxInventoryB.AddTime -- We want added ones added first, first.
						else
							return BoxInventoryA.CrateData.Volume &gt; BoxInventoryB.CrateData.Volume
						end
					end)

					for Index, Item in ipairs(ItemSlots) do -- ItemSlots come first...
						Slots[Index] = Item.Content
					end
				end

				-- Sort VoxelGrids, we want the full ones first. There should not be any emptyones in here. 
				if VoxelGridSlots then
					table.sort(VoxelGridSlots, function(ItemA, ItemB)
						if ItemA.Content.ItemVolumeSum == ItemB.Content.ItemVolumeSum then
							return ItemA.Content.AddTime &lt; ItemB.Content.AddTime
						else
							return ItemA.Content.ItemVolumeSum &gt; ItemB.Content.ItemVolumeSum
						end
					end)

					local ItemSlotsCount = #Slots

					for Index, Item in ipairs(VoxelGridSlots) do
						Slots[ItemSlotsCount + Index] = Item.Content
					end
				end

				local Index = 1;
				for _, VoxelGridSlot in ipairs(VoxelGridContentSlots) do
					local ItemVolumeSum = 0;

					for Slot in VoxelPairsSlot(VoxelGridSlot) do -- There should theroetically be enough slots every single time.
						local NewContent = Slots[Index]
						if NewContent then					
							local SlotType = Slot.Type

							if Slot.Content ~= NewContent then
								Slot.Content = NewContent

								if NewContent.Interfaces then -- Determine type of newly modified slot.
									NewContent.Interfaces.BoxInventory.CurrentSlot = Slot;
									ItemVolumeSum = ItemVolumeSum + NewContent.Interfaces.BoxInventory.CrateData.ItemSize^3;
									Slot.Type = &quot;Item&quot;;

									BoxInventory.ItemSlotChanged:fire(Slot.Content, Slot)
								else
									Slot.Type = &quot;VoxelGrid&quot;;
									ItemVolumeSum = ItemVolumeSum + Slot.Content.ItemVolumeSum
									BoxInventory.VoxelGridSlotChanged:fire(Slot.Content, Slot)
								end
							else -- We still have to add to the count.
								if NewContent.Interfaces then -- Item
									ItemVolumeSum = ItemVolumeSum + NewContent.Interfaces.BoxInventory.CrateData.ItemSize^3;
								else -- VoxelGrid
									ItemVolumeSum = ItemVolumeSum + Slot.Content.ItemVolumeSum
								end
							end
						elseif SlotType ~= &quot;EmptySlot&quot; then -- No  content can be added, remove it!
							if not Slot.IsStorageSlot then
								Slot.Type = &quot;EmptySlot&quot;;
								Slot.Content = nil;
							else -- StorageSlots just get their content wiped
								Slot.Content = nil;
							end
						end
						Index = Index + 1;
					end

					if ItemVolumeSum == 0 then --if ItemChildCount == 0 then
						-- Remove this voxel grid, unless it&apos;s a Storage slot
						if not VoxelGridSlot.IsStorageSlot then
							BoxInventory.VoxelGridRemoving:fire(VoxelGridSlot.Content, VoxelGridSlot)

							-- Remove from table index of sorting thing
							local FoundIndex
							for Index, SlotInList in pairs(VoxelGridSlotsByGridSize[VoxelGridSlot.GridSize]) do
								if SlotInList == VoxelGridSlot then
									FoundIndex = Index;
									break;
								end
							end
							table.remove(VoxelGridSlotsByGridSize[VoxelGridSlot.GridSize], FoundIndex)

							VoxelGridSlot.Content = nil;
							VoxelGridSlot.Type = &quot;EmptySlot&quot;;
						end
					else
						-- VoxelGridSlot.Content.ItemChildCount = ItemChildCount
						VoxelGridSlot.Content.ItemVolumeSum = ItemVolumeSum;
					end
				end
			end
		end
	end
	BoxInventory.DeepSort = DeepSort;
	BoxInventory.deepSort = DeepSort


	local function GetEmptySlot(CrateData)
		-- Return&apos;s an empty spot, if it can find it...

		-- Search for the empty slot in each one...
		for _, VoxelSlot in ipairs(StorageSpaces) do
			local EmptySlot = LookForEmptySlotInVoxelGridSlot(VoxelSlot, CrateData)
			if EmptySlot then -- Only return if we&apos;ve got one...
				return EmptySlot
			end
		end

		return nil -- Could not find...
	end

	local CrateDataCache = {} -- Cache data per model to save on calcuation costs.
	local function AddBoxInventoryInterface(Item)
		-- Add&apos;s data storage interface and calculates data...

		if not Item.Interfaces.BoxInventory then
			-- Create a new interface that can be used to store data...

			local NewInterface = {};
			--NewInterface.CurrentBoxInventory = BoxInventory
			NewInterface.CrateData = CrateDataCache[Item.Model] or GenerateCrateData((Item.Model and qInstance.GetBricks(Item.Model) or error(&quot;[BoxInventory] - BoxInventory requires all items to have a &apos;Model&apos;&quot;)))
			--assert(NewInterface.CrateData ~= nil, &quot;[BoxInventory][InterfaceAdder] - Crate data ended up nil&quot;)
			CrateDataCache[Item.Model] = NewInterface.CrateData
			-- NewInterface.CurrentSlot = nil;

			function NewInterface.RemoveSelfFromInventory()
				-- Removes the item from the inventory.
				if NewInterface.CurrentSlot then
					BoxInventory.RemoveItemFromSlot(NewInterface.CurrentSlot)
					return true;
				else
					error(&quot;Item is not currently in an inventory, cannot remove&quot;)
					return false;
				end
			end

			Item.Interfaces.BoxInventory = NewInterface
		end
	end

	-------------------
	-- ITEM ADDITION --
	-------------------

	local function AddItem(Item, SourceCFrame, DoNotSort)
		--- &apos;Item&apos; is an InventoryObject item...
		-- SourceCFrame is the position that the item came from. Not required. Relative to global origin. 
		-- Return&apos;s the slot it was added too..
		-- @param DoNotSort 

		AddBoxInventoryInterface(Item)
		-- print(&quot;Adding Item, ItemSize: &quot;..Item.Interfaces.BoxInventory.CrateData.ItemSize..&quot;; GridSize: &quot;..Item.Interfaces.BoxInventory.CrateData.GridSize..&quot;; SideLength = &quot;..Item.Interfaces.BoxInventory.CrateData.SideLength)
		local EmptySlot = GetEmptySlot(Item.Interfaces.BoxInventory.CrateData)
		if EmptySlot then
			--print(EmptySlot.Content, EmptySlot.LocalPosition)
			EmptySlot.Content = Item;
			EmptySlot.Type = &quot;Item&quot;
			Item.Interfaces.BoxInventory.CurrentSlot = EmptySlot
			Item.Interfaces.BoxInventory.AddTime = tick() -- For sorting.

			-- assert(EmptySlot.VoxelGrid ~= nil, &quot;EmptySlot.VoxelGrid is nil. What is this!&quot;)
			--SimpleSort(EmptySlot.VoxelGrid)

			if SourceCFrame then
				-- Find CFrame relative to the Source...
				-- Origin will be the current slot... 
				-- local RelativePosition, VoxelPart = GetRelativePositionToVoxelPart(Item.Interfaces.BoxInventory.CurrentSlot)
				--Item.Interfaces.BoxInventory.SourceCFrame = SourceCFrame * VoxelPart.CFrame:inverse()
				--weld.Part0.CFrame * weld.C0 = weld.Part1.CFrame * weld.C1 ~ Oysi

				Item.Interfaces.BoxInventory.SourceCFrame = SourceCFrame
			else
				Item.Interfaces.BoxInventory.SourceCFrame = CFrame.new(Item.Interfaces.BoxInventory.CurrentSlot.RelativePosition)
			end
			--assert(Item.Interfaces.BoxInventory.SourceCFrame ~= nil, &quot;Item.Interfaces.BoxInventory.SourceCFrame is nil&quot;)
			
			if not DoNotSort then
				DeepSort()
			end

			BoxInventory.ItemAdded:fire(Item, Item.Interfaces.BoxInventory.CurrentSlot); -- Fire OnAdd event...
			return EmptySlot;
		else
			print(&quot;[BoxInventory] - *** ERROR *** Could not identify slot for item to be added, Size: &quot;..Item.Interfaces.BoxInventory.CrateData.ItemSize)
			return nil; -- Not enough space...
		end
	end
	BoxInventory.AddItem = AddItem;
	BoxInventory.addItem = AddItem;

	local function CanAdd(Item)
		--- Return&apos;s the slot it can be added to...
		-- @param Item an InventoryItem that should be tested for, if it can be added. 
		-- @return the Slot that the item may be added too.

		AddBoxInventoryInterface(Item)

		local EmptySlot = GetEmptySlot(NewInterface.CrateData)
		return EmptySlot
	end
	BoxInventory.CanAdd = CanAdd;
	BoxInventory.canAdd = CanAdd;

	local function RemoveItemFromSlot(Slot)
		--- Removes an item from a slot
		-- @param Slot The slot to remove the item from
		-- @return The slot that is being removed. 

		local ItemBeingRemoved = Slot.Content
		if Slot.Type == &quot;Item&quot; then
			local OldContent = Slot.Content

			Slot.Content = nil;
			Slot.Type = &quot;EmptySlot&quot;;

			DeepSort()

			BoxInventory.ItemRemoved:fire(ItemBeingRemoved, Slot)
			return OldContent;
		else
			error(&quot;[BoxInventory] - Cannot remove a(n) &quot;..tostring(Slot.Type)..&quot; form a slot, it must be an Item&quot;);
			return nil;
		end
	end
	BoxInventory.RemoveItemFromSlot = RemoveItemFromSlot;
	BoxInventory.removeItemFromSlot = RemoveItemFromSlot;

	local function GetSlotOfItemClass(ClassName)
		--- Get&apos;s the slot of an ItemClass if it exists and returns it.

		local Recurse
		function Recurse(VoxelGrid)
			for Slot in VoxelPairsSlot(VoxelGrid) do
				if Slot.Content then
					if Slot.Content.Type == nil then -- When it&apos;s nil, it&apos;s an object. 
						if Slot.Content.ClassName == ClassName then
							return Slot
						end
					elseif Slot.Content.Type == &quot;VoxelGrid&quot; then
						Recurse(Slot)
					end
				end
			end
		end
		for _, VoxelGrid in pairs(StorageSpaces) do
			local Result = Recurse(VoxelGrid)
			if Result then
				return Result
			end
		end
		return nil;
	end
	BoxInventory.GetSlotOfItemClass = GetSlotOfItemClass
	BoxInventory.getSlotOfItemClass = GetSlotOfItemClass

	local function RemoveItemClass(ClassName)
		-- Removes a single item of &quot;ItemClass&quot; from the inventory if it can find it.
		-- @return If it removed it successfully or not

		local Slot = GetSlotOfItemClass(ClassName)
		if Slot then
			RemoveItemFromSlot(Slot)
		end
	end
	BoxInventory.RemoveItemClass = RemoveItemClass
	BoxInventory.removeItemClass = RemoveItemClass
end)
lib.MakeBoxInventory = MakeBoxInventory
lib.makeBoxInventory = MakeBoxInventory

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX18">
<Properties>
<string name="Name">BoxInventoryManager</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local Players           = game:GetService(&quot;Players&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local EventGroup        = LoadCustomLibrary(&quot;EventGroup&quot;)
local BoxInventory      = LoadCustomLibrary(&quot;BoxInventory&quot;)
local qInstance         = LoadCustomLibrary(&quot;qInstance&quot;)

qSystems:Import(getfenv(0))


-- BoxInventoryManager.lua
-- This script handles the networking side of the inventory system. Basically, it makes sure events replicate correctly.

-- @author Quenty

--[[ -- Change Log --
Febrary 13th, 2014
v.1.1.1
- Made inventory remove on client, and then send request, on retreival, if it fails then it
  adds it back in .
- Added save and load functions

February 7th, 2014
v.1.1.0
- Added IsUIDRegistered function
- Added GetInventoryName function
- Fixed error with addition to ItemList on client.

v.1.0.0
- Initial script written
- Added change log
--]]

local lib = {}

local MakeBoxInventoryServerManager = Class(function(BoxInventoryServerManager, Player, StreamName)
	--- Create one per a player. StreamName should be unique per a player (I think?)
	-- @param Player The player to make the stream for
	-- @param StreamName The name of the stream

	-- Get raw stream data.
	local RemoteFunction  = NevermoreEngine.GetDataStreamObject(StreamName)
	local RemoteEvent = NevermoreEngine.GetEventStreamObject(StreamName)

	local Managers = {}

	local function AddInventoryToManager(BoxInventory, InventoryUID)
		-- @param BoxInventory The BoxInventory to send events for.
		-- @param InventoryUID String, the UID to associate the inventory with.

		local Events = EventGroup.MakeEventGroup() -- We&apos;ll manage events like this.

		local InventoryManager = {} -- Returned object
		InventoryManager.UID = InventoryUID
		InventoryManager.Updated = CreateSignal() -- Whenever it updates. Suppose to be used as a hook to save the inventory.

		local function FireEventOnClient(EventName, ...)
			--- Fires the event on the client with the EventName given. Used internally.
			-- @param EventName String, the name of the event. 

			RemoteEvent:FireClient(Player, InventoryUID, EventName, ...)
		end

		-- SAVING UTILITY STUFF --
		local function ValidateData(OldValue)
			if OldValue and OldValue.SaveVersion == &quot;1.0&quot; and type(OldValue.TimeStamp) == &quot;number&quot; and type(OldValue.Items) == &quot;table&quot; then
				return true
			else
				
				if OldValue then
					print(&quot;OldValue.SaveVersion == &quot; .. tostring(OldValue.SaveVersion) .. &quot;; type(OldValue.TimeStamp) == &apos;&quot; .. type(OldValue.TimeStamp) ..&quot;&apos;; type(OldValue.Items) == &apos;&quot; .. type(OldValue.Items) ..&quot;&apos;&quot;)
				else
					print(&quot;OldValue is &quot; .. tostring(OldValue))
				end
				return false
			end
		end

		local function UpdateSaveInventory(OldValue)
			-- Utility function used by SaveInventory, updated inventory.
			-- Meant to be caled by DataStore:UpdateAsync&apos;s function thingy

			return {
				Items       = InventoryManager.GetListOfItems();
				TimeStamp   = tick();
				SaveVersion = &quot;1.0&quot;;
			}
		end

		local function SaveInventory(DataStore, Key)
			-- @param DataStore The DataStore to load from
			-- @param Key The key to use when loading.

			if DataStore then
				DataStore:UpdateAsync(Key, UpdateSaveInventory)
			else
				print(&quot;[InventoryManager] - No Datastore provided, cannot save&quot;)
			end
		end
		InventoryManager.SaveInventory = SaveInventory
		InventoryManager.saveInventory = SaveInventory

		local function LoadValidData(ItemSystem, InventoryData)
			for _, Data in pairs(InventoryData.Items) do
				if type(Data.classname) == &quot;string&quot; and Data.uid then
					local NewConstruct = ItemSystem.ConstructClassFromData(Data)
					if NewConstruct then

						-- Add item, make sure we can add it.
						local DidAdd = BoxInventory.AddItem(NewConstruct, nil, true)

						if not DidAdd then
							print(&quot;[ItemSystem][LoadInventory] - Inventory failed to add item&quot;)
						end
					else
						print(&quot;[ItemSystem][LoadInventory] - Unable to construct new Item class &apos;&quot; .. Item.classname ..&quot;&apos;&quot;)
					end
				end
			end

			-- We set it to not sort on add. Now we sort!
			BoxInventory.DeepSort()
		end

		local function LoadInventory(ItemSystem, DataStore, Key)
			--- Load&apos;s the inventory. Only call once nubs.
			-- @param DataStore The DataStore to load from
			-- @param Key The Key to use when loading

			if DataStore then
				local InventoryData = DataStore:GetAsync(Key)
				if ValidateData(InventoryData) then
					LoadValidData(ItemSystem, InventoryData)
				else
					print(&quot;[InventoryManager][LoadInventory] - Invalid data from datastore given.&quot;)
				end
			else
				print(&quot;[InventoryManager] - No Datastore provided, cannot save&quot;)
			end
		end
		InventoryManager.LoadInventory = LoadInventory
		InventoryManager.loadInventory = LoadInventory
		
		-- OTHER METHODS --

		local function Destroy()
			--- Destroy&apos;s the InventoryManager

			-- Tell the client the inventory is disconnecting
			FireEventOnClient(EventName, &quot;InventoryRemoving&quot;)
			InventoryManager.Updated:Destroy()
			Events(&quot;Clear&quot;)
			Events = nil
			InventoryManager.Destroy = nil
			FireEventOnClient = nil
			Managers[InventoryUID] = nil
		end
		InventoryManager.Destroy = Destroy
		InventoryManager.destroy = Destroy

		-- VALID REQUESTS --
		local function GetListOfItems()
			--- Return&apos;s a list of items in the inventory
			--- Only returns the Data, nothing more.
			--- Used by the networking side of this.

			local Items = BoxInventory.GetListOfItems()
			local ParsedItems = {}

			for _, Item in pairs(Items) do
				-- print(&quot;[BoxInventoryClientManager] - Item.Data = &quot; .. tostring(Item.Data))
				ParsedItems[#ParsedItems+1] = Item.Content.Data
			end

			return ParsedItems
		end
		InventoryManager.GetListOfItems = GetListOfItems
		InventoryManager.getListOfItems = GetListOfItems

		local function GetInventoryName()
			-- Return&apos;s the inventories name. Used internally

			return BoxInventory.Name
		end
		InventoryManager.GetInventoryName = GetInventoryName
		InventoryManager.getInventoryName = GetInventoryName

		local function GetLargestGridSize()
			-- Get&apos;s the largest grid size. Used internally

			return BoxInventory.LargestGridSize
		end
		InventoryManager.GetLargestGridSize = GetLargestGridSize
		InventoryManager.getLargestGridSize = GetLargestGridSize

		local function RemoveItemFromInventory(UID)
			-- Remove&apos;s the item with the UID (Unique Identifier), from the inventory. Used internally.
			if UID then
				local Items = BoxInventory.GetListOfItems()
				for _, ItemSlot in pairs(Items) do
					local Item = ItemSlot.Content
					if Item.UID == UID then
						Item.Interfaces.BoxInventory.RemoveSelfFromInventory()
						return true
					end
				end
				print(&quot;[BoxInventoryServerManager] - Unable to find item with UID &apos;&quot; .. UID .. &quot;&apos;&quot;)
				return false
			else
				error(&quot;[BoxInventoryServerManager] - UID is &apos;&quot; .. tostring(UID) ..&quot;&apos;&quot;)
			end
		end
		InventoryManager.RemoveItemFromInventory = RemoveItemFromInventory
		InventoryManager.removeItemFromInventory = RemoveItemFromInventory

		-- Setup actual events --
		Events.ItemAdded = BoxInventory.ItemAdded:connect(function(Item, Slot)
			-- We won&apos;t (and can&apos;t) send the slot. Only the ItemData is safe. 
			InventoryManager.Updated:fire()
			FireEventOnClient(&quot;ItemAdded&quot;, Item.Data)
		end)
		Events.ItemRemoved = BoxInventory.ItemRemoved:connect(function(Item, Slot)
			-- We won&apos;t (and can&apos;t) send the slot. Only the ItemData is safe.  Client side will interpret based on UID to remove the correct item.
			InventoryManager.Updated:fire()
			FireEventOnClient(&quot;ItemRemoved&quot;, Item.Data)
		end)

		-- Make sure we aren&apos;t killing a manager.
		if Managers[InventoryUID] ~= nil then
			error(&quot;[BoxInventoryServerManager] A manager with the UID of &apos;&quot; .. InventoryUID .. &quot;&apos; already exists!&quot;)
		end

		Managers[InventoryUID] = InventoryManager
		return InventoryManager
	end
	BoxInventoryServerManager.AddInventoryToManager = AddInventoryToManager
	BoxInventoryServerManager.addInventoryToManager = AddInventoryToManager

	local function RemoveInventoryFromManager(InventoryUID)
		Managers[InventoryUID]:Destroy()
	end


	-- List of requests that can be called to a manager.
	local ValidRequests = {
		GetListOfItems          = true;
		GetInventoryName        = true;
		GetLargestGridSize      = true;
		RemoveItemFromInventory = true;
	}

	RemoteFunction.OnServerInvoke = function(Requester, InventoryUID, Request, ...)
		-- Fix networking problems on SoloTestMode
		if NevermoreEngine.SoloTestMode then
			Requester = Players:GetPlayers()[1]
		end

		if Requester == Player then
			if InventoryUID then
				if ValidRequests[Request] then
					if Managers[InventoryUID] then
						return Managers[InventoryUID][Request](...)
					else
						error(&quot;[BoxInventoryServerManager] - An inventory with the UID &apos;&quot; .. InventoryUID .. &quot;&apos; does not exist!&quot;)
					end
				elseif Request == &quot;IsUIDRegistered&quot; then
					return (Managers[InventoryUID] ~= nil)
				else
					error(&quot;[BoxInventoryServerManager] - Invalid request &apos;&quot; .. tostring(Request) ..&quot;&apos; !&quot;)
				end
			else
				error(&quot;[BoxInventoryServerManager] - InventoryUID is nil or false&quot;)
			end
		else
			error(&quot;[BoxInventoryServerManager] - RemoteFunction.OnServerInvoke, Requester (&quot; .. tostring(Requester) .. &quot;) ~= Player (&quot; .. tostring(Player) ..&quot;).&quot;)
		end
	end

	local function Destroy()
		--- GC&apos;s the overall Manager

		for UID, Manager in pairs(Managers) do
			Manager:Destroy()
		end

		RemoteFunction.OnServerInvoke = nil
		RemoteEvent:Destroy()
		RemoteFunction:Destroy()
	end
	BoxInventoryServerManager.Destroy = Destroy
	BoxInventoryServerManager.destroy = Destroy
end)
lib.MakeBoxInventoryServerManager = MakeBoxInventoryServerManager
lib.makeBoxInventoryServerManager = MakeBoxInventoryServerManager

local CrateDataCache = {}

local MakeBoxInventoryClientManager = Class(function(BoxInventoryClientManager, Player, StreamName, ItemSystem)
	local RemoteFunction = NevermoreEngine.GetDataStreamObject(StreamName)
	local RemoteEvent    = NevermoreEngine.GetEventStreamObject(StreamName)

	local Inventories = {}

	local function MakeClientInventoryInterface(InventoryUID)
		-- print(&quot;[BoxInventoryClientManager] - Registering ClientInventoryInterface &apos;&quot; .. InventoryUID ..&quot;&apos;&quot;)
		
		--- Connects to the server system, and makes an inteface that can be interaced with.
		-- Tracks only the items in the current inventory, so duplicates *may* exist if removal occurs.
		-- Removal should only occur on serverside.. 

		local InventoryInterface = {}
		InventoryInterface.UID         = InventoryUID
		InventoryInterface.Interfaces  = {} -- Client side Interfaces linker.
		
		InventoryInterface.ItemAdded   = CreateSignal()
		InventoryInterface.ItemRemoved = CreateSignal()

		local Events = EventGroup.MakeEventGroup() -- We&apos;ll manage events like this.
		local ItemList = {}

		while not RemoteFunction:InvokeServer(InventoryUID, &quot;IsUIDRegistered&quot;) do
			print(&quot;[BoxInventoryClientManager] - Waiting for server to register UID &apos;&quot; .. InventoryUID ..&quot;&apos;&quot;)
			wait(0)
		end

		InventoryInterface.Name            = RemoteFunction:InvokeServer(InventoryUID, &quot;GetInventoryName&quot;)
		InventoryInterface.LargestGridSize = RemoteFunction:InvokeServer(InventoryUID, &quot;GetLargestGridSize&quot;)
		
		-- Methods --
		local function Destroy()
			Events(&quot;Clear&quot;)
			Events = nil
			InventoryInterface.UID            = nil
			InventoryInterface.Destroy        = nil
			InventoryInterface.GetListOfItems = GetListOfItems
			Inventories[InventoryUID]         = nil

			InventoryInterface.ItemAdded:destroy()
			InventoryInterface.ItemRemoved:destroy()

			InventoryInterface.ItemAdded   = nil
			InventoryInterface.ItemRemoved = nil
		end
		InventoryInterface.Destroy = Destroy
		InventoryInterface.destroy = Destroy

		local function GetItemFromData(ItemData)
			--- Searches ItemList for an item with the same UID
			-- @return The item found, if it is found,
			--         boolean found.

			local UID = ItemData.uid

			for _, Item in pairs(ItemList) do
				if Item.UID == UID then
					return Item, true
				end
			end

			return nil, false
		end

		local OnItemRemove
		local OnItemAdd

		local function AddInterfacesToItem(ItemData, Constructed)
			--- Addes interfaces to an item
			-- @param ItemData The item data
			-- @param Constructed The newly constructed item

			local BoxInventoryManagerInterface = {} do
				BoxInventoryManagerInterface.PendingRemoval = false

				local function RemoveItemFromInventory()
					-- You have no idea how inefficient this is...

					if not BoxInventoryManagerInterface.PendingRemoval then
						OnItemRemove(ItemData)
						BoxInventoryManagerInterface.PendingRemoval = true
						local DidRemove = {RemoteFunction:InvokeServer(InventoryUID, &quot;RemoveItemFromInventory&quot;, Constructed.UID)}
						if not DidRemove then
							print(&quot;[BoxInventoryClientManager] - Data failed to remove, adding back to inventory&quot;)

							OnItemAdd(ItemData)
							BoxInventoryManagerInterface.PendingRemoval = false
						end
						return DidRemove
					end
				end
				BoxInventoryManagerInterface.RemoveItemFromInventory = RemoveItemFromInventory
			end
			Constructed.Interfaces.BoxInventoryManager = BoxInventoryManagerInterface

			local BoxInventoryInterface = {} do
				BoxInventoryInterface.CrateData = CrateDataCache[Constructed.Model] 

				if not BoxInventoryInterface.CrateData then
					if Constructed.Model then
						BoxInventoryInterface.CrateData = BoxInventory.GenerateCrateData(qInstance.GetBricks(Constructed.Model))
						CrateDataCache[Constructed.Model] = BoxInventoryInterface.CrateData
					else
						error(&quot;[BoxInventoryClientManager] - BoxInventory requires all items to have a &apos;Model&apos;&quot;)
					end
				end

				BoxInventoryInterface.RemoveSelfFromInventory = BoxInventoryManagerInterface.RemoveItemFromInventory
			end
			Constructed.Interfaces.BoxInventory = BoxInventoryInterface
		end

		local function DeparseItemData(ItemData)
			--- Deparses the item into a valid item. If the item already exists, will return it.
			-- @param ItemData The item data
			-- @return The deparsed item. True if it already was in the system, false if it wasn&apos;t

			if not ItemData.uid then
				error(&quot;[BoxInventoryClientManager] - Cannot deparse, no UID&quot;)
			end

			-- Make sure item does not exist already...
			local Item, ItemFound = GetItemFromData(ItemData)
			if ItemFound then
				return Item, true
			else
				local Constructed = ItemSystem.ConstructClassFromData(ItemData)

				AddInterfacesToItem(ItemData, Constructed)

				return Constructed, false
			end
		end

		local function GetListOfItems(DoNotNetwork)
			--- Return&apos;s a list of items in the inventory. 
			local List = RemoteFunction:InvokeServer(InventoryUID, &quot;GetListOfItems&quot;)
			if List then
				local ListOfItems = {}

				for _, ItemData in pairs(List) do
					local Item, IsNewItem = DeparseItemData(ItemData)
					ListOfItems[#ListOfItems+1] = Item
					if IsNewItem then
						InventoryInterface.ItemAdded:fire(NewItem)
					end
				end

				ItemList = ListOfItems
				return ListOfItems
			else
				print(&quot;[BoxInventoryClientManager] - Failed to retrieve item list&quot;)
			end
		end
		InventoryInterface.GetListOfItems = GetListOfItems
		InventoryInterface.getListOfItems = GetListOfItems

		function OnItemAdd(ItemData)
			local NewItem, AlreadyInSystem = DeparseItemData(ItemData)
			if not AlreadyInSystem then
				ItemList[#ItemList+1] = NewItem
				InventoryInterface.ItemAdded:fire(NewItem)
			else
				print(&quot;[BoxInventoryClientManager][OnItemAdd] - Item &quot; .. ItemData.classname .. &quot; UID &apos;&quot; .. ItemData.uid .. &quot;&apos;&apos; already exists in the inventory&quot;)
			end
		end

		function OnItemRemove(ItemData)
			local Item, AlreadyInSystem = GetItemFromData(ItemData)
			if AlreadyInSystem then
				if not Item.Interfaces.BoxInventoryManager.PendingRemoval then
					InventoryInterface.ItemRemoved:fire(Item)
				else
					print(&quot;[BoxInventoryClientManager][OnItemRemove] - Item &quot; .. ItemData.classname .. &quot;@&quot; .. ItemData.uid .. &quot; is pending removal. Removal confirmed, setting PendingRemoval to false&quot;)
					Item.Interfaces.BoxInventoryManager.PendingRemoval = false
				end
			else 
				print(&quot;[BoxInventoryClientManager][OnItemRemove] - Item &quot; .. ItemData.classname .. &quot;@&quot; .. ItemData.uid .. &quot; was not in the inventory. &quot;)
			end
			
		end

		local function HandleNewEvent(EventName, ...)
			--- Handles new events that update the inventory

			-- print(&quot;[BoxInventoryClientManager] - New event &apos;&quot; .. EventName ..&quot;&apos; fired&quot;)
			if EventName == &quot;ItemAdded&quot; then
				OnItemAdd(...)
			elseif EventName == &quot;ItemRemoved&quot; then
				OnItemRemove(...)
			else
				print(&quot;[BoxInventoryClientManager] - No event linked to &apos;&quot; .. tostring(EnventName) .. &quot;&apos;&quot;)
			end
		end
		InventoryInterface.HandleNewEvent = HandleNewEvent
		InventoryInterface.handleNewEvent = HandleNewEvent

		-- Update list --
		GetListOfItems()

		if Inventories[InventoryUID] then
			error(&quot;[BoxInventoryClientManager] - An inventory with the UID &apos;&quot; .. InventoryUID .. &quot;&apos; already exists.&quot;)
		else
			Inventories[InventoryUID] = InventoryInterface
		end
		return Inventories[InventoryUID]
	end
	BoxInventoryClientManager.MakeClientInventoryInterface = MakeClientInventoryInterface
	BoxInventoryClientManager.makeClientInventoryInterface = MakeClientInventoryInterface

	local ClientEventConnection = RemoteEvent.OnClientEvent:connect(function(InventoryUID, EventName, ...)
		if InventoryUID then
			local InventoryInterface = Inventories[InventoryUID]
			if InventoryInterface then
				InventoryInterface.HandleNewEvent(EventName, ...)
			else
				print(&quot;[BoxInventoryClientManager] - No InventoryInterface exists with UID of &apos;&quot; .. tostring(InventoryUID) ..&quot;&apos;&quot;)
			end
		else
			print(&quot;[BoxInventoryClientManager] - InventoryUID is not correct, is &apos;&quot; .. tostring(InventoryUID) ..&quot;&apos;&quot;)
		end
	end)

	local function Destroy()
		-- Destroys the BoxInventoryClientManager, cannot destroy connection objects.

		ClientEventConnection:disconnect()
		ClientEventConnection = nil

		for _, InventoryInterface in pairs(Inventories) do
			InventoryInterface:Destroy()
		end
		Inventories = nil
		BoxInventoryClientManager.Destroy = nil
	end
	BoxInventoryClientManager.Destroy = Destroy
	BoxInventoryClientManager.destroy = Destroy
end)
lib.MakeBoxInventoryClientManager = MakeBoxInventoryClientManager
lib.makeBoxInventoryClientManager = MakeBoxInventoryClientManager

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX19">
<Properties>
<string name="Name">BoxInventoryRender</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems                = LoadCustomLibrary(&quot;qSystems&quot;)
local Table                   = LoadCustomLibrary(&quot;Table&quot;)
local qString                 = LoadCustomLibrary(&quot;qString&quot;)
local qGUI                    = LoadCustomLibrary(&quot;qGUI&quot;)
local ScrollBar               = LoadCustomLibrary(&quot;ScrollBar&quot;)
local EventGroup              = LoadCustomLibrary(&quot;EventGroup&quot;)
local OverriddenConfiguration = LoadCustomLibrary(&quot;OverriddenConfiguration&quot;)

-- BoxInventoryRender.lua
-- @author Quenty
-- This library handles rendering the BoxInventory in 2D for interaction. It also handles, or course, player interaction
-- with it. It&apos;s basically split between datastructures and rendering structures. 

--[[ -- Change Log
---- NOTE INDIVIDUAL CHANGE LOGS ARE NOW ALSO MAINTAINED PER A CLASS. GLOBAL CHANGES LISTED HERE (Changes related to whole system)

February 13th, 2014
- OverriddenConfiguration is now semi-utilized

February 7th, 2014
- Updated to name BoxInventoryRender (previous InventoryRender)
- Updated to use BoxInventory
- Added change log
- Updated to use ClientInventoryInterface (From BoxInventoryManager) for localside interactions

February 3rd, 2014
- Updated to new Nevermore System
- Updated to use new class system.

--]]

qSystems:Import(getfenv(0))

local lib = {}

----------------------
-- INTERNAL UTILITY --
----------------------

local function MakeTitleFrame(Parent, Title, Subtitle, ZIndex, Height, XOffset)
	--- Generates the top &apos;header frame&apos; at the top.
	--[[ Looks something like this:
	   __________________________
	  |                          |
	  | TITLE HERE               |
	  | TITLE HERE Subtitle      |
	  |__________________________|
	--]]

	-- @param Parent the parent of the TitleFrame, which must be rendered to get the right rendering.
	-- @param Title the title of the frame
	-- @param Subtitle the subtitle to display. Will auto offset from title.
	-- @param [ZIndex] the ZIndex of the title frame. 
	-- @param [Height] the height of the title frame to be. 
	-- @param [XOffset] the offset from the left (X Axis)
	-- @pre The GUI must be a descendent of a PlayerGui in order for the Subtitle to be rendered correctly.
	-- @post Subtitle is only parented to the TitleFrame is it Subtitle ~= &quot;&quot; and Subtitle is given.
	-- @return TitleFrame -- the title frame that was generated. Used by MakeBox2DRender... Helper function.
	
	Height = Height or 50;
	XOffset = XOffset or 10;

	local TitleFrame = Make &apos;Frame&apos; {
		Archivable             = false;
		BackgroundColor3       = Color3.new(0, 0, 0);
		BackgroundTransparency = 0.3;
		BorderSizePixel        = 0;
		ClipsDescendants       = true; -- Make sure if the Title goes past the size, we can still work....
		Name                   = &quot;TitleFrame&quot;;
		Parent                 = Parent;
		Position               = UDim2.new(0, 0, 0, 0);
		Size                   = UDim2.new(1, 0, 0, Height);
		Visible                = true;
		ZIndex                 = ZIndex;
	}

	local Title = Make &apos;TextLabel&apos; {
		Archivable             = false;
		BackgroundColor3       = Color3.new(0, 0, 0);
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Font                   = &quot;Arial&quot;;
		FontSize               = &quot;Size24&quot;;
		Name                   = &quot;Title&quot;;
		Parent                 = TitleFrame;
		Position               = UDim2.new(0, XOffset, 0, 0);
		Size                   = UDim2.new(1, -XOffset, 1, -10);
		Text                   = Title;
		TextColor3             = Color3.new(1, 1, 1);
		TextStrokeTransparency = 1;
		TextXAlignment         = &quot;Left&quot;;
		TextYAlignment         = &quot;Bottom&quot;;
		Visible                = true;
		ZIndex                 = ZIndex;
	}

	local TitleSpace = Title.TextBounds.X + 5;

	if Subtitle and Subtitle ~= &quot;&quot; then
		local Subtite = Make &apos;TextLabel&apos; {
			Archivable             = false;
			BackgroundColor3       = Color3.new(0, 0, 0);
			BackgroundTransparency = 1;
			BorderSizePixel        = 0;
			Font                   = &quot;Arial&quot;;
			FontSize               = &quot;Size14&quot;;
			Name                   = &quot;Title&quot;;
			Parent                 = TitleFrame;
			Position               = UDim2.new(0, XOffset + TitleSpace, 0, 0);
			Size                   = UDim2.new(1, -TitleSpace - XOffset, 1, -12);
			Text                   = Subtitle;
			TextColor3             = Color3.new(1, 1, 1);
			TextStrokeTransparency = 1;
			TextXAlignment         = &quot;Left&quot;;
			TextYAlignment         = &quot;Bottom&quot;;
			Visible                = true;
			ZIndex                 = ZIndex;
		}
	end

	return TitleFrame;
end

local function RenderSizeIcon(IconSize, GridSize, Color, ZIndex)
	--- Render&apos;s a SizeIcon that is broken up like a grid.
	-- @param IconSize size of the icon in pixels
	-- @param GridSize the number of seperations to make
	-- @param Color the color of the hightlighted icon.
	
	local RenderFrame = Make &apos;Frame&apos; {
		Archivable             = false;
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Name                   = &quot;SizeIcon&quot;;
		Size                   = UDim2.new(0, IconSize, 0, IconSize);
		Visible                = true;
		ZIndex                 = ZIndex;
	}

	Color = Color or Color3.new(0.5, 0.5, 0.5);

	local RegularColor = Color3.new(0.8, 0.8, 0.8)
	local SpacingSize = 2
	local FrameSize = math.floor((IconSize - (SpacingSize * (GridSize - 1)))/GridSize) -- Almost like LISP.
	local Offset = (IconSize - (((FrameSize + SpacingSize) * GridSize) - SpacingSize))/2
	--print(&quot;[RenderSizeIcon] - FrameSize : &quot;..((((FrameSize + SpacingSize) * GridSize) - SpacingSize)))
	--print(&quot;[RenderSizeIcon] - Offset = &quot;..Offset)

	-- Yeah, look at all these loops. It&apos;s beautiful!
	for XPosition = 0, (GridSize - 1) do
		for YPosition = 0, (GridSize - 1) do
			local BoxPartFrame = Make &apos;Frame&apos; {
				Archivable       = false;
				BackgroundColor3 = RegularColor;
				BorderSizePixel  = 0;
				Name             = &quot;BoxPart-&quot; .. XPosition .. &quot;-&quot; .. YPosition;
				Parent           = RenderFrame;
				Size             = UDim2.new(0, FrameSize, 0, FrameSize);
				Visible          = true;
				ZIndex           = ZIndex;
				Position         = UDim2.new(0, Offset + ((FrameSize * XPosition) + ((XPosition) * SpacingSize)), 0, Offset + ((FrameSize * YPosition) + (YPosition * SpacingSize)));
			}
		end
	end

	-- Set that last color
	RenderFrame[&quot;BoxPart-0-&quot;..(GridSize-1)].BackgroundColor3 = Color
	return RenderFrame
end

--[[
	Made Configuration use OverriddenConfiguration 
--]]
local function MakeCollapseButton(State, Configuration)
	--- Makes a minimize/maximize window icon.
	-- @param State If true, shows the maximize button, otherwise shows the minimze button.
	-- @param ZIndex The ZIndex of the button.
	
	State = State or false; -- Presume if no state is given that the window is shown.

	Configuration = OverriddenConfiguration.new(Configuration, {
		DefaultTransparency    = (Configuration and Configuration.DefaultTransparency) or 0.3;
		Color                  = (Configuration and Configuration.Color) or Color3.new(1, 1, 1);
		ZIndex                 = (Configuration and Configuration.ZIndex) or 1;
		OnOverTransparency     = (Configuration and Configuration.OnOverTransparency) or 0;
		TransparencyChangeTime = (Configuration and Configuration.TransparencyChangeTime) or 0.1;
		DoAnimateOnOver        = (Configuration and Configuration.DoAnimateOnOver ~= nil and Configuration.DoAnimateOnOver) or true;
	})
	local Button = {}
	
	
	local CollapseButton = Make &apos;ImageButton&apos; {
		Archivable             = false;
		BackgroundTransparency = 1;
		BackgroundColor3       = Configuration.Color;
		Image                  = &quot;&quot;;
		Size                   = UDim2.new(0, 30, 0, 25);
		ZIndex                 = Configuration.ZIndex + 1;
		BorderSizePixel        = 0;
		Make &apos;Frame&apos; {
			Name                   = &quot;Minimize&quot;;
			ZIndex                 = Configuration.ZIndex;
			Archivable             = false;
			BorderSizePixel        = 0;
			BackgroundColor3       = Configuration.Color;
			Position               = UDim2.new(0.1, 0, 0.6, 0);
			Style                  = &quot;Custom&quot;;
			Visible                = false;
			BackgroundTransparency = Configuration.DefaultTransparency;
			Size                   = UDim2.new(0.8, 0, 0.2, 0);
		};
		Make &apos;Frame&apos; {
			Name                   = &quot;Maximize&quot;;
			ZIndex                 = ZIndex;
			Archivable             = false;
			BorderSizePixel        = 0;
			BackgroundTransparency = 1;
			Position               = UDim2.new(0, 0, 0, 0);
			Style                  = &quot;Custom&quot;;
			Visible                = false;
			Size                   = UDim2.new(1, 0, 1, 0);
			Make &apos;Frame&apos; {
				ZIndex                 = Configuration.ZIndex;
				Archivable             = false;
				BorderSizePixel        = 0;
				BackgroundTransparency = Configuration.DefaultTransparency;
				BackgroundColor3       = Configuration.Color;
				Position               = UDim2.new(0.1, 0, 0.2, 0);
				Size                   = UDim2.new(0.8, 0, 0.25, 0);
			};
			Make &apos;Frame&apos; {
				ZIndex                 = Configuration.ZIndex;
				Archivable             = false;
				BorderSizePixel        = 0;
				BackgroundTransparency = Configuration.DefaultTransparency;
				BackgroundColor3       = Configuration.Color;
				Position               = UDim2.new(0.1, 0, 0.75, 0);
				Size                   = UDim2.new(0.8, 0, 0.1, 0);
			};
			Make &apos;Frame&apos; {
				ZIndex                 = Configuration.ZIndex;
				Archivable             = false;
				BorderSizePixel        = 0;
				BackgroundTransparency = Configuration.DefaultTransparency;
				BackgroundColor3       = Configuration.Color;
				Position               = UDim2.new(0.8, 0, 0.45, 0);
				Size                   = UDim2.new(0.1, 0, 0.3, 0);
			};
			Make &apos;Frame&apos; {
				ZIndex                 = Configuration.ZIndex;
				Archivable             = false;
				BorderSizePixel        = 0;
				BackgroundTransparency = Configuration.DefaultTransparency;
				BackgroundColor3       = Configuration.Color;
				Position               = UDim2.new(0.1, 0, 0.45, 0);
				Size                   = UDim2.new(0.1, 0, 0.3, 0);
			};
		};
	}
	Button.Gui = CollapseButton
	
	function Button.SetState(DoShowMaximize)
		-- Updates the state and updatess accordingly.

		State = DoShowMaximize;
		if DoShowMaximize then
			CollapseButton.Minimize.Visible = false;
			CollapseButton.Maximize.Visible = true;
		else
			CollapseButton.Minimize.Visible = true;
			CollapseButton.Maximize.Visible = false;
		end
	end
	
	function Button.GetState()
		-- @return The current displayed state of the button.
		return State;
	end
	
	Button.SetState(State);
	
	if Configuration.DoAnimateOnOver then
		-- Setup animation events.

		CollapseButton.MouseEnter:connect(function()
			for _, Item in pairs(CollapseButton.Maximize:GetChildren()) do
				qGUI.TweenTransparency(Item, {BackgroundTransparency = Configuration.OnOverTransparency}, Configuration.TransparencyChangeTime, true)
			end
			qGUI.TweenTransparency(CollapseButton.Minimize, {BackgroundTransparency = Configuration.OnOverTransparency}, Configuration.TransparencyChangeTime, true)
		end)
		CollapseButton.MouseLeave:connect(function()
			for _, Item in pairs(CollapseButton.Maximize:GetChildren()) do
				qGUI.TweenTransparency(Item, {BackgroundTransparency = Configuration.DefaultTransparency}, Configuration.TransparencyChangeTime, true)
			end
			qGUI.TweenTransparency(CollapseButton.Minimize, {BackgroundTransparency = Configuration.DefaultTransparency}, Configuration.TransparencyChangeTime, true)
		end)
	end
	
	return Button;
end

local MakePercentFilledImage = Class(function(PercentFilledImage, ImageLabel, FullIcon, Axis, Inverse)
	--- Makes a &apos;percent&apos; filled object that displays an image based on how much it&apos;s filled up.
	-- @param ImageLabel the image label used when filling it. Should contain the &quot;Empty&quot; icon.
	-- @param FullIcon the icon when it&apos;s full. Asset URL.
	-- @param Axis the axis of which to operate. 
	-- @param Inverse should Default is start hiding from left to right, and up to down, 
	--        depending on axix. So at 75% full, the 25% not displayed would be on the right, or at the top or left.
	--        This param, if true, will inverse that. 

	-- Used with hearts, et. cetera. Really only used here so far. May be moved to a seperate system later.

	Inverse = Inverse or false;
	Inverse = Axis or &apos;Y&apos;

	local CurrentPercent = 1; -- readonly
	PercentFilledImage.Gui = ImageLabel;

	local RenderFrame = Make &apos;Frame&apos; {
		Archivable             = false;
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		ClipsDescendants       = true;
		Name                   = &quot;DisplayHidePercent&quot;;
		Position               = UDim2.new(0, 0, 0, 0);
		Size                   = UDim2.new(1, 0, 1, 0);
		Visible                = true;
		ZIndex                 = ImageLabel.ZIndex;
	}

	local FullIcon = Make &apos;ImageLabel&apos; {
		Archivable             = false;
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		ClipsDescendants       = true;
		Image                  = FullImage;
		Name                   = &quot;FullImage&quot;;
		Position               = UDim2.new(0, 0, 0, 0);
		Size                   = UDim2.new(1, 0, 1, 0);
		Visible                = true;
		ZIndex                 = ImageLabel.ZIndex;
	}

	local function Update()
		-- Used to update rendering. Automatically called on Change. 
		-- @post updating is fixed. 

		if Axis == &apos;Y&apos; then
			RenderFrame.Size = UDim2.new(CurrentPercent, 0, 1, 0)
			if Inverse then
				FullIcon.Position = UDim2.new(0, 0, 0, 0);
			else
				FullIcon.Size = UDim2.new(1/CurrentPercent, 0, 1, 0)
				FullIcon.Position = UDim2.new(1 - (1/CurrentPercent), 0, 1, 0) 
			end
		else
			RenderFrame.Size = UDim2.new(1, 0, CurrentPercent, 0)
			if Inverse then
				FullIcon.Size = UDim2.new(1, 0, 1/CurrentPercent, 0)
				FullIcon.Position = UDim2.new(1, 0, 1 - (1/CurrentPercent), 0) 
			else
				FullIcon.Position = UDim2.new(0, 0, 0, 0);
			end
		end
	end
	PercentFilledImage.Update = Update;
	PercentFilledImage.update = Update;

	local function SetPercent(Percent)
		--- Set&apos;s the percent and updates teh GUI. 
		-- @param Percent a number from 0 to 1. 1 is completely full, 0 is hidden/empty.
		-- @post percent is done, and GUI is updated accordingly. 

		CurrentPercent = Percent
		Update()
	end
	PercentFilledImage.SetPercent = SetPercent
	PercentFilledImage.setPercent = SetPercent

	local function GetCurrentPercent()
		--- Return&apos;st he current percent

		return CurrentPercent
	end
	PercentFilledImage.GetCurrentPercent = GetCurrentPercent
	PercentFilledImage.getCurrentPercent =GetCurrentPercent

	local function Destroy()
		--- Destroy&apos;s and garbage collects it.
		-- @post completely GC

		for Index, Value in pairs(PercentFilledImage) do
			PercentFilledImage[Index] = nil;
		end
	end
	RenderFrame:Destroy()
	PercentFilledImage.Destroy = Destroy

	Update()
end)
lib.MakePercentFilledImage = MakePercentFilledImage
lib.makePercentFilledImage = MakePercentFilledImage

------------------------
-- MAIN CLASS SYSTEMS --
------------------------
--[[
Change Log
- Added SelectionChanged event.

--]]
local MakeBoxSelection = Class(function(BoxSelection, Box2DInterface)
	-- Datastructure to handle the selection of items...
	-- @param Box2DInterface The Box2DInterface associated with the selection. The Box2DInterface will
	--                       be automatically created.

	-- Note that the selection service is based upon the render interface, not the items themselves.

	local Selected = {}
	local SelectedListCache -- Cache selection list.

	BoxSelection.SelectionAdded        = CreateSignalInternal() -- When a single new item is selected. Will fire many times relative to
	                                           -- SelectionGroupAdded&apos;s firing rate.
	BoxSelection.SelectionGroupAdded   = CreateSignalInternal() -- When a group is added. Cut down on calcuations..
	BoxSelection.SelectionRemoved      = CreateSignalInternal() -- Like above, but when an item is unselected. 
	BoxSelection.SelectionGroupRemoved = CreateSignalInternal() -- Like above, but when an item is unselected. 
	
	BoxSelection.SelectionChanged      = CreateSignalInternal() -- This one is fired when the counts inside of the selection change.
	-- Also fired when group events fires.

	-- Note that firing is done via outside items of the class too....

	local function Select(self, ...)
		-- Select&apos;s an object, if it can be selected.
		-- @pre Item is a Box2DRenderItem

		-- Note, this isn&apos;t selecting items, but rather, selecting visible interfaces. This means unselect must
		-- reference Item.Interfaces.Box2DInventory.BoxInventoryRender

		SelectedListCache = nil; -- Clear Cache, selection has changed.
		local ToSelect = {...}
		local SelectedList = {}
		for _, Box2DRenderItem in pairs(ToSelect) do
			assert(Box2DRenderItem.IsBox2DRenderItem, &quot;Box2DRenderItem.IsBox2DRenderItem == &quot;..tostring(Box2DRenderItem.IsBox2DRenderItem)..&quot;, cannot select none Box2DRenderItem&quot;)
			
			if not Box2DRenderItem.Selected then
				Box2DRenderItem.Selected = true;

				SelectedList[#SelectedList+1] = Box2DRenderItem;
				table.insert(Selected, Box2DRenderItem);

				Box2DRenderItem.ShowSelection()
				BoxSelection.SelectionAdded:fire(Item)
				--print(&quot;[BoxSelection] - Selected Item&quot;)
			else
				print(&quot;[BoxSelection][Select] - Item already selected, cannot reselect&quot;)
			end
		end
		if #SelectedList &gt;= 1 then
			BoxSelection.SelectionGroupAdded:fire(SelectedList)
			BoxSelection.SelectionChanged:fire()
		end
	end
	BoxSelection.Select = Select;
	BoxSelection.Select = Select;

	local function IsSelected(Box2DRenderItem)
		return Box2DRenderItem.Selected
	end
	BoxSelection.IsSelected = IsSelected;
	BoxSelection.isSelected = IsSelected;--]]

	local function Unselect(self, ...)
		-- Unselects items
		-- @pre Item has property &quot;Render&quot; which is a Box2DRenderItem

		-- Note, this isn&apos;t selecting items, but rather, selecting visible interfaces. This means unselect must
		-- reference Item.Interfaces.Box2DInventory.BoxInventoryRender

		SelectedListCache = nil; -- Clear Cache, selection has changed.
		local ToUnselect = {...}
		local UnselectedItems = {}
		for _, Box2DRenderItem in pairs(ToUnselect) do
			assert(Box2DRenderItem.IsBox2DRenderItem, &quot;Box2DRenderItem.IsBox2DRenderItem == &quot;..tostring(Box2DRenderItem.IsBox2DRenderItem)..&quot;, cannot select none Box2DRenderItem&quot;)
			
			if Box2DRenderItem.Selected then
				Box2DRenderItem.Selected = false;
				BoxSelection.SelectionRemoved:fire(Box2DRenderItem)

				UnselectedItems[#UnselectedItems+1] = Box2DRenderItem; -- Add for the SelectionGroupRemoved event.

				-- Safely remove, index backwards.
				for Index = #Selected, 1, -1 do
					if Selected[Index] == Box2DRenderItem then
						table.remove(Selected, Index)
					end
				end

				Box2DRenderItem.HideSelection()
			else
				print(&quot;[BoxSelection][Unselect] - Item not selected in the first place, can&apos;t unselect&quot;)
			end
		end
		if #UnselectedItems &gt;= 1 then
			BoxSelection.SelectionGroupRemoved:fire(UnselectedItems)
			BoxSelection.SelectionChanged:fire()
		end
	end
	BoxSelection.Unselect = Unselect
	BoxSelection.unselect = Unselect

	local function GetSelection()
		-- Return&apos;s the actual items selected. Kind of expensive?
		if not SelectedListCache then
			local SelectedList = {}

			for _, Box2DRenderItem in pairs(Selected) do
				Table.Append(SelectedList, Box2DRenderItem.GetItems())
			end

			SelectedListCache = SelectedList;
			return SelectedList;
		else
			return SelectedListCache
		end
	end
	BoxSelection.GetSelection = GetSelection
	BoxSelection.getSelection = GetSelection

	local function GetSelectionClasses()
		return Selected;
	end
	BoxSelection.GetSelectionClasses = GetSelectionClasses
	BoxSelection.getSelectionClasses = GetSelectionClasses

	local function UnselectAll(self)
		-- Unselects all the items...

		BoxSelection:Unselect(unpack(Selected))
	end
	BoxSelection.UnselectAll = UnselectAll;
	BoxSelection.unselectAll = UnselectAll
end)

--[[ Change Log

February 13th, 2014
- Added Configuration argument

--]]
local MakeBox2DRenderItem = Class(function(Box2DRenderItem, Item, BoxInventoryRender, ItemColor, Configuration)
	--  Will probably be removed/added a lot.. Only one should exist per an item. Used internally. 

	-- Local variables
	local MouseOver = false;
	--local CurrentItemCount = 1; -- How many of this thing does it have.
	local CurrentItems = {} -- Store items in the inventory render thing.

	ItemColor = ItemColor or Color3.new(199/255, 244/255, 100/255) -- Let&apos;s use this pallet -- http://www.colourlovers.com/palette/1930/cheer_up_emo_kid

	-- Global variables.

	local Configuration = OverriddenConfiguration.new(Configuration, {
		DefaultTransparency           = 1; -- Normal transparency...
		SelectedTransparency          = 0.4; -- Transparency when the item is selected. 
		MouseOverTransparencyChange   = 0.8; -- Transparency when the mouse is over it. Inversed.
		TransparencyChangeTime        = 0.1; -- How long it takes to change the transparency. 
		ZIndex                        = BoxInventoryRender.Box2DInterface.Configuration.ZIndex; -- Takes over 3 spaces. 
		NameLabelPixelOffset          = 10; -- How far from the left it&apos;s offset.
		NameLabelPixelOffsetMouseDown = 15;
		CountLabelPixelOffset         = 5;
		MouseDownChangeTime           = 0.2; -- For mouseDown animations.
		Height                        = 40;
		CheckmarkIconSize             = 20; -- In pixels
		GridSizeIconSize              = 30;
		CheckmarkIcon                 = &quot;http://www.roblox.com/asset/?id=136822096&quot;; --&quot;http://www.roblox.com/asset/?id=136821278&quot;;
	})
	Configuration.CurrentTransparency = Configuration.DefaultTransparency

	-- Start rendering. 
	local Gui = Make &apos;ImageButton&apos; { -- MainGui
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Name                   = &quot;ItemButton&quot;..Item.ClassName;
		Size                   = UDim2.new(1, 0, 0, Configuration.Height);
		Visible                = true;
		ZIndex                 = Configuration.ZIndex + 2;
		Archivable             = false;
	}
	Box2DRenderItem.Gui = Gui;

	local Container = Make &apos;Frame&apos; { -- Container GUI
		Archivable             = false;
		BackgroundColor3       = Color3.new(1, 1, 1);
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Name                   = &quot;Container&quot;;
		Parent                 = Gui;
		Size                   = UDim2.new(1, 0, 1, 0);
		Visible                = true;
		ZIndex                 = Configuration.ZIndex + 1;
	}

	local MouseOverCover = Make &apos;Frame&apos; {
		Archivable             = false;
		BackgroundColor3       = Color3.new(1, 1, 1);
		BackgroundTransparency = Configuration.MouseOverTransparencyChange;
		BorderSizePixel        = 0;
		Name                   = &quot;Cover&quot;;
		Parent                 = Gui;
		Size                   = UDim2.new(1, 0, 1, 0);
		Visible                = true;
		ZIndex                 = Configuration.ZIndex + 1;
	}

	local CheckmarkIcon = Make &apos;ImageLabel&apos; {
		Archivable             = false;
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Name                   = &quot;CheckmarkIcon&quot;;
		Parent                 = Container;
		Size                   = UDim2.new(0, Configuration.CheckmarkIconSize, 0, Configuration.CheckmarkIconSize);
		Visible                = false;
		Image                  = Configuration.CheckmarkIcon;
		ZIndex                 = Configuration.ZIndex + 2;
	}

	local NameLabel = Make &apos;TextLabel&apos; {
		Archivable             = false;
		BackgroundColor3       = Color3.new(0, 0, 0);
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Font                   = &quot;Arial&quot;;
		FontSize               = &quot;Size14&quot;;
		Name                   = &quot;NameLabel&quot;;
		Parent                 = Container;
		Position               = UDim2.new(0, Configuration.NameLabelPixelOffset, 0, 0);
		Size                   = UDim2.new(1, -Configuration.NameLabelPixelOffset, 0, 40);
		Text                   = Item.ClassName;
		TextColor3             = Color3.new(1, 1, 1);
		TextStrokeTransparency = 1;
		TextTransparency       = 1;
		TextXAlignment         = &quot;Left&quot;;
		TextYAlignment         = &quot;Center&quot;;
		Visible                = true;
		ZIndex                 = Configuration.ZIndex + 1;
	}

	local CountLabel = Make &apos;TextLabel&apos; {
		Archivable             = false;
		BackgroundColor3       = Color3.new(0, 0, 0);
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Font                   = &quot;Arial&quot;;
		FontSize               = &quot;Size14&quot;;
		Name                   = &quot;CountLabel&quot;;
		Parent                 = Container;
		--Position               = UDim2.new(0, NameLabel.TextBounds.X + Configuration.CountLabelPixelOffset + Configuration.NameLabelPixelOffset, 0, 0);
		--Size                   = UDim2.new(1, -(NameLabel.TextBounds.X + Configuration.CountLabelPixelOffset + Configuration.NameLabelPixelOffset), 0, 40);
		Text                   = &quot;// 1&quot;;
		TextColor3             = ItemColor;
		TextStrokeTransparency = 1;
		TextTransparency       = 1;
		TextXAlignment         = &quot;Left&quot;;
		TextYAlignment         = &quot;Center&quot;;
		Visible                = false;
		ZIndex                 = Configuration.ZIndex + 1;
	}

	--assert(Item.Interfaces.BoxInventory.CrateData.GridSize ~= nil, &quot;Item.Interfaces.BoxInventory.GridSize is nil&quot;)
	local SizeIcon                    = RenderSizeIcon(Configuration.GridSizeIconSize, (BoxInventoryRender.Inventory.LargestGridSize + 1) - Item.Interfaces.BoxInventory.CrateData.GridSize, ItemColor, Configuration.ZIndex + 1)
	SizeIcon.Parent                   = Container
	SizeIcon.Position                 = UDim2.new(1, -(Configuration.GridSizeIconSize + ((Configuration.Height - Configuration.GridSizeIconSize)/2)), 0, 5);
	Box2DRenderItem.YRenderHeight     = Configuration.Height;
	
	-- READ ONLY VALUES --
	Box2DRenderItem.IsBox2DRenderItem = true; -- For selection service debug
	--Box2DRenderItem.BoxInventory      = BoxInventoryRender.BoxInventory -- The active inventory that this is associated with.
	Box2DRenderItem.RenderedClassName = Item.ClassName -- Class name of the item being rendered/represented.

	Box2DRenderItem.Selected = false;
	local MouseDown = false;

	local function Update()
		--- Updates rendering, YRenderHeight;

		Box2DRenderItem.YRenderHeight = Configuration.Height;
		--[[if MouseOver then
			if Container.BackgroundTransparency ~= Configuration.CurrentTransparency + Configuration.MouseOverTransparencyChange then
				qGUI.TweenTransparency(Container, {BackgroundTransparency = Configuration.CurrentTransparency + Configuration.MouseOverTransparencyChange}, Configuration.TransparencyChangeTime, true)
			end
		else
			if Container.BackgroundTransparency ~= Configuration.CurrentTransparency then
				qGUI.TweenTransparency(Container, {BackgroundTransparency = Configuration.CurrentTransparency}, Configuration.TransparencyChangeTime, true)
			end
		end--]]
		if not MouseDown then -- Otherwise MouseDown will handle it.
			MouseOverCover.Visible = MouseOver
		end

		if Selected then
			qGUI.TweenTransparency(Container, {BackgroundTransparency = Configuration.CurrentTransparency - Configuration.SelectedTransparency}, Configuration.TransparencyChangeTime, true)
		else
			qGUI.TweenTransparency(Container, {BackgroundTransparency = Configuration.CurrentTransparency}, Configuration.TransparencyChangeTime, true)
		end
	end
	Box2DRenderItem.Update = Update;
	Box2DRenderItem.update = Update

	local function ShowSelection()
		--- Renders as if it was selected. 

		print(&quot;[BoxSelection] - Showing selection&quot;)
		--Configuration.CurrentTransparency = Configuration.SelectedTransparency
		--Selected = true; -- Handled by BoxSelection
		CheckmarkIcon.Visible = true;
		Update()

	end
	Box2DRenderItem.ShowSelection = ShowSelection;
	Box2DRenderItem.showSelection = ShowSelection;

	local function HideSelection()
		--- Renders as if it was not selected. 

		--Configuration.CurrentTransparency = Configuration.DefaultTransparency
		--Selected = false; -- Handled by BoxSelection
		CheckmarkIcon.Visible = false;
		Update()
	end
	Box2DRenderItem.HideSelection = HideSelection;
	Box2DRenderItem.hideSelection = HideSelection;

	local function AnimateShow(DoSetPosition, TimePlay)
		-- Makes it show up coolio... 
		-- @param DoSetPosition if you want the animation to set the position to be at -1.

		TimePlay = TimePlay or 0.25
		if DoSetPosition then
			Container.Position = UDim2.new(-1, 0, 0, 0);
		end
		qGUI.TweenTransparency(NameLabel, {TextTransparency = 0}, TimePlay, true)
		qGUI.TweenTransparency(CountLabel, {TextTransparency = 0}, TimePlay, true)
		--Container.BackgroundTransparency = 1;
		--Update() -- Make fancy transparency animation... :D
		Container:TweenPosition(UDim2.new(0, 0, 0, 0), &quot;Out&quot;, &quot;Quart&quot;, TimePlay, true)
	end
	Box2DRenderItem.AnimateShow = AnimateShow
	Box2DRenderItem.animateShow = AnimateShow

	local function AnimateHide(TimePlay)
		-- HIdes the GUI, animates it.

		TimePlay = TimePlay or 0.25
		Configuration.CurrentTransparency = 1;
		Container:TweenPosition(UDim2.new(-1, 0, 0, 0), &quot;In&quot;, &quot;Quart&quot;, TimePlay, true)
		qGUI.TweenTransparency(NameLabel, {TextTransparency = 1}, TimePlay, true)
		qGUI.TweenTransparency(CountLabel, {TextTransparency = 1}, TimePlay, true)
	end
	Box2DRenderItem.AnimateHide = AnimateHide;
	Box2DRenderItem.animateHide = AnimateHide;

	local function GetItemCountPosition()
		-- Return&apos;s the position that the itemCount is suppose to be at. Since this varies a lot... well, here we are

		if MouseDown then
			return UDim2.new(0, NameLabel.TextBounds.X + Configuration.CountLabelPixelOffset + Configuration.NameLabelPixelOffset, 0, 0);
		else
			return UDim2.new(0, NameLabel.TextBounds.X + Configuration.NameLabelPixelOffsetMouseDown + Configuration.NameLabelPixelOffset, 0, 0);
		end
	end

	local function Select()
		-- Selects the item. Just a simplification.

		BoxInventoryRender.Box2DInterface.BoxSelection:Select(Box2DRenderItem)
	end
	Box2DRenderItem.Select = Select
	Box2DRenderItem.select = Select

	local function Unselect()
		-- Unselects the item. Just a simplification.

		BoxInventoryRender.Box2DInterface.BoxSelection:Unselect(Box2DRenderItem)
	end
	Box2DRenderItem.Unselect = Unselect
	Box2DRenderItem.unselect = Unselect

	local function GetCurrentItemCount()
		-- Return&apos;s the Current item count being rendered

		return #CurrentItems
	end
	Box2DRenderItem.GetCurrentItemCount = GetCurrentItemCount
	Box2DRenderItem.getCurrentItemCount = GetCurrentItemCount

	local function UpdateItemCount()
		-- Updates rendering/item count
		-- TODO: Animate better

		local CurrentItemCount = GetCurrentItemCount()

		CountLabel.Text = &quot;// &quot;..CurrentItemCount
		if CurrentItemCount &gt; 1 then
			CountLabel.Visible = true;
		else
			CountLabel.Visible = false;
		end
		CountLabel.Size = UDim2.new(1, -(NameLabel.TextBounds.X + Configuration.CountLabelPixelOffset + Configuration.NameLabelPixelOffset), 0, 40);
		CountLabel.Position = GetItemCountPosition()
	end

	local function AddItemToSlot(Item)
		--- Add&apos;s an item into the slot. Called automatically with the first item given.

		CurrentItems[#CurrentItems+1] = Item;
		UpdateItemCount()

		-- Update selection change, so the option modules change. Yes, it&apos;s this complicated.
		BoxInventoryRender.Box2DInterface.BoxSelection.SelectionChanged:fire()
	end
	Box2DRenderItem.AddItemToSlot = AddItemToSlot;
	Box2DRenderItem.addItemToSlot = AddItemToSlot

	local function GetItemIndex(Item)
		--- Return&apos;s an item&apos;s index in the CurrentItem&apos;s list
		-- @param Item The item to find the index of
		-- @pre The item is in the list
		-- @return The item&apos;s index

		for Index, ItemInList in pairs(CurrentItems) do
			if ItemInList.UID == Item.UID then
				return Index
			end
		end
		return nil;
	end
	Box2DRenderItem.GetItemIndex = GetItemIndex
	Box2DRenderItem.getItemIndex = GetItemIndex

	local function RemoveItemFromSlot(Item)
		--- Used internally to remove an item from the slot.
		-- @pre The item is in the list
		-- @param Item the item to remove
		-- @return The item removed
		-- Kind of expensive

		local ItemIndex = GetItemIndex(Item)
		if ItemIndex then
			local Removed = table.remove(CurrentItems, ItemIndex)
			UpdateItemCount()

			-- Update selection change, so the option modules change. Panic. Now.
			BoxInventoryRender.Box2DInterface.BoxSelection.SelectionChanged:fire()
			return Removed
		else
			error(&quot;[BoxInventoryRender][RemoveItemFromSlot] - ItemIndex could not be identified, the item is not in the slot.&quot;)
			return nil
		end
		
	end
	Box2DRenderItem.RemoveItemFromSlot = RemoveItemFromSlot
	Box2DRenderItem.removeItemFromSlot = RemoveItemFromSlot

	local function GetLastItem()
		-- Return&apos;s the last item in the list of items

		return CurrentItems[#CurrentItems]
	end
	Box2DRenderItem.GetLastItem = GetLastItem
	Box2DRenderItem.getLastItem = GetLastItem

	local function GetItems()
		-- Return&apos;s a table of all the items in the inventory

		return Table.Copy(CurrentItems)
	end
	Box2DRenderItem.GetItems = GetItems
	Box2DRenderItem.getItems = GetItems

	local function GetRawItems()
		-- Returns&apos; the raw currentItems table, which should not be modified.

		return CurrentItems;
	end
	Box2DRenderItem.GetRawItems = GetRawItems
	Box2DRenderItem.getRawItems = GetRawItems

	local function GetItemIndex(Item)
		-- Get&apos;s an item&apos;s index in the list
		-- @return The item&apos;s index, if it&apos;s in the list. Otherwise, return&apos;s nil.

		for Index, ItemInList in pairs(CurrentItems) do
			if ItemInList == Item then
				return Index;
			end
		end

		return nil;
	end
	Box2DRenderItem.GetItemIndex = GetItemIndex;
	Box2DRenderItem.getItemIndex = GetItemIndex;

	local function Destroy()
		--- Destroy&apos;s the object for GC. 
		-- @post the object is gone, and can be GCed. Item, if it was selected, will be disselected. 
		-- @pre There are no items in the list
		-- @return If it is successfully destroyed.

		if GetCurrentItemCount() &gt; 0 then
			error(&quot;[BoxInventoryRender] - Cannot destroy, There are still &quot;..GetCurrentItemCount()..&quot; item(s) in this renderthingy&quot;)
			return false;
		else
			if BoxInventoryRender.Box2DInterface.BoxSelection.IsSelected(Item) then
				BoxInventoryRender.Box2DInterface.BoxSelection:Unselect(Item);
			end
			BoxInventoryRender.EventStorage[Item.ClassName] = nil
			Gui:Destroy()
			for Index, Value in pairs(Box2DRenderItem) do
				Box2DRenderItem[Index] = nil;
			end
			return true;
		end
	end
	Box2DRenderItem.Destroy = Destroy;
	Box2DRenderItem.destroy = Destroy;

	local function MouseDownUpdate()
		-- Updates the renderer when the mouse goes down.
		if not MouseDown then
			MouseDown = true;
			--NameLabel.FontSize = &quot;Size18&quot;;
			NameLabel:TweenPosition(UDim2.new(0, Configuration.NameLabelPixelOffsetMouseDown, 0, 0), &quot;Out&quot;, &quot;Sine&quot;, Configuration.MouseDownChangeTime, true)
			CountLabel:TweenPosition(GetItemCountPosition(), &quot;Out&quot;, &quot;Sine&quot;, Configuration.MouseDownChangeTime, true);
		end
	end

	local function MouseUpUpdate()
		-- Updates the render when the mouse is up.
		if MouseDown then
			MouseDown = false;
			--NameLabel.FontSize = &quot;Size14&quot;;
			NameLabel:TweenPosition(UDim2.new(0, Configuration.NameLabelPixelOffset, 0, 0), &quot;In&quot;, &quot;Sine&quot;, Configuration.MouseDownChangeTime, true)
			CountLabel:TweenPosition(GetItemCountPosition(), &quot;In&quot;, &quot;Sine&quot;, Configuration.MouseDownChangeTime, true);
			if not MouseOver then -- Otherwise MouseOver will handle it.
				MouseOverCover.Visible = false;
			end
		end
	end

	-- Connect events --
	BoxInventoryRender.EventStorage[Item.ClassName].MouseEnter = Gui.MouseEnter:connect(function()
		MouseOver = true
		Update()
	end)

	BoxInventoryRender.EventStorage[Item.ClassName].MouseLeave = Gui.MouseLeave:connect(function()
		MouseOver = false
		Update()
	end)

	BoxInventoryRender.EventStorage[Item.ClassName].MouseButton1Down = Gui.MouseButton1Down:connect(function()
		MouseDownUpdate()
	end)

	BoxInventoryRender.EventStorage[Item.ClassName].MouseButton1Up = Gui.MouseButton1Up:connect(function()
		MouseUpUpdate()
	end)

	BoxInventoryRender.EventStorage[Item.ClassName].Button1Up = BoxInventoryRender.Box2DInterface.Mouse.Button1Up:connect(function()
		MouseUpUpdate()
	end)

	AddItemToSlot(Item)
	UpdateItemCount()
	--Update()
end)

--[[
Change Log

February 13th, 2014
- Fixed problem with RenderFrame leaving some frames visible.

--]]
local MakeInventoryOptionModule = Class(function(InventoryOptionModule, Name, OptionSystem, ShowCallback)
	--- An option module that can be assigned to specific types of inventories.  Groups options, such as &quot;Jetson&quot; and &quot;Destroy&quot; I guess
	-- Can be collapsed.
	-- @param Name The name of the option group is given. Will be rendered in the options.
	-- @param ShowCallback Functon ShowCallback(InventoryOptionModule) returns true or false depending on if the inventoryoptionmodele should
	--                     be rendered. It will also fail to render if the number of options available to be shown is zero. However, some modules
	--                     such as a shop probably shouldn&apos;t be shown at all. 
	--                     
	--                     This should be used to prevent extra calcutions from occuring, such as when no item is selected for a valid inventory.

	-- Configuration --
	local Configuration = OptionSystem.Configuration
	InventoryOptionModule.Configuration = Configuration;
	InventoryOptionModule.Data = {} -- Store specific data.

	--print(&quot;OptionSystem: &quot;..tostring(OptionSystem)..&quot;; OptionSystem.Box2DInterface = &quot;..tostring(OptionSystem.Box2DInterface))

	--assert(OptionSystem.Box2DInterface ~= nil, &quot;OptionSystem.Box2DInterface == &quot;..tostring(OptionSystem.Box2DInterface))
	-- Render --
	local MainFrame = Make &apos;Frame&apos; {
		Archivable             = false;
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Name                   = &quot;InventoryOptionModule&quot;..Name;
		Parent                 = OptionSystem.Box2DInterface.ScreenGUI;
		Size                   = UDim2.new(0, Configuration.ColumnWidth, 0, Configuration.IndividualHeaderHeight);
		Visible                = true;
		ZIndex                 = Configuration.ZIndex;
	}
	InventoryOptionModule.Gui = MainFrame

	local RenderFrame = Make &apos;Frame&apos; { -- Contains the options.
		Archivable             = false;
		BackgroundColor3       = Color3.new(0, 0, 0);
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		ClipsDescendants       = true;
		Name                   = &quot;RenderFrame&quot;;
		Parent                 = MainFrame; -- Can be sketch. But tweening requires a parent. Also, title doesn&apos;t work without it.
		Position               = UDim2.new(0, 0, 0, Configuration.IndividualHeaderHeight);
		Size                   = UDim2.new(1, 0, 1, -Configuration.IndividualHeaderHeight);
		Visible                = true;
		ZIndex                 = Configuration.ZIndex;
	}

	-- Render the title frame
	local TitleFrame = MakeTitleFrame(
		MainFrame, 
		Name, 
		nil,
		Configuration.ZIndex, 
		Configuration.IndividualHeaderHeight
	);
	TitleFrame.Parent = MainFrame;
	TitleFrame.Position = UDim2.new(0, 0, 0, 0);

	-- Render the collapse button
	local CollapseButton = MakeCollapseButton(false, {
		ZIndex = Configuration.ZIndex;
	})
	CollapseButton.Gui.Parent = TitleFrame
	CollapseButton.Gui.Position = UDim2.new(1, -(CollapseButton.Gui.Size.X.Offset + 5), 0.5, -CollapseButton.Gui.Size.Y.Offset/2)

	-- Public Variables --
	InventoryOptionModule.OptionSystem         = OptionSystem
	InventoryOptionModule.CollapseStateChanged = CreateSignalInternal()
	InventoryOptionModule.YRenderHeight        = Configuration.IndividualHeaderHeight;
	
	InventoryOptionModule.XRenderWidth         = Configuration.ColumnWidth;
	InventoryOptionModule.Name                 = Name;
	InventoryOptionModule.ShowCallback         = ShowCallback 

	-- Private variables --
	local IsCollapsed = false;
	local OptionList = {} -- Contains all the &quot;options.&quot; that exist. Each can be customized, but contain a &quot;general framework&quot; 
	-- of expected variables, listed below

	-- Private Methods --
	--[[
		Option 
			Gui -- Will be positioned
			RenderHeightY -- How high of a size it will take up. 
			Shown = true/false -- Is it visible? 
			Update -- Updates rendering and settings
			OptionSystem -- The option system it&apos;s linked too
	--]]




	-- Public Methods --
	local function AddOption(Option)
		-- Adds an option to the list...
		table.insert(OptionList, Option);
		Option.Gui.Parent = RenderFrame;
		Option.OptionSystem = OptionSystem -- Make sure it can access the OptionSystem
	end
	InventoryOptionModule.AddOption = AddOption;
	InventoryOptionModule.addOption = AddOption

	local function Collapse()
		-- Collapses the option module

		IsCollapsed = true;
		InventoryOptionModule.CollapseStateChanged:fire()
	end
	InventoryOptionModule.Collapse = Collapse
	InventoryOptionModule.collapse = Collapse

	local function Uncollapse()
		-- ncollapes the option module

		IsCollapsed = false;
		InventoryOptionModule.CollapseStateChanged:fire()
	end
	InventoryOptionModule.Uncollapse = Uncollapse
	InventoryOptionModule.uncollapse = Uncollapse

	local function CheckIfShowable()
		--- Return&apos;s if the option module can be shown or not. Also updates the modules.
		-- ShowCallback does not have to exist.		
		
		if InventoryOptionModule.ShowCallback then
			if InventoryOptionModule:ShowCallback(OptionSystem.Box2DInterface) then
				local ShowCount = InventoryOptionModule.Update()
				return ShowCount &gt;= 1
			else
				return false;
			end
		else
			local ShowCount = InventoryOptionModule.Update()
			return ShowCount &gt;= 1
		end
	end
	InventoryOptionModule.CheckIfShowable = CheckIfShowable;
	InventoryOptionModule.checkIfShowable = CheckIfShowable;

	local function Update()
		--- Updates rendering, may redraw.
		-- @return Visible Number of visible?

		CollapseButton.SetState(IsCollapsed)

		local YHeight = 0;
		local ShowCount = 0;

		for _, Option in pairs(OptionList) do
			Option:Update(OptionSystem.Box2DInterface)

			if Option.Shown then
				if IsCollapsed then
					--Option.Gui.Visible = false;
				else
					Option.Gui.Position = UDim2.new(0, 0, 0, YHeight)
					--Option.Gui.Visible = true;
					YHeight = YHeight + Option.RenderHeightY
				end
				ShowCount = ShowCount + 1;
			end
		end
		InventoryOptionModule.RenderHeightY = YHeight;
		MainFrame.Size = UDim2.new(0, Configuration.ColumnWidth, 0, InventoryOptionModule.RenderHeightY)
		RenderFrame:TweenSize(UDim2.new(1, 0, 0, YHeight), &quot;Out&quot;, &quot;Sine&quot;, Configuration.TweenAnimationTime, true)
		return ShowCount;
	end
	InventoryOptionModule.Update = Update
	InventoryOptionModule.update = Update

	-- Connect events --
	CollapseButton.Gui.MouseButton1Click:connect(function()
		if IsCollapsed then
			Uncollapse()
		else
			Collapse()
		end
	end)
end)
lib.MakeInventoryOptionModule = MakeInventoryOptionModule
lib.makeInventoryOptionModule = MakeInventoryOptionModule

-- Utility Function --
local function GetCenterY(ScreenGui, RenderHeightY)
	--- Get&apos;s the Y.Offset factor of a screenGUI, and frame (withthe RenderHeightY given), 
	--- Used internally by the options module
	-- @return Number value that the UDim2Y should be set to

	local Height = ScreenGui.AbsoluteSize.Y;
	return (Height - RenderHeightY)/2
end


--[[
Change log

February 13th, 2014
- Set it so modules now render at the top, not centered.
--]]
local MakeOptionSystem = Class(function(OptionSystem, Box2DInterface)
	--- This handles options and stuff. This is basically how the player will interact with the inventory, so it
	--  deserves much documentation.

	-- The inventory is first RENDERED. Items in it based upon class name can be SELECTED. 
	-- Then the system automatically finds every single action that can be executed on this.
	-- This is what the OptionSystem is. 

	-- Options are catagorized into modules/catagories. Each module can be occluded or included per inventory based upon
	-- The &quot;ShowCallback&quot; argument. Each option can also be occluded or included based upon thier own &quot;Shown&quot; property (This property
	-- is to be changed during Update() to prevent over-calculation.).

	-- Each option has a Gui that will be positioned. This GUI will handle rendering, et cetera, and all that. This is suppose to be
	-- flexible, et cetera. 

	-- Gui should be 40 high. 

	--[[
		Option 
			Gui -- Will be positioned
			RenderHeightY -- How high of a size it will take up. 
			Shown = true/false -- Is it visible? 
			Update -- Updates rendering and settings
			OptionSystem -- The option system it&apos;s linked too
	--]]

	local OptionsSystemModules = {}

	-- Global Variables --
	OptionSystem.Box2DInterface = Box2DInterface
	assert(OptionSystem.Box2DInterface ~= nil, &quot;OptionSystem.Box2DInterface == &quot;..tostring(OptionSystem.Box2DInterface))

	OptionSystem.Configuration = {
		IndividualHeaderHeight = 40;
		ColumnWidth            = 250;
		ZIndex                 = 2;
		PaddingY               = 20; -- Padding on the top and the bottom for the topions.
		SpacingSize            = 30; -- Padding between each option;
		ColumnPaddingX         = 50; -- Padding between each column
		TweenAnimationTime     = 0.2; -- Universal animation time;
	}
	local Configuration = OptionSystem.Configuration
	local BoxSelection = Box2DInterface.BoxSelection

	local RenderFrame = Make &apos;Frame&apos; {
		Archivable             = false;
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Name                   = &quot;OptionSystemRenderFrame&quot;;
		Parent                 = OptionSystem.Box2DInterface.ScreenGUI;
		Size                   = UDim2.new(0, Configuration.ColumnWidth, 1, 0);
		Visible                = true;
		ZIndex                 = Configuration.ZIndex;
	}
	OptionSystem.Gui = RenderFrame


	-- Functions --
	local function AddModule(Module)
		--- Adds a module into the system

		OptionsSystemModules[Module.Name] = Module
		Module.Gui.Parent = RenderFrame

		-- Connect events.
		Module.CollapseStateChanged:connect(function()
			OptionSystem.Update()
		end)

		OptionSystem.Update() -- Update whenever a new module is added.
	end
	OptionSystem.AddModule = AddModule
	OptionSystem.addModule = AddModule

	local function Update()
		-- Updates the whol thing, relaigns columns 

		local MaxYHeight = Box2DInterface.ScreenGui.AbsoluteSize.Y
		MaxYHeight = MaxYHeight - (Configuration.PaddingY*2)

		local ColumnCount = 1;
		local CurrentRenderHeightY = Configuration.PaddingY*2;
		local CurrentOptionModulesInColumn = {}

		local function CheckifBranchToNewColumnAndExecute()
			-- Checks if a new column needs to be made, recenters the modulers
			-- If you have a really big modular, this kind of messes up, as far as I can think. I think it&apos;ll float over an extra one
			-- So... let&apos;s just not let that happen. Boo iphone users. 

			if ((CurrentRenderHeightY) &gt; MaxYHeight) then
				-- Recenter and switch to a new column

				local HeightY = OptionSystem.Configuration.PaddingY -- GetCenterY(Box2DInterface.ScreenGui, CurrentRenderHeightY)
				for Index, OptionModule in pairs(CurrentOptionModulesInColumn) do
					if Index &lt; #CurrentOptionModulesInColumn then -- We don&apos;t want the last one, it wraps around
						OptionModule.Gui.Position = UDim2.new(0, (ColumnCount - 1) * (Configuration.ColumnWidth + Configuration.ColumnPaddingX), 0, HeightY)
						HeightY = HeightY + OptionModule.RenderHeightY + Configuration.SpacingSize
					end
				end

				CurrentRenderHeightY = Configuration.PaddingY*2; -- Reset..
				ColumnCount = ColumnCount + 1;
				CurrentOptionModulesInColumn = {CurrentOptionModulesInColumn[#CurrentOptionModulesInColumn]} -- Include the last one
			end
		end

		for _, OptionModule in pairs(OptionsSystemModules) do
			OptionModule.Update(Box2DInterface.BoxSelection)
			if OptionModule.CheckIfShowable() then
				OptionModule.Gui.Visible = true;
				table.insert(CurrentOptionModulesInColumn, OptionModule)
				CurrentRenderHeightY = CurrentRenderHeightY + OptionModule.RenderHeightY + Configuration.SpacingSize
				CheckifBranchToNewColumnAndExecute()
			else
				OptionModule.Gui.Visible = false;
			end
		end

		if #CurrentOptionModulesInColumn &gt;= 1 then
			-- Finish rendering up the rest of them, but only if there&apos;s something left to render. #CurrentOptionModulesInColumn is generally &gt; 0, except when 0 options exist.

			local HeightY = OptionSystem.Configuration.PaddingY -- GetCenterY(Box2DInterface.ScreenGui, CurrentRenderHeightY)

			for Index, OptionModule in pairs(CurrentOptionModulesInColumn) do
				local NewPosition = UDim2.new(0, (ColumnCount - 1) * (Configuration.ColumnWidth + Configuration.ColumnPaddingX), 0, HeightY)
				--OptionModule.Gui.Position = NewPosition
				OptionModule.Gui:TweenPosition(NewPosition, &quot;Out&quot;, &quot;Sine&quot;, Configuration.TweenAnimationTime, true);
				HeightY = HeightY + OptionModule.RenderHeightY + Configuration.SpacingSize
			end
		end
		RenderFrame.Size = UDim2.new(0, ColumnCount * (Configuration.ColumnWidth + Configuration.ColumnPaddingX) - Configuration.ColumnPaddingX, 1, 0);
	end
	OptionSystem.Update = Update
	OptionSystem.update = Update

	-- Connect events. Better is use groups so a ton of items selected at once doesn&apos;t lag.
	BoxSelection.SelectionChanged:connect(function()
		Update()
	end)
	-- BoxSelection.SelectionGroupRemoved:connect(function()
	-- 	Update()
	-- end)
end)


local MakeBoxInventoryRender = Class(function(BoxInventoryRender, Box2DInterface, BoxInventory)
	-- Render&apos;s itself in a frame, can be collapsed, et cetera. Represents a SINGLE inventory. 

	-- Represents a single inventory, which can be manipulated, et cetera. 
	-- @param Box2DRenderItem The Box2DRenderItem that the BoxInventoryRender will be represented in
	-- @param BoxInventory The inventory of which content&apos;s are being displayed

	local Configuration = Box2DInterface.Configuration;

	-- Render GUIs, this holds everything in it.
	local RenderFrame = Make &apos;Frame&apos; {
		Archivable             = false;
		BackgroundColor3       = Color3.new(0, 0, 0);
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		ClipsDescendants       = false;
		Name                   = &quot;InventoryRenderFrame&quot;;
		Parent                 = Box2DInterface.ContentContainer; -- Can be sketch. But tweening requires a parent. Also, title doesn&apos;t work without it.
		Position               = UDim2.new(0, 0, 0, 0);
		Size                   = UDim2.new(1, 0, 0, Configuration.IndividualHeaderHeight);
		Visible                = true;
		ZIndex                 = Box2DInterface.Configuration.ZIndex;
	}
	BoxInventoryRender.Gui = RenderFrame
	BoxInventoryRender.Inventory = BoxInventory

	-- Holds all the specific items in it.
	local ContentFrame = Make &apos;Frame&apos; {
		Archivable             = false;
		BackgroundColor3       = Color3.new(0, 0, 0);
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		ClipsDescendants       = true;
		Name                   = &quot;ContentFrame&quot;;
		Parent                 = RenderFrame;
		Position               = UDim2.new(0, 0, 0, Configuration.IndividualHeaderHeight);
		Size                   = UDim2.new(0, Configuration.ColumnWidth, 0, 0);
		Visible                = true;
		ZIndex                 = Box2DInterface.Configuration.ZIndex;
	}
	BoxInventoryRender.ContentFrame = ContentFrame

	-- Contains 2 states...
	local CollapseButton = MakeCollapseButton(false, {
		ZIndex = Configuration.ZIndex;
	}) -- Set the state to false, that is the whole thing is shown.
	-- Event&apos;s for button setup later. 
	
	local TitleFrame = MakeTitleFrame(
		RenderFrame, 
		BoxInventory.Name, 
		nil,--&quot;// subtitle&quot;,
		Configuration.ZIndex, 
		Configuration.IndividualHeaderHeight
	);
	TitleFrame.BackgroundTransparency = 0.7;
	TitleFrame.Parent = RenderFrame;
	TitleFrame.Position = UDim2.new(0, 0, 0, 0); 	

	CollapseButton.Gui.Parent = TitleFrame
	CollapseButton.Gui.Position = UDim2.new(1, -(CollapseButton.Gui.Size.X.Offset + 5), 0.5, -CollapseButton.Gui.Size.Y.Offset/2)
	--CollapseButton.Gui.BackgroundColor3 = Color3.new(0, 0, 0)

	-- Public variables
	BoxInventoryRender.Box2DInterface = Box2DInterface; -- Read only
	BoxInventoryRender.BoxInventory = BoxInventory	-- Read only
	BoxInventoryRender.CollapseStateChanged = CreateSignalInternal()
	local EventStorage = EventGroup.MakeEventGroup() -- Store Box2DRenderItem
	BoxInventoryRender.EventStorage = EventStorage

	EventStorage.CollapseButton.MouseEnter = CollapseButton.Gui.MouseEnter:connect(function()
		qGUI.TweenTransparency(CollapseButton.Gui, {BackgroundTransparency = 0.7;}, 0.1, true)
	end)

	EventStorage.CollapseButton.MouseLeave = CollapseButton.Gui.MouseLeave:connect(function()
		qGUI.TweenTransparency(CollapseButton.Gui, {BackgroundTransparency = 1;}, 0.1, true)
	end)

	-- Private variables
	local RenderHeightY = Box2DInterface.Configuration.IndividualHeaderHeight; -- Read only
	local IsCollapsed = false; 
	local HasContentToRender = false;

	local RenderHeightY = 0;

	local VisibleItems = {}

	-- Private Methods
	local function FindRenderInterface(ClassName)
		--- Used internally to find out if an item exists in the inventory already
		-- @param ClassName the Classname of the itemclass to find. 
		-- @return The item found, and if an item was found (bool)

		-- This is used because instead of making a new button for each item, it instead groups items by number.

		for Index, RenderInterface in pairs(VisibleItems) do
			if RenderInterface.ClassName == ClassName then
				return RenderInterface, Index, true
			end
		end
		return nil, nil, false
	end

	local function SortInventory(Mode)
		-- Sort&apos;s visible items. Default is &quot;alphabetical&quot;, which is currenlty the only option.
		-- Mode is the mode to sort by...

		table.sort(VisibleItems, function(ItemA, ItemB)
			return ItemA.ClassName &lt; ItemB.ClassName -- Sort by alphabet!
		end)
	end

	local function AddItems(Items)
		-- Used internally to add new items to the render. 
		-- @param Items A table full of ItemSystem items.

		-- Loop through each item and add it.
		for _, Item in pairs(Items) do
			-- print(&quot;[BoxInventoryRender] - Adding Item &quot;..Item.ClassName)
			local Interface = FindRenderInterface(Item.ClassName)
			if not Interface then
				Interface = {}
					
				Interface.Render = MakeBox2DRenderItem(Item, BoxInventoryRender, nil)
				Interface.ClassName = Item.ClassName

				BoxInventoryRender.EventStorage[Item.ClassName].MouseButton1Click = Interface.Render.Gui.MouseButton1Click:connect(function()
					-- Select! Yay!

					-- print(&quot;[BoxInventoryRender] - Item button clicked&quot;)
					if Interface.Render.Selected then
						Box2DInterface.BoxSelection:Unselect(Interface.Render);
					else
						Box2DInterface.BoxSelection:Select(Interface.Render);
					end
				end)

				Interface.Render.Gui.Parent = ContentFrame;
				Interface.Render.AnimateShow()

				Item.Interfaces[&quot;BoxInventoryRender&quot;] = Interface
				table.insert(VisibleItems, Interface)
				SortInventory()
			else
				Item.Interfaces[&quot;BoxInventoryRender&quot;] = Interface
				Interface.Render.AddItemToSlot(Item)
			end
		end
		BoxInventoryRender.Update()
	end

	local function RemoveItems(Items)
		-- Used internally to remove  items from the render.  Gets called whenever BoxInventory.ItemRemoved fires...

		-- @param Items A table full of ItemSystem items, with the BoxInventoryRender

		for _, Item in pairs(Items) do
			local RenderInterface, Index, DidFindInterface = FindRenderInterface(Item.ClassName) -- Get the render represetngint the item

			if DidFindInterface then
				RenderInterface.Render.RemoveItemFromSlot(Item) -- Update RenderInterface
				Item.Interfaces.BoxInventoryRender = nil; -- Cleanup RenderInterface

				if RenderInterface.Render.GetCurrentItemCount() &lt;= 0 then
					Box2DInterface.BoxSelection:Unselect(RenderInterface.Render)
					RenderInterface.Render:Destroy() -- Destroys the render interface, which is removed from the item
					-- by setting Item.Interfaces.BoxInventoryRender to nil below.

					table.remove(VisibleItems, Index) -- Clean out from VisibleItems...
				end
			else
				error(&quot;[BoxInventoryRender] - Item &apos;&quot; .. Item.ClassName ..&quot;&apos; does not exist in the InventoryRender system, cannot remove.&quot;)
			end
		end

		Box2DInterface.Update()
	end

	-- Public Methods --

	local UpdatePropertiesId = 0; -- Prevent override

	local function UpdateProperties()
		--- Updates BoxInventoryRender.RenderHeightY to the correct value. Also updates
		--  HasContentToRender and IsCollapsed
		-- Called by Update()
		local YHeight = 0;
		--[[ --Box2DInterface.Configuration.IndividualHeaderHeight;
		local LocalUpdatePropertiesId = UpdatePropertiesId + 1;
		UpdatePropertiesId = LocalUpdatePropertiesId;

		if not IsCollapsed then
			for _, Interface in pairs(VisibleItems) do
				Interface.Render.Update() -- Maybe disable if it&apos;s too inefficient?
				Interface.Render.Gui:TweenPosition(UDim2.new(0, 0, 0, YHeight), &quot;Out&quot;, &quot;Sine&quot;, Configuration.CollapseAnimateTime, true);
				YHeight = YHeight + Interface.Render.YRenderHeight;
			end
		else -- Hide if collapsed. 
			for _, Interface in pairs(VisibleItems) do
				for _, Interface in pairs(VisibleItems) do -- This can get messy. Fix later. 
					Interface.Render.Gui:TweenPosition(UDim2.new(0, 0, 0, 0), &quot;Out&quot;, &quot;Sine&quot;, Configuration.CollapseAnimateTime, true);
				end
			end
		end
		RenderHeightY = YHeight + Box2DInterface.Configuration.IndividualHeaderHeight;
		if RenderFrame.Size.Y.Offset &gt; RenderHeightY then
			delay(Configuration.CollapseAnimateTime, function()
				if UpdatePropertiesId == LocalUpdatePropertiesId then
					RenderFrame.Size = UDim2.new(1, 0, 0, RenderHeightY)
				end
			end)
		else
			RenderFrame.Size = UDim2.new(1, 0, 0, RenderHeightY)
		end--]]

		if not IsCollapsed then
			for _, Interface in pairs(VisibleItems) do
				Interface.Render.Update() -- Maybe disable if it&apos;s too inefficient?
				Interface.Render.Gui.Position = UDim2.new(0, 0, 0, YHeight) -- Position relative to the bottom. Animaiton
				YHeight = YHeight + Interface.Render.YRenderHeight;
			end
		end
		RenderHeightY = YHeight + Box2DInterface.Configuration.IndividualHeaderHeight
	end

	local function ResizeContentFrame(DoNotAnimate)
		-- Resizes the content frame based upon collapsed or not

		UpdateProperties()
		local Size = UDim2.new(1, 0, 0, RenderHeightY - Box2DInterface.Configuration.IndividualHeaderHeight)
		if DoNotAnimate then
			ContentFrame.Size = Size;
		else
			ContentFrame:TweenSize(Size, &quot;Out&quot;, &quot;Sine&quot;, Configuration.CollapseAnimateTime, true);
		end
	end

	local function Collapse()
		-- Collapses the inventory, and fires the event (Which then updates it)

		for _, Item in pairs(VisibleItems) do-- Unselect visible items... Make sure that we don&apos;t have any hidden selections.
			Box2DInterface.BoxSelection:Unselect(VisibleItems.Render)
		end 

		IsCollapsed = true;
		BoxInventoryRender.CollapseStateChanged:fire(IsCollapsed); -- Should fire Update()
		--ResizeContentFrame() -- Handled by event being fired
	end
	BoxInventoryRender.Collapse = Collapse;

	local function Uncollapse()
		-- Decollapses the inventory 
		IsCollapsed = false;
		BoxInventoryRender.CollapseStateChanged:fire(IsCollapsed); -- Should fire Update()
		--ResizeContentFrame() -- Handled by event being fired
	end
	BoxInventoryRender.Uncollapse = Uncollapse;

	local function Update()
		-- Redraw&apos;s and updates the render.

		--UpdateProperties() -- Handled by ResizeContentFrame()
		ResizeContentFrame()
		CollapseButton.SetState(IsCollapsed)
	end
	BoxInventoryRender.Update = Update;

	local function Destroy()
		-- Destroy&apos;s the render for GC.
		-- Not tested. 

		for _, Item in pairs(VisibleItems) do
			Box2DInterface.BoxSelection:Unselect(VisibleItems.Render) -- Unselect this thing
			Item.Interfaces.BoxInventoryRender.Render.Destroy()
		end

		EventStorage(&quot;Clear&quot;)

		RenderFrame:Destroy()
		for Index, Item in pairs(BoxInventoryRender) do
			BoxInventoryRender[Index] = nil;
		end
	end

	-- GET methods 

	function BoxInventoryRender.GetHasContentToRender()
		--- Return&apos;s if this class has any content to render.
		return HasContentToRender
	end
	function BoxInventoryRender.GetIsCollapsed()
		-- Return if this inventory is collapsed or not. 
		return IsCollapsed
	end
	function BoxInventoryRender.GetRenderHeightY()
		-- Return the RenderHeightY value 
		return RenderHeightY
	end

	-- Add initial items on creation. --
	AddItems(BoxInventory.GetListOfItems())

	BoxInventory.ItemAdded:connect(function(Item)
		AddItems({Item})
	end)

	BoxInventory.ItemRemoved:connect(function(Item)
		RemoveItems({Item})
	end)

	CollapseButton.Gui.MouseButton1Click:connect(function()
		if not CollapseButton.GetState() then
			Collapse()
		else
			Uncollapse()
		end
	end)

	ResizeContentFrame(true)
end)

--[[
Box2DInterface is the TOP LEVEL interface.

Change Log

February 13th, 2014
- Added &quot;Gui&quot; field pointing to MainFrame
- Made configuration use OverriddenConfiguration

--]]
local MakeBox2DInterface = Class(function(Box2DInterface, Mouse, ScreenGui, Configuration)
	--- Models and controls the Box2D rendering overall. Supports multiple inventories. 

	-- Configuration and settings
	Configuration = OverriddenConfiguration.new(Configuration, {
		Subtitle = &quot;// trade enterprise&quot;;
		Title    = &quot;Stock&quot;;
		Width    = 250;

		-- Rendering options
		ScrollbarWidth         = 7;
		ZIndex                 = 1; -- Index may go 2+ this, so range [1-8]
		IndividualHeaderHeight = 40; -- Per each inventory. 
		FooterHeight           = 80;
		CollapseAnimateTime    = 0.1; -- When collapsing inventory rendering. 
		OptionPanePaddingX     = 20; -- Padding between the inventory and the options
		CloseIconRegular       = &quot;http://www.roblox.com/asset/?id=139944727&quot;;
		CloseIconOver          = &quot;http://www.roblox.com/asset/?id=139944744&quot;;
		CloseButtonSize        = 30; -- Since it&apos;s a square, the length of one side.
		ToggleAnimationTime = 0.3; -- When toggling the inventory open or closed
	})

	Box2DInterface.Mouse = Mouse;

	-- Rendering --
	local MainFrame = Make &apos;Frame&apos; {
		BackgroundColor3       = Color3.new(0, 0, 0);
		BackgroundTransparency = 0.9;
		BorderSizePixel 	   = 0;
		Name                   = &quot;Box2DRender&quot;;
		Parent                 = ScreenGui;
		Position               = UDim2.new(0, 0, 0, 0);
		Size                   = UDim2.new(0, Configuration.Width, 1, 0);
		Visible                = true;
		ZIndex                 = Configuration.ZIndex;
		Archivable             = false;
	}
	Box2DInterface.Gui = MainFrame

	local ContentContainer = Make &apos;Frame&apos; {
		Archivable             = false;
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		ClipsDescendants       = true;
		Name                   = &quot;ContentContainer&quot;;
		Parent                 = MainFrame;
		Position               = UDim2.new(0, 0, 0, Configuration.IndividualHeaderHeight);
		Size                   = UDim2.new(1, 0, 1, -Configuration.IndividualHeaderHeight - Configuration.FooterHeight);
		Visible                = true;
		ZIndex                 = Configuration.ZIndex;
	}
	Box2DInterface.ContentContainer = ContentContainer

	local ContentFrame = Make &apos;Frame&apos; { -- Stuff goes in here. 
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Name                   = &quot;ContentFrame&quot;;
		Parent                 = ContentContainer;
		Position               = UDim2.new(0, 0, 0, 0);
		Size                   = UDim2.new(1, -Configuration.ScrollbarWidth, 1.5, 0);
		Visible                = true;
		ZIndex                 = Configuration.ZIndex;
		Archivable             = false;
	}

	local ScrollBarFrame = Make &apos;Frame&apos; { -- Stuff goes in here. 
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Name                   = &quot;ScrollBarFrame&quot;;
		Parent                 = MainFrame;
		Position               = UDim2.new(1, -Configuration.ScrollbarWidth, 0, 0);
		Size                   = UDim2.new(0, Configuration.ScrollbarWidth, 1, -Configuration.FooterHeight);
		Visible                = true;
		ZIndex                 = Configuration.ZIndex;
		Archivable             = false;
	}

	local HeaderFrame = MakeTitleFrame(MainFrame, Configuration.Title, Configuration.Subtitle, MainFrame.ZIndex, Configuration.IndividualHeaderHeight)
	HeaderFrame.Size  = UDim2.new(1, -Configuration.ScrollbarWidth, 0, Configuration.IndividualHeaderHeight)

	local CloseButtonOffset = (Configuration.IndividualHeaderHeight - Configuration.CloseButtonSize)/2
	local CloseButton = Make &apos;ImageButton&apos; {
		Archivable             = false;
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Image                  = Configuration.CloseIconRegular;
		Name                   = &quot;CloseButton&quot;;
		Parent                 = HeaderFrame;
		Position               = UDim2.new(1, -(CloseButtonOffset + Configuration.CloseButtonSize), 0, CloseButtonOffset);
		Size                   = UDim2.new(0, Configuration.CloseButtonSize, 0, Configuration.CloseButtonSize);
	}

	-- Properties
	Box2DInterface.Configuration = Configuration -- Should not be modified, technically read only.
	Box2DInterface.BoxSelection  = MakeBoxSelection(Box2DInterface)
	Box2DInterface.ScreenGui     = ScreenGui

	Box2DInterface.Opened = CreateSignal() -- Fires when ShowInterface() is called
	Box2DInterface.Closed = CreateSignal() -- Fires when HideInterface is called
	
	local OptionSystem = MakeOptionSystem(Box2DInterface)
	OptionSystem.Gui.Parent     = MainFrame
	OptionSystem.Gui.Position   = UDim2.new(0, Configuration.Width + Configuration.OptionPanePaddingX, 0, 0);
	Box2DInterface.OptionSystem = OptionSystem

	--assert(OptionSystem.Box2DInterface ~= nil, &quot;OptionSystem.Box2DInterface == &quot;..tostring(OptionSystem.Box2DInterface))

	-- Signals
	Box2DInterface.InventoryAdded = CreateSignalInternal();
	Box2DInterface.InventoryRemoved = CreateSignalInternal();

	local Scroller = ScrollBar.MakeScroller(ContentContainer, ContentFrame, ScreenGui, &apos;Y&apos;)
	local ScrollBar = Scroller:AddScrollBar(ScrollBarFrame)

	-- Local Properties (Private)
	local RenderedInventories = {}
	local UpdateEvents = EventGroup.MakeEventGroup()
	local InterfaceVisible = false; 

	-- Global Methods
	local function ShowInterface(DoNotAnimate)
		Box2DInterface.Opened:fire()
		InterfaceVisible = true;
		local Position = UDim2.new(0, 0, 0, 0)

		if DoNotAnimate then
			MainFrame.Position = Position;
		else
			MainFrame:TweenPosition(Position, &quot;Out&quot;, &quot;Quart&quot;, Configuration.ToggleAnimationTime, true)
		end
	end
	Box2DInterface.ShowInterface = ShowInterface;
	Box2DInterface.showInterface = ShowInterface

	local function HideInterface(DoNotAnimate)
		Box2DInterface.Closed:fire()
		InterfaceVisible = false;
		local Position = UDim2.new(0, -Configuration.Width, 0, 0)
		Box2DInterface.BoxSelection:UnselectAll()

		if DoNotAnimate then
			MainFrame.Position = Position;
		else
			MainFrame:TweenPosition(Position, &quot;In&quot;, &quot;Quart&quot;, Configuration.ToggleAnimationTime, true)
		end
	end
	Box2DInterface.HideInterface = HideInterface;
	Box2DInterface.hideInterface = HideInterface;

	local function ToggleInterface(DoNotAnimate)
		if InterfaceVisible then
			HideInterface(DoNotAnimate)
		else
			ShowInterface(DoNotAnimate)
		end
	end
	Box2DInterface.ToggleInterface = ToggleInterface;
	Box2DInterface.toggleInterface = ToggleInterface;

	local function Update(IsCollapseUpdate)
		--- Updates rendering and the children.
		-- @param [IsCollapseUpdate] Boolean, if this update is after a collapse.

		local YHeight = 0;
		for _, Interface in pairs(RenderedInventories) do
			local BoxInventoryRender = Interface;
			BoxInventoryRender.Update();
			local Position = UDim2.new(0, 0, 0, YHeight);

			if IsCollapseUpdate then
				BoxInventoryRender.Gui.Position = Position
			else
				BoxInventoryRender.Gui:TweenPosition(Position, &quot;Out&quot;, &quot;Sine&quot;, Configuration.CollapseAnimateTime, true);
			end

			YHeight = YHeight + BoxInventoryRender.GetRenderHeightY();
		end
		local Size = UDim2.new(1, -Configuration.ScrollbarWidth, 0, math.max(ContentContainer.AbsoluteSize.Y, YHeight))
		ContentFrame.Size = Size;
	end
	Box2DInterface.Update = Update
	Box2DInterface.update = Update

	local function AddClientInventory(ClientInventory)
		--- Displays ClientInventoryInterface to the world.  The actual inventory will be on the server.
		-- @param ClientInventory The ClientInventory to use. 

		local Interface = ClientInventory.Interfaces.BoxInventoryRender
		if not Interface then
			Interface            = MakeBoxInventoryRender(Box2DInterface, ClientInventory);
			Interface.Gui.Parent = ContentFrame;
		end
		table.insert(RenderedInventories, Interface)

		UpdateEvents[Box2DInterface].OnCollapse = Interface.CollapseStateChanged:connect(function()
			Update(true) -- Update the rendering to compensate. 
		end)

		Update()

		return Interface
	end
	Box2DInterface.AddClientInventory = AddClientInventory
	Box2DInterface.addClientInventory = AddClientInventory

	local function RemoveClientInventory(Index)
		--- Removes the inventory from the interface.

		RenderedInventories[Index].Destroy()
		table.remove(RenderedInventories, Index)
		UpdateEvents[Box2DInterface](&quot;Clear&quot;)
		UpdateEvents[Box2DInterface] = {}
	end
	Box2DInterface.RemoveClientInventory = RemoveClientInventory
	Box2DInterface.removeClientInventory = RemoveClientInventory

	-- Hook events and add updates -- 
	ContentContainer.Changed:connect(function(Property)
		if Property == &quot;AbsoluteSize&quot; then
			Update()
		end
	end)

	CloseButton.MouseEnter:connect(function()
		CloseButton.Image = Configuration.CloseIconOver;
	end)

	CloseButton.MouseLeave:connect(function()
		CloseButton.Image = Configuration.CloseIconRegular;
	end)

	CloseButton.MouseButton1Click:connect(function()
		ToggleInterface()
	end)

	HideInterface(true)
end)
lib.MakeBox2DInterface = MakeBox2DInterface;
lib.makeBox2DInterface = MakeBox2DInterface

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX20">
<Properties>
<string name="Name">InventoryOptionMaker</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local qGUI              = LoadCustomLibrary(&quot;qGUI&quot;)

-- InventoryOptionMaker.lua
-- @author Quenty


--[[ -- Change Log
February 13th, 2014
- Fixed glitch / problem with icon variables being overwritten

February 7th, 2014
- Removed BoxInventoryRender dependency
- Added change log

February 3rd, 2014
- Updated to work with NevermoreEngine
--]]
qSystems:Import(getfenv(0));

local lib = {}

local function MakeIconOptionBase(Name, Color, IconURL)
	-- Generates the basis for a button, to be modified later. Handles some Gui stuff like animations.

	local Configuration = {
		Height              = 40;
		Color               = Color or Color3.new(0.8, 0.8, 0.8);
		ZIndex              = 3;
		DefaultTransparency = 0.7; -- Normal backing transparency
		EnterTransparency   = 0.6; -- Transparency when a players mouse enters.
	}
	
	local XSpacing = 10;

	local Button = Make &apos;ImageButton&apos; {
		Archivable             = false;
		AutoButtonColor        = false;
		BackgroundColor3       = Color3.new(0, 0, 0);
		BackgroundTransparency = Configuration.DefaultTransparency;
		BorderSizePixel        = 0;
		ClipsDescendants       = false;
		Name                   = Name..&quot;Button&quot;;
		Position               = UDim2.new(0, 0, 0, 0);
		Size                   = UDim2.new(1, 0, 0, Configuration.Height);
		Visible                = true;
		ZIndex                 = Configuration.ZIndex + 1;
	}

	local Icon

	-- Generate icon if available.
	if IconURL then
		Icon = Make &apos;Frame&apos; {
			Archivable             = false;
			BackgroundColor3       = Configuration.Color;
			BackgroundTransparency = 1;
			BackgroundTransparency = 1;
			BorderSizePixel        = 0;
			Name                   = &quot;IconContainer&quot;;
			Parent                 = Button;
			Size                   = UDim2.new(0, Configuration.Height, 1, 0);
			Visible                = true;
			ZIndex                 = Button.ZIndex;
			Make &apos;ImageLabel&apos; {
				Archivable             = false;
				BackgroundTransparency = 1;
				BorderSizePixel        = 0;
				ZIndex                 = Button.ZIndex;
				Size                   = UDim2.new(1, 0, 1, 0);
				Visible                = true;
				Name                   = &quot;Icon&quot;;
				Image                  = IconURL;
			}
		}
		XSpacing = XSpacing + Configuration.Height;
	end

	local TextLabel = Make &apos;TextLabel&apos; {
		Archivable             = false;
		BackgroundTransparency = 1;
		Font                   = &quot;Arial&quot;;
		FontSize               = &quot;Size14&quot;;
		Parent                 = Button;
		Position               = UDim2.new(0, XSpacing, 0, 0);
		Size                   = UDim2.new(1, -XSpacing, 1, 0);
		Text                   = Name;
		TextColor3             = Color3.new(1, 1, 1);
		TextStrokeTransparency = 1;
		TextTransparency       = 0;
		TextXAlignment         = &quot;Left&quot;;
		TextYAlignment         = &quot;Center&quot;;
		Visible                = true;
		ZIndex                 = Button.ZIndex;
	}

	Button.MouseEnter:connect(function()
		if Icon then
			Icon.BackgroundTransparency = 0;
		end
		Button.BackgroundTransparency = Configuration.EnterTransparency;
	end)

	Button.MouseLeave:connect(function()
		if Icon then
			Icon.BackgroundTransparency = 1;
		end
		Button.BackgroundTransparency = Configuration.DefaultTransparency;
	end)

	local Option = {}
	Option.Gui           = Button
	Option.RenderHeightY = Configuration.Height;
	Option.Shown         = true;
	Option.Update        = function(self, Box2DInterface)
		local Selection = Box2DInterface.BoxSelection.GetSelection()
		self.Shown      = #Selected &gt;= 1
	end
	return Option
end
lib.MakeIconOptionBase = MakeIconOptionBase
lib.makeIconOptionBase = MakeIconOptionBase

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX21">
<Properties>
<string name="Name">ItemSystem</string>
<ProtectedString name="Source">local ReplicatedStorage       = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine         = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary       = NevermoreEngine.LoadLibrary

local qSystems                = LoadCustomLibrary(&quot;qSystems&quot;)
local OverriddenConfiguration = LoadCustomLibrary(&quot;OverriddenConfiguration&quot;)

qSystems:Import(getfenv(0))

local lib = {}

--- Handles Items in away that is persistent and parsable.
-- ItemSystem.lua
-- @author Quenty

--[[ -- Change Log
February 11th, 2014
- Opened up GenerateUID to the world

February 7th, 2014
- Updated so Data is now stored locally in a table. 
- Added change log
- Added some documentation
- Updated to use OverriddenConfiguration
- Removed ParseConstructor
- Added UID system for server-client interactions.

- Fixed Class Index Problem

February 3rd, 2014
- Updated to work with New Nevermore System

-------------------
-- DOCUMENTATION --
-------------------

The item system is used to handle &quot;items&quot; and construct them. This is for in-game items. Before they were stored in Configuration objects,
with items in them, but this turned out to be rather messy. 

We have now switched to using tables, as new networking and FilteringEnabled in workspace now exist, and it is more easy to do it this way.
Items contain several components to work with them. ROBLOX (or Lua) do not provide easy OOP, but we can make do with tables and metatablse.

Attributes aren&apos;t case sensitive.

`Table` [Item] Item
	This is a generic item created by this system.

	`Table` [ClassBase] ClassBase
		This points to the ClassBase &apos;Template&apos; object that the object uses. This is purely for internal usage.
	`String` ClassName 
		The ClassName of the class
	`Table` Data
		Specific &quot;Attributes&quot; that aren&apos;t global
	`Table` Interfaces
		This is the fun part. The Interfaces table is one that can be used by other programs / codes to store specific data related to the
		item. The programs should only create a table for them to use, and it should be a specific name to prevent conflicts.

		I can&apos;t do too much to prevent conflicts. It seems messy, but maintaining a linked array is so messy. 

		An example here would be BoxInventory using an interface at 
			Item.Interfaces.BoxInventory

		This is just a table associated with the Item. I called it &quot;Interfaces&quot; because that&apos;s what I&apos;d totally like it to be, an implimentable
		class &quot;interface&quot; over the class (IF you&apos;re familiar with OOP, this might make more sense).

The bin that is used to create these objects is stored in ROBLOX objects because it is easier to edit and modify them there, as wella s generate
them. There is an efficiency lost, I&apos;m sure. It is suggested they are stored in a single bin, as will be shown below, but bins can be combined,
et cetera, as the ItemSystem takes in a table of them.

Backpack and Configuration are interchanable, here. 

`Backpack` ItemClassNameHere
	Your generic Item class definition here. It&apos;s in ROBLOX objects. 

	`Configuration` Attributes
		These attributes should only be ROBLOX objects with the class names noted in the RobloxValueTypes table.
		Please note that ththe name used for these binsan be changed via the Configuration.
		
		`IntValue` BurnPoints
			This is an example, you can have an attribute called &apos;BurnPoints&apos; that would be different per a user.
			The value set here is the &quot;DefaultValue&quot; of the item.
		...
	`Configuration` GlobalAttributes
		These are static attributes, shared accross all items, and don&apos;t change. 
		Please note that ththe name used for these binsan be changed via the Configuration.
		
		`Model` Model
			This is an exmaple, for example, you could have a model that is the 3D representation of the object.

The following names cannot be used for Attributes:
	UID
	ClassName
	Interfaces
	ClassBase
	Data

--]]



-- List of all the ROBLOXValue types...
local RobloxValueTypes = {
	[&quot;BoolValue&quot;]              = true;
	[&quot;BrickColorValue&quot;]        = true;
	[&quot;CFrameValue&quot;]            = true;
	[&quot;Color3Value&quot;]            = true;
	[&quot;DoubleConstrainedValue&quot;] = true;
	[&quot;IntConstrainedValue&quot;]    = true;
	[&quot;IntValue&quot;]               = true;
	[&quot;NumberValue&quot;]            = true;
	-- [&quot;ObjectValue&quot;]            = true; -- We can&apos;t send this one over the network. 
	[&quot;RayValue&quot;]               = true;
	[&quot;StringValue&quot;]            = true;
	[&quot;Vector3Value&quot;]           = true;
}


local function GetValue(Class, AttributeName)
	--- Return&apos;s the attribute if it can find it, and true if it&apos;s static, false if it&apos;s not
	--- Helper function
	-- @param Class The class to check, constructed

	local ClassBase = Class.ClassBase;
	for LocalAttributeName, Attribute in pairs(ClassBase.StaticAttributes) do
		if AttributeName:lower() == LocalAttributeName:lower() then
			return Attribute, true
		end
	end

	local Data = Class.Data[AttributeName:lower()]
	if Data ~= nil then
		return Data
	end

	return nil;
end

-- To be set on classes to facilitate removal/addition
local ClassMetatable = {
	__index = function(Class, IndexName)
		if type(IndexName) == &quot;string&quot; then
			if IndexName:lower() == &quot;get&quot; or IndexName:lower() == &quot;getvalue&quot; then
				return GetValue
			elseif IndexName:lower() == &quot;data&quot; then
				return Class.Data
			end
		end

		local Attribute = GetValue(Class, IndexName)
		if Attribute then
			if RobloxValueTypes[Attribute.ClassName] then
				return Attribute.Value;
			else
				return Attribute -- Maybe want to clone it? Nah, they can&apos;t &quot;hypothetically&quot; change it...
			end
		end

		if IndexName == &quot;ClassName&quot; then
			return ClassBase.ClassName;
		elseif Instance == &quot;Interfaces&quot; then
			return ClassBase.Interfaces	
		end

		return nil;
	end;
	__newindex = function(Class, IndexName, NewValue)
		if NewValue ~= nil then
			IndexName = IndexName:lower()

			if Class.Data[IndexName:lower()] then
				Class.Data[IndexName:lower()] = NewValue
			else
				error(&quot;[ItemSystem] - Attribute &apos;&quot;..Attribute.Name..&quot;&apos; could not be found.&quot;)
			end
		else
			error(&quot;[ItemSystem] - Tried to set &apos;&quot; .. IndexName .. &quot;&apos; but the value was &apos;&quot; .. tostring(NewValue) .. &quot;&apos; (nil).&quot;)
		end
	end;
	__tostring = function(Class)
		return &quot;Item@&apos;&quot;..Class.ClassName..&quot;&apos;&quot;..Class.Data.uid;
	end;
}

local MakeItemSystem = Class(function(ItemSystem, Configuration, ItemClassList, Constructor)
	-- Handles items properties, new items, and whatnot.  Handles construction and properties and stuffz. :)
	-- @param Constructor function that will be called on Item construction. It will send the preconstructed class to the constructor, as well as any arguments passed into it..
	-- @param ItemClassList A list of items. Each item should be setup like this
	--[[
		`Backpack` ItemClassNameHere
			Your generic Item class definition here. It&apos;s in ROBLOX objects. 

			`Configuration` Attributes
				These attributes should only be ROBLOX objects with the class names noted in the RobloxValueTypes table.
				Please note that the name used for these bins can be changed via the Configuration.

				`IntValue` BurnPoints
					This is an example, you can have an attribute called &apos;BurnPoints&apos; that would be different per a user.
					The value set here is the &quot;DefaultValue&quot; of the item.
				...
			`Configuration` GlobalAttributes
				These are static attributes, shared accross all items, and don&apos;t change. 
				Please note that the name used for these bins can be changed via the Configuration.

				`Model` Model
					This is an exmaple, for example, you could have a model that is the 3D representation of the object.
	]]


	local ItemClasses = {}
	Configuration = OverriddenConfiguration.New(Configuration, {
		-- Default Configuration

		StaticAttributeBinName = &quot;GlobalAttributes&quot;;
		AttributeBinName       = &quot;Attributes&quot;;
	})
	

	local function AddNewItemClass(ItemClass)
		-- Add an ItemClass into the system.  Will check for duplicates in information. To be called, preferably, once.
		-- @param ItemClass The ItemClass bin, as specified above. 
		-- @post Item is added into ItemClasses table.

		local ItemName = ItemClass.Name;
		if not ItemClasses[ItemName] then
			local NewClass = {}
			NewClass.ClassName = ItemName;
			--NewClass.Interfaces = {} -- Should be in normal instantation. 
			
			-- Get bins and verify existance.
			local StaticAttributeBin = ItemClass:FindFirstChild(Configuration.StaticAttributeBinName)
			assert(StaticAttributeBin, &quot;[ItemSystem] - StaticAttribute in ItemClass &quot;..ItemClass.Name..&quot; could not be found. (Expect to be @ &quot;..ItemClass:GetFullName()..&quot;.&quot;..Configuration.StaticAttributeBinName)
			local AttributeBin = ItemClass:FindFirstChild(Configuration.AttributeBinName)
			assert(AttributeBin, &quot;[ItemSystem] - AttributeBin in ItemClass &quot;..ItemClass.Name..&quot; could not be found. (Expect to be @ &quot;..ItemClass:GetFullName()..&quot;.&quot;..Configuration.StaticAttributeBinName)

			NewClass.StaticAttributes = {}
			NewClass.AttributeBin     = {}

			-- Add Statis Attributes in
			for _, ItemClass in pairs(StaticAttributeBin:GetChildren()) do
				if not NewClass.StaticAttributes[ItemClass.Name] then
					NewClass.StaticAttributes[ItemClass.Name] = ItemClass;
				else
					error(&quot;[ItemSystem] - StaticAttribute for ItemClass &apos;&quot;..ItemClass.Name..&quot;&apos; already exists in &apos;&quot;..ItemClass.Name..&quot;&apos;&quot;)
				end
			end

			-- Add local attributes in.
			for _, ItemClass in pairs(AttributeBin:GetChildren()) do
				if NewClass.AttributeBin[ItemClass.Name] then
					error(&quot;[ItemSystem] - Attribute for ItemClass &apos;&quot;..ItemClass.Name..&quot;&apos; already exists in &apos;&quot;..ItemClass.Name..&quot;&apos; in the Attribute Bin&quot;)
				elseif NewClass.StaticAttributes[ItemClass.Name] then
					error(&quot;[ItemSystem] - Attribute for ItemClass &apos;&quot;..ItemClass.Name..&quot;&apos; already exists in &apos;&quot;..ItemClass.Name..&quot;&apos; in the StaticAttribute Bin&quot;)
				else
					NewClass.AttributeBin[ItemClass.Name] = ItemClass;
				end
			end

			ItemClasses[ItemClass.Name] = NewClass;
		else
			error(&quot;[ItemSystem] - ItemClass Class &apos;&quot;..ItemClass.Name..&quot;&apos; already exists in ItemSystem&quot;)
		end
	end
	ItemSystem.AddNewItemClass = AddNewItemClass
	ItemSystem.addNewItemClass = AddNewItemClass

	local function GetItemClasses()
		--- Return&apos;s all ItemClasse that exist.
		-- @return A list of the ItemClasses that exist. Should not modify values inside of this without deep copy.

		return ItemClasses
	end
	ItemSystem.GetItemClasses = GetItemClasses
	ItemSystem.getItemClasses = GetItemClasses

	local UIDCounter = 1
	local function GenerateUID(ItemData)
		UIDCounter = UIDCounter + 1
		return &quot;Class@&quot; .. tostring(ItemData) .. &quot;@&quot; .. UIDCounter
	end
	ItemSystem.GenerateUID = GenerateUID]
	ItemSystem.generateUID = GenerateUID

	local function ConstructNewItem(ClassName, ...)
		--- Constructs a new item, with the ClassName &apos;ClassName&apos;
		-- @param ClassName The name of the class to construct
		-- @param ... Constructure arguments.
		-- @return The constructud class. 

		if ItemClasses[ClassName] then
			local NewClass      = {}
			NewClass.ClassBase  = ItemClasses[ClassName]
			NewClass.ClassName  = ClassName;
			NewClass.Data       = {}
			NewClass.Interfaces = {}

			local UID = GenerateUID(NewClass.Data)

			for AttributeName, AttributeObject in pairs(ItemClasses[ClassName].AttributeBin) do
				NewClass.Data[AttributeName:lower()] = AttributeObject.Value
			end
			NewClass.UID = UID

			-- Must be lower case, because everything in Data is lowe case. 
			NewClass.Data.classname = ClassName
			NewClass.Data.uid = UID

			-- Finish construction.
			if Constructor then
				Constructor(ItemSystem, NewClass, ...) -- May error with the &apos;...&apos;, may have to repack and unpack...
			end
			setmetatable(NewClass, ClassMetatable)

			return NewClass;
		else
			error(&quot;[ItemSystem] - Could not find Class data for Class &apos;&quot;..ClassName..&quot;&apos;&quot;)
		end
	end
	ItemSystem.ConstructNewItem = ConstructNewItem;
	ItemSystem.constructNewItem = ConstructNewItem;
	ItemSystem.New              = ConstructNewItem;
	ItemSystem.new              = ConstructNewItem;

	local function ConstructClassFromData(Data, ...)
		--- Reconstructs a class from the Data given. 
		-- @param Data The data from an old class, NewClass.Data
		-- @param ... Constructer arguements. 
		-- @return The cosntructed class

		if type(Data.classname) ~= &quot;string&quot; then
			error(&quot;[ItemSystem] - Data.classname == &apos;&quot; .. tostring(Data.classname) ..&quot;&apos;, invalid Data, unable to construct new item&quot;)
		end
		if not Data.uid then
			error(&quot;[ItemSystem] - Data.uid == &apos;&quot; .. tostring(Data.uid) ..&quot;&apos;, invalid UID, unable to construct new item&quot;)
		end

		local ClassName = Data.classname

		if not ItemClasses[ClassName] then
			error(&quot;[ItemSystem] - Cannot find ItemClass with ClassName of &apos;&quot; .. ClassName ..&quot;&apos;&quot;)
		end
		
		local NewClass = {}
		
		NewClass.ClassBase = ItemClasses[ClassName]
		NewClass.ClassName = ClassName;
		NewClass.UID = Data.uid

		NewClass.Data       = {}
		for Index, Value in pairs(Data) do
			NewClass.Data[Index:lower()] = Value
		end
		for AttributeName, AttributeObject in pairs(ItemClasses[ClassName].AttributeBin) do
			if not NewClass.Data[AttributeName:lower()] then
				print(&quot;[ItemSystem] - Warning, &apos;&quot; .. AttributeName .. &quot;&apos; was not included in Data!&quot;)
				NewClass.Data[AttributeName:lower()] = AttributeObject.Value
			end
		end
		NewClass.Interfaces = {}

		if Constructor then
			Constructor(ItemSystem, NewClass, ...) -- May error with the &apos;...&apos;, may have to repack and unpack...
		end
		setmetatable(NewClass, ClassMetatable)

		return NewClass
	end
	ItemSystem.ConstructClassFromData = ConstructClassFromData;
	ItemSystem.constructClassFromData = ConstructClassFromData;
	ItemSystem.ParseData              = ConstructClassFromData;
	ItemSystem.parseData              = ConstructClassFromData;

	--- Parse existing items in the class system.
	if ItemClassList then
		for _, Item in pairs(ItemClassList) do
			AddNewItemClass(Item)
		end
	end
end)
lib.MakeItemSystem = MakeItemSystem;
lib.makeItemSystem = MakeItemSystem;

return lib
</ProtectedString>
</Properties>
</Item>
</Item>
<Item class="Backpack" referent="RBX22">
<Properties>
<string name="Name">IO</string>
</Properties>
<Item class="ModuleScript" referent="RBX23">
<Properties>
<string name="Name">KeyboardStatus</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local Players           = game:GetService(&quot;Players&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&apos;qSystems&apos;)
local Table             = LoadCustomLibrary(&apos;Table&apos;)

local lib = {}

qSystems:import(getfenv(0));

-- KeyboardStatus.lua
-- @author Quenty
-- Last Modified February 3rd, 2014
-- TODO: Modify this to make it use Enums et cetera. 

local KeyChart = {
	-- Chart of all the keys, so we can do keys.A to get the byte code of it. Nice and efficient, coding wise... :D
	[&quot;a&quot;]             = string.char(97);
	[&quot;b&quot;]             = string.char(98);
	[&quot;c&quot;]             = string.char(99);
	[&quot;d&quot;]             = string.char(100);
	[&quot;e&quot;]             = string.char(101);
	[&quot;f&quot;]             = string.char(102);
	[&quot;g&quot;]             = string.char(103);
	[&quot;h&quot;]             = string.char(104);
	[&quot;i&quot;]             = string.char(105);
	[&quot;j&quot;]             = string.char(106);
	[&quot;k&quot;]             = string.char(107);
	[&quot;l&quot;]             = string.char(108);
	[&quot;m&quot;]             = string.char(109);
	[&quot;n&quot;]             = string.char(110);
	[&quot;o&quot;]             = string.char(111);
	[&quot;p&quot;]             = string.char(112);
	[&quot;q&quot;]             = string.char(113);
	[&quot;r&quot;]             = string.char(114);
	[&quot;s&quot;]             = string.char(115);
	[&quot;t&quot;]             = string.char(116);
	[&quot;u&quot;]             = string.char(117);
	[&quot;v&quot;]             = string.char(118);
	[&quot;w&quot;]             = string.char(119);
	[&quot;x&quot;]             = string.char(120);
	[&quot;y&quot;]             = string.char(121);
	[&quot;z&quot;]             = string.char(122);
	[&quot;arrowKeyUp&quot;]    = string.char(17);
	[&quot;arrowKeyDown&quot;]  = string.char(18);
	[&quot;arrowKeyRight&quot;] = string.char(19);
	[&quot;arrowKeyLeft&quot;]  = string.char(20);
	[&quot;home&quot;]          = string.char(22);
	[&quot;end&quot;]           = string.char(23);
	[&quot;f2&quot;]            = string.char(27);
	[&quot;f4&quot;]            = string.char(29);
	[&quot;f5&quot;]            = string.char(30);
	[&quot;esc&quot;]           = string.char(27);
	[&quot;tab&quot;]           = string.char( 9);
	[&quot;enter&quot;]         = string.char(13);
		[&quot;enterKey&quot;]      = string.char(13);
	[&quot;space&quot;]         = string.char(32);
		[&quot;spaceBar&quot;]      = string.char(32);
	[&quot;ctrl&quot;]          = string.char(50);
		[&quot;ctrlLeft&quot;]      = string.char(50);
		[&quot;ctrlRight&quot;]     = string.char(49);
	[&quot;alt&quot;]           = string.char(52);
		[&quot;altLeft&quot;]       = string.char(52);
		[&quot;altRight&quot;]      = string.char(51);
	[&quot;windows&quot;]       = string.char(54);
		[&quot;windowsLeft&quot;]   = string.char(54);
		[&quot;windowsRight&quot;]  = string.char(53);
	[&quot;backspace&quot;]     = string.char(8);
	[&quot;shift&quot;]         = string.char(48);
		[&quot;shiftRight&quot;]    = string.char(47);
		[&quot;shiftLeft&quot;]     = string.char(48);
	[&quot;esc&quot;] = string.char(27);
	[&quot;`&quot;] = string.char(96);
	[&quot;~&quot;] = string.char(96);
	[&quot;1&quot;]             = string.char(49);
	[&quot;2&quot;]             = string.char(50);
	[&quot;3&quot;]             = string.char(51);
	[&quot;4&quot;]             = string.char(52);
	[&quot;5&quot;]             = string.char(53);
	[&quot;6&quot;]             = string.char(54);
	[&quot;7&quot;]             = string.char(55);
	[&quot;8&quot;]             = string.char(56);
	[&quot;9&quot;]             = string.char(57);
	[&quot;0&quot;]             = string.char(48);
	[&quot;mousebutton1&quot;]  = &quot;mousebutton1&quot;;
	[&quot;mousebutton2&quot;]  = &quot;mousebutton2&quot;;
}

lib.Keys = KeyChart
lib.KeyChart = KeyChart

-- This system ends up working a lot like regex javascript objects, I guess...
-- It tracks all down keys, and setups up statuses and stuff. 

--[[

Sample Usage:

	local KeyboardStatus = LoadCustomLibrary(&apos;KeyboardStatus&apos;)
	local Keys           = KeyboardStatus.KeyChart

	local Input = KeyboardStatus.MakeKeyboardStatus(LocalPlayer:GetMouse())

	if Input.GetKeyStatus(Keys.q) then
		TargetZoom = TargetZoom - 25;
	end
	if Input.GetKeyStatus(Keys.e) then
		TargetZoom = TargetZoom + 25;
	end
	
	------ OR -------

	local NightVisionToggle = Input.MakeCombinationsEvent(Input.KeyDown, Input.MultipleCombinationStatus, {
		{Keys.q;};
	})

	local NightVisionUp = Input.MakeCombinationsEvent(Input.KeyUp, Input.MultipleCombinationStatus, {
		{Keys.q;};
	})

	local FlashlightToggle = Input.MakeCombinationsEvent(Input.KeyDown, Input.MultipleCombinationStatus, {
		{Keys.f;};
	})

	local MenuOpen = Input.MakeCombinationsEvent(Input.KeyDown, Input.MultipleCombinationStatus, {
		{Keys.m;};
	})

	NightVisionToggle.Event:connect(function()
		if HasTag(LocalPlayer, &quot;Playing&quot;) and not CutscenePlayer.CutscenePlaying then
			if not IsBeast.Value then
				if not VisionEnabled then
					VisionEnabled = true;
					Spawn(function()
						while VisionEnabled do
							if CheckCharacter(LocalPlayer) then
								LocalPlayer.Character.Humanoid:TakeDamage(1);
							end
							wait(0.5)
						end
					end)
					SetToLightingCurrent(0.25)
					NightVisionUp.Event:wait()
					VisionEnabled = false;
					SetToLightingCurrent(0.25)
				end
			end
		end
	end)

	-- You should also be able to connect directly

	FlashlightToggle:connect(function()
		Flashlight.Toggle(not Flashlight.Toggled)
	end)
--]]

local MakeKeyboardStatus = Class(function(KeyboardStatus, Mouse)
	-- Tracks keys and mouse input

	local KeysDown = {} -- Table of keys down.  Keys are direct, but lowercase. 

	local KeyDown  = Make &apos;BindableEvent&apos; {
		Name       = &quot;KeyDown&quot;;
		Archivable = false;
	}

	KeyboardStatus.KeyDown = KeyDown
	local KeyUp  = Make &apos;BindableEvent&apos; {
		Name       = &quot;KeyUp&quot;;
		Archivable = false;
	}
	KeyboardStatus.KeyUp = KeyUp

	local function GetKeyStatus(Key)
		return KeysDown[Key:lower()]
	end
	KeyboardStatus.GetKeyStatus = GetKeyStatus

	local function GetCombinationStatus(Combination)
		-- Returns the if all the keys in the combination list are down. 

		for _, Key in pairs(Combination) do
			if not GetKeyStatus(Key) then
				return false
			end
		end
		return true;
	end
	KeyboardStatus.GetCombinationStatus = GetCombinationStatus

	local function GetCombinationMatch(Combination)
		-- Returns true only if the keys down match the combination down. 
		-- So if the keydown, is say, including another key, it won&apos;t fire.

		local CombinationCopy = Table.Copy(Combination)

		for Index, Key in pairs(Combination) do
			CombinationCopy[Index] = nil
			if not GetKeyStatus(Key) then
				return false
			end
		end

		if Table.Count(CombinationCopy) == 0 then
			return true;
		else
			return false
		end
	end
	KeyboardStatus.GetCombinationMatch = GetCombinationMatch

	local function MultipleCombinationStatus(Combinations)
		-- In case more than one key combo exists, it&apos;ll go through each combination and return true or false.

		for _, Combination in pairs(Combinations) do
			if GetCombinationStatus(Combination) then
				return true
			end
		end
		return false
	end
	KeyboardStatus.MultipleCombinationStatus = MultipleCombinationStatus

	local function MultipleCombinationMatch(Combinations)
		-- In case more than one key combo exists, it&apos;ll go through each combination and return true or false, but if and only if those
		-- are enabled.

		for _, Combination in pairs(Combinations) do
			if GetCombinationMatch(Combination) then
				return true
			end
		end
		return false
	end
	KeyboardStatus.MultipleCombinationMatch = MultipleCombinationMatch

	local function MakeCombinationsEvent(BindableEvent, Checker, Combinations)
		--- Rather tricky to use, but basically, pick your event object, pick your checker function, and then pick your combinations... &gt;:D
		-- @param BindableEvent An event included in the KeyboardStatus, either KeyDown or KeyUp, in which this event should be checked
		-- @param Checker This is the checker function, in this class. Probably use MultipleCombinationMatch, as the other one requires ONLY those
		--        keys down
		-- @param Combinations a table with ... more tables! In this case, each combination 
		-- @return Class, which can be used to connect

		local Class = {}
		local BindableEventLocal = Make &apos;BindableEvent&apos; {
			Name       = &quot;KeyDown&quot;;
			Archivable = false;
		}
		Class.Event        = BindableEventLocal.Event
		Class.Combinations = Combinations
		Class.connect      = function(self, ...)
			BindableEventLocal.Event:connect(...)
		end

		BindableEvent.Event:connect(function()
			if Checker(Combinations) then
				BindableEventLocal:Fire()
			end
		end)

		function Class:Fire()
			-- Manualy fires the event

			BindableEventLocal:Fire()
		end

		function Class:Destroy()
			-- Destroy&apos;s the class

			BindableEvent:Destroy()
			Class.Event        = nil
			Class.Fire         = nil
			Class.Destroy      = nil
			Class.Combinations = nil
			Class.connect      = nil
			Class              = nil
		end

		return Class
	end
	KeyboardStatus.MakeCombinationsEvent = MakeCombinationsEvent

	local Events = {}

	local function SetupMouse(Mouse)
		print(&quot;[KeyboardStatus] - Setting up mouse events&quot;)

		if Events then
			for _, Event in pairs(Events) do
				Event:disconnect()
			end
			Events = {}
		end

		Events[#Events+1] = Mouse.KeyDown:connect(function(Key)
			--print(&quot;[KeyboardStatus] - KeyDownEvent&quot;)
			KeysDown[Key:lower()] = true;
			KeyDown:Fire(KeysDown)
		end)

		Events[#Events+1] = Mouse.KeyUp:connect(function(Key)
			--print(&quot;[KeyboardStatus] - KeyUpEvent&quot;)
			KeyUp:Fire(KeysDown)
			KeysDown[Key:lower()] = nil;
		end)

		Events[#Events+1] = Mouse.Button1Down:connect(function(Key)
			KeysDown[&quot;mousebutton1&quot;] = true;
			KeyDown:Fire(KeysDown)
		end)

		Events[#Events+1] = Mouse.Button1Up:connect(function(Key)
			KeyUp:Fire(KeysDown)
			KeysDown[&quot;mousebutton1&quot;] = nil;
		end)

		Events[#Events+1] = Mouse.Button2Down:connect(function(Key)
			KeysDown[&quot;mousebutton2&quot;] = true;
			KeyDown:Fire(KeysDown)
		end)

		Events[#Events+1] = Mouse.Button2Up:connect(function(Key)
			KeyUp:Fire(KeysDown)
			KeysDown[&quot;mousebutton2&quot;] = nil;
			
		end)
	end

	while not CheckPlayer(Players.LocalPlayer) do
		wait(0)
		print(&quot;[KeyboardStatus] - Waiting for Players.LocalPlayer to validate&quot;)
	end

	SetupMouse(Mouse)

	--SetupMouse(Players.LocalPlayer:GetMouse())
	KeyboardStatus.SetupMouse = SetupMouse
	--[[Players.LocalPlayer.CharacterAdded:connect(function()
		print(&quot;[KeyboardStatus] - Character added&quot;)
		SetupMouse(Players.LocalPlayer:GetMouse())
	end)--]]
end)

lib.MakeKeyboardStatus = MakeKeyboardStatus
lib.makeKeyboardStatus = MakeKeyboardStatus

return lib</ProtectedString>
</Properties>
</Item>
</Item>
<Item class="Backpack" referent="RBX24">
<Properties>
<string name="Name">Menu</string>
</Properties>
<Item class="Script" referent="RBX25">
<Properties>
<string name="Name">MenuDocumentationSystem</string>
<ProtectedString name="Source">while not _G.NevermoreEngine do wait(0) end

local Players              = Game:GetService(&apos;Players&apos;)
local StarterPack          = Game:GetService(&apos;StarterPack&apos;)
local StarterGui           = Game:GetService(&apos;StarterGui&apos;)
local Lighting             = Game:GetService(&apos;Lighting&apos;)
local Debris               = Game:GetService(&apos;Debris&apos;)
local Teams                = Game:GetService(&apos;Teams&apos;)
local BadgeService         = Game:GetService(&apos;BadgeService&apos;)
local InsertService        = Game:GetService(&apos;InsertService&apos;)
local Terrain              = Workspace.Terrain

local NevermoreEngine      = _G.NevermoreEngine
local LoadCustomLibrary    = NevermoreEngine.LoadLibrary;

local qSystems             = LoadCustomLibrary(&apos;qSystems&apos;)
local ParagraphConstructor = LoadCustomLibrary(&apos;ParagraphConstructor&apos;)
local MenuSystem           = LoadCustomLibrary(&apos;MenuSystem&apos;)
local qGUI                 = LoadCustomLibrary(&apos;qGUI&apos;)
local qString              = LoadCustomLibrary(&apos;qString&apos;)
local ScrollBar            = LoadCustomLibrary(&apos;ScrollBar&apos;)

qSystems:Import(getfenv(0));

--[[

This system draws up documentation and instructions based upon markdown, and allows
the menu system to interact with it.  To be used specifically with the menu system.

--]]

local lib = {}

local MakeDocumentationSystem = Class &apos;DocumentationSystem&apos; (function(DocumentationSystem, Menu, ScreenGui, Format)
	-- Should not be used while another system designed for MenuSystem is being used. That is, don&apos;t try to pull up instructions
	-- while customization is open or something.

	Format = Format or {}
	Format.Name = Format.Name or &quot;Documentation&quot; -- What the menu displays as. 
	Format.SizeX = Format.SizeX or 400;
	Format.OffsetX = Format.OffsetX or 260
	Format.OffsetY = Format.OffsetY or 10 -- When scrolling, space between the top of the screen and the text&apos;s start.
	Format.ExtraYOffsetBetween = Format.ExtraYOffsetBetween or 400 -- for safety&apos;s sake... What if they resize the screen? 
	Format.CharacterLimit = 15;
	Format.FadeBackgroundTo = 0.7;

	local Instructions = {}
	local DocumentationMenu = MenuSystem.MakeListMenuLevel(Format.Name)
	local LastInstructionPosition = 0; -- Keep track of Y axis...
	local ShowMenuVisible = false
	local ShowMenuLevel = 0

	local DocumentationFrame = Make &apos;Frame&apos; {
		BackgroundColor3       = qGUI.NewColor3(0, 0, 0);
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Name                   = &quot;qDocumentationSystem&quot;;
		Parent                 = ScreenGui;
		Size                   = UDim2.new(1, 0, 1, 0);
		Visible                = true;
		ZIndex                 = 1;
	}
	local ShowInstructions, HideInstructions
	local FirstInstructonTitle

	local Container = Make &apos;ImageButton&apos; {
		Name = &quot;Container&quot;;
		Parent = DocumentationFrame;
		Size = UDim2.new(0, Format.SizeX, 1, 0);
		Position = UDim2.new(0, Format.OffsetX, 1, 10);
		Visible = true;
		BackgroundTransparency = 1;
		BorderSizePixel = 0;
	};

	--local Scroller = ScrollBar.MakeScroller(DocumentationFrame, Container, ScreenGui, &apos;Y&apos;)
	--Scroller.CanDrag = true

	Menu.MenuLevelChange:connect(function(NewLevel)
		if NewLevel &lt; ShowMenuLevel then
			--print(&quot;[DocumentationSystem] - DocumentationMenu is hiding / being disconnected&quot;)
			ShowMenuVisible = false
			HideInstructions()
		end
	end)

	local function GetFirstInstruction()
		-- Return&apos;s the first instruction it can find. 
		if FirstInstructonTitle and Instructions[FirstInstructonTitle] then
			return Instructions[FirstInstructonTitle]
		else
			print(&quot;[DocumentationSystem] - Warning, FirstInstructonTitle failed&quot;)
			for _, Item in pairs(Instructions) do
				return Item
			end
			error(&quot;[DocumentationSystem] - No instructions have been added to the MenuDocumentationSystem&quot;)
		end
	end

	local function ShowMenu()
		if not ShowMenuVisible then
			--print(&quot;[DocumentationSystem] - DocumentationMenu being shown&quot;) 
			ShowMenuLevel = Menu.CurrentLevel + 1
			Menu:AddMenuLayer(DocumentationMenu)
			ShowMenuVisible = true

			local Instruction = GetFirstInstruction()
			if Instruction then
				ShowInstructions(Instruction.Title)
			end

		else
			error(&quot;[DocumentationSystem] - DocumentationMenu is already visible&quot;) 
		end
	end
	DocumentationSystem.ShowMenu = ShowMenu

	function ShowInstructions(InstructionTitle, Animation)
		if not ShowMenuVisible then 
			Menu:AddMenuLayer(DocumentationMenu)
		end
		Animation = Animation or &quot;slide&quot;
		Animation = Animation:lower()
		local Instruction = Instructions[InstructionTitle]
		assert(Instructions[InstructionTitle], &quot;Instruction &quot;..tostring(InstructionTitle)..&quot; equals &quot;..tostring(Instructions[InstructionTitle])..&quot;&apos;&quot;)
		local InstructionPosition = UDim2.new(0, Format.OffsetX, 0, -Instruction.Position + Format.OffsetY)

		if DocumentationFrame.BackgroundTransparency ~= Format.FadeBackgroundTo then
			if Animation ~= &quot;none&quot; then
				qGUI.TweenTransparency(DocumentationFrame, {
					BackgroundTransparency = Format.FadeBackgroundTo
				}, 0.5, true)
				CallOnChildren(Container, function(Child)
					if Child:IsA(&quot;TextLabel&quot;) then
						if Child:IsDescendantOf(Instructions.Gui) then
							if Child.TextTransparency ~= 0 then
								qGUI.TweenTransparency(Child, {TextTransparency = 0}, 0.5, true)
							end
						else
							if Child.TextTransparency ~= 1 then
								qGUI.TweenTransparency(Child, {TextTransparency = 1}, 0.5, true)
							end
						end
					end
				end)
			else
				DocumentationFrame.BackgroundTransparency = Format.FadeBackgroundTo
				CallOnChildren(Container, function(Child)
					if Child:IsA(&quot;TextLabel&quot;) then
						if Child:IsDescendantOf(Instructions.Gui) then
							Child.TextTransparency = 0
						else
							Child.TextTransparency = 1
						end
					end
				end)
			end
		end
		--print(&apos;-(Instruction.Position+Instruction.Size-ScreenGui.AbsoluteSize.Y), Instruction.Position = &apos;..-(Instruction.Position+Instruction.Size-ScreenGui.AbsoluteSize.Y)..&quot;, &quot;..-Instruction.Position)
		--Scroller.KineticModel:SetRange(math.min(-(Instruction.Position-ScreenGui.AbsoluteSize.Y), -(Instruction.Position+Instruction.Size-ScreenGui.AbsoluteSize.Y)), 0)
		--Scroller.CanDrag = true
		if Animation == &quot;slide&quot; then
			--Scroller.KineticModel:ScrollTo(-Instruction.Position + Format.OffsetY)
			Container:TweenPosition(InstructionPosition, &quot;Out&quot;, &quot;Sine&quot;, 0.5, true)
		elseif Animation == &quot;none&quot; then
			Container.Position = InstructionPosition;
		else
			error(&quot;[DocumentationSystem] - No animation specified&quot;, 2)
		end
	end
	DocumentationSystem.ShowInstructions = ShowInstructions

	function HideInstructions(Animation)
		--Scroller.CanDrag = false
		Animation = Animation or &quot;slide&quot;
		Animation = Animation:lower()

		if DocumentationFrame.BackgroundTransparency ~= 1 then
			if Animation ~= &quot;none&quot; then
				qGUI.TweenTransparency(DocumentationFrame, {BackgroundTransparency = 1;}, 0.5, true)
				CallOnChildren(Container, function(Child)
					if Child:IsA(&quot;TextLabel&quot;) then
						if Child.TextTransparency ~= 1 then
							qGUI.TweenTransparency(Child, {TextTransparency = 1;}, 0.5, true)
						end
					end
				end)
			else
				DocumentationFrame.BackgroundTransparency = 1
				CallOnChildren(Container, function(Child)
					if Child:IsA(&quot;TextLabel&quot;) then
						Child.TextTransparency = 1
					end
				end)
			end
		end

		local InstructionPosition = UDim2.new(0, Format.OffsetX, 1, 50);

		if Animation == &quot;slide&quot; then
			Container:TweenPosition(InstructionPosition, &quot;In&quot;, &quot;Sine&quot;, 0.5, true)
		elseif Animation == &quot;none&quot; then
			Container.Position = InstructionPosition;
		else
			error(&quot;[DocumentationSystem] - No animation specified&quot;, 2)
		end
	end
	DocumentationSystem.HideInstructions = HideInstructions

	local function AddInstruction(InstructionTitle, Text)
		-- Adds a button to the documentation menu, and adds instructions...

		local NewInstruction = {}
		NewInstruction.Text = Text
		NewInstruction.Title = InstructionTitle
		local Button = MenuSystem.MakeMenuButton(qString.DumbElipseLimit(InstructionTitle, Format.CharacterLimit))
		DocumentationMenu:AddRawButton(Button)
		local Frame = Make &apos;Frame&apos; {
			BackgroundTransparency = 1;
			BorderSizePixel        = 0;
			Name                   = InstructionTitle..&quot;Container&quot;;
			Parent                 = Container;
			Size                   = UDim2.new(1, 0, 0, 0);
			Visible                = true;
		}

		NewInstruction.Gui = Frame
		local _, HeightY = ParagraphConstructor.ConstructBlock(Text, Frame, ScreenGui, {})
		NewInstruction.Position = LastInstructionPosition;
		Frame.Position = UDim2.new(0, 0, 0, LastInstructionPosition)
		NewInstruction.Size = HeightY
		LastInstructionPosition = NewInstruction.Position + HeightY + ScreenGui.AbsoluteSize.Y + Format.ExtraYOffsetBetween;
		Container.Size = UDim2.new(0, Format.SizeX, 0, LastInstructionPosition)
		Instructions[InstructionTitle] = NewInstruction

		if not FirstInstructonTitle then
			FirstInstructonTitle = InstructionTitle
		end

		Button.OnClick:connect(function()
			ShowInstructions(InstructionTitle)
		end)
	end
	DocumentationSystem.AddInstruction = AddInstruction

	
end)
lib.MakeDocumentationSystem = MakeDocumentationSystem
lib.makeDocumentationSystem = MakeDocumentationSystem

NevermoreEngine.RegisterLibrary(&apos;MenuDocumentationSystem&apos;, lib)</ProtectedString>
<bool name="Disabled">true</bool>
</Properties>
</Item>
<Item class="Script" referent="RBX26">
<Properties>
<string name="Name">MenuSystem</string>
<ProtectedString name="Source">while not _G.NevermoreEngine do wait(0) end

local Players           = Game:GetService(&apos;Players&apos;)
local StarterPack       = Game:GetService(&apos;StarterPack&apos;)
local StarterGui        = Game:GetService(&apos;StarterGui&apos;)
local Lighting          = Game:GetService(&apos;Lighting&apos;)
local Debris            = Game:GetService(&apos;Debris&apos;)
local Teams             = Game:GetService(&apos;Teams&apos;)
local BadgeService      = Game:GetService(&apos;BadgeService&apos;)
local InsertService     = Game:GetService(&apos;InsertService&apos;)
local Terrain           = Workspace.Terrain

local NevermoreEngine   = _G.NevermoreEngine
local LoadCustomLibrary = NevermoreEngine.LoadLibrary;

local qSystems          = LoadCustomLibrary(&apos;qSystems&apos;)
local Table             = LoadCustomLibrary(&apos;Table&apos;)
local EventBin          = LoadCustomLibrary(&apos;EventBin&apos;)

local lib    = {}
local Styles = {} -- Stores &apos;styles&apos; for the objects. :D
local Images = {} -- Stores asset ID&apos;s for the menu system. :D

qSystems:import(getfenv(0)) -- Import qSystems.

Images.BackButtonRegular = &quot;http://www.roblox.com/asset/?id=108244852&quot;;
Images.MenuButtonRegular = &quot;http://www.roblox.com/asset/?id=108248522&quot;;
Images.BackButtonOver = &quot;http://www.roblox.com/asset/?id=108248716&quot;;
Images.MenuButtonOver = &quot;http://www.roblox.com/asset/?id=108248707&quot;;

Styles.BorderlessFrame07 = {
	BackgroundColor3       = Color3.new(0, 0, 0);
	BackgroundTransparency = 0.7;
	BorderSizePixel        = 0;
	-- Style                  = &quot;Custom&quot;;
}
Styles.TransparentFrame = {
	BackgroundColor3       = Color3.new(0, 0, 0);
	BackgroundTransparency = 1;
	BorderSizePixel        = 0;
	-- Style                  = &quot;Custom&quot;;
}
Styles.BorderlessFrame09 = {
	BackgroundColor3       = Color3.new(0, 0, 0);
	BackgroundTransparency = 0.9;
	BorderSizePixel        = 0;
	-- Style                  = &quot;Custom&quot;;
}
Styles.Decoration07 = {
	BackgroundColor3       = Color3.new(1, 1, 1);
	BackgroundTransparency = 0.7;
	BorderSizePixel        = 0;
	-- Style                  = &quot;Custom&quot;;
}
Styles.Decoration05 = {
	BackgroundColor3       = Color3.new(1, 1, 1);
	BackgroundTransparency = 0.5;
	BorderSizePixel        = 0;
	-- Style                  = &quot;Custom&quot;;
}
Styles.Decoration03Dark = {
	BackgroundColor3       = Color3.new(0, 0, 0);
	BackgroundTransparency = 0.3;
	BorderSizePixel        = 0;
	-- Style                  = &quot;Custom&quot;;
}

Styles.MenuButton = {
	FontSize        = &quot;Size14&quot;;
	TextColor3      = Color3.new(1, 1, 1);
	BorderSizePixel = 0;
}
Styles.MenuButtonOver = {
	FontSize        = &quot;Size18&quot;;
	TextColor3      = Color3.new(1, 1, 1);
	BorderSizePixel = 0;
}
Styles.SubMenuButton = {
	FontSize        = &quot;Size10&quot;;
	TextColor3      = Color3.new(1, 1, 1);
	BorderSizePixel = 0;
}
Styles.SubMenuButtonOver = {
	FontSize        = &quot;Size11&quot;;
	TextColor3      = Color3.new(1, 1, 1);
	BorderSizePixel = 0;
}
Styles.ButtonSubcaption = {
	FontSize               = &quot;Size12&quot;;
	TextTransparency       = 0.5;
	Font                   = &quot;Arial&quot;;
	TextColor3             = Color3.new(1,1,1);
	BackgroundTransparency = 1;
	BorderSizePixel        = 0;
}
Styles.SubTitle = {
	FontSize               = &quot;Size12&quot;;
	TextTransparency       = 0;
	TextStrokeTransparency = 1;
	Font                   = &quot;Legacy&quot;;
	BorderSizePixel        = 0;
	TextColor3             = Color3.new(1,1,1);
	BackgroundTransparency = 1;
}
Styles.Divider = {
	BackgroundTransparency = 0.7;
	BorderSizePixel        = 0;
	BackgroundColor3       = Color3.new(1, 1, 1);
}


local MakeMenuButton = class &apos;MenuButton&apos; (function(Button, Name, OnRender)
	-- Menu buttons are those buttons in the menu, this continas a ton of event connectors and rendering functions to
	-- manipulate them.  It&apos;s a storage container basically. 

	Button.Name    = Name;
	Button.OnClick = CreateSignal()
	Button.OnEnter = CreateSignal()
	Button.OnLeave = CreateSignal()
	Button.Events = {};

	-- Button.Gui

	local OnClickEvents = {}
	local OnEnterEvents = {}
	local OnLeaveEvents = {}

	function Button:AddEvent(Event)
		Button.Events[#Button.Events+1] = Event;
	end

	function Button:DisconnectEvents()
		-- Removes all events associated with it.  (Used by internal system)

		for _, Event in pairs(Button.Events) do
			Event:disconnect();
		end

		Button.Events = {}
	end

	local SubcaptionLabel

	function Button:AddSubcaption(Caption)
		-- For stuff like &apos;[ Enter ]&apos;, etc.  This will renrender or create each time it&apos;s called. 

		SubcaptionLabel = SubcaptionLabel or make &apos;TextLabel&apos; {
			Archivable = false;
			Position   = UDim2.new(0, 0, 0.5, 0);
			Size       = UDim2.new(1, 0, 0.5, 0);
			Visible    = true;
			ZIndex     = 5;
		}
		Modify(SubcaptionLabel, Styles.ButtonSubcaption);

		SubcaptionLabel.Text = Caption;
		SubcaptionLabel.Parent = Button.Gui or nil;
	end

	function Button:Render(BaseButton)
		-- Basically modifies the button GUI and rehooks events... 

		Modify(BaseButton, Table.CopyAndAppend(Styles.TransparentFrame, {
			Name = Name..&quot;Button&quot;;
			Text = Name;
			ZIndex = 4;
			SubcaptionLabel;
		}))

		OnClickEvents[BaseButton] = OnClickEvents[BaseButton] or BaseButton.MouseButton1Click:connect(function(x, y)
			Button.OnClick:fire(x, y);
		end);

		OnEnterEvents[BaseButton] = OnEnterEvents[BaseButton] or BaseButton.MouseEnter:connect(function()
			Button.OnEnter:fire();
		end);

		OnLeaveEvents[BaseButton] = OnLeaveEvents[BaseButton] or BaseButton.MouseLeave:connect(function()
			Button.OnLeave:fire();
		end);
	end; 
end)
lib.MakeMenuButton = MakeMenuButton

local MakeGenericMenuLevel = class &apos;GenericMenuLevel&apos; (function(GenericMenuLevel, Title)
	-- A menu level without anything in it, just a title and the menu... No buttons. 

	GenericMenuLevel.Events = EventBin.MakeEventBin()
	GenericMenuLevel.MainMenuFrame = nil;

	function GenericMenuLevel.InitialRender()
		--print(&quot;initiating new GenericMenuLevel &quot;..tostring(Title))
		-- Called to create the resources...

		local MenuFrame = make &quot;Frame&quot; { -- Rendering code. Quite a bit of it.  
			Archivable = false;
			Size       = UDim2.new(1,0,1,0);
			Name       = &quot;MainMenu&quot;;
		}
		Modify(MenuFrame, Styles.BorderlessFrame07)

		local TitleLabel = make &apos;TextLabel&apos; {
			Name       = &quot;Title&quot;;
			Archivable = false;
			Position   = UDim2.new(0, 0, 0, 50);
			Size       = UDim2.new(1, 0, 0, 30);
			Text       = tostring(Title);
			Parent     = MenuFrame;
			ZIndex     = 2;
		}
		Modify(TitleLabel, Styles.SubTitle)

		local TitleDecoration = make &apos;Frame&apos; {
			Archivable = false;
			Position   = UDim2.new(0, 3, 1, 0);
			Size       = UDim2.new(1, -11, 0, 1);
			ZIndex     = 2;
			Parent     = TitleLabel;
		}
		Modify(TitleDecoration, Styles.Divider)

		local CommandBar = Make &apos;Frame&apos; {
			Name     = &quot;CommandBar&quot;;
			Size     = UDim2.new(1, 0, 0, 40);
			Position = UDim2.new(0, 0, 0, 5);
			ZIndex   = 2;
			Parent   = MenuFrame;
		}
		Modify(CommandBar, Styles.Decoration03Dark);

		local MainMenuButton = Make &apos;TextButton&apos; {
			Name     = &quot;MainMenu&quot;;
			Size     = UDim2.new(0, 100, 0, 30);
			Position = UDim2.new(1, -110, 0, 5);
			Parent   = CommandBar;
			Text     = &quot;&quot;;
			ZIndex   = 4;
			Make &apos;ImageLabel&apos; {
				Name                   = &quot;Icon&quot;;
				Size                   = UDim2.new(0, 20, 0, 20);
				Position               = UDim2.new(0, 5, 0, 5);
				BackgroundTransparency = 1;
				ZIndex                 = 4;
				Image                  = Images.MenuButtonRegular;
			};
			Make &apos;TextLabel&apos; {
				Name                   = &quot;TextLabel&quot;;
				Position               = UDim2.new(0, 30, 0, 0);
				Size                   = UDim2.new(1, -30, 1, 0);
				BackgroundTransparency = 1;
				Text                   = &quot;Main Menu&quot;;
				ZIndex                 = 4;
				TextColor3             = Color3.new(1, 1, 1);
			}
		}
		Modify(MainMenuButton, Styles.TransparentFrame)

		local BackButton = MainMenuButton:Clone()
		Modify(BackButton, {
			Name = &quot;BackButton&quot;;
			Parent =  CommandBar;
			Position = UDim2.new(0, 10, 0, 5); 
		})
		BackButton.Icon.Image = Images.BackButtonRegular;
		BackButton.TextLabel.Text = &quot;Go Back&quot;;

		return MenuFrame;
	end

	function GenericMenuLevel.OnEntrance(MenuFrame, MenuSystem)
		-- Probably will just hookup events...  (And so it does)

		print(&quot;[MenuSystem] - Disconnecting all events: OnEntrance:&quot;)
		
		GenericMenuLevel.Events:clear()

		local CommandBar = WaitForChild(MenuFrame, &quot;CommandBar&quot;);
		local BackButton = WaitForChild(CommandBar, &quot;BackButton&quot;);
		local MainMenuButton = WaitForChild(CommandBar, &quot;MainMenu&quot;)

		GenericMenuLevel.Events:add(BackButton.MouseButton1Click:connect(function()
			--print(&quot;[MenuSystem] - Back button clicked&quot;);
			if not MenuSystem.Animating then
				MenuSystem:ReduceLevel()
			end
		end))

		GenericMenuLevel.Events:add(BackButton.MouseEnter:connect(function()
			BackButton.Icon.Image = Images.BackButtonOver 
		end))

		GenericMenuLevel.Events:add(BackButton.MouseLeave:connect(function()
			BackButton.Icon.Image = Images.BackButtonRegular 
		end))

		GenericMenuLevel.Events:add(MainMenuButton.MouseEnter:connect(function()
			MainMenuButton.Icon.Image = Images.MenuButtonOver 
		end))

		GenericMenuLevel.Events:add(MainMenuButton.MouseLeave:connect(function()
			MainMenuButton.Icon.Image = Images.MenuButtonRegular
		end))

		GenericMenuLevel.Events:add(MainMenuButton.MouseButton1Click:connect(function()
			--print(&quot;[MenuSystem] - MainMenuButton clicked&quot;);
			if not MenuSystem.Animating then
				MenuSystem:GoToHome()
			end
		end))
	end

	function GenericMenuLevel.OnLeave(MenuFrame, MenuSystem)
		-- WIll only fire if it&apos;s being &quot;left&quot; as in the snse of reducing it&apos;s menu level below this ones. That means if it&apos;s sliding to the right, it won&apos;t fire this,
		-- but sliding to the left will. :)

		print(&quot;[MenuSystem] - Disconnecting all events: OnLeave:&quot;)
		local CommandBar = WaitForChild(MenuFrame, &quot;CommandBar&quot;);
		local BackButton = WaitForChild(CommandBar, &quot;BackButton&quot;);
		local MainMenuButton = WaitForChild(CommandBar, &quot;MainMenu&quot;)

		BackButton.Icon.Image = Images.BackButtonRegular;
		MainMenuButton.Icon.Image = Images.MenuButtonRegular

		GenericMenuLevel.Events:clear()
	end
end)

lib.MakeMenuLevel = MakeGenericMenuLevel;
lib.makeMenuLevel = MakeGenericMenuLevel;

lib.MakeGenericMenuLevel = MakeGenericMenuLevel;
lib.makeGenericMenuLevel = MakeGenericMenuLevel;


local MakeListMenuLevel = class &apos;ListMenuLevel&apos; (function(ListMenuLevel, Title)
	ListMenuLevel.MainMenuFrame = nil;

	local MenuLevelBase = MakeGenericMenuLevel(Title)
	local Buttons = {}
	ListMenuLevel.Buttons = Buttons
	local ButtonHover
	local ButtonHoverHeight
	local ButtonHoverPosition
	local OffsetX = 15

	ListMenuLevel.Events = MenuLevelBase.Events
	ListMenuLevel.ButtonHoverAnimationTime = 0.15

	ListMenuLevel.ButtonEnter = CreateSignal();
	ListMenuLevel.ButtonLeave = CreateSignal();
	ListMenuLevel.ButtonClick = CreateSignal();

	local function UpdateMenuButtons(MenuFrame, ButtonHover)
		local NumberOfMenuButtons = 0;
		ButtonHoverHeight = ButtonHover.AbsoluteSize.Y
		ButtonHoverPosition = ButtonHover.Position;


		for _, Button in pairs(Buttons) do
			if not Button.Gui then
				Button.DisconnectEvents();

				Button.Gui = make &quot;TextButton&quot; {
					Parent = MenuFrame;
					Size = ButtonHover.Size + UDim2.new(0, -OffsetX, 0, 0);
					TextXAlignment = &quot;Left&quot;;
					Position = ButtonHoverPosition + UDim2.new(0, 0, 0, ButtonHoverHeight * (NumberOfMenuButtons)) + UDim2.new(0, OffsetX, 0, 0); 
					ZIndex = 4;
				}
				Modify(Button.Gui, Styles.SubMenuButton);
				Button:Render(Button.Gui);

				Button:AddEvent(Button.OnEnter:connect(function()
					if Button.Gui then
						Modify(Button.Gui, Styles.SubMenuButtonOver)
						local LocalPos = Button.Gui.Position
						ButtonHover:TweenPosition(UDim2.new(0, 0, LocalPos.Y.Scale, LocalPos.Y.Offset), &quot;Out&quot;, &quot;Sine&quot;, ListMenuLevel.ButtonHoverAnimationTime, true)
						ListMenuLevel.ButtonEnter:fire(Button)
					end
				end))

				Button:AddEvent(Button.OnLeave:connect(function()
					if Button.Gui then
						Modify(Button.Gui, Styles.SubMenuButton)
						ListMenuLevel.ButtonLeave:fire(Button)
					end
				end))

				Button:AddEvent(Button.OnClick:connect(function()
					ListMenuLevel.ButtonClick:fire(Button)
				end))

				NumberOfMenuButtons = NumberOfMenuButtons + 1;
			end
		end
	end

	function ListMenuLevel:AddMenuButton(MenuName)
		local NewButton = MakeMenuButton(MenuName)
		table.insert(Buttons, NewButton);

		return NewButton;
	end

	function ListMenuLevel:AddRawButton(NewButton) -- This adds stuff to the main menu level, but expects a raw button. 
		table.insert(Buttons, NewButton);
		--print(&quot;[MenuSystem] [ListMenuLevel] - Added Raw Button &quot; .. NewButton.Name)
		return NewButton;
	end

	function ListMenuLevel.InitialRender()
		local MenuFrame = MenuLevelBase.InitialRender()

		ButtonHover = make &quot;Frame&quot; {
			Size   = UDim2.new(1, 0, 0, 40);
			Position = UDim2.new(0, 0, 0, 100);
			Name   = &quot;ButtonHover&quot;;
			Parent = MenuFrame;
			make &quot;Frame&quot; (Table.CopyAndAppend(Styles.Decoration07, {
				Name     = &quot;Decoration&quot;;
				Position = UDim2.new(1, -5, -20, 0);
				Size     = UDim2.new(0, 2, 20, 0);
				ZIndex   = 2;
			}));
			make &quot;Frame&quot; (Table.CopyAndAppend(Styles.Decoration07, {
				Name     = &quot;Decoration&quot;;
				Position = UDim2.new(1, -5, 1, 0);
				Size     = UDim2.new(0, 2, 20, 0);
				ZIndex   = 2;
			}));
			make &quot;Frame&quot; (Table.CopyAndAppend(Styles.Decoration07, {
				Name     = &quot;DecorationInner&quot;;
				Position = UDim2.new(1, -2, 0, 0);
				Size     = UDim2.new(0, 2, 1, 0);
				ZIndex   = 2;
			}));
		}
		Modify(ButtonHover, Styles.BorderlessFrame09)

		UpdateMenuButtons(MenuFrame, ButtonHover)
		return MenuFrame;
	end

	local function AnimateButtonsIn(SwitchDirection)
		-- Animations the buttons in all nice and smooth. If SwitchDirection is true then they come from the other direction.
		local Side = SwitchDirection and -1 or 1
		if ButtonHover then
			for Index, Button in pairs(Buttons) do
				Button.Gui.Position = ButtonHoverPosition + UDim2.new(Side, 0, 0, ButtonHoverHeight * (Index-1))
			end
			print(&quot;[Menu System] - Animate Buttons In (Submenu) @ &quot;..Side)
			Spawn(function()

				for Index, Button in pairs(Buttons) do
					Button.Gui:TweenPosition((ButtonHoverPosition + UDim2.new(0, 0, 0, ButtonHoverHeight * (Index-1)) + UDim2.new(0, OffsetX, 0, 0)), &quot;Out&quot;, &quot;Elastic&quot;, 1, true)
					wait(0.125)
				end
			end)
		else
			print(&quot;[Menu System] - Failed Animate Buttons In (Submenu), ButtonHovor nil&quot;)
		end
	end

	local function AnimateButtonsOut()
		if ButtonHover then
			print(&quot;[Menu System] - Animate Buttons Out (Submenu)&quot;)
			for Index, Button in pairs(Buttons) do
				delay(0.0625 * (#Buttons - Index), function()
					Button.Gui:TweenPosition((ButtonHoverPosition + UDim2.new(-1, 0, 0, ButtonHoverHeight * (Index-1)) + UDim2.new(0, OffsetX, 0, 0)), &quot;In&quot;, &quot;Elastic&quot;, 0.5, true)
				end)
			end
		else
			print(&quot;[Menu System] - Failed Animate Buttons In (Submenu), ButtonHovor nil&quot;)
		end
	end

	function ListMenuLevel.Show()
		-- When it first becomes visible to the player... But visual elements only. 
		AnimateButtonsIn()
	end

	function ListMenuLevel.ShowBack() 
		-- When going from a higher level (Like 3) to a lower one (Like 2), so buttons should 
		-- translate in cleanerish by coming in the other direction 

		AnimateButtonsIn(true)
	end

	function ListMenuLevel.OnEntrance(MenuFrame, MenuSystem) -- Fires when the list menu is entered (Visible to the player)
		MenuLevelBase.OnEntrance(MenuFrame, MenuSystem)
	end

	function ListMenuLevel.OnLeave(MenuFrame, MenuSystem) -- When the list menu is left (disappears from player&apos;s view)
		MenuLevelBase.OnLeave(MenuFrame, MenuSystem)
	end
end)

lib.MakeListMenuLevel = MakeListMenuLevel
lib.makeListMenuLevel = MakeListMenuLevel;


local MakeMenuSystem = class &apos;MenuSystem&apos; (function(MenuSystem, ScreenGui, Width)

	local MenuButtons = {}
	local NumberOfMenuButtons = 0;
	local CurrentLevels = {} -- Store all of the &quot;GUI Levels&quot; in here. Each level is 1 frame the width of the menu,
	-- so we can slide back and forth (Left and right) per a frame, with each level a... well, level deeper...

	-- Positioning looks like this:
	--[[

    __ __ __ __ __
   |  |  |  |  |  |
   |L0|L1|L2|L3|L4|
   |  |  |  |  |  |
   |__|__|__|__|__|

   However, users can only see 1 level at the time. L0 is the main menu.  When they go to L1, it slides over, so
   it&apos;s now like this
 __ __ __ __ __
|  |  |  |  |  |
|L0|L1|L2|L3|L4|  &lt;-- Translates that way.
|  |  |  |  |  |
|__|__|__|__|__|

	Where only L1 is visible (The rest is hidden by ClipsDescendents. When a user goes back a menu, it deletes all
	the menus in front of that menu, say user is on L4. If they go back to L2, then it&apos;ll clear out L3 and L4, AFTER
	translating, mind you.

	This is because the previous menus are KNOWN, going back a level will result in these menus being still loaded, but
	menus PAST that are arbitrary, and could  easily be different. 

--]]

	MenuSystem.AnimationTime = 0.35;
	MenuSystem.ButtonHoverAnimationTime = 0.15; -- The mouse over sliding thing in the main menu. 
	MenuSystem.AnimationTimeBack = 0.2; -- When returning to home. 
	MenuSystem.CurrentLevel = 0; -- Transitions left and right. 0 is default. 
	MenuSystem.MenuLevelChange = CreateSignal(); 
	MenuSystem.Animating = false;

	MenuSystem.ButtonEnter = CreateSignal() -- For easy styling/sound effects. 
	MenuSystem.ButtonLeave = CreateSignal() 
	MenuSystem.ButtonClick = CreateSignal()
	MenuSystem.GoingHome = CreateSignal()
	MenuSystem.LevelDeeper = CreateSignal() -- When it goes deeper into the section...
	MenuSystem.LevelUpper = CreateSignal() -- And when it goes closer to the top (Level 0)


	MenuSystem.Closing = CreateSignal()
	MenuSystem.Showing = CreateSignal()

	MenuSystem.Guis = {}

	local MainMenuContainer = make &quot;Frame&quot; {
		Archivable       = false;
		ClipsDescendants = true;
		Draggable        = false;
		Visible          = false;
		Name             = &quot;MainMenuContainer&quot;;
		Parent           = ScreenGui;
		Size             = UDim2.new(0, Width, 1, 3); -- Ofset by 3 because of ROBLOX&apos;s weird system where it starts offset a bit from the top of the screen... 
		Position = UDim2.new(0, 0, 0, -3);
	}
	Modify(MainMenuContainer, Styles.TransparentFrame)
	MenuSystem.Guis.MainMenuContainer = MainMenuContainer;


	local MainMenu = make &quot;Frame&quot; {
		Archivable = false;
		Size   = UDim2.new(1,0,1,0);
		Name   = &quot;MainMenu&quot;;
		Parent = MainMenuContainer;
	}
	Modify(MainMenu, Styles.BorderlessFrame07)

	local ButtonHover = make &quot;Frame&quot; {
		Size   = UDim2.new(1, 0, 0, 75);
		Position = UDim2.new(0, 0, 0.2, 0);
		Name   = &quot;ButtonHover&quot;;
		Parent = MainMenu;
		make &quot;Frame&quot; (Table.CopyAndAppend(Styles.Decoration07, {
			Name     = &quot;Decoration&quot;;
			Position = UDim2.new(1, -5, -20, 0);
			Size     = UDim2.new(0, 2, 20, 0);
			ZIndex   = 2;
		}));
		make &quot;Frame&quot; (Table.CopyAndAppend(Styles.Decoration07, {
			Name     = &quot;Decoration&quot;;
			Position = UDim2.new(1, -5, 1, 0);
			Size     = UDim2.new(0, 2, 20, 0);
			ZIndex   = 2;
		}));
		make &quot;Frame&quot; (Table.CopyAndAppend(Styles.Decoration07, {
			Name     = &quot;DecorationInner&quot;;
			Position = UDim2.new(1, -2, 0, 0);
			Size     = UDim2.new(0, 2, 1, 0);
			ZIndex   = 2;
		}));
	}
	Modify(ButtonHover, Styles.BorderlessFrame09)

	local MenuLevelSetLocked = false; -- When true, thene menu won&apos;t animate anywhere. 
	local ButtonHoverHeight = ButtonHover.AbsoluteSize.Y; -- I guess for efficiency? 
	local ButtonHoverPosition = ButtonHover.Position

	local function AnimateToLevel(Level, DoNotAnimate, TransitionTime)
		DoNotAnimate = DoNotAnimate or false;
		TransitionTime = TransitionTime or MenuSystem.AnimationTime;

		local Position = UDim2.new(-Level, 0, 0, 0);

		if DoNotAnimate then
			MainMenu.Position = Position
		else
			MainMenu:TweenPosition(Position, &quot;Out&quot;, &quot;Sine&quot;, TransitionTime, true)
		end
	end

	local AnimationId = 0;

	local function AnimateButtonsIn(Time)
		Time = Time or 0.5;
		print(&quot;[Menu System] - Animate Buttons In&quot;)
		-- Fancy animations in..
		for Index, Button in pairs(MenuButtons) do
			Button.Gui.Position = ButtonHoverPosition + UDim2.new(-1, 0, 0, ButtonHoverHeight * (Index-1))
		end
		local WaitTime = (Time/2)/#MenuButtons
		Spawn(function()
			for Index, Button in pairs(MenuButtons) do
				Button.Gui:TweenPosition((ButtonHoverPosition + UDim2.new(0, 0, 0, ButtonHoverHeight * (Index-1))), &quot;Out&quot;, &quot;Elastic&quot;, Time/2, true)
				wait(WaitTime)
			end
		end)
	end
	local function AnimateButtonsOut(Time)
		print(&quot;[Menu System] - Animate Buttons Out&quot;)
		-- Fancy animations out..
		Time = Time or 0.5;
		local WaitTime = (Time/2)/#MenuButtons
		for Index, Button in pairs(MenuButtons) do
			--print(&quot;[MenuSystem] - Delay @ &quot; .. (0.125 * (#MenuButtons - Index)))
			delay(WaitTime * (#MenuButtons - Index), function()
				Button.Gui:TweenPosition((ButtonHoverPosition + UDim2.new(-1, 0, 0, ButtonHoverHeight * (Index-1))), &quot;In&quot;, &quot;Elastic&quot;, Time/2, true)
			end)
		end
	end

	local function Show(Time)
		--- Show&apos;s the menu, animation it in Time...
		Time = Time or 0.75
		MenuSystem:Render(true)
		MainMenuContainer.Position = UDim2.new(0, -Width, 0, 0)
		MainMenuContainer:TweenPosition(UDim2.new(0, 0, 0, 0), &quot;Out&quot;, &quot;Sine&quot;, Time/3, true)
		for Index, Button in pairs(MenuButtons) do
			Button.Gui.Position = ButtonHoverPosition + UDim2.new(-1, 0, 0, ButtonHoverHeight * (Index-1))
		end
		MainMenuContainer.Visible = true
		wait(Time/6) -- So we&apos;ve used 1/2 after this wait...
		MenuSystem.Showing:fire()
		if MenuSystem.CurrentLevel == 0 then
			AnimateButtonsIn(Time/2)
		end
	end
	MenuSystem.Show = Show

	local function Hide(Time)
		Time = Time or 0.75
		MenuSystem:Render(true)
		if MenuSystem.CurrentLevel == 0 then
			AnimateButtonsOut(Time/2)
		elseif CurrentLevels[MenuSystem.CurrentLevel].Hide then
			CurrentLevels[MenuSystem.CurrentLevel].Hide(Time)
		end
		wait(Time/2)
		MenuSystem.Closing:fire()
		MainMenuContainer:TweenPosition(UDim2.new(0, -Width, 0, 0), &quot;Out&quot;, &quot;Sine&quot;, Time/2, true)
		
	end
	MenuSystem.Hide = Hide

	local function SetLevel(LevelNumber, DoNotAnimate, TransitionTime)  
		-- Sets the menu level, but really not the way I want to implement it... OH WELL. :D

		if not MenuLevelSetLocked then
			--print(&quot;[MenuSystem] - Setting menu level @ &quot;..LevelNumber)
			local OldLevel = MenuSystem.CurrentLevel

			if OldLevel &gt; LevelNumber then
				MenuSystem.LevelUpper:fire(LevelNumber) -- We&apos;re going closer to the top (0)
			else
				MenuSystem.LevelDeeper:fire(LevelNumber)
			end 


			TransitionTime = DoNotAnimate and 0 or (TransitionTime or MenuSystem.AnimationTime);
			MenuSystem.CurrentLevel = LevelNumber;

			Spawn(function()
				AnimationId = AnimationId + 1;
				local CurrentAnimationId = AnimationId;

				MenuSystem.Animating = true
				AnimateToLevel(MenuSystem.CurrentLevel, DoNotAnimate);
				--[[if (not DoNotAnimate) and OldLevel == 0 then
					AnimateButtonsOut()
				else--]]

				if (not DoNotAnimate) and LevelNumber == 0 then
					AnimateButtonsIn()
				elseif (not DoNotAnimate) and OldLevel &lt; LevelNumber then -- Animate in the buttons, all fancy... &gt;:D
					if CurrentLevels[LevelNumber].Show then
						CurrentLevels[LevelNumber].Show()
					end
				elseif (not DoNotAnimate) and OldLevel &gt; LevelNumber then
					if CurrentLevels[LevelNumber].ShowBack then
						CurrentLevels[LevelNumber].ShowBack()
					end
				end

				wait(TransitionTime)
				if CurrentAnimationId == AnimationId then
					--print(&quot;[MenuSystem] - for i=&quot;..OldLevel..&quot;, &quot;..(LevelNumber+1)..&quot;, -1 do&quot;)
					for i=OldLevel, LevelNumber+1, -1 do -- When going backwards, remove them...
						if CurrentLevels[i] then
							--print(&quot;Activating onLeave for CurrentLevels[&quot;..i..&quot;]&quot;)
							local GenericMenuLevel = CurrentLevels[i]
							GenericMenuLevel.OnLeave(GenericMenuLevel.MainMenuFrame, MenuSystem)
							GenericMenuLevel.MainMenuFrame.Parent = nil;
							CurrentLevels[i] = nil;
						else
							print(&quot;[MenuSystem] - CurrentLevels[&quot;..i..&quot;] = nil?&quot;)
						end
					end
					MenuSystem.Animating = false;
					MenuSystem.MenuLevelChange:fire(LevelNumber)
				end
			end)

			return true;
		else
			print(&quot;[MenuSystem] - Menu level lock is enabled, can not set level to &quot;..LevelNumber);
			return false;
		end
	end
	MenuSystem.SetLevel = SetLevel

	function MenuSystem:AddMenuLayer(GenericMenuLevel)
		--print(&quot;[MenuSystem] - Adding Menu Layer&quot;);
		for Index, Value in pairs(CurrentLevels) do
			if Value == GenericMenuLevel then
				error(&quot;MenuLevel &quot;..Index..&quot; has already been added to the MenuSystem&quot;, 2)
			end
		end

		CurrentLevels[MenuSystem.CurrentLevel + 1] = GenericMenuLevel;
		local MainFrame = GenericMenuLevel.MainMenuFrame or GenericMenuLevel.InitialRender()
		Modify(MainFrame, {
			Name = &quot;MenuLevel&quot;..(MenuSystem.CurrentLevel + 1);
			Parent = MainMenu;
			Position = UDim2.new((MenuSystem.CurrentLevel + 1), 0, 0, 0);
		})
		GenericMenuLevel.MainMenuFrame = MainFrame;
		GenericMenuLevel.OnEntrance(MainFrame, MenuSystem);
		SetLevel(MenuSystem.CurrentLevel + 1)
		return GenericMenuLevel
	end

	function MenuSystem:Render(DoNotAnimate, NewWidth)
		--print(&quot;[MenuSystem] - Rendering Menu&quot;);

		Width = NewWidth or Width;

		MainMenuContainer.Size = UDim2.new(0, Width, 1, 2);
		SetLevel(MenuSystem.CurrentLevel, DoNotAnimate)

		for _, Button in pairs(MenuButtons) do
			--print(&quot;[MenuSystem] - Rendering Button &quot;);
			if not Button.Gui then
				--print(&quot;[MenuSystem] - Rendering Button / Making New Button&quot;);
				Button.DisconnectEvents(); 

				Button.Gui = make &quot;TextButton&quot; {
					Parent = MainMenu;
					Size = ButtonHover.Size;
					Position = ButtonHoverPosition + UDim2.new(0, 0, 0, ButtonHoverHeight * (NumberOfMenuButtons));
					ZIndex = 3;
				}
				Modify(Button.Gui, Styles.MenuButton);
				Button:Render(Button.Gui);

				Button:AddEvent(Button.OnEnter:connect(function()
					--print &quot;Button entered&quot;;
					if Button.Gui then
						Modify(Button.Gui, Styles.MenuButtonOver);
						local LocalPos = Button.Gui.Position
						ButtonHover:TweenPosition(UDim2.new(0, 0, LocalPos.Y.Scale, LocalPos.Y.Offset), &quot;Out&quot;, &quot;Sine&quot;, MenuSystem.ButtonHoverAnimationTime, true)
						MenuSystem.ButtonEnter:fire(Button)
					end
				end))

				Button:AddEvent(Button.OnLeave:connect(function()
					if Button.Gui then
						Modify(Button.Gui, Styles.MenuButton);
						MenuSystem.ButtonLeave:fire(Button)
					end
				end))

				Button:AddEvent(Button.OnClick:connect(function()
					MenuSystem.ButtonClick:fire(Button);
				end))

				NumberOfMenuButtons = NumberOfMenuButtons + 1;
			end
		end
	end

	function MenuSystem:ReduceLevel(DoNotAnimate)
		if MenuSystem.CurrentLevel &lt;= 0 then
			error(&quot;MenuSystem is already at home level, can not &apos;reduce level&apos;&quot;, 2)
		else
			SetLevel(MenuSystem.CurrentLevel - 1, DoNotAnimate)
		end
	end

	function MenuSystem:GoToHome(DoNotAnimate)
		SetLevel(0, DoNotAnimate)  
	end



	function MenuSystem:AddMenuButton(MenuName) -- This adds stuff to the main menu level.  
		local NewButton = MakeMenuButton(MenuName)
		table.insert(MenuButtons, NewButton);

		return NewButton;
	end

	function MenuSystem:AddRawButton(NewButton) -- This adds stuff to the main menu level, but expects a raw button. 
		table.insert(MenuButtons, NewButton);

		return NewButton;
	end

	function MenuSystem:GetButtons()
		return Table.Copy(MenuButtons); -- We want to keep our stuff at least fairly secure and clean. 
	end

	function MenuSystem:GetLevel()
		return MenuSystem.CurrentLevel
	end
end)

lib.MakeMenuSystem = MakeMenuSystem;

NevermoreEngine.RegisterLibrary(&apos;MenuSystem&apos;, lib);</ProtectedString>
<bool name="Disabled">true</bool>
</Properties>
</Item>
</Item>
<Item class="Backpack" referent="RBX27">
<Properties>
<string name="Name">OutputStream</string>
</Properties>
<Item class="ModuleScript" referent="RBX28">
<Properties>
<string name="Name">OutputClassStreamLoggers</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local Players           = game:GetService(&quot;Players&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local CircularBuffer    = LoadCustomLibrary(&quot;CircularBuffer&quot;)
local Table             = LoadCustomLibrary(&quot;Table&quot;)

qSystems:Import(getfenv(0));

local lib = {}

-- @author Quenty
-- OutputClassStreamLoggers.lua
-- This script handles some logging stuff for OutputStreams. 
-- Last modified January 26th, 2014

local MakeGlobalOutputStreamLog = Class(function(GlobalOutputStreamLog, BufferSize)
	--- Represents a &quot;stream&quot; that can be subscribbed too. Each stream has it&apos;s own way of
	-- logging data, and filtering it out towards clients. This stream is one that has no
	-- permissions system at all. 
	-- @param [BufferSize] Int, the size of the buffer. Defaults at 100

	-- Output streams can then be syndicated into one window. Windows will subscribe to output
	-- streams. 

		--[[
		Data Specification

		Data		
			string `Parsed`
				Parsed JSON, saved to the data. 
	--]]


	local Logs = CircularBuffer.New(BufferSize or 100)

	function GlobalOutputStreamLog:GetLogs(Client)
		--- Return&apos;s all the logs based upon the client.
		-- @param Client The client retrieving the logs for, can be used to filter out specific players, say
		--               on an admin log.
		-- @pre The data must have a variable called &quot;Parsed&quot; in it, before being logged.
		-- @return A table of parsed JSON logs. 

		local NewData = {}
		for _, Item in pairs(Logs:GetData()) do
			NewData[#NewData + 1] = Item.Parsed
		end
		return NewData
	end

	--[[function GlobalOutputStreamLog:Sendable(Client, Data)
		--- Figures out whether or not the data should be sent to the client. 
		-- @param Client The client to check
		-- @param Data The data to check
		-- @return Boolean true if it should be sent, false otherwise. 

		return true
	end--]]

	function GlobalOutputStreamLog:LogData(Data)
		--- Logs the Data into the Logs. 
		-- @param Data The data to log
		-- Data must contain &quot;Parsed&quot; data type.

		Logs:Add(Data)
	end
end)
lib.MakeGlobalOutputStreamLog = MakeGlobalOutputStreamLog
lib.makeGlobalOutputStreamLog = MakeGlobalOutputStreamLog

local MakePlayerNotificationStreamLog = Class(function(PlayerNotificationStreamLog, BufferSize)
	--- Like a GlobalOutputStreamLog, but it specifically filters it to certain players. It sends temporary
	-- notifications, and should be used to yell at players, but not log anything valuable. 
	-- @param [BufferSize] Int, the size of the buffer. Defaults at 100

	-- Technical issues can occur when the buffer get&apos;s killed, but it shouldn&apos;t matter at all, as
	-- logging here is trivial. 

	--[[
		Data Specification

		Data
			table `FilterList`
				number `userId` -- userId is preferred by 99999999%
				number `userId`
				...
				String `PlayerName`
				String `PlayerName`
				String `PlayerName`
				...

			boolean `Inclusive`
				If this boolean is true, then it will only send to players whose userId or name (Caps sensitive) is in the FilterList
				Otherwise, if it is false, it will send it to any player who is NOT in the filter list. 
			
			string `Parsed`
				Parsed JSON, saved to the data. 
	--]]

	local Logs = CircularBuffer.New(BufferSize or 100)

	function PlayerNotificationStreamLog:GetLogs(Client)
		--- Return&apos;s all the logs based upon the client.
		-- @param Client The client retrieving the logs for, can be used to filter out specific players, say
		--               on an admin log.
		-- @pre The data must have a variable called &quot;Parsed&quot; in it, before being logged.
		-- @return A table of parsed JSON logs. 

		local NewData = {}
		for _, Item in pairs(Logs:GetData()) do
			if PlayerNotificationStreamLog:Sendable(Client, Item) then
				NewData[#NewData+1] = Item.Parsed
			end
		end
		return NewData
	end

	function PlayerNotificationStreamLog:Sendable(Client, Data)
		--- Figures out whether or not the data should be sent to the client. 
		-- @param Client The client to check
		-- @param Data The data to check
		-- @return Boolean true if it should be sent, false otherwise. 

		if Data.FilterList then
			for _, Item in pairs(Data.FilterList) do
				if Item == Client or Item == Client.userId or Item == Client.Name then
					return Data.Inclusive
				end
			end
			return not Data.Inclusive
		else
			-- print(&quot;No filter list. &quot; .. tostring(Data.FilterList) .. &quot;, Data = &quot; .. tostring(Data))
			error(&quot;[PlayerNotificationStreamLog] - Data does not have filter list&quot;)
		end
	end

	function PlayerNotificationStreamLog:LogData(Data)
		--- Logs the Data into the Logs. 
		-- @param Data The data to log
		-- Data must contain &quot;Parsed&quot; data type.

		-- print(&quot;Logging data, Data.FilterList = &quot; .. tostring(Data.FilterList))
		Logs:Add(Data)
	end
end)
lib.MakePlayerNotificationStreamLog = MakePlayerNotificationStreamLog
lib.makePlayerNotificationStreamLog = MakePlayerNotificationStreamLog

local MakeFilteredLogStreamLog = Class(function(FilteredLogStreamLog, BufferSize)
	--- This class filters on a single unit basis. It&apos;s for admin logs and error logs that the general
	-- player should not see. 

	-- @param [BufferSize] Int, the size of the buffer. Defaults at 100

	-- Leaves the caching up the the Filter function. 

	local Logs = CircularBuffer.New(BufferSize or 100)

	function FilteredLogStreamLog:GetLogs(Client)
		--- Return&apos;s all the logs based upon the client.
		-- @param Client The client retrieving the logs for, can be used to filter out specific players, say
		--               on an admin log.
		-- @pre The data must have a variable called &quot;Parsed&quot; in it, before being logged.
		-- @return A table of parsed JSON logs. 

		local NewData = {}
		for _, Item in pairs(Logs:GetData()) do
			if FilteredLogStreamLog:Sendable(Client, Item) then
				NewData[#NewData+1] = Item.Parsed
			end
		end
		return NewData
	end

	function FilteredLogStreamLog:LogData(Data)
		--- Logs the Data into the Logs. 
		-- @param Data The data to log
		-- Data must contain &quot;Parsed&quot; data type.

		Logs:Add(Data)
	end

	function FilteredLogStreamLog:Sendable(Client, Data)
		--- Figures out whether or not the data should be sent to the client. 
		-- @param Client The client to check
		-- @param Data The data to check
		-- @return Boolean true if it should be sent, false otherwise. 

		return Data.Filter(Client)
	end
end)
lib.MakeFilteredLogStreamLog = MakeFilteredLogStreamLog
lib.makeFilteredLogStreamLog = MakeFilteredLogStreamLog

local MakeGlobalFilteredLogStreamLog = Class(function(FilteredLogStreamLog, Filter, BufferSize)
	--- This class filters on a &quot;global&quot; basis. It&apos;s for admin logs and error logs that the general
	-- player should not see. 
	-- @param Filter Function, indicates whether or not a player should be sent the data
		-- function `Filter` ( Player `Client` )
		-- @return boolean `ShouldSend` A boolean, if true, it should send the player the data. 

	-- @param [BufferSize] Int, the size of the buffer. Defaults at 100

	-- Leaves the caching up the the Filter function. 

	local Logs = CircularBuffer.New(BufferSize or 100)

	function FilteredLogStreamLog:GetLogs(Client)
		--- Return&apos;s all the logs based upon the client.
		-- @param Client The client retrieving the logs for, can be used to filter out specific players, say
		--               on an admin log.
		-- @pre The data must have a variable called &quot;Parsed&quot; in it, before being logged.
		-- @return A table of parsed JSON logs. 

		local NewData = {}
		for _, Item in pairs(Logs:GetData()) do
			if FilteredLogStreamLog:Sendable(Client, Item) then
				NewData[#NewData+1] = Item.Parsed
			end
		end
		return NewData
	end

	function FilteredLogStreamLog:LogData(Data)
		--- Logs the Data into the Logs. 
		-- @param Data The data to log
		-- Data must contain &quot;Parsed&quot; data type.

		Logs:Add(Data)
	end

	function FilteredLogStreamLog:Sendable(Client, Data)
		--- Figures out whether or not the data should be sent to the client. 
		-- @param Client The client to check
		-- @param Data The data to check
		-- @return Boolean true if it should be sent, false otherwise. 

		return Filter(Client)
	end
end)
lib.MakeGlobalFilteredLogStreamLog = MakeGlobalFilteredLogStreamLog
lib.makeGlobalFilteredLogStreamLog = MakeGlobalFilteredLogStreamLog

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX29">
<Properties>
<string name="Name">OutputStream</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local Players           = game:GetService(&quot;Players&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems       = LoadCustomLibrary(&quot;qSystems&quot;)
local Table          = LoadCustomLibrary(&quot;Table&quot;)
local RbxUtility     = LoadLibrary(&quot;RbxUtility&quot;)
local CircularBuffer = LoadCustomLibrary(&quot;CircularBuffer&quot;)

qSystems:Import(getfenv(0));

local lib = {}

--[[-- Change Log

January 27th, 2014
- Fixed logging
- Added change log

January 26th, 2014
- Initial rewrite


--]]

--[[
This is an improved version of RenderStream, and focuses upon improving the
reliability of the program, as well as the flexibility. 

Logging and Filtering
- Subscription services?


HOW IT WORKS
------------

Stuff is classified by how it&apos;s suppose to display. That is, each &quot;display item&quot; has three different things
- Parser
- Render

Each Stream has it&apos;s own log, which also filters out players. 

Now, streams can (and will be) syndicated by the OutputStreamSyndicator (on the client).
Streams can thus filter out data, but also maintain a coherent &quot;overview&quot; on the client.

Streams can even be reused in different syndications (OutputStreamSyndicator) so admin logs, say
can go into a global server output log, and also into an admin log thing.

The thing is, the logger or whatever is on the server is still MAINTAINED per a stream per a class.

It&apos;s all very haxy and inefficient, maybe, but the only way I could figure out how to do it while
maintaining every single condition. 
--]]

local ParserUIDCounter = 0;

local function GetUID()
	--- Return&apos;s a UID (Unique ID) for the chat parser to use.
	ParserUIDCounter = ParserUIDCounter + 1
	return ParserUIDCounter
end

local MakeOutputParser = Class(function(OutputParser, Parse, Unparse)
	--- Parses and deparses data between transit. 
	-- @param Parse Lua function 
		-- Parse( Table `Data`)
			--- Returns a Table of the data to be sent over.
		-- Unparse( Table `Data`)
			--- Return&apos;s a Table of the deparsed data


	function OutputParser.Parse(OutputClassName, Data)
		--- Parses the Data into a packet, adds 3 elements.
		-- @return Data
			-- Data will have these items in it
			-- ClassName (String)
			-- UID (Number)
			-- TimeStamp (Number)
			-- Parsed (Table, parsed Data)

		Data.ClassName = OutputClassName
		Data.UID = GetUID()
		Data.TimeStamp = tick()

		local Parsed = Parse(Data)

		Parsed.ClassName = OutputClassName
		Parsed.UID = Data.UID
		Parsed.TimeStamp = Data.TimeStamp

		Data.Parsed = Parsed

		return Data
	end

	OutputParser.Unparse = Unparse
	-- Will simply mutate Data
end)
lib.MakeOutputParser = MakeOutputParser
lib.makeOutputParser = MakeOutputParser

local MakeOutputClass = Class(function(OutputClass, Name, Parser, Render)
	--- Represents a type of output to render. 
	
	OutputClass.Name = Name
	OutputClass.Parser = Parser
	OutputClass.Render = Render
end)
lib.MakeOutputClass = MakeOutputClass
lib.makeOutputClass = MakeOutputClass

local MakeOutputStreamServer = Class(function(OutputStreamServer, Logger, StreamName)
	--- Handles connections send and receive, and brings all the classes together.
	-- @param Logger A logger, should have the following properties.
		-- :GetLogs(Client)
		-- :LogData(Data)
		-- [:Sendable](Client, Data)
	-- OutputClassStreamLoggers.lua as some examples. 

	-- Client subscribes to any OutputStreamServer
	--  --&gt; Updates get pushed to client. 

	OutputStreamServer.Name = StreamName

	local DataStream = NevermoreEngine.GetDataStream(StreamName)
	local EventStream = NevermoreEngine.GetEventStream(StreamName)

	local OutputClasses = {}

	local function GetOutputClass(OutputClassName)
		return OutputClasses[OutputClassName:lower()]
	end

	local function AddOutputClass(OutputClass)
		--- Adds the OutputClass to the system so it can be used. Could be called &quot;Create&quot; but it doesn&apos;t really create it.
		-- @param OutputClass The class itself. 

		local OutputClassName = OutputClass.Name

		if not GetOutputClass(OutputClassName) then
			OutputClasses[OutputClassName:lower()] = OutputClass
		else
			error(&quot;[OutputStreamServer] - StreamName &quot; .. OutputClassName .. &quot; is already registered. &quot;)
		end
	end
	OutputStreamServer.AddOutputClass = AddOutputClass
	OutputStreamServer.addOutputClass = AddOutputClass

	local function Send(OutputClassName, Data)
		--- Constructs a new OutputStream item and then sends it to the appropriate places.

		local OutputClass = GetOutputClass(OutputClassName)
		if OutputClass then
			-- print(&quot;Filter list [0.5] @ Send &quot; .. tostring(Data.FilterList) .. &quot;, Data = &quot; .. tostring(Data))
			OutputClass.Parser.Parse(OutputClassName, Data)
			assert(Data.Parsed ~= nil, &quot;Data.Parsed is nil&quot;)
			-- print(&quot;Filter list [1] @ Send &quot; .. tostring(Data.FilterList) .. &quot;, Data = &quot; .. tostring(Data))
			if Logger.Sendable then
				for _, Player in pairs(Players:GetPlayers()) do

					-- print(&quot;Filter list [2] @ Send &quot; .. tostring(Data.FilterList) .. &quot;, Data = &quot; .. tostring(Data))
					if Logger:Sendable(Player, Data) then
						EventStream.Fire(Player, &quot;Push&quot;, OutputClassName, Data.Parsed)
					end
				end
			else
				EventStream.FireAllClients(&quot;Push&quot;, OutputClassName, Data.Parsed)
			end

			Logger:LogData(Data)
		else
			error(&quot;[OutputStreamServer] - OutputClass &apos;&quot; .. OutputClassName .. &quot;&apos; is not registered.&quot;)
		end
		-- print(&quot;Done sending data.&quot;)
	end
	OutputStreamServer.Send = Send
	OutputStreamServer.send = Send

	DataStream.RegisterRequestTag(&quot;Pull&quot;, function(Client)
		return Logger:GetLogs(Client)
	end)
end)
lib.MakeOutputStreamServer = MakeOutputStreamServer
lib.makeOutputStreamServer = MakeOutputStreamServer

local MakeOutputStreamClient = Class(function(OutputStreamClient, StreamName)
	--- Manages connections, on the client, and subscriptions. Should be reconstructed after every reset. 
	-- @param StreamName The name of the Stream, string. Should be unique, as it will construct a new DataStream and EventStream from it.
	
	assert(type(StreamName) == &quot;string&quot;, &quot;[OutputStreamClient] - StreamName is a &apos;&quot; .. type(StreamName) .. &quot;&apos; tostring() == &quot; .. tostring(StreamName))

	local DataStream = NevermoreEngine.GetDataStream(StreamName)
	local EventStream = NevermoreEngine.GetEventStream(StreamName)

	OutputStreamClient.Name = StreamName

	local OutputClasses = {}
	local OutputClassesSignals = {}

	OutputStreamClient.NewItem = CreateSignalInternal()

	local function GetOutputClass(OutputClassName)
		return OutputClasses[OutputClassName:lower()]
	end

	local function AddOutputClass(OutputClass)
		--- Adds the OutputClass to the system so it can be used. 
		-- @param OutputClass The class itself. 

		local OutputClassName = OutputClass.Name
		
		if not GetOutputClass(OutputClassName) then
			OutputClasses[OutputClassName:lower()] = OutputClass
		else
			error(&quot;[OutputStreamClient] - StreamName &quot; .. OutputClassName .. &quot; is already registered. &quot;)
		end
	end
	OutputStreamClient.AddOutputClass = AddOutputClass
	OutputStreamClient.addOutputClass = AddOutputClass

	EventStream.RegisterRequestTag(&quot;Push&quot;, function(OutputClassName, Data)

		assert(Data.TimeStamp ~= nil, &quot;TimeStamp is nil&quot;)

		local OutputClass = GetOutputClass(OutputClassName)
		if OutputClass then
			OutputClass.Parser.Unparse(Data)
			OutputStreamClient.NewItem:fire(OutputClass, Data)
		else
			Warn(&quot;[OutputStreamClient] - No OutputStream class for &apos;&quot; .. tostring(OutputClassName) .. &quot;&apos;&quot;)
		end
	end)


	local function GetLogs()
		--- Takes all the logs from all the classes

		local Logs = DataStream.Call(&quot;Pull&quot;)
		if Logs then
			local UnparsedLogs = {}
			for Index, Item in pairs(Logs) do
				local Class = GetOutputClass(Item.ClassName)
				if Class then
					Class.Parser.Unparse(Item)
					UnparsedLogs[#UnparsedLogs+1] = {
						Data = Item;
						OutputClass = Class;
					}
				else
					Warn(&quot;[OutputStreamClient] - Class &apos;&quot; .. Item.ClassName .. &quot;&apos; is not registered!&quot;)
				end
			end
			return UnparsedLogs, true
		else
			Warn(&quot;Could not retrieve logs!&quot;)
			return {}, false
		end
	end
	OutputStreamClient.GetLogs = GetLogs
	OutputStreamClient.getLogs = GetLogs

	local function GetSortedLogs()
		--- Sorts by TimeStamp
		local UnparsedLogs, Success = GetLogs()
		table.sort(UnparsedLogs, function(A, B)
			return A.Data.TimeStamp &lt; B.Data.TimeStamp
		end)
		return UnparsedLogs
	end
	OutputStreamClient.GetSortedLogs = GetSortedLogs
	OutputStreamClient.getSortedLogs = GetSortedLogs
end)
lib.MakeOutputStreamClient = MakeOutputStreamClient
lib.makeOutputStreamClient = MakeOutputStreamClient

_G.OutputSyndicatedLogs = {}
local LoggerDatabase = _G.OutputSyndicatedLogs

local MakeOutputStreamSyndicator = Class(function(OutputStreamSyndicator, Name, BufferSize)
	--- Managers multiple streams being synced into one. Caches data so chat loads fast on respawn. Used on the client only.
	-- @param Name The name of the Syndictator, purely for technical reasons. If no name is given, one will be generated.
	-- @param [BufferSize] Size of the Cached Buffer to use. 

	BufferSize = BufferSize or 100

	OutputStreamSyndicator.Name = Name or tostring(&quot;[ &quot; .. OutputStreamSyndicator ..&quot; ]&quot;)
	local OutputStreams = {}
	OutputStreamSyndicator.NewItem = CreateSignalInternal()

	local function GetOutputStream(StreamName)
		return OutputStreams[StreamName:lower()]
	end

	local function AddOutputStream(OutputStreamClient)

		local OutputStreamClientName = OutputStreamClient.Name
		if not GetOutputStream(OutputStreamClientName) then
			OutputStreams[OutputStreamClientName] = OutputStreamClient

			OutputStreamClient.NewItem:connect(function(OutputClass, Data)
				OutputStreamSyndicator.NewItem:fire(OutputStreamClient, OutputClass, Data)
				-- CircularBuffer:Add(
				-- {
					-- Data        = Data;
					-- OutputClass = OutputClass;
				-- })
			end)
		else
			error(&quot;[OutputStreamSyndicator] - Cannot add OutputStreamClient &apos;&quot; .. OutputStreamClientName .. &quot;&apos; as is already is added. &quot;)
		end
	end
	OutputStreamSyndicator.AddOutputStream = AddOutputStream
	OutputStreamSyndicator.addOutputStream = AddOutputStream

	local function GetSyndicatedLogs(NoCache)
		--- NOTE: CACHING NOT APPLIED

		--- Syndicates all the logs together and sorts by time stamp.
		-- @param NoCache Boolean, if true, does not use cached data. 
		-- @return CircularBuffer with the logs in it. 

		-- if NoCache or not LoggerDatabase[Name] then
			local LogList = {}
			for _, Item in pairs(OutputStreams) do
				local Logs = Item:GetLogs()
				for _, Item in pairs(Logs) do
					LogList[#LogList+1] = Item
				end
			end

			--- We have to sort if we get more results back than we need?
			table.sort(LogList, function(A, B)
				return A.Data.TimeStamp &lt; B.Data.TimeStamp
			end)

			if #LogList &gt; BufferSize then
				-- Cull list size.
				local NewList = {}

				for Index = #LogList, #LogList - 100, -1 do
					NewList[#NewList+1] = LogList[Index]
				end
				LogList = NewList

				return NewList
			end

			return LogList
			-- LoggerDatabase[Name] = CircularBuffer.new(BufferSize, LogList)
		-- end

		-- return LoggerDatabase[Name]
	end
	OutputStreamSyndicator.GetSyndicatedLogs = GetSyndicatedLogs
	OutputStreamSyndicator.getSyndicatedLogs = GetSyndicatedLogs
end)
lib.MakeOutputStreamSyndicator = MakeOutputStreamSyndicator
lib.makeOutputStreamSyndicator = MakeOutputStreamSyndicator

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX30">
<Properties>
<string name="Name">OutputStreamInterface</string>
<ProtectedString name="Source">local ReplicatedStorage       = game:GetService(&quot;ReplicatedStorage&quot;)
local Players                 = game:GetService(&quot;Players&quot;)

local NevermoreEngine         = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary       = NevermoreEngine.LoadLibrary

local qSystems                = LoadCustomLibrary(&quot;qSystems&quot;)
local ScrollBar               = LoadCustomLibrary(&apos;ScrollBar&apos;)
local qGUI                    = LoadCustomLibrary(&apos;qGUI&apos;)
local CircularBuffer          = LoadCustomLibrary(&quot;CircularBuffer&quot;)
local PseudoChatSettings      = LoadCustomLibrary(&quot;PseudoChatSettings&quot;)
local OverriddenConfiguration = LoadCustomLibrary(&quot;OverriddenConfiguration&quot;)
local qTime = LoadCustomLibrary(&quot;qTime&quot;)

qSystems:Import(getfenv(0));

local lib = {}

--- OutputStreamInterface.lua
--- This library handles displaying render streams, from multiple channels.
-- @author Quenty
-- Last modified Janurary 26th, 2014

--[[--Change Log

-- January 26th, 2014
- Add Change log
- Update to use PseudoChatSettings

-- January 5th, 2014
- Wrote initial script

--]]
local DefaultConfiguration = {
	TitleWidth            = 30;
	ContentHeight         = 108; -- Height of the inteface. 
	ScrollbarWidth        = 7;
	ZIndex                = 8;
	FrameRenderBufferSize = 100;
	
	TitleLabelOffset = 10;
	MenuZIndex       = 9; -- ZIndex of the menu overlay. We&apos;ll try to maintain a [8,9] ZIndex range. 
	MenuAnimateTime  = 0.2;
	MenuDefaultColor = Color3.new(0.5, 0.5, 0.5);
	MenuNameWhenOpen = &quot;Switch Channels?&quot;;
}

local MakeOutputStreamMenu = Class(function(RenderStreamMenu, Parent, ScreenGui, Configuration)
	--- Creates a list of open &quot;Channels&quot; which can be dynamically changed and modified. 
	-- @param OutputStreamInterface The interface that this stream menu is associated with. 
	-- Used internally, Configuration is expected to be sent by the script, all contents intact.

	local MainFrame = Make &apos;Frame&apos; {
		Active                 = false;
		Archivable             = false;
		BackgroundColor3       = Color3.new(0.25, 0.25, 0.25);
		BackgroundTransparency = 0;
		BorderSizePixel        = 1;
		Name                   = &quot;MenuFrame&quot;;
		Position               = UDim2.new(0.5, 0, 0, 0);
		Size                   = UDim2.new(0.5, 0, 1, 0);
		ZIndex                 = Configuration.MenuZIndex;
		Parent                 = Parent;
	}
	RenderStreamMenu.Gui = MainFrame

	local TitleButton = Make &apos;ImageButton&apos; {
		Archivable       = false;
		BackgroundColor3 = Color3.new(0.25, 0.25, 0.25);
		BorderSizePixel  = 0;
		Name             = &quot;TitleButton&quot;;
		Parent           = MainFrame;
		Position         = UDim2.new(0, -Configuration.TitleWidth, 0, 0);
		Size             = UDim2.new(0, Configuration.TitleWidth, 1, 0);
		ZIndex           = Configuration.MenuZIndex;
	}

	local TitleLabel = Make &apos;TextLabel&apos; {
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Name                   = &quot;TitleLabel&quot;;
		Parent                 = TitleButton;
		Rotation               = 90;
		Size                   = UDim2.new(0, TitleButton.AbsoluteSize.Y - Configuration.TitleLabelOffset, 0, Configuration.TitleWidth);
		Text                   = &quot;Main Menu&quot;;
		TextColor3             = Color3.new(1, 1, 1);
		TextXAlignment         = &quot;Right&quot;;
		ZIndex                 = Configuration.MenuZIndex;
	}
	TitleLabel.Position = UDim2.new(0.5, -(TitleButton.AbsoluteSize.Y) / 2, 0.5, -(Configuration.TitleWidth) / 2);

	local ContentContainer = Make &apos;Frame&apos; {
		Active                 = false;
		BackgroundTransparency = 1;
		ClipsDescendants       = true;
		Name                   = &quot;ContentContainer&quot;;
		Parent                 = MainFrame;
		Position               = UDim2.new(0, 0, 0, 0);
		Size                   = UDim2.new(1, -Configuration.ScrollbarWidth, 1, 0);
		ZIndex                 = Configuration.MenuZIndex;
		Archivable             = false;
	}

	local ContentFrame = Make &apos;ImageButton&apos; {
		Image                  = &quot;&quot;; 
		Active                 = false;
		BackgroundTransparency = 1;
		ClipsDescendants       = true;
		Name                   = &quot;ContentFrame&quot;;
		Parent                 = ContentContainer;
		Position               = UDim2.new(0, 0, 0, 0);
		Size                   = UDim2.new(1, 0, 1, 0);
		ZIndex                 = Configuration.MenuZIndex;
		Archivable             = false;
	}

	local ScrollBarFrame = Make &apos;Frame&apos; {
		BackgroundTransparency = 1;
		BorderSizePixel        = 0; 
		Name                   = &quot;ScrollBarFrame&quot;;
		Parent                 = MainFrame;
		Position               = UDim2.new(1, -Configuration.ScrollbarWidth, 0, 0);
		Size                   = UDim2.new(0, Configuration.ScrollbarWidth, 1, 0);
		Visible                = true;
		ZIndex                 = Configuration.MenuZIndex;
		Archivable             = false;
	}

	local Scroller = ScrollBar.MakeScroller(ContentContainer, ContentFrame, ScreenGui, &apos;Y&apos;)
	local ScrollBar = Scroller:AddScrollBar(ScrollBarFrame)
	local IsShown = false
	local CurrentColor = Color3.new(0.25, 0.25, 0.25);
	local CurrentTitle = &quot;[ Nothing Active ]&quot;
	local ActiveChoices = {}

	RenderStreamMenu.MenuCollapseChanged = CreateSignal() -- Sends Signal(IsCollapsed)

	local function UpdateChoices()
		--- Repositions and updates the choices to new locations. 

		local YPosition = 0;
		for _, Choice in pairs(ActiveChoices) do
			Choice.Gui.Position = UDim2.new(0, PseudoChatSettings.RenderStreamMenu.ChoiceSizeXPadding/2,
				0, YPosition);
			YPosition = YPosition + PseudoChatSettings.RenderStreamMenu.ChoiceYPadding + Choice.YHeight
		end
		ContentFrame.Size = UDim2.new(1, 0, 0, math.max(YPosition, ContentContainer.AbsoluteSize.Y))

		if YPosition &gt; ContentContainer.AbsoluteSize.Y then
			ScrollBarFrame.Visible = true
		else
			ScrollBarFrame.Visible = false
		end
	end

	local function UpdateTitleBar(BackgroundColor3, Text, DoNotAnimate)
		--- Sets the TitleBar, helper function
		-- @param BackgroundColor3 The new backgroundColor3 to set
		-- @param Text The text to set
		-- @param DoNotAnimate Shoudl it animate or not?

		TitleLabel.Text = Text;

		if DoNotAnimate then
			TitleButton.BackgroundColor3 = BackgroundColor3
		else
			qGUI.TweenColor3(TitleButton, {BackgroundColor3 = BackgroundColor3}, Configuration.MenuAnimateTime, true)
		end
	end

	local MouseEvent
	local Mouse = Players.LocalPlayer:GetMouse()


	local function Uncollapse(DoNotAnimate)
		--- Show&apos;s the menu
		-- @param [DoNotAnimate] If indicated, will not animate the menu when showing or hiding. 

		-- If they don&apos;t click on the menu, hide it.
		if not MouseEvent then
			MouseEvent = Mouse.Button1Down:connect(function()
				if not qGUI.MouseOver(Mouse, MainFrame) and not qGUI.MouseOver(Mouse, MainFrame) then
					RenderStreamMenu.Collapse()
				end
			end)
		end

		IsShown = true
		local Position = UDim2.new(0.5, 0, 0, 0)
		UpdateTitleBar(Configuration.MenuDefaultColor, Configuration.MenuNameWhenOpen, DoNotAnimate)

		if DoNotAnimate then
			MainFrame.Position = Position
		else
			MainFrame:TweenPosition(Position, &quot;Out&quot;, &quot;Sine&quot;, Configuration.MenuAnimateTime, true)
		end

		RenderStreamMenu.MenuCollapseChanged:fire(false)
	end
	RenderStreamMenu.Uncollapse = Uncollapse
	RenderStreamMenu.uncollapse = Uncollapse

	local function Collapse(DoNotAnimate)
		--- Hide&apos;s the menu
		-- @param [DoNotAnimate] If indicated, will not animate the menu when showing or hiding. 

		if MouseEvent then
			MouseEvent:disconnect()
			MouseEvent = nil
		end

		IsShown = false
		local Position = UDim2.new(1, 0, 0, 0)
		UpdateTitleBar(CurrentColor, CurrentTitle, DoNotAnimate)

		if DoNotAnimate then
			MainFrame.Position = Position
		else
			MainFrame:TweenPosition(Position, &quot;Out&quot;, &quot;Sine&quot;, Configuration.MenuAnimateTime, true)
		end

		RenderStreamMenu.MenuCollapseChanged:fire(true)
	end
	RenderStreamMenu.Collapse = Collapse
	RenderStreamMenu.Collapse = Collapse

	local CurrentTransparency

	local function SetTransparency(NewTransparency, AnimateTime)
		--- Sets the transparency of the Interface to NewTransparency
		-- @param NewTransparency The transparency to set it to
		-- @param AnimateTime The time to animate. If not provided, will do it instantly. 

		assert(NewTransparency ~= nil, &quot;NewTransparency is nil.&quot;)

		if CurrentTransparency ~= NewTransparency then -- Make sure we don&apos;t waste processing power. 
			CurrentTransparency = NewTransparency
			if AnimateTime then
				qGUI.TweenTransparency(MainFrame, {BackgroundTransparency = NewTransparency}, AnimateTime, true)
				qGUI.TweenTransparency(TitleButton, {BackgroundTransparency = NewTransparency}, AnimateTime, true)
				qGUI.TweenTransparency(TitleLabel, {TextTransparency = NewTransparency}, AnimateTime, true)
				for _, Item in pairs(ActiveChoices) do
					qGUI.TweenTransparency(Item.Gui, {BackgroundTransparency = NewTransparency}, AnimateTime, true)
					qGUI.TweenTransparency(Item.Gui.ChoiceLabel, {TextTransparency = NewTransparency}, AnimateTime, true)
				end
			else
				qGUI.StopTransparencyTween(MainFrame)
				qGUI.StopTransparencyTween(TitleButton)
				qGUI.StopTransparencyTween(TitleLabel)
				MainFrame.BackgroundTransparency = NewTransparency
				TitleButton.BackgroundTransparency = NewTransparency
				TitleLabel.TextTransparency = NewTransparency
				for _, Item in pairs(ActiveChoices) do
					qGUI.StopTransparencyTween(Item.Gui) 
					qGUI.StopTransparencyTween(Item.Gui.ChoiceLabel)

					Item.Gui.BackgroundTransparency = NewTransparency
					Item.Gui.ChoiceLabel.BackgroundTransparency = NewTransparency
				end
			end
		end
	end
	RenderStreamMenu.SetTransparency = SetTransparency
	RenderStreamMenu.setTransparency = SetTransparency

	local function SetColorAndTitle(Color, Title)
		-- Sets the color and title of the Menu that it will display while &quot;Hidden.&quot; &quot;
		-- @param Color A Color3, the color of the menu to set.
		-- @param Title The title to show.

		CurrentColor = Color
		CurrentTitle = Title
		if not IsShown then
			UpdateTitleBar(Color, Title)
		end
	end
	RenderStreamMenu.SetColorAndTitle = SetColorAndTitle
	RenderStreamMenu.setColorAndTitle = SetColorAndTitle


	local function Toggle(DoNotAnimate)
		--- Toggle&apos;s the menu&apos;s visibility. 
		-- @param [DoNotAnimate] If indicated, will not animate the menu when showing or hiding. 

		if IsShown then
			Collapse(DoNotAnimate)
		else
			Uncollapse(DoNotAnimate)
		end
	end
	RenderStreamMenu.Toggle = Toggle
	RenderStreamMenu.toggle = Toggle

	local function MakeChoice(Text, BackgroundColor3)
		--- Creates a new &quot;Choice&quot; GUI, for further manipulation.
		-- @param [BackgroundColor3] The color3 value of the background
		-- @param Text The text to display on the button.
		-- @return The new choice

		BackgroundColor3 = BackgroundColor3 or Color3.new(0, 0, 0)

		local NewChoice = {}

		NewChoice.BackgroundColor3 = BackgroundColor3
		NewChoice.Text = Text
		
		NewChoice.Gui = Make &apos;TextButton&apos; {
			Archivable             = false;
			BackgroundColor3       = BackgroundColor3;
			BackgroundTransparency = 0.3;
			BorderSizePixel        = 0;
			FontSize               = PseudoChatSettings.ChatFontSize;
			Name                   = &quot;ChoiceButton&quot;;
			Parent                 = ContentFrame;
			Size                   = UDim2.new(1, -PseudoChatSettings.RenderStreamMenu.ChoiceSizeXPadding, 0, PseudoChatSettings.RenderStreamMenu.ChoiceSizeY);
			Text                   = &quot;&quot;;
			Visible                = true;
			ZIndex                 = Configuration.MenuZIndex;
			Make &apos;TextLabel&apos; {
				BackgroundTransparency = 1;
				BorderSizePixel        = 0;
				Name                   = &quot;ChoiceLabel&quot;;
				Position               = UDim2.new(0, 10, 0, 0);
				Size                   = UDim2.new(1, -10, 1, 0);
				Text                   = Text;
				TextColor3             = Color3.new(1, 1, 1);
				TextXAlignment         = &quot;Left&quot;;
				ZIndex                 = Configuration.MenuZIndex
			}
		}
		NewChoice.YHeight = PseudoChatSettings.RenderStreamMenu.ChoiceSizeY

		ActiveChoices[#ActiveChoices + 1] = NewChoice

		function NewChoice:Destroy()
			-- For the GC of the choice.

			local Index = GetIndexByValue(ActiveChoices, NewChoice)

			NewChoice.Gui:Destroy()
			NewChoice.Destroy = nil
			NewChoice         = nil

			table.remove(ActiveChoices, Index)
			UpdateChoices()
		end

		UpdateChoices()
		return NewChoice
	end
	RenderStreamMenu.MakeChoice = MakeChoice
	RenderStreamMenu.makeChoice = MakeChoice

	local function GetIsShown()
		return IsShown
	end
	RenderStreamMenu.GetIsShown = GetIsShown
	RenderStreamMenu.getIsShown = GetIsShown

	-- Setup events
	TitleButton.MouseButton1Click:connect(function()
		Toggle()
	end)

	Collapse(true)
	UpdateChoices()
end)

local MakeNotifier = Class(function(Notifier, ContentContainer, IsTop)
	-- Used by the OutputStreamRender, creates a notification bar.
	-- @param ContentContainer The parent of the NotificationBar
	-- @param IsTop Boolean, if true, then it goes at the top, otherwise it goes to the top.

	local Configuration = {
		Height = 25;
		ZIndex = DefaultConfiguration.ZIndex + 1;
	}

	local NotificationBar = Make &apos;ImageButton&apos; {
		Visible                = true;
		BackgroundTransparency = 0;
		Parent                 = ContentContainer;
		Name                   = &quot;Notification&quot;;
		BorderSizePixel        = 0;
		BackgroundColor3       = Color3.new(51/255, 102/255, 204/255);
		Size                   = UDim2.new(1, 0, 0, Configuration.Height);
		Position               = UDim2.new(0, 0, 1, 0);
		Archivable             = false;
		ZIndex                 = Configuration.ZIndex;
	}
	Notifier.Gui = NotificationBar

	local TextLabel = Make &apos;TextLabel&apos; {
		Parent                 = NotificationBar;
		TextColor3             = Color3.new(1, 1, 1);
		Size                   = UDim2.new(1, -10, 1, 0);
		Position               = UDim2.new(0, 10, 0, 0);
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Visible                = true;
		Archivable             = false;
		ZIndex                 = NotificationBar.ZIndex;
		Text                   = &quot;&quot;;
		TextXAlignment         = &quot;Left&quot;;
	}

	local IsVisible
	local ShowPosition
	local HidePosition

	if IsTop then
		ShowPosition = UDim2.new(0, 0, 0, 0)
		HidePosition = UDim2.new(0, 0, 0, -Configuration.Height);
	else
		ShowPosition = UDim2.new(0, 0, 1, -Configuration.Height)
		HidePosition = UDim2.new(0, 0, 1, 0);
	end

	local function Show(DoNotAnimate)
		--- Show&apos;s the Notification bar. Updates the IsVisible variable to true
		-- @param DoNotAnimate Boolean, if true, then it will not animate when showing, otherwise it will tween

		IsVisible = true

		if DoNotAnimate then
			NotificationBar.Position = ShowPosition
		else	
			NotificationBar:TweenPosition(ShowPosition, &quot;Out&quot;, &quot;Sine&quot;, 0.2, true)
		end
	end
	Notifier.Show = Show

	local function Hide(DoNotAnimate)
		--- Hide&apos;s the Notification bar. Updates the IsVisible variable to false
		-- @param DoNotAnimate Boolean, if true, then it will not animate when hiding, otherwise it will tween

		IsVisible = false

		if DoNotAnimate then
			NotificationBar.Position = HidePosition
		else
			NotificationBar:TweenPosition(HidePosition, &quot;In&quot;, &quot;Sine&quot;, 0.2, true)
		end
	end
	Notifier.Hide = Hide

	local function SetText(NewText)
		if not IsVisible then
			Show()
		end

		TextLabel.Text = NewText;
	end
	Notifier.SetText = SetText

	Hide(true)
end)

local MakeOutputStreamRender = Class(function(OutputStreamRender, Configuration, ScreenGui)
	--- Render&apos;s a single stream, actual &quot;view&quot; model versus DataStreamRender conceptual model. 
	-- @param FrameRenderBufferSize Number The amount of frames to render.
	--                              This get&apos;s kind of messy when it comes down to it, because a render can be used by multiple
	--                              classes. A standardized number should be used. 

	local Configuration = OverriddenConfiguration.New(Configuration, DefaultConfiguration)
	local Buffer   = CircularBuffer.New(Configuration.FrameRenderBufferSize)
	OutputStreamRender.Buffer = Buffer
	-- Make the new frame containing the whole thing. Will also hold the scroll bar. 
	local MainFrame = Make &apos;Frame&apos; {
		Active                 = false;
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Name                   = &quot;OutputStreamRender&quot;;
		Size                   = UDim2.new(1, 0, 1, 0);
		ZIndex                 = Configuration.ZIndex;
		Archivable             = false;
	}
	OutputStreamRender.Gui = MainFrame

	local ContentContainer = Make &apos;Frame&apos; {
		Active                 = false;
		BackgroundTransparency  = 1;
		ClipsDescendants       = true;
		Name                   = &quot;ContentContainer&quot;;
		Parent                 = MainFrame;
		Position               = UDim2.new(0, 0, 0, 0);
		Size                   = UDim2.new(1, -Configuration.ScrollbarWidth, 1, 0);
		ZIndex                 = Configuration.ZIndex;
	}

	local ContentFrame = Make &apos;ImageButton&apos; {
		Image                  = &quot;&quot;; 
		Active                 = false;
		BackgroundTransparency = 1;
		ClipsDescendants       = true;
		Name                   = &quot;ContentFrame&quot;;
		Parent                 = ContentContainer;
		Position               = UDim2.new(0, 0, 0, 0);
		Size                   = UDim2.new(1, 0, 1, 0);
		ZIndex                 = Configuration.ZIndex;
	}
	OutputStreamRender.ContentFrame = ContentFrame

	local ScrollBarFrame = Make &apos;Frame&apos; {
		BackgroundTransparency = 1;
		BorderSizePixel        = 0; 
		Name                   = &quot;ScrollBarFrame&quot;;
		Parent                 = MainFrame;
		Position               = UDim2.new(1, -Configuration.ScrollbarWidth, 0, 0);
		Size                   = UDim2.new(0, Configuration.ScrollbarWidth, 1, 0);
		Visible                = true;
		ZIndex                 = Configuration.ZIndex;
		Archivable             = false;
	}

	local NotifierTop = MakeNotifier(ContentContainer, true)
	local NotifierBottom = MakeNotifier(ContentContainer, false)

	local Scroller          = ScrollBar.MakeScroller(ContentContainer, ContentFrame, ScreenGui, &apos;Y&apos;)
	OutputStreamRender.Scroller = Scroller
	local ScrollBar         = Scroller:AddScrollBar(ScrollBarFrame)
	local ScrollBarAtBottom = true
	local IsScrolling       = false
	local IsAutoScrolling = false -- Is the porgram scrolling by itself? 

	local function IsItemGuiVisible(Gui)
		--- Calculates whether or not the player can see the label.
		-- Used internally.

		if MainFrame.Visible then
			local PositionY = Gui.AbsolutePosition.Y
			if ContentContainer.AbsolutePosition.Y &gt;= PositionY and (ContentContainer.AbsolutePosition.Y + ContentContainer.Size.Y.Offset) &lt;= PositionY then
				return true
			else
				PositionY = PositionY + Gui.Size.Y.Offset
				return ContentContainer.AbsolutePosition.Y &gt;= PositionY and (ContentContainer.AbsolutePosition.Y + ContentContainer.Size.Y.Offset) &lt;= PositionY 
			end
		else
			return false
		end
	end

	local function DoShowInterface()
		--- Returns whether or not the interface shoudl be shown.
		-- Not efficient, but readable, which is more important.
		-- @return boolean Should be shown, if true, otherwise, false

		if IsScrolling or IsAutoScrolling then
			return true
		elseif not ScrollBarAtBottom then
			return true
		end

		return false
	end
	OutputStreamRender.DoShowInterface = DoShowInterface
	OutputStreamRender.doShowInterface = DoShowInterface

	local function RemoveOldItem(OldItem)
		--- GC&apos;s an old item, removing from the qeueue. 
		-- @param OldItem An old item in the equeue, created by RenderNew in the DataStreamRender class.
		
		OldItem.Gui:Destroy()
	end

	local function HideScrollBar()
		--- Makes the scroll bar invisible

		-- print(&quot;Hideing scroll bar&quot;)
		ScrollBarFrame.Visible = false
	end
	OutputStreamRender.HideScrollBar = HideScrollBar
	OutputStreamRender.hideScrollBar = HideScrollBar

	local function ShowScrollBar()
		--- Makes the scroll bar visible.

		-- print(&quot;Showing scroll bar&quot;)
		ScrollBarFrame.Visible = true
	end
	OutputStreamRender.ShowScrollBar = ShowScrollBar
	OutputStreamRender.showScrollBar = ShowScrollBar

	local function GetScrollBarAtBottom()
		--- Check&apos;s to see if the scroll bar is at the bottom or not
		-- @return Boolean, true if the scroll bar is at the bottom. 
		-- Used internally.

		return Scroller.KineticModel.Position &lt;= Scroller.KineticModel.Minimum + 2
	end

	local function ScrollToBottom(DoNotAnimate)
		--- Scrolls the scrol bar to the bottom. 
		-- print(DoNotAnimate)
		Scroller:AdjustRange() -- Unfortunately, the event fires slow otherwise. 
		Scroller.ScrollTo(ContentContainer.AbsoluteSize.Y - ContentFrame.AbsoluteSize.Y, DoNotAnimate)
	end
	OutputStreamRender.ScrollToBottom = ScrollToBottom
	OutputStreamRender.ScrollToBottom = ScrollToBottom

	local function UpdateInterface(IsActive)
		if IsActive then
			ShowScrollBar()
		else
			HideScrollBar()
		end
	end
	OutputStreamRender.UpdateInterface = UpdateInterface
	OutputStreamRender.updateInterface = UpdateInterface

	local LastFrameHeight = ContentFrame.Size.Y.Offset

	local function TimeStampToText(TimeStamp)
		-- Converts the time stamp into something more relative...
		-- @param TimeStamp A time stamp

		local RenderTimePass = &quot;[ Error ]&quot;
		if TimeStamp &lt; 20 then
			RenderTimePass = &quot;a few seconds&quot;;
		elseif TimeStamp &lt; 60 then
			RenderTimePass = &quot;less than a minute&quot;;
		elseif TimeStamp &lt; 120 then
			RenderTimePass = &quot;1 minute&quot;
		elseif TimeStamp &lt; 3600 then
			RenderTimePass = qTime.GetMinute(TimeStamp) .. &quot; minutes&quot;
		elseif TimeStamp &lt; 216000 then
			RenderTimePass = &quot;1 hour&quot;
		elseif TimeStamp &lt; 219600 then
			RenderTimePass = qTime.GetHour(TimeStamp) .. &quot; hours&quot;
		else
			RenderTimePass = qTime.GetDayOfTheWeek(SmallestTimeStamp) -- If this ever ever happens in a ROBLOX server, I may die. 
		end

		return RenderTimePass
	end

	local function UpdateSeenCount(TopOfWindow, BottomOfWindow)
		--[[
		local ItemsNotSeenBelow = 0;
		local ItemsNotSeenAbove = 0;
		local SmallestTimeStampBelow = tick()
		local SmallestTimeStampAbove = tick()

		local DataBuffer = Buffer:GetData()

		for Index = #DataBuffer, 1, -1 do
			local Item = DataBuffer[Index]
			
			if not Item.Seen then
				local YPosition = Item.Gui.AbsolutePosition.Y

				--[[ Mental Thoughts

				(Y) POS &lt;= TopSpawn (-5)

				----- TOP SPAN (0)

				----- BOTTOM SPAN (10)

				(Y) POS &gt;= BottomSpan (20)

				--
				if YPosition &gt;= BottomOfWindow then
					ItemsNotSeenBelow = ItemsNotSeenBelow + 1
					if Item.Data.TimeStamp &lt; SmallestTimeStamp then
						SmallestTimeStampBelow = Item.Data.TimeStamp
					end
				elseif YPosition &lt;= TopOfWindow then
					ItemsNotSeenAbove = ItemsNotSeenAbove + 1
					if Item.Data.TimeStamp &lt; SmallestTimeStampAbove then
						SmallestTimeStampAbove = Item.Data.TimeStamp
					end
				else
					Item.Seen = true
				end
			end
		end--]]

		-- if ItemsNotSeenBelow &gt;= 1 then
		-- 	NotifierBottom.SetText(ItemsNotSeenBelow .. &quot; unread message&quot; .. ((ItemsNotSeenBelow == 1) and &quot;&quot; or &quot;s&quot;) .. &quot; (&quot; .. TimeStampToText(tick() - SmallestTimeStampBelow))
		-- else
		-- 	NotifierBottom.Hide()
		-- end
		-- if ItemsNotSeenAbove &gt;= 1 then
		-- 	NotifierTop.SetText(ItemsNotSeenAbove .. &quot; unread message&quot; .. ((ItemsNotSeenBelow == 1) and &quot;&quot; or &quot;s&quot;) .. &quot; (&quot; .. TimeStampToText(tick() - SmallestTimeStampAbove))
		-- else
		-- 	NotifierTop.Hide()
		-- end

		NotifierBottom.Hide(true)
		NotifierTop.Hide(true)
	end


	local function Update(DoNotAnimate, OldItemChange)
		--- Updates positions and rendering.
		-- @param DoNotAnimate Set to true if you do not want to animate

		local WasAtBottom = ScrollBarAtBottom
		local CurrentHeight = 0

		local DataBuffer = Buffer:GetData()

		for Index = #DataBuffer, 1, -1 do
			local Item = DataBuffer[Index]
			Item.Gui.Position = UDim2.new(0, 0, 0, CurrentHeight)
			CurrentHeight = CurrentHeight + Item.Gui.Size.Y.Offset

			if not Item.Seen then
				Item.Seen = IsItemGuiVisible(Item.Gui)
			end
		end

		-- for _, Element in ipairs(Buffer:GetData()) do
			-- CurrentHeight = CurrentHeight + Element.Gui.Size.Y.Offset
			-- Element.Gui.Position = UDim2.new(0, 0, 1, -CurrentHeight)
		-- end

		ContentFrame.Size = UDim2.new(1, 0, 0, math.max(CurrentHeight, ContentContainer.AbsoluteSize.Y))
		local ChangeInSize = (LastFrameHeight - ContentFrame.Size.Y.Offset)
		LastFrameHeight = ContentFrame.Size.Y.Offset

		-- Only auto scroll if we are already auto scrolling and the user is not scrolling.
		if not IsScrolling or IsAutoScrolling then
			if WasAtBottom then
				-- Autoscroll down if we&apos;re already at the bottom. 
				
				IsAutoScrolling = true
				ScrollToBottom(DoNotAnimate)
			elseif OldItemChange ~= 0 then
				if Scroller.KineticModel.Position &lt; -OldItemChange then
					-- Stay even, unless we&apos;re at the very end. 
					-- print(&quot;Item was not at bottom; ChangeInIndex = &quot; .. ChangeInIndex .. &quot; Scroller.KineticModel.Position = &quot; .. Scroller.KineticModel.Position)
					print(&quot;Current Position @ &quot; .. Scroller.KineticModel.Position .. &quot;! OldItemChange is &quot; .. OldItemChange)
					-- Scroller.ScrollTo(Scroller.KineticModel.Position + ChangeInIndex, true)
					IsAutoScrolling = true
					Scroller.ScrollTo(Scroller.KineticModel.Position + OldItemChange, true)
				else
					IsAutoScrolling = true
					Scroller.ScrollTo(0, true)
				end
			end
		end

		UpdateSeenCount(ContentFrame.AbsolutePosition.Y, ContentFrame.AbsolutePosition.Y + ContentFrame.AbsoluteSize.Y)
		LastHeight = CurrentHeight
	end

	--[[
	local function Add(NewElement, DoNotAnimate)
		--- Render&apos;s the new item, and puts it into the frame, will be called by the interface. 
		-- @param NewElement The new GUI to add

		local OldItem = Buffer:Add(NewRender)
		local Change = 0

		-- Garbage collect
		if OldItem then
			Change = OldItem.Gui.Size.Y.Offset
			RemoveOldItem(OldItem)
		end

		Update(DoNotAnimate, Change)
	end
	OutputStreamRender.Add = Add
	OutputStreamRender.add = Add==]]

	local function Insert(Index, NewElement, DoNotAnimate)
		local OldItem = Buffer:Insert(Index, NewElement)
		local Change = 0

		-- Garbage collect
		if OldItem then
			Change = OldItem.Gui.Size.Y.Offset
			RemoveOldItem(OldItem)
		end

		NewElement.Seen = IsItemGuiVisible(NewElement.Gui);

		Update(DoNotAnimate, Change)
	end
	OutputStreamRender.Insert = Insert
	OutputStreamRender.insert = Insert

	--------------------
	-- CONNECT EVENTS --
	--------------------

	-- Scroll events. 
	local StartScrollPosition = 0

	--[[
	0     StartPosition


	-5000 EndPosition
	-----------
	0 EndPosition

	-5000 StartPosition
	---]]
	Scroller.ScrollStarted:connect(function(Position)
		StartScrollPosition = ContentFrame.AbsolutePosition.Y -- Let&apos;s say this is -200 out of -400 max range.
		IsScrolling = true -- We scroll to -300 (So we&apos;ve scrolled up) We need to catch 
	end)

	Scroller.ScrollFinished:connect(function(KineticEndPosition)
		if IsAutoScrolling then -- Make sure it isn&apos;t the program that is scrolling. 
			IsAutoScrolling = false
		else
			local ChangeInPosition = ContentFrame.AbsolutePosition.Y - StartScrollPosition
			if ChangeInPosition ~= 0 then
				local EndPosition
				local StartPosition

				if ChangeInPosition &gt; 0 then
					-- Moved up

					EndPosition = ContentContainer.AbsolutePosition.Y
					StartPosition = ContentContainer.AbsolutePosition.Y + ContentContainer.AbsoluteSize.Y + ChangeInPosition
					print(&quot;Scroll Up: StartPosition = &quot; .. StartPosition .. &quot; :: EndPosition = &quot; .. EndPosition)
				elseif ChangeInPosition &lt; 0 then
					-- Moved down 

					EndPosition = ContentContainer.AbsolutePosition.Y + ContentContainer.AbsoluteSize.Y
					StartPosition = ContentContainer.AbsolutePosition.Y + ChangeInPosition
					print(&quot;Scroll Down: StartPosition = &quot; .. StartPosition .. &quot; :: EndPosition = &quot; .. EndPosition)
				end

				UpdateSeenCount(StartPosition, EndPosition)
			end
		end

		IsScrolling = false
		ScrollBarAtBottom = GetScrollBarAtBottom()
	end)
end)

local MakeOutputStreamInterface = Class(function(OutputStreamInterface, Configuration, ScreenGui)
	-- Creates an interactive interface that allows for multiple incoming channels, et cetera. 

	local Configuration = OverriddenConfiguration.New(Configuration, DefaultConfiguration)
	local Subscribed = {} -- Maintain list of subscribed units. 

	local MainFrame = Make &apos;ImageButton&apos; {
		Active                 = false;
		BackgroundColor3       = Color3.new(0, 0, 0);
		BackgroundTransparency = 1.0;
		Name                   = &quot;OutputStreamInterface&quot;;
		Parent                 = ScreenGui;
		Size                   = qGUI.IsPhone(ScreenGui) and -- Some really horrible calculatinzsdf
		                         UDim2.new(0, 280 + Configuration.TitleWidth + Configuration.ScrollbarWidth, 0, Configuration.ContentHeight + PseudoChatSettings.LineHeight) 
		                         or UDim2.new(0, 500 + Configuration.TitleWidth + Configuration.ScrollbarWidth, 0, Configuration.ContentHeight + PseudoChatSettings.LineHeight);
		ZIndex                 = Configuration.MenuZIndex - 1;
		ClipsDescendants       = true;
	}
	OutputStreamInterface.Gui = MainFrame

	local ContentContainer = Make &apos;Frame&apos; {
		Active                 = false;
		BackgroundTransparency = 1;
		ClipsDescendants       = true;
		Name                   = &quot;ContentContainer&quot;;
		Parent                 = MainFrame;
		Position               = UDim2.new(0, 0, 0, 0);
		Size                   = UDim2.new(1, -Configuration.TitleWidth, 1, 0);
		ZIndex                 = Configuration.ZIndex;
	}

	local Menu = MakeOutputStreamMenu(MainFrame, ScreenGui, Configuration)
	local ActiveSubscriber
	local Mouse = Players.LocalPlayer:GetMouse()
	local MouseOver = qGUI.MouseOver(Mouse, MainFrame)

	local function DoShowInterface()
		if MouseOver then --qGUI.MouseOver(Mouse, MainFrame) then
			return true
		elseif Menu.GetIsShown() then
			return true
		elseif ActiveSubscriber then
			if not ActiveSubscriber.IsMainStream then
				return true
			else
				return ActiveSubscriber.RenderFrame.DoShowInterface()
			end
		else
			return false
		end
	end

	local function UpdateVisibility(DoNotAnimate)
		if DoShowInterface() then
			Menu.SetTransparency(0, DoNotAnimate and nil or Configuration.MenuAnimateTime)
			for _, Item in pairs(Subscribed) do
				Item.RenderFrame.ShowScrollBar()
			end
		else
			Menu.SetTransparency(1, DoNotAnimate and nil or Configuration.MenuAnimateTime)
			for _, Item in pairs(Subscribed) do
				Item.RenderFrame.HideScrollBar()
			end
		end
	end
	OutputStreamInterface.UpdateVisibility = UpdateVisibility

	local ScrollerEvent

	local function SetActiveStream(Subscriber, DoNotAnimate)
		if ActiveSubscriber then
			ActiveSubscriber.Hide()
		end
		ActiveSubscriber = Subscriber
		Subscriber.Show()
		UpdateVisibility(DoNotAnimate)


		if ScrollerEvent then
			ScrollerEvent:disconnect()
			ScrollerEvent = nil
		end

		ScrollerEvent = Subscriber.RenderFrame.Scroller.ScrollFinished:connect(function()
			wait(0)
			UpdateVisibility()
		end)
	end

	local function Subscribe(OutputStreamSyndicator, RenderName, RenderColor, IsMainStream)
		-- @param RenderName &quot;String&quot; The name to show on the menu option, if the default StreamName does not look pretty.
		-- @param RenderColor The color3 value to use on the menu choice.
		-- @param [IsMainStream] if IsMainStream is true, it will let the interface disappear, otherwise it won&apos;t. 

		IsMainStream = IsMainStream ~= nil and IsMainStream or false

		if Subscribed[OutputStreamSyndicator] then
			error(&quot;[OutputStreamInterface] - Already subscribed to &apos;&quot; .. OutputStreamSyndicator.Name .. &quot;&apos;&quot;)
		else
			RenderColor = RenderColor or Color3.new(0, 0, 0)
			RenderName = RenderName or OutputStreamSyndicator.Name or tostring(OutputStreamSyndicator)

			local Subscriber = {}
			local RenderFrame = MakeOutputStreamRender(Configuration, ScreenGui)
			local MenuOption = Menu.MakeChoice(RenderName, RenderColor)
			Subscriber.RenderFrame = RenderFrame
			Subscriber.IsMainStream = IsMainStream

			local function HandleNewItem(OutputClass, Data, DoNotAnimate)
				local BufferData = RenderFrame.Buffer:GetData()
				local Index = 1
				local TimeStamp = Data.TimeStamp
				assert(TimeStamp ~= nil, &quot;[OutputStreamInterface] - TimeStamp is &quot; .. tostring(TimeStamp))
				-- TimeStamp organization / mental thoughts
				--[[ Inserting: 3000

					1 : Most Recent : 2000
					2 : Second Reef : 1995
					3 : ........... : 0343

					if [1] and 2000 &gt; 3000 then
						Index = 2
					....
					if [2] and 1995 &gt; 3000 
				--]]

				while BufferData[Index] and BufferData[Index].Data.TimeStamp &gt; TimeStamp do
					print(Index .. &quot; : &quot; .. BufferData[Index].Data.TimeStamp .. &quot; &gt; &quot; .. TimeStamp)
					Index = Index + 1
				end

				if Index &lt; RenderFrame.Buffer.BufferSize then
					local NewItem = {}

					local Gui    = OutputClass.Render(ActiveSubscriber.RenderFrame.ContentFrame, Data, DoNotAnimate or (Index == RenderFrame.Buffer.BufferSize))
					Gui.Parent   = RenderFrame.ContentFrame
					NewItem.Gui  = Gui
					NewItem.Data = Data

					-- print(&quot;DoNotAnimate: &quot; .. DoNotAnimate)
					RenderFrame.Insert(Index, NewItem, DoNotAnimate)
				else
					print(&quot;[OutputStreamInterface] - Will not insert new item old time stamp @ &quot; .. tostring(TimeStamp))
				end
			end

			function Subscriber.Show()
				RenderFrame.Gui.Visible = true
				Menu.SetColorAndTitle(RenderColor, RenderName)
			end

			function Subscriber.Hide()
				RenderFrame.Gui.Visible = false
			end

			-- Connect Events --

			OutputStreamSyndicator.NewItem:connect(function(OutputStreamClient, OutputClass, Data)
				assert(Data ~= nil, &quot;Data is nil&quot;)
				HandleNewItem(OutputClass, Data, ActiveSubscriber ~= Subscriber)
			end)

			MenuOption.Gui.MouseButton1Click:connect(function()
				SetActiveStream(Subscriber)
				Menu.Collapse()
			end)

			-- Setup Subscription, GUI stuff --

			RenderFrame.Gui.Parent = ContentContainer

			Subscribed[OutputStreamSyndicator] = Subscriber
			if not ActiveSubscriber then
				SetActiveStream(Subscriber)
			else
				Subscriber.Hide()
			end

			-- Handle Logs -- 
			local Logs = OutputStreamSyndicator.GetSyndicatedLogs()
			for _, Item in pairs(Logs) do
				HandleNewItem(Item.OutputClass, Item.Data, true)
			end
			Logs = nil -- GC

			return Subscriber
		end
	end
	OutputStreamInterface.Subscribe = Subscribe
	OutputStreamInterface.subscribe = Subscribe

	-- SETUP EVENTS --
	MainFrame.MouseEnter:connect(function()
		MouseOver = true
		UpdateVisibility()
	end)

	MainFrame.MouseLeave:connect(function()
		MouseOver = false
		UpdateVisibility()
	end)

	Menu.MenuCollapseChanged:connect(function(State)
		UpdateVisibility()
	end)

	UpdateVisibility(true)
end)
lib.MakeOutputStreamInterface = MakeOutputStreamInterface
lib.makeOutputStreamInterface = MakeOutputStreamInterface

return lib</ProtectedString>
</Properties>
</Item>
<Item class="Backpack" referent="RBX31">
<Properties>
<string name="Name">PseudoChat</string>
</Properties>
<Item class="ModuleScript" referent="RBX32">
<Properties>
<string name="Name">PseudoChat</string>
<ProtectedString name="Source">local ReplicatedStorage        = game:GetService(&quot;ReplicatedStorage&quot;)
local Players                  = game:GetService(&quot;Players&quot;)
local LogService               = game:GetService(&quot;LogService&quot;)
local ScriptContext            = game:GetService(&quot;ScriptContext&quot;)

local NevermoreEngine          = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary        = NevermoreEngine.LoadLibrary

local qSystems                 = LoadCustomLibrary(&quot;qSystems&quot;)
local OutputStreamInterface    = LoadCustomLibrary(&quot;OutputStreamInterface&quot;)
local PseudoChatParser         = LoadCustomLibrary(&quot;PseudoChatParser&quot;)
local OutputClassStreamLoggers = LoadCustomLibrary(&quot;OutputClassStreamLoggers&quot;)
local OutputStream             = LoadCustomLibrary(&quot;OutputStream&quot;)



-- Setups up the PseudoChat on the client. It&apos;s the equivalent of the PseudoChatManager for the
-- server

-- PseudoChat.lua
-- Intended for the client only. Sets up pseudo chat on the client. 
-- @author Quenty
-- Last modified Janurary 19th, 2014

--[[-- Update Log --
February 6th, 2014
- Added local-side output support for errors.
- Output does not go to global chat log now
- Fixed glitch with script concatination

January 26th, 2014
- Updated to OutputStream

January 19th, 2014
- Added change log
- Added ScriptbuilderParser
- Added QuentyAdminCommandsOutput

January 5th, 2014
- Wrote intitial script

--]]


qSystems:Import(getfenv(0))

local lib = {}

local function MakePseudoChat(ScreenGui)
	--- This will render a pseudo chat output stream thingy. Of course, you don&apos;t have to use this module, but it simplifies everything.
	-- @param ScreenGui The ScreenGui the chat goes into. 
	local ClientToServerOutputStream = NevermoreEngine.GetEventStream(&quot;ClientToServerOutputStream&quot;)

	local Chat = {}

	local MainChannelGlobal = OutputStream.MakeOutputStreamClient(
		&quot;MainChannel-Global&quot;
	);
	MainChannelGlobal.AddOutputClass(PseudoChatParser.OutputOutputClass)
	MainChannelGlobal.AddOutputClass(PseudoChatParser.ChatOutputClass)

	-- Notification stream
	local MainChannelNotify = OutputStream.MakeOutputStreamClient(
		&quot;MainChannel-Notify&quot;
	);
	MainChannelNotify.AddOutputClass(PseudoChatParser.OutputOutputClass)

	-- Admin stream
	local AdminGlobal = OutputStream.MakeOutputStreamClient(
		&quot;Admin-Global&quot;
	);
	AdminGlobal.AddOutputClass(PseudoChatParser.OutputOutputClass)

	-- Output Stream
	local AdminOutput = OutputStream.MakeOutputStreamClient(
		&quot;Admin-Output&quot;
	);
	AdminOutput.AddOutputClass(PseudoChatParser.OutputOutputClass)

	-- We will syndicate resources. 
	-- Global one has all of &apos;em. 
	local GlobalSyndictator = OutputStream.MakeOutputStreamSyndicator(&quot;Global Channel&quot;)
		GlobalSyndictator.AddOutputStream(MainChannelGlobal)
		GlobalSyndictator.AddOutputStream(MainChannelNotify)
		GlobalSyndictator.AddOutputStream(AdminGlobal)
		-- GlobalSyndictator.AddOutputStream(AdminOutput)

	-- Chat Syndictator has only chat.
	local ChatSyndictator = OutputStream.MakeOutputStreamSyndicator(&quot;Main chat&quot;)
		ChatSyndictator.AddOutputStream(MainChannelGlobal)
		ChatSyndictator.AddOutputStream(MainChannelNotify)

	local NotificationSyndictator = OutputStream.MakeOutputStreamSyndicator(&quot;Notifications&quot;)
		NotificationSyndictator.AddOutputStream(MainChannelNotify)
		NotificationSyndictator.AddOutputStream(AdminOutput)

	-- And admin only admin stuff. 
	local AdminSyndictator  = OutputStream.MakeOutputStreamSyndicator(&quot;Admin syndictator&quot;)
		AdminSyndictator.AddOutputStream(AdminGlobal)
		AdminSyndictator.AddOutputStream(AdminOutput)

	local Interface = OutputStreamInterface.MakeOutputStreamInterface(nil, ScreenGui)
	Chat.Interface  = Interface
	Chat.Gui        = Interface.Gui

	Interface.Subscribe(GlobalSyndictator,         nil, Color3.new( 85/255,  98/255, 112/255), true)
	Interface.Subscribe(ChatSyndictator,           nil, Color3.new( 78/255, 205/255, 196/255), false)
	Interface.Subscribe(NotificationSyndictator,   nil, Color3.new(199/255, 244/255, 100/255), false)
	Interface.Subscribe(AdminSyndictator,          nil, Color3.new(255/255, 107/255, 107/255), false)

	if not NevermoreEngine.SoloTestMode then
		-- In SoloTest mode we log Errors already. 
		
		ScriptContext.Error:connect(function(Message, StackTrace, Script)
			Script = tostring(Script)

			ClientToServerOutputStream.Fire(&quot;Error&quot;, {
				Message    = Message;
				StackTrace = StackTrace;
				Script     = Script;
			})
		end)
	end

	return Chat
end
lib.MakePseudoChat = MakePseudoChat
lib.makePseudoChat = MakePseudoChat

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX33">
<Properties>
<string name="Name">PseudoChatManager</string>
<ProtectedString name="Source">local ReplicatedStorage        = game:GetService(&quot;ReplicatedStorage&quot;)
local Players                  = game:GetService(&quot;Players&quot;)
local LogService               = game:GetService(&quot;LogService&quot;)
local ScriptContext            = game:GetService(&quot;ScriptContext&quot;)

local NevermoreEngine          = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary        = NevermoreEngine.LoadLibrary

local qSystems                 = LoadCustomLibrary(&quot;qSystems&quot;)
local PseudoChatSettings       = LoadCustomLibrary(&quot;PseudoChatSettings&quot;)
local PseudoChatParser         = LoadCustomLibrary(&quot;PseudoChatParser&quot;)
local OutputClassStreamLoggers = LoadCustomLibrary(&quot;OutputClassStreamLoggers&quot;)
local OutputStream             = LoadCustomLibrary(&quot;OutputStream&quot;)
local qString                  = LoadCustomLibrary(&quot;qString&quot;)
local AuthenticationService    = LoadCustomLibrary(&quot;AuthenticationService&quot;)

qSystems:Import(getfenv(0))

-- PseudoChatManager.lua
-- Manages chat connections, sends and making chats, filtering, et cetera.
-- Intendend for Serverside use only. 
-- @author Quenty
-- Last modified Janurary 19th, 2014

--[[-- Change Log --
Febraury 6th, 2015
- Updated to use AuthenticationService
- Modified AdminOutput to not use filter
- Modified to accept error output from client

February 3rd, 2014
- Fixed issue with /e emoticons and filtering.

January 26th, 2014
- Switched to OutputStream system. 

January 19th, 2014
- Added callback system to PseudoChatManager
- Added QuentyAdminCommandsOutput parser to system
- Added ScriptbuilderParser to the system
- Added Changelog

-- January 5th, 2014 --
- Wrote initial script

--]]

local PseudoChatManager = {} do
	local ClientToServerOutputStream = NevermoreEngine.GetEventStream(&quot;ClientToServerOutputStream&quot;)

	local MainChannelGlobal = OutputStream.MakeOutputStreamServer(
		OutputClassStreamLoggers.MakeGlobalOutputStreamLog(),
		&quot;MainChannel-Global&quot;
	);
	MainChannelGlobal.AddOutputClass(PseudoChatParser.OutputOutputClass)
	MainChannelGlobal.AddOutputClass(PseudoChatParser.ChatOutputClass)

	-- Notification stream
	local MainChannelNotify = OutputStream.MakeOutputStreamServer(
		OutputClassStreamLoggers.MakePlayerNotificationStreamLog(), 
		&quot;MainChannel-Notify&quot;
	);
	MainChannelNotify.AddOutputClass(PseudoChatParser.OutputOutputClass)

	-- Admin stream
	local AdminGlobal = OutputStream.MakeOutputStreamServer(
		OutputClassStreamLoggers.MakeGlobalFilteredLogStreamLog(AuthenticationService.IsAuthorized), 
		&quot;Admin-Global&quot;
	);
	AdminGlobal.AddOutputClass(PseudoChatParser.OutputOutputClass)

	-- Output Stream
	local AdminOutputClass = OutputStream.MakeOutputStreamServer(
		OutputClassStreamLoggers.MakeGlobalFilteredLogStreamLog(AuthenticationService.IsAuthorized), 
		&quot;Admin-Output&quot;
	);
	AdminOutputClass.AddOutputClass(PseudoChatParser.OutputOutputClass)

	local Muted = {} -- List of muted players
	local ChatCallbacks = {}

	local function ExecuteChatCallbacks(Player, Message, PlayerColor, ChatColor)
		--- Goes through each ChatCallbacks and executes it.
		-- Used internally, called before a player is allowed to chat. 
		-- Called even if mute is enabled. Calls every one. Order is undefined. 
		-- @return Boolean True if it should not render.

		local DoExecute = false

		for _, Item in pairs(ChatCallbacks) do
			local Result = Item(Player, Message, PlayerColor, ChatColor)
			if Result then
				print(&quot;[PseudoChatManager] - Callback result was &quot; .. tostring(Result))
				DoExecute = true
			end
		end
		return DoExecute
	end

	local function AddChatCallback(Callback)
		--- Adds a callback to the chat callback system.
		-- @param CallbackName The name of the callback.
			--- Should do stuff with the information, and / or execute code.
			-- @param PlayerName The name of the player chatting
			-- @param Message The message
			-- @param PlayerColor Color3, The color of the player label 
			-- @param ChatColor	Color3 The color of the chat
			-- @return Boolean, true if it should not render. 
		-- Callbacks will be executed in any arbitary order. 

		ChatCallbacks[#ChatCallbacks + 1] = Callback
	end
	PseudoChatManager.AddChatCallback = AddChatCallback
	PseudoChatManager.addChatCallback = AddChatCallback
	PseudoChatManager.add_chat_callback = AddChatCallback

	local function Mute(PlayerName)
		--- Mute&apos;s any player&apos;s with the name &quot;PlayerName&quot;;
		-- @param PlayerName String, The name of the player to mute

		Muted[PlayerName:lower()] = true
	end
	PseudoChatManager.Mute = Mute
	PseudoChatManager.mute = Mute

	local function Unmute(PlayerName)
		--- Remove&apos;s the mute from the player
		-- @param PlayerName String, The name of the player to unmute

		Muted[PlayerName:lower()] = nil
	end
	PseudoChatManager.Unmute = Unmute
	PseudoChatManager.unmute = Unmute

	local function IsMuted(PlayerName)
		--- Get if a player is muted or not
		-- @param PlayerName String, The name of the player to check
		-- @return Boolean, is the player muted or not.

		return Muted[PlayerName:lower()] or false
	end
	PseudoChatManager.IsMuted = IsMuted
	PseudoChatManager.isMuted = IsMuted

	local function FilteredNotify(PlayerList, Message, ChatColor)
		--- Notifies a player
		-- @param PlayerList A list of players to send it too
		-- @param ChatColor The color of the chat. 
		-- @param Message The message to send

		-- This is basically a shortcode for RenderDataStream.Send

		assert(PlayerList ~= nil, &quot;[PseudoChatManager] - PlayerList is nil.&quot;)

		MainChannelNotify.Send(&quot;OutputOutputClass&quot;, {
			Message = tostring(Message);
			ChatColor = ChatColor;

			Inclusive = true;
			FilterList = PlayerList;
		})
	end
	PseudoChatManager.FilteredNotify = FilteredNotify
	PseudoChatManager.filteredNotify = FilteredNotify

	local function Notify(Message, ChatColor)
		MainChannelNotify.Send(&quot;OutputOutputClass&quot;, {
			Message = tostring(Message);
			ChatColor = ChatColor;

			Inclusive = false;
			FilterList = {};
		})
	end
	PseudoChatManager.Notify = Notify
	PseudoChatManager.Notify = Notify

	local function Output(Output, ChatColor)
		--- Output&apos;s script builder output to a player
		-- @param Output The output to output
		-- @param ChatColor The chat color to output.

		-- print(&quot;*** OUTPUT \&quot;&quot; .. Output .. &quot;\&quot;&quot;)

		local Data = {
			Message = Output;
			ChatColor = ChatColor;
		}
		-- print(&quot;Filter list [0] @ Send&quot; .. tostring(Data.FilterList) .. &quot;, Data = &quot; .. tostring(Data))

		AdminOutputClass.Send(&quot;OutputOutputClass&quot;, Data)

	end
	PseudoChatManager.Output = Output
	PseudoChatManager.output = Output

	local function AdminOutput(Output, ChatColor)
		--- Output&apos;s admin commands log
		-- @param Output The output to Output
		-- @param ChatColor The chat color to output.


		AdminGlobal.Send(&quot;OutputOutputClass&quot;, {
			Message   = Output;
			ChatColor = ChatColor;
		})
	end
	PseudoChatManager.AdminOutput = AdminOutput
	PseudoChatManager.adminOutput = AdminOutput

	local function Chat(PlayerName, Message, PlayerColor, ChatColor)
		--- Makes the player with the name &quot;PlayerName&quot; chat &quot;Message&quot; No callbacks or filtered anything
		-- @param PlayerName The name of the player saying the message
		-- @param Message The message to say
		-- @param [PlayerColor] The color of the player&apos;s name. Optional. 
		-- @param [ChatColor] The color of the chat. Optional. 

		MainChannelGlobal.Send(&quot;ChatOutputClass&quot;, {
			PlayerName  = tostring(PlayerName);
			Message     = tostring(Message);
			PlayerColor = PlayerColor;
			ChatColor   = ChatColor;
		})
	end
	PseudoChatManager.RawChat  = Chat
	PseudoChatManager.rawChat  = Chat
	PseudoChatManager.raw_chat = Chat

	local function HandleChat(PlayerName, Message, PlayerColor, ChatColor)
		--- Handle&apos;s chat replciation whenver a player chats.
		-- @param PlayerName The PlayerName chatting
		-- @param Message The message of the player

		local DoNotDisplay = ExecuteChatCallbacks(PlayerName, Message, PlayerColor, ChatColor)

		if DoNotDisplay then
			print(&quot;[PseudoChatManager] - Player &quot; .. PlayerName .. &quot;&apos;s chat was stopped by a callback. &quot;)
		else
			if not IsMuted(PlayerName) then
				Chat(PlayerName, Message, PlayerColor, ChatColor)
			else
				print(&quot;[PseudoChatManager] - Player &apos;&quot; .. PlayerName .. &quot;&apos; is muted. &quot;)
				-- Notify the player that they can&apos;t speak, they are muted!
				local Player = Players:FindFirstChild(PlayerName)
				if Player and Player:IsA(&quot;Player&quot;) then
					FilteredNotify({Player.userId}, PseudoChatSettings.MutedMessage, PseudoChatSettings.MutedMessageColor)
				else
					print(&quot;No player identified to notify the cannot chat&quot;)
				end
			end
		end
	end
	PseudoChatManager.Chat = HandleChat
	PseudoChatManager.chat = HandleChat

	local function HandlePlayer(Player)
		--- Handle&apos;s the player by connecting events, et cetera.

		Player.Chatted:connect(function(Message)
			HandleChat(Player.Name, Message)
		end)
	end
	
	local function Initiate()
		-- Sets up PseudoChat. 

		-- Connect events
		for _, Player in pairs(Players:GetPlayers()) do
			HandlePlayer(Player)
		end

		Players.PlayerAdded:connect(function(Player)
			HandlePlayer(Player)
		end)

		ScriptContext.Error:connect(function(Message, StackTrace, Script)
			Script = tostring(Script)
			
			Output((Script .. &quot; &quot; .. Message), Color3.new(1, 0, 0))
			Output(StackTrace, Color3.new(0, 209/255, 255/255))
		end)

		LogService.MessageOut:connect(function(Message, MessageType)
			local MessageColor
			if MessageType.Name == &quot;MessageWarning&quot; then
				MessageColor = Color3.new(255/255, 233/255, 181/255)
			elseif MessageType.Name == &quot;MessageError&quot; then
				MessageColor = Color3.new(1, 0, 0)
			elseif MessageType.Name == MessageInfo then
				MessageColor = Color3.new(0, 209/255, 255/255)
			end
			Output(Message, MessageColor)
		end)
	end
	PseudoChatManager.Initiate = Initiate
	PseudoChatManager.Initiate = Initiate

	ClientToServerOutputStream.RegisterRequestTag(&quot;Error&quot;, function(Client, NewOutput)
		Output(&quot;[&quot; .. tostring(Client) .. &quot;] - &quot; .. NewOutput.Script .. NewOutput.Message, Color3.new(1, 0, 0))
		Output(NewOutput.StackTrace, Color3.new(0, 209/255, 255/255))
	end)
end

PseudoChatManager.AddChatCallback(function(Player, Message, PlayerColor, ChatColor)
	if qString.CompareCutFirst(Message, &quot;/e&quot;) then
		return true
	end
	return false
end)

return PseudoChatManager
</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX34">
<Properties>
<string name="Name">PseudoChatParser</string>
<ProtectedString name="Source">local ReplicatedStorage  = game:GetService(&quot;ReplicatedStorage&quot;)
local Players            = game:GetService(&quot;Players&quot;)

local NevermoreEngine    = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary  = NevermoreEngine.LoadLibrary

local qSystems           = LoadCustomLibrary(&quot;qSystems&quot;)
local qString            = LoadCustomLibrary(&quot;qString&quot;)
local PseudoChatSettings = LoadCustomLibrary(&quot;PseudoChatSettings&quot;)
local qColor3            = LoadCustomLibrary(&quot;qColor3&quot;)
local qMath              = LoadCustomLibrary(&quot;qMath&quot;)
local qGUI               = LoadCustomLibrary(&quot;qGUI&quot;)
local OutputStream       = LoadCustomLibrary(&quot;OutputStream&quot;)

local RbxUtility         = LoadLibrary(&quot;RbxUtility&quot;)

qSystems:Import(getfenv(0));

local lib = {}

-- @author Quenty
-- This script handles parsing and rendering of specific pseudo chat stuff,
-- to be used with OutputStream
-- Last Modified January 26th, 2014

local GetPlayerNameColorRaw do 
	local PlayerColours = {
		BrickColor.new(&quot;Bright red&quot;),
		BrickColor.new(&quot;Bright blue&quot;),
		BrickColor.new(&quot;Earth green&quot;),
		BrickColor.new(&quot;Bright violet&quot;),
		BrickColor.new(&quot;Bright orange&quot;),
		BrickColor.new(&quot;Bright yellow&quot;),
		BrickColor.new(&quot;Light reddish violet&quot;),
		BrickColor.new(&quot;Brick yellow&quot;),
	}

	local function GetNameValue(Name)
		-- Returns the Player&apos;s color that their name is suppose to be.  
		-- Credit to noliCAIKS for finding this solution. He&apos;s epicale. 

		local Length = #Name
		local Value = 0
		for Index = 1, Length do
			local CharacterValue = string.byte(string.sub(Name, Index, Index))
			local ReverseIndex = Length - Index + 1
			if Length % 2 == 1 then
				ReverseIndex = ReverseIndex - 1
			end
			if ReverseIndex % 4 &gt;= 2 then
				CharacterValue = -CharacterValue
			end
			Value = Value + CharacterValue
		end
		return Value % 8
	end

	function GetPlayerNameColorRaw(Name)
		return PlayerColours[GetNameValue(Name) + 1]
	end
end
lib.GetPlayerNameColorRaw = GetPlayerNameColorRaw
lib.getPlayerNameColorRaw = GetPlayerNameColorRaw

local function IsRobloxAdmin(Name)
	--- Finds out if a player is a ROBLOX admin
	-- @param Name The name of the player to check for
	-- @return Boolean if the player is a ROBLOX admin or not.

	Name = Name:lower()
	for _, Admin in pairs(PseudoChatSettings.ROBLOXAdminList) do
		if Admin:lower() == Name then
			return true
		end
	end
	return false
end
lib.IsRobloxAdmin = IsRobloxAdmin
lib.isRobloxAdmin = IsRobloxAdmin

local function GetPlayerFromName(PlayerName)
	--- Get&apos;s a player from their username.
	-- @param PlayerName THe name of the player
	-- @return The player, if they are in-game.

	local Player = Players:FindFirstChild(PlayerName)
	if Player and Player:IsA(&quot;Player&quot;) then
		return Player
	else
		return nil
	end
end
lib.GetPlayerFromName = GetPlayerFromName
lib.getPlayerFromName = GetPlayerFromName

local function GetPlayerChatColor(Name)
	--- Return&apos;s a player&apos;s chat color
	-- @param Name THe name of the player

	if PseudoChatSettings.SpecialChatColors[Name] then
		return PseudoChatSettings.SpecialChatColors[Name]
	elseif IsRobloxAdmin(Name) then
		return PseudoChatSettings.RobloxAdminChatColor
	else
		return PseudoChatSettings.DefaultChatColor
	end
end
lib.GetPlayerChatColor = GetPlayerChatColor
lib.getPlayerChatColor = GetPlayerChatColor

local function GetPlayerNameColor(Name)
	--- Return&apos;s a player&apos;s name color.
	-- Priorities predefined, and then their TeamColor, and then finally the hashed name.
	-- @param Name THe name of the player
	-- @return Color3 value of what to color their name.

	local Player = GetPlayerFromName(Name)

	if PseudoChatSettings.SpecialNameColors[Name] then
		return PseudoChatSettings.SpecialNameColors[Name]
	else
		if not Player or Player.Neutral then
			return GetPlayerNameColorRaw(Name)
		else
			return Player.TeamColor.Color
		end
	end
end
lib.GetPlayerNameColor = GetPlayerNameColor
lib.getPlayerNameColor = GetPlayerNameColor

local CachedSpaceStringList = {}

local function ComputeSpaceString(Label, PlayerLabel)
	--- Given a name, return the spaces required to push a text wrapped thing out of the way. Tricky Sorcus. Tricky. 
	-- @param Label The label to test upon, probably the message label.
	-- @param PlayerLabel The label representing the Player&apos;s name.

	local newString = &quot; &quot;
	
	Label.Text = newString

	while Label.TextBounds.X &lt; PlayerLabel.TextBounds.X do
		print(Label.TextBounds.X .. &quot; &lt; &quot; .. PlayerLabel.TextBounds.X)
		newString = newString .. &quot; &quot;
		Label.Text = newString;
	end
	newString = newString .. &quot; &quot;
	CachedSpaceStringList[PlayerLabel.Text] = newString
	Label.Text = &quot;&quot;

	return newString
end
lib.ComputeSpaceString = ComputeSpaceString
lib.computeSpaceString = ComputeSpaceString

local function GetSpaceString(Label, PlayerLabel)
	--- Get&apos;s the cached version of the space string, or return&apos;s a new one. Since we&apos;re caching, the size of the text can&apos;t change halfway
	--  through.
	-- @param Label The label to test upon, probably the message label.
	-- @param PlayerLabel The label representing the Player&apos;s name.

	return CachedSpaceStringList[PlayerLabel.Text] or ComputeSpaceString(Label, PlayerLabel)
end
lib.GetSpaceString = GetSpaceString
lib.getSpaceString = GetSpaceString

local function GenericTextFadeIn(Gui, Time)
	--- Transitions text labels to fade in. Recurses on children. 

	CallOnChildren(Gui, function(Child)
		if Child:IsA(&quot;TextLabel&quot;) or Child:IsA(&quot;TextButton&quot;) or Child:IsA(&quot;TextBox&quot;) then
			local CurrentTextTransparency = Child.TextTransparency
			local CurrentStrokeTransparency = Child.TextStrokeTransparency
			Child.TextTransparency        = 1;
			Child.TextStrokeTransparency  = 1;

			qGUI.TweenTransparency(Child, {
				TextTransparency       = CurrentTextTransparency;
				TextStrokeTransparency = CurrentStrokeTransparency;
			}, Time, true)
		end
	end)
end

local function GenericTextFadeOut(Gui, Time)
	--- Trasitions text labels to fade out. Recurses on children. 

	CallOnChildren(Gui, function(Child)
		if Child:IsA(&quot;TextLabel&quot;) or Child:IsA(&quot;TextButton&quot;) or Child:IsA(&quot;TextBox&quot;) then
			qGUI.TweenTransparency(Child, {
				TextTransparency       = 1;
				TextStrokeTransparency = 1;
			}, Time, true)
		end
	end)
end
local ChatParser, ChatRender, ChatOutputClass do -- Chat parsing
	function ChatRender(Parent, Data, DoNotAnimate)
		--- Renders a frame, and returns it
		-- @param Data The data is sent from the below parser, to the client
		--[[ The following expected
			Message &apos;String&apos; The message to be displayed.
			PlayerColor &apos;Color3&apos; The Color3 value, in JSON, of the Player&apos;s name.
			ClassName &apos;String&apos; The class of the chat. Automatically added.
			ChatColor &apos;Color3&apos; The Color3 value
		--]]
		-- @return Gui Frame, resized correctly for the parent. 

		local PlayerChatFrame = Make &apos;Frame&apos; {
			BackgroundTransparency = 1;
			BorderSizePixel        = 0;
			Parent                 = Parent;
			Size                   = UDim2.new(1, 0, 1, 0);
			Visible                = true;
			Name                   = Data.ClassName;
		}

		local PlayerLabel = Make &apos;TextLabel&apos; {
			BackgroundTransparency = 1;
			BorderSizePixel        = 0;
			FontSize               = PseudoChatSettings.ChatFontSize;
			Name                   = &quot;ChatNameLabel&quot;;
			Parent                 = PlayerChatFrame; -- For text bounds, reassigned later. 
			Position               = UDim2.new(0, PseudoChatSettings.LabelOffsetX, 0, 0);
			Size                   = UDim2.new(1, -PseudoChatSettings.LabelOffsetX, 1, 0);
			Text                   = Data.PlayerName..&quot;:&quot;;
			TextColor3             = Data.PlayerColor;
			TextStrokeColor3       = Color3.new(0.5, 0.5, 0.5);
			TextStrokeTransparency = 1;
			TextTransparency       = 0;
			TextWrapped            = false;
			TextXAlignment         = &quot;Left&quot;;
			TextYAlignment         = &quot;Top&quot;;
			ZIndex                 = Parent.ZIndex;	
		}

		local MessageLabel = Make &apos;TextLabel&apos; {
			BackgroundTransparency = 1;
			BorderSizePixel        = 0.0;
			FontSize               = PseudoChatSettings.ChatFontSize;
			Name                   = &quot;Message&quot;;
			Parent                 = PlayerChatFrame;
			Position               = UDim2.new(0, PseudoChatSettings.LabelOffsetX, 0, 0);
			Size                   = UDim2.new(1, -PseudoChatSettings.LabelOffsetX, 1, 0);
			TextColor3             = Data.ChatColor;
			TextStrokeColor3       = Color3.new(0, 0, 0);
			TextWrapped            = true;
			TextStrokeTransparency = Data.MessageLabelTextStrokeTransparency;
			TextXAlignment         = &quot;Left&quot;;
			TextYAlignment         = &quot;Top&quot;;
			ZIndex                 = Parent.ZIndex;
		}

		-- Set Message&apos;s Text --
		local MessageSpacer = GetSpaceString(MessageLabel, PlayerLabel)
		MessageLabel.Text   = MessageSpacer .. PseudoChatSettings.ContentFailed
		MessageLabel.Text   = MessageSpacer .. Data.Message

		local Height = qMath.RoundUp(MessageLabel.TextBounds.Y, PseudoChatSettings.LineHeight)
		PlayerChatFrame.Size = UDim2.new(1, 0, 0, Height)

		if DoNotAnimate then
			
		else
			GenericTextFadeIn(PlayerChatFrame, 0.5)
		end
		return PlayerChatFrame
	end

	ChatParser = OutputStream.MakeOutputParser(function(Data)
		--- Constructs a new &quot;data&quot; field to be sent, as well as fills in Data.

		local Parsed = {}

		Data.Message     = qString.TrimString(Data.Message and tostring(Data.Message) or &quot;[ No Message Provided ]&quot;)
		Data.PlayerName  = Data.PlayerName or &quot;NoPlayerName&quot;;
		Data.PlayerColor = Data.PlayerColor or GetPlayerNameColor(Data.PlayerName)
		Data.ChatColor   = Data.ChatColor or GetPlayerChatColor(Data.PlayerName)
		Data.MessageLabelTextStrokeTransparency = Data.MessageLabelTextStrokeTransparency or 0.8

		Parsed.Message     = Data.Message
		Parsed.PlayerName  = Data.PlayerName
		Parsed.PlayerColor = qColor3.Encode(Data.PlayerColor)
		Parsed.ChatColor   = qColor3.Encode(Data.ChatColor)		
		Parsed.MessageLabelTextStrokeTransparency = Data.MessageLabelTextStrokeTransparency

		-- print(Parsed.PlayerColor)
		-- print(Parsed.ChatColor)

		return Parsed
	end, function(Data)
		--- Decodes JSON (unparses) it.
		-- @return Table, if unparsed successfully, otherwise, nil

		-- print(Data.PlayerColor)
		-- print(Data.ChatColor)

		local DecodedChatColor = qColor3.Decode(Data.ChatColor)
		if DecodedChatColor then
			Data.ChatColor = DecodedChatColor
		else
			Warn(&quot;[OutputParser] - Unable to parse Notifications&apos;s ChatColor in data&quot;)
		end

		local DecodedPlayerColor = qColor3.Decode(Data.PlayerColor)
		if DecodedPlayerColor then
			Data.PlayerColor = DecodedPlayerColor
		else
			Warn(&quot;[OutputParser] - Unable to parse Notifications&apos;s PlayerColor in data&quot;)
		end

		return Data
	end)

	ChatOutputClass = OutputStream.MakeOutputClass(&quot;ChatOutputClass&quot;, 
		ChatParser, 
		ChatRender
	);
end
lib.ChatOutputClass = ChatOutputClass

local OutputParser, OutputRender, OutputOutputClass do -- Output parsing
	function OutputRender(Parent, Data, DoNotAnimate)
		--- Renders a new &quot;Output&quot; from the Data given.
		-- @param Data The data given. 

		local NotificationChatFrame = Make &apos;Frame&apos; {
			BackgroundTransparency = 1;
			BorderSizePixel        = 0;
			Parent                 = Parent;
			Size                   = UDim2.new(1, 0, 1, 0);
			Visible                = true;
			Name                   = Data.ClassName;
		}

		local MessageLabel = Make &apos;TextLabel&apos; {
			BackgroundTransparency = 1;
			BorderSizePixel        = 0.0;
			FontSize               = PseudoChatSettings.ChatFontSize;
			Name                   = &quot;Message&quot;;
			Parent                 = NotificationChatFrame;
			Position               = UDim2.new(0, PseudoChatSettings.LabelOffsetXOutput, 0, 0);
			Size                   = UDim2.new(1, -PseudoChatSettings.LabelOffsetXOutput, 1, 0);
			TextColor3             = Data.ChatColor;
			Text                   = PseudoChatSettings.ContentFailed;
			TextStrokeColor3       = Color3.new(0, 0, 0);
			TextWrapped            = true;
			TextStrokeTransparency = Data.MessageLabelTextStrokeTransparency;
			TextXAlignment         = &quot;Left&quot;;
			TextYAlignment         = &quot;Top&quot;;
			ZIndex                 = Parent.ZIndex;
		}
		MessageLabel.Text = tostring(Data.Message)

		local Height = qMath.RoundUp(MessageLabel.TextBounds.Y, PseudoChatSettings.LineHeight)
		NotificationChatFrame.Size = UDim2.new(1, -PseudoChatSettings.LabelOffsetXOutput, 0, Height)

		return NotificationChatFrame
	end

	OutputParser = OutputStream.MakeOutputParser(function(Data)
		--- Constructs a new &quot;data&quot; field to be sent.
		-- @param Message The chat the player said
		-- @param ChatColor The ChatColor to render at

		local Parsed = {}

		Data.Message     = qString.TrimString(Data.Message and tostring(Data.Message) or &quot;[ No Message Provided ]&quot;)
		Data.ChatColor   = Data.ChatColor or PseudoChatSettings.DefaultNotificationColor;
		Data.MessageLabelTextStrokeTransparency = Data.MessageLabelTextStrokeTransparency or 0.8

		Parsed.Message     = Data.Message
		Parsed.ChatColor   = qColor3.Encode(Data.ChatColor)		
		Parsed.MessageLabelTextStrokeTransparency = Data.MessageLabelTextStrokeTransparency
		

		return Parsed
	end, function(Data)
		--- Decodes JSON (unparses) it.
		-- @param JSONData String JSON data, to be deparsed

		local DecodedChatColor = qColor3.Decode(Data.ChatColor)
		if DecodedChatColor then
			Data.ChatColor = DecodedChatColor
		else
			Warn(&quot;[OutputParser] - Unable to parse Notifications&apos;s ChatColor in data&quot;)
		end

		return Data
	end)

	OutputOutputClass = OutputStream.MakeOutputClass(&quot;OutputOutputClass&quot;, 
		OutputParser, 
		OutputRender
	);
end
lib.OutputOutputClass = OutputOutputClass

return lib</ProtectedString>
</Properties>
</Item>
<Item class="Script" referent="RBX35">
<Properties>
<string name="Name">PseudoChatSettings</string>
<ProtectedString name="Source">-- PseudoChatSettings.lua
-- @author Quenty
-- Last modified Januarty 26th, 2014
-- Maintains PseudoChat settings.

return {
	-- COLORS --
	SpecialChatColors = {
		[&quot;Quenty&quot;]          = BrickColor.new(&quot;Br. yellowish green&quot;).Color;
		[&quot;Mauv&quot;]       = BrickColor.new(&quot;Br. yellowish green&quot;).Color; -- Color3.new(1, 215/255, 0); 
		[&quot;Player1&quot;]         = BrickColor.new(&quot;Br. yellowish green&quot;).Color; -- Color3.new(1, 215/255, 0);
		[&quot;PumpedRobloxian&quot;] = Color3.new(0, 202/255, 220/255);
		[&quot;xXxMoNkEyMaNxXx&quot;] = BrickColor.new(&quot;Lavender&quot;).Color;
		[&quot;ColorfulBody&quot;]    = Color3.new(252/255, 0, 154/255); -- Magenta #fc009a 
	};
	SpecialNameColors = {
		[&quot;ColorfulBody&quot;]    = Color3.new(254/255, 191/255, 229/255); -- Magenta #febfe5 
	};
	RobloxAdminChatColor = BrickColor.new(&quot;Hot pink&quot;).Color;
	DefaultChatColor = Color3.new(1, 1, 1);
	
	-- RENDERING --
	LineHeight   = 18; -- Recommended Height per chat line.
	LinesShown   = 6;  -- Chat lines to show
	LabelOffsetX = 12; -- Offset from the left side of the frame.
	LabelOffsetXOutput = 20; -- Output get&apos;s indented more.
	ChatFontSize = &quot;Size12&quot;; -- Fontsize of chat.

	-- RENDERSTREAM CHOICE MENU --
	RenderStreamMenu = {
		ChoiceSizeY = 30; 
		ChoiceSizeXPadding = 10; -- Padding total on the X axis. 
		ChoiceYPadding = 5; -- Padding between each choice. 
	};

	DefaultNotificationColor = Color3.new(1, 1, 1);
	ContentFailed = &quot;[ Content Deleted ]&quot;; -- When it fails to display content. 
	MutedMessage = &quot;You are muted, and cannot chat.&quot;; -- Message to send to players when they are muted. 
	MutedMessageColor = Color3.new(255/255, 233/255, 181/255);
	
	ScriptBuilder = {
		-- Blue color, specifying when stuff is running, et cetera. 
		InternalOutputColor = Color3.new(0, 209/255, 255/255);
		ErrorOutputColor = Color3.new(1, 0, 0);
	};
	
	OutputFontSize = &quot;Size10&quot;;
	
	ROBLOXAdminList = {
		&quot;AcesWayUpHigh&quot;;
		&quot;Anaminus&quot;;
		&quot;Brighteyes&quot;;
		&quot;Builderman&quot;;
		&quot;CodeWriter&quot;;
		&quot;Cr3470r&quot;;
		&quot;DaveYorkRBX&quot;;
		&quot;David.Baszucki&quot;;
		&quot;Dbapostle&quot;;
		&quot;Doughtless&quot;;
		&quot;Erik.Cassel&quot;;
		&quot;FusRoblox&quot;;
		&quot;Games&quot;;
		&quot;GemLocker&quot;;
		&quot;GongfuTiger&quot;;
		&quot;HotThoth&quot;;
		&quot;JediTkacheff&quot;;
		&quot;Keith&quot;;
		&quot;LordRugDump&quot;;
		&quot;Matt Dusek&quot;;
		&quot;nJay&quot;;
		&quot;OnlyTwentyCharacters&quot;;
		&quot;OstrichSized&quot;;
		&quot;Phil&quot;;
		&quot;RBAdam&quot;;
		&quot;ReeseMcblox&quot;;
		&quot;ROBLOX&quot;;
		&quot;Shedletsky&quot;;
		&quot;SolarCrane&quot;;
		&quot;Sorcus&quot;;
		&quot;StickMasterLuke&quot;;
		&quot;Stravant&quot;;
		&quot;Tarabyte&quot;;
		&quot;Telamon&quot;;
		&quot;TobotRobot&quot;;
		&quot;Tone&quot;;
		&quot;Totbl&quot;;
		&quot;twberg&quot;;
	};
};
</ProtectedString>
<bool name="Disabled">true</bool>
</Properties>
</Item>
</Item>
</Item>
<Item class="Backpack" referent="RBX36">
<Properties>
<string name="Name">Penlight</string>
</Properties>
<Item class="ModuleScript" referent="RBX37">
<Properties>
<string name="Name">PenlightLexer</string>
<ProtectedString name="Source">-- PenlightLexar.lua
-- Last Modified February 3rd, 2014
-- @author Steve Donovan
-- @author Quenty (Modified)

-- Derived from Penlight, modified to work in qSystems
-- https://github.com/stevedonovan/Penlight/blob/master/lua/pl/lexer.lua

--[[
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the &quot;Software&quot;), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF
    ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
    TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
    PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT
    SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
    ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
    OR OTHER DEALINGS IN THE SOFTWARE.
--]]


--[[
    Lexical scanner for creating a sequence of tokens from text.
    `lexer.scan(s)` returns an iterator over all tokens found in the
    string `s`. This iterator returns two values, a token type string
    (such as &apos;string&apos; for quoted string, &apos;iden&apos; for identifier) and the value of the
    token.

    Versions specialized for Lua and C are available; these also handle block comments
    and classify keywords as &apos;keyword&apos; tokens. For example:

       &gt; s = &apos;for i=1,n do&apos;
       &gt; for t,v in lexer.lua(s)  do print(t,v) end
       keyword for
       iden    i
       =       =
       number  1
       ,       ,
       iden    n
       keyword do

    See the Guide for further @{06-data.md.Lexical_Scanning|discussion}
    @module pl.lexer
--]]

local yield,wrap = coroutine.yield,coroutine.wrap
local strfind = string.find
local strsub = string.sub
local append = table.insert

local function assert_arg(idx,val,tp)
    if type(val) ~= tp then
        error(&quot;argument &quot;..idx..&quot; must be &quot;..tp, 2)
    end
end

local lexer = {}

local NUMBER1 = &apos;^[%+%-]?%d+%.?%d*[eE][%+%-]?%d+&apos;
local NUMBER2 = &apos;^[%+%-]?%d+%.?%d*&apos;
local NUMBER3 = &apos;^0x[%da-fA-F]+&apos;
local NUMBER4 = &apos;^%d+%.?%d*[eE][%+%-]?%d+&apos;
local NUMBER5 = &apos;^%d+%.?%d*&apos;
local IDEN = &apos;^[%a_][%w_]*&apos;
local WSPACE = &apos;^%s+&apos;
local STRING0 = [[^([&apos;\&quot;]).-\\%1]]
local STRING1 = [[^([&apos;\&quot;]).-[^\]%1]]
local STRING3 = &quot;^(([&apos;\&quot;])%2)&quot; -- empty string
local PREPRO = &apos;^#.-[^\\]\n&apos;

local plain_matches,lua_matches,cpp_matches,lua_keyword,cpp_keyword

local function tdump(tok)
    return yield(tok,tok)
end

local function ndump(tok,options)
    if options and options.number then
        tok = tonumber(tok)
    end
    return yield(&quot;number&quot;,tok)
end

-- regular strings, single or double quotes; usually we want them
-- without the quotes
local function sdump(tok,options)
    if options and options.string then
        tok = tok:sub(2,-2)
    end
    return yield(&quot;string&quot;,tok)
end

-- long Lua strings need extra work to get rid of the quotes
local function sdump_l(tok,options)
    if options and options.string then
        tok = tok:sub(3,-3)
    end
    return yield(&quot;string&quot;,tok)
end

local function chdump(tok,options)
    if options and options.string then
        tok = tok:sub(2,-2)
    end
    return yield(&quot;char&quot;,tok)
end

local function cdump(tok)
    return yield(&apos;comment&apos;,tok)
end

local function wsdump (tok)
    return yield(&quot;space&quot;,tok)
end

local function pdump (tok)
    return yield(&apos;prepro&apos;,tok)
end

local function plain_vdump(tok)
    return yield(&quot;iden&quot;,tok)
end

local function lua_vdump(tok)
    if lua_keyword[tok] then
        return yield(&quot;keyword&quot;,tok)
    else
        return yield(&quot;iden&quot;,tok)
    end
end

local function cpp_vdump(tok)
    if cpp_keyword[tok] then
        return yield(&quot;keyword&quot;,tok)
    else
        return yield(&quot;iden&quot;,tok)
    end
end

--- create a plain token iterator from a string or file-like object.
-- @param s the string
-- @param matches an optional match table (set of pattern-action pairs)
-- @param filter a table of token types to exclude, by default {space=true}
-- @param options a table of options; by default, {number=true,string=true},
-- which means convert numbers and strip string quotes.
function lexer.scan (s,matches,filter,options)
    --assert_arg(1,s,&apos;string&apos;)
    local file = type(s) ~= &apos;string&apos; and s
    filter = filter or {space=true}
    options = options or {number=true,string=true}
    if filter then
        if filter.space then filter[wsdump] = true end
        if filter.comments then
            filter[cdump] = true
        end
    end
    if not matches then
        if not plain_matches then
            plain_matches = {
                {WSPACE,wsdump},
                {NUMBER3,ndump},
                {IDEN,plain_vdump},
                {NUMBER1,ndump},
                {NUMBER2,ndump},
                {STRING3,sdump},
                {STRING0,sdump},
                {STRING1,sdump},
                {&apos;^.&apos;,tdump}
            }
        end
        matches = plain_matches
    end
    local function lex ()
        local i1,i2,idx,res1,res2,tok,pat,fun,capt
        local line = 1
        if file then s = file:read()..&apos;\n&apos; end
        local sz = #s
        local idx = 1
        --print(&apos;sz&apos;,sz)
        while true do
            for _,m in ipairs(matches) do
                pat = m[1]
                fun = m[2]
                i1,i2 = strfind(s,pat,idx)
                if i1 then
                    tok = strsub(s,i1,i2)
                    idx = i2 + 1
                    if not (filter and filter[fun]) then
                        lexer.finished = idx &gt; sz
                        res1,res2 = fun(tok,options)
                    end
                    if res1 then
                        local tp = type(res1)
                        -- insert a token list
                        if tp==&apos;table&apos; then
                            yield(&apos;&apos;,&apos;&apos;)
                            for _,t in ipairs(res1) do
                                yield(t[1],t[2])
                            end
                        elseif tp == &apos;string&apos; then -- or search up to some special pattern
                            i1,i2 = strfind(s,res1,idx)
                            if i1 then
                                tok = strsub(s,i1,i2)
                                idx = i2 + 1
                                yield(&apos;&apos;,tok)
                            else
                                yield(&apos;&apos;,&apos;&apos;)
                                idx = sz + 1
                            end
                            --if idx &gt; sz then return end
                        else
                            yield(line,idx)
                        end
                    end
                    if idx &gt; sz then
                        if file then
                            --repeat -- next non-empty line
                                line = line + 1
                                s = file:read()
                                if not s then return end
                            --until not s:match &apos;^%s*$&apos;
                            s = s .. &apos;\n&apos;
                            idx ,sz = 1,#s
                            break
                        else
                            return
                        end
                    else break end
                end
            end
        end
    end
    return wrap(lex)
end

local function isstring (s)
    return type(s) == &apos;string&apos;
end

--- insert tokens into a stream.
-- @param tok a token stream
-- @param a1 a string is the type, a table is a token list and
-- a function is assumed to be a token-like iterator (returns type &amp; value)
-- @param a2 a string is the value
function lexer.insert (tok,a1,a2)
    if not a1 then return end
    local ts
    if isstring(a1) and isstring(a2) then
        ts = {{a1,a2}}
    elseif type(a1) == &apos;function&apos; then
        ts = {}
        for t,v in a1() do
            append(ts,{t,v})
        end
    else
        ts = a1
    end
    tok(ts)
end

--- get everything in a stream upto a newline.
-- @param tok a token stream
-- @return a string
function lexer.getline (tok)
    local t,v = tok(&apos;.-\n&apos;)
    return v
end

--- get current line number. &lt;br&gt;
-- Only available if the input source is a file-like object.
-- @param tok a token stream
-- @return the line number and current column
function lexer.lineno (tok)
    return tok(0)
end

--- get the rest of the stream.
-- @param tok a token stream
-- @return a string
function lexer.getrest (tok)
    local t,v = tok(&apos;.+&apos;)
    return v
end

--- get the Lua keywords as a set-like table.
-- So &lt;code&gt;res[&quot;and&quot;]&lt;/code&gt; etc would be &lt;code&gt;true&lt;/code&gt;.
-- @return a table
function lexer.get_keywords ()
    if not lua_keyword then
        lua_keyword = {
            [&quot;and&quot;] = true, [&quot;break&quot;] = true,  [&quot;do&quot;] = true,
            [&quot;else&quot;] = true, [&quot;elseif&quot;] = true, [&quot;end&quot;] = true,
            [&quot;false&quot;] = true, [&quot;for&quot;] = true, [&quot;function&quot;] = true,
            [&quot;if&quot;] = true, [&quot;in&quot;] = true,  [&quot;local&quot;] = true, [&quot;nil&quot;] = true,
            [&quot;not&quot;] = true, [&quot;or&quot;] = true, [&quot;repeat&quot;] = true,
            [&quot;return&quot;] = true, [&quot;then&quot;] = true, [&quot;true&quot;] = true,
            [&quot;until&quot;] = true,  [&quot;while&quot;] = true
        }
    end
    return lua_keyword
end


--- create a Lua token iterator from a string or file-like object.
-- Will return the token type and value.
-- @param s the string
-- @param filter a table of token types to exclude, by default {space=true,comments=true}
-- @param options a table of options; by default, {number=true,string=true},
-- which means convert numbers and strip string quotes.
function lexer.lua(s,filter,options)
    filter = filter or {space=true,comments=true}
    lexer.get_keywords()
    if not lua_matches then
        lua_matches = {
            {WSPACE,wsdump},
            {NUMBER3,ndump},
            {IDEN,lua_vdump},
            {NUMBER4,ndump},
            {NUMBER5,ndump},
            {STRING3,sdump},
            {STRING0,sdump},
            {STRING1,sdump},
            {&apos;^%-%-%[%[.-%]%]&apos;,cdump},
            {&apos;^%-%-.-\n&apos;,cdump},
            {&apos;^%[%[.-%]%]&apos;,sdump_l},
            {&apos;^==&apos;,tdump},
            {&apos;^~=&apos;,tdump},
            {&apos;^&lt;=&apos;,tdump},
            {&apos;^&gt;=&apos;,tdump},
            {&apos;^%.%.%.&apos;,tdump},
            {&apos;^%.%.&apos;,tdump},
            {&apos;^.&apos;,tdump}
        }
    end
    return lexer.scan(s,lua_matches,filter,options)
end

--- create a C/C++ token iterator from a string or file-like object.
-- Will return the token type type and value.
-- @param s the string
-- @param filter a table of token types to exclude, by default {space=true,comments=true}
-- @param options a table of options; by default, {number=true,string=true},
-- which means convert numbers and strip string quotes.
function lexer.cpp(s,filter,options)
    filter = filter or {comments=true}
    if not cpp_keyword then
        cpp_keyword = {
            [&quot;class&quot;] = true, [&quot;break&quot;] = true,  [&quot;do&quot;] = true, [&quot;sizeof&quot;] = true,
            [&quot;else&quot;] = true, [&quot;continue&quot;] = true, [&quot;struct&quot;] = true,
            [&quot;false&quot;] = true, [&quot;for&quot;] = true, [&quot;public&quot;] = true, [&quot;void&quot;] = true,
            [&quot;private&quot;] = true, [&quot;protected&quot;] = true, [&quot;goto&quot;] = true,
            [&quot;if&quot;] = true, [&quot;static&quot;] = true,  [&quot;const&quot;] = true, [&quot;typedef&quot;] = true,
            [&quot;enum&quot;] = true, [&quot;char&quot;] = true, [&quot;int&quot;] = true, [&quot;bool&quot;] = true,
            [&quot;long&quot;] = true, [&quot;float&quot;] = true, [&quot;true&quot;] = true, [&quot;delete&quot;] = true,
            [&quot;double&quot;] = true,  [&quot;while&quot;] = true, [&quot;new&quot;] = true,
            [&quot;namespace&quot;] = true, [&quot;try&quot;] = true, [&quot;catch&quot;] = true,
            [&quot;switch&quot;] = true, [&quot;case&quot;] = true, [&quot;extern&quot;] = true,
            [&quot;return&quot;] = true,[&quot;default&quot;] = true,[&apos;unsigned&apos;]  = true,[&apos;signed&apos;] = true,
            [&quot;union&quot;] =  true, [&quot;volatile&quot;] = true, [&quot;register&quot;] = true,[&quot;short&quot;] = true,
        }
    end
    if not cpp_matches then
        cpp_matches = {
            {WSPACE,wsdump},
            {PREPRO,pdump},
            {NUMBER3,ndump},
            {IDEN,cpp_vdump},
            {NUMBER4,ndump},
            {NUMBER5,ndump},
            {STRING3,sdump},
            {STRING1,chdump},
            {&apos;^//.-\n&apos;,cdump},
            {&apos;^/%*.-%*/&apos;,cdump},
            {&apos;^==&apos;,tdump},
            {&apos;^!=&apos;,tdump},
            {&apos;^&lt;=&apos;,tdump},
            {&apos;^&gt;=&apos;,tdump},
            {&apos;^-&gt;&apos;,tdump},
            {&apos;^&amp;&amp;&apos;,tdump},
            {&apos;^||&apos;,tdump},
            {&apos;^%+%+&apos;,tdump},
            {&apos;^%-%-&apos;,tdump},
            {&apos;^%+=&apos;,tdump},
            {&apos;^%-=&apos;,tdump},
            {&apos;^%*=&apos;,tdump},
            {&apos;^/=&apos;,tdump},
            {&apos;^|=&apos;,tdump},
            {&apos;^%^=&apos;,tdump},
            {&apos;^::&apos;,tdump},
            {&apos;^.&apos;,tdump}
        }
    end
    return lexer.scan(s,cpp_matches,filter,options)
end

--- get a list of parameters separated by a delimiter from a stream.
-- @param tok the token stream
-- @param endtoken end of list (default &apos;)&apos;). Can be &apos;\n&apos;
-- @param delim separator (default &apos;,&apos;)
-- @return a list of token lists.
function lexer.get_separated_list(tok,endtoken,delim)
    endtoken = endtoken or &apos;)&apos;
    delim = delim or &apos;,&apos;
    local parm_values = {}
    local level = 1 -- used to count ( and )
    local tl = {}
    local function tappend (tl,t,val)
        val = val or t
        append(tl,{t,val})
    end
    local is_end
    if endtoken == &apos;\n&apos; then
        is_end = function(t,val)
            return t == &apos;space&apos; and val:find &apos;\n&apos;
        end
    else
        is_end = function (t)
            return t == endtoken
        end
    end
    local token,value
    while true do
        token,value=tok()
        if not token then return nil,&apos;EOS&apos; end -- end of stream is an error!
        if is_end(token,value) and level == 1 then
            append(parm_values,tl)
            break
        elseif token == &apos;(&apos; then
            level = level + 1
            tappend(tl,&apos;(&apos;)
        elseif token == &apos;)&apos; then
            level = level - 1
            if level == 0 then -- finished with parm list
                append(parm_values,tl)
                break
            else
                tappend(tl,&apos;)&apos;)
            end
        elseif token == delim and level == 1 then
            append(parm_values,tl) -- a new parm
            tl = {}
        else
            tappend(tl,token,value)
        end
    end
    return parm_values,{token,value}
end

--- get the next non-space token from the stream.
-- @param tok the token stream.
function lexer.skipws (tok)
    local t,v = tok()
    while t == &apos;space&apos; do
        t,v = tok()
    end
    return t,v
end

local skipws = lexer.skipws

--- get the next token, which must be of the expected type.
-- Throws an error if this type does not match!
-- @param tok the token stream
-- @param expected_type the token type
-- @param no_skip_ws whether we should skip whitespace
function lexer.expecting (tok,expected_type,no_skip_ws)
    assert_arg(1,tok,&apos;function&apos;)
    assert_arg(2,expected_type,&apos;string&apos;)
    local t,v
    if no_skip_ws then
        t,v = tok()
    else
        t,v = skipws(tok)
    end
    if t ~= expected_type then error (&quot;expecting &quot;..expected_type,2) end
    return v
end

return lexer</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX38">
<Properties>
<string name="Name">PenlightPretty</string>
<ProtectedString name="Source">-- PenlightPretty.lua
-- Last Modified February 3rd, 2014
-- @author Steve Donovan
-- @author Quenty (Modified)

local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

-- Derived from Penlight, modified to work in qSystems
-- https://github.com/stevedonovan/Penlight/blob/master/lua/pl/pretty.lua

--[[
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the &quot;Software&quot;), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF
	ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
	TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
	PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT
	SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
	ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
	OR OTHER DEALINGS IN THE SOFTWARE.
--]]

--[[
	Pretty-printing Lua tables.
	Also provides a sandboxed Lua table reader and
	a function to present large numbers in human-friendly format.

	Dependencies: `pl.utils`, `pl.lexer`
	@module pl.pretty
--]]
local append = table.insert
local concat = table.concat
local lexer = LoadCustomLibrary(&quot;PenlightLexer&quot;)


---- Derived from pl.utils
--- assert that the given argument is in fact of the correct type.
-- @param n argument index
-- @param val the value
-- @param tp the type
-- @param verify an optional verfication function
-- @param msg an optional custom message
-- @param lev optional stack position for trace, default 2
-- @raise if the argument n is not the correct type
-- @usage assert_arg(1,t,&apos;table&apos;)
-- @usage assert_arg(n,val,&apos;string&apos;,path.isdir,&apos;not a directory&apos;)
local function assert_arg (n,val,tp,verify,msg,lev)
	if type(val) ~= tp then
		error((&quot;argument %d expected a &apos;%s&apos;, got a &apos;%s&apos;&quot;):format(n,tp,type(val)),lev or 2)
	end
	if verify and not verify(val) then
		error((&quot;argument %d: &apos;%s&apos; %s&quot;):format(n,val,msg),lev or 2)
	end
end

---- Derived from pl.utils
--- convert an array of values to strings.
-- @param t a list-like table
-- @param temp buffer to use, otherwise allocate
-- @param tostr custom tostring function, called with (value,index).
-- Otherwise use `tostring`
-- @return the converted buffer
local function load(str,src,mode,env)
	local chunk,err
	if type(str) == &apos;string&apos; then
		chunk,err = loadstring(str,src)
	else
		chunk,err = lua51_load(str,src)
	end
	if chunk and env then setfenv(chunk,env) end
	return chunk, err
end


local pretty = {}

local function save_string_index ()
	local SMT = getmetatable &apos;&apos;
	if SMT then
		SMT.old__index = SMT.__index
		SMT.__index = nil
	end
	return SMT
end

local function restore_string_index (SMT)
	if SMT then
		SMT.__index = SMT.old__index
	end
end

--- read a string representation of a Lua table.
-- Uses load(), but tries to be cautious about loading arbitrary code!
-- It is expecting a string of the form &apos;{...}&apos;, with perhaps some whitespace
-- before or after the curly braces. A comment may occur beforehand.
-- An empty environment is used, and
-- any occurance of the keyword &apos;function&apos; will be considered a problem.
-- in the given environment - the return value may be `nil`.
-- @param s {string} string of the form &apos;{...}&apos;, with perhaps some whitespace
-- before or after the curly braces.
-- @return a table
function pretty.read(s)
	assert_arg(1,s,&apos;string&apos;)
	if s:find &apos;^%s*%-%-&apos; then -- may start with a comment..
		s = s:gsub(&apos;%-%-.-\n&apos;,&apos;&apos;)
	end
	if not s:find &apos;^%s*%b{}%s*$&apos; then return nil,&quot;not a Lua table&quot; end
	if s:find &apos;[^\&apos;&quot;%w_]function[^\&apos;&quot;%w_]&apos; then
		local tok = lexer.lua(s)
		for t,v in tok do
			if t == &apos;keyword&apos; then
				return nil,&quot;cannot have functions in table definition&quot;
			end
		end
	end
	s = &apos;return &apos;..s
	local chunk,err = load(s,&apos;tbl&apos;,&apos;t&apos;,{})
	if not chunk then return nil,err end
	local SMT = save_string_index()
	local ok,ret = pcall(chunk)
	restore_string_index(SMT)
	if ok then return ret
	else
		return nil,ret
	end
end

--- read a Lua chunk.
-- @param s Lua code
-- @param env optional environment
-- @param paranoid prevent any looping constructs and disable string methods
-- @return the environment
function pretty.load (s, env, paranoid)
	env = env or {}
	if paranoid then
		local tok = lexer.lua(s)
		for t,v in tok do
			if t == &apos;keyword&apos;
				and (v == &apos;for&apos; or v == &apos;repeat&apos; or v == &apos;function&apos; or v == &apos;goto&apos;)
			then
				return nil, &quot;looping not allowed&quot;
			end
		end
	end
	local chunk,err = load(s,&apos;tbl&apos;,&apos;t&apos;,env)
	if not chunk then return nil,err end
	local SMT = paranoid and save_string_index()
	local ok,err = pcall(chunk)
	restore_string_index(SMT)
	if not ok then return nil,err end
	return env
end

local function quote_if_necessary(v)
	if not v then return &apos;&apos;
	else
		if v:find &apos; &apos; then v = &apos;&quot;&apos;..v..&apos;&quot;&apos; end
	end
	return v
end

local keywords

local function is_identifier(s)
	return type(s) == &apos;string&apos; and s:find(&apos;^[%a_][%w_]*$&apos;) and not keywords[s]
end

local function quote(s)
	if type(s) == &apos;table&apos; then
		return pretty.write(s,&apos;&apos;)
	else
		return (&apos;%q&apos;):format(tostring(s))
	end
end

local function index (numkey,key)
	if not numkey then key = quote(key) end
	return &apos;[&apos;..key..&apos;]&apos;
end


--- Create a string representation of a Lua table.
--  This function never fails, but may complain by returning an
--  extra value. Normally puts out one item per line, using
--  the provided indent; set the second parameter to &apos;&apos; if
--  you want output on one line.
--  @param tbl {table} Table to serialize to a string.
--  @param space {string} (optional) The indent to use.
--  Defaults to two spaces; make it the empty string for no indentation
--  @param not_clever {bool} (optional) Use for plain output, e.g {[&apos;key&apos;]=1}.
--  Defaults to false.
--  @return a string
--  @return a possible error message
local function write(tbl,space,not_clever)
	if type(tbl) ~= &apos;table&apos; then
		local res = tostring(tbl)
		if type(tbl) == &apos;string&apos; then return quote(tbl) end
		return res, &apos;not a table&apos;
	end
	if not keywords then
		keywords = lexer.get_keywords()
	end
	local set = &apos; = &apos;
	if space == &apos;&apos; then set = &apos;=&apos; end
	space = space or &apos;  &apos;
	local lines = {}
	local line = &apos;&apos;
	local tables = {}


	local function put(s)
		if #s &gt; 0 then
			line = line..s
		end
	end

	local function putln (s)
		if #line &gt; 0 then
			line = line..s
			append(lines,line)
			line = &apos;&apos;
		else
			append(lines,s)
		end
	end

	local function eat_last_comma()
		local n,lastch = #lines
		local lastch = lines[n]:sub(-1,-1)
		if lastch == &apos;,&apos; then
			lines[n] = lines[n]:sub(1,-2)
		end
	end


	local writeit
	writeit = function (t,oldindent,indent)
		local tp = type(t)
		if tp ~= &apos;string&apos; and  tp ~= &apos;table&apos; then
			putln(quote_if_necessary(tostring(t))..&apos;,&apos;)
		elseif tp == &apos;string&apos; then
			if t:find(&apos;\n&apos;) then
				putln(&apos;[[\n&apos;..t..&apos;]],&apos;)
			else
				putln(quote(t)..&apos;,&apos;)
			end
		elseif tp == &apos;table&apos; then
			if tables[t] then
				putln(&apos;&lt;cycle&gt;,&apos;)
				return
			end
			tables[t] = true
			local newindent = indent..space
			putln(&apos;{&apos;)
			local used = {}
			if not not_clever then
				for i,val in ipairs(t) do
					put(indent)
					writeit(val,indent,newindent)
					used[i] = true
				end
			end
			for key,val in pairs(t) do
				local numkey = type(key) == &apos;number&apos;
				if not_clever then
					key = tostring(key)
					put(indent..index(numkey,key)..set)
					writeit(val,indent,newindent)
				else
					if not numkey or not used[key] then -- non-array indices
						if numkey or not is_identifier(key) then
							key = index(numkey,key)
						end
						put(indent..key..set)
						writeit(val,indent,newindent)
					end
				end
			end
			tables[t] = nil
			eat_last_comma()
			putln(oldindent..&apos;},&apos;)
		else
			putln(tostring(t)..&apos;,&apos;)
		end
	end
	writeit(tbl,&apos;&apos;,space)
	eat_last_comma()
	return concat(lines,#space &gt; 0 and &apos;\n&apos; or &apos;&apos;)
end
pretty.write = write
pretty.Write = write

pretty.tableToString = write -- My type of syntax. 
pretty.TableToString = write

--- Dump a Lua table out to a file or stdout.
--  @param t {table} The table to write to a file or stdout.
--  @param ... {string} (optional) File name to write too. Defaults to writing
--  to stdout.
--[[
function pretty.dump (t,...)
	if select(&apos;#&apos;,...)==0 then
		print(pretty.write(t))
		return true
	else
		return utils.writefile(...,pretty.write(t))
	end
end
--]]

local memp,nump = {&apos;B&apos;,&apos;KiB&apos;,&apos;MiB&apos;,&apos;GiB&apos;},{&apos;&apos;,&apos;K&apos;,&apos;M&apos;,&apos;B&apos;}

local comma
function comma (val)
	local thou = math.floor(val/1000)
	if thou &gt; 0 then return comma(thou)..&apos;,&apos;..(val % 1000)
	else return tostring(val) end
end

--- format large numbers nicely for human consumption.
-- @param num a number
-- @param kind one of &apos;M&apos; (memory in KiB etc), &apos;N&apos; (postfixes are &apos;K&apos;,&apos;M&apos; and &apos;B&apos;)
-- and &apos;T&apos; (use commas as thousands separator)
-- @param prec number of digits to use for &apos;M&apos; and &apos;N&apos; (default 1)
function pretty.number (num,kind,prec)
	local fmt = &apos;%.&apos;..(prec or 1)..&apos;f%s&apos;
	if kind == &apos;T&apos; then
		return comma(num)
	else
		local postfixes, fact
		if kind == &apos;M&apos; then
			fact = 1024
			postfixes = memp
		else
			fact = 1000
			postfixes = nump
		end
		local div = fact
		local k = 1
		while num &gt;= div and k &lt;= #postfixes do
			div = div * fact
			k = k + 1
		end
		div = div / fact
		if k &gt; #postfixes then k = k - 1; div = div/fact end
		if k &gt; 1 then
			return fmt:format(num/div,postfixes[k] or &apos;duh&apos;)
		else
			return num..postfixes[1]
		end
	end
end

return pretty</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX39">
<Properties>
<string name="Name">PenlightUtils</string>
<ProtectedString name="Source">--- Generally useful routines.
-- See  @{01-introduction.md.Generally_useful_functions|the Guide}.
-- @module pl.utils
local format,gsub,byte = string.format,string.gsub,string.byte
local clock = os.clock
local stdout = io.stdout
local append = table.insert

local collisions = {}

local utils = {}

-- Derived from Penlight, modified to work in qSystems
-- https://github.com/stevedonovan/Penlight/blob/master/lua/pl/utils.lua

--[[
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the &quot;Software&quot;), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF
    ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
    TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
    PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT
    SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
    ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
    OR OTHER DEALINGS IN THE SOFTWARE.
--]]

utils._VERSION = &quot;1.1.0&quot;

local lua51 = rawget(_G,&apos;setfenv&apos;)

utils.lua51 = lua51
if not lua51 then -- Lua 5.2 compatibility
    unpack = table.unpack
    loadstring = load
end

utils.dir_separator = _G.package.config:sub(1,1)

--- end this program gracefully.
-- @param code The exit code or a message to be printed
-- @param ... extra arguments for message&apos;s format&apos;
-- @see utils.fprintf
function utils.quit(code,...)
    if type(code) == &apos;string&apos; then
        utils.fprintf(io.stderr,code,...)
        code = -1
    else
        utils.fprintf(io.stderr,...)
    end
    io.stderr:write(&apos;\n&apos;)
    os.exit(code)
end

--- print an arbitrary number of arguments using a format.
-- @param fmt The format (see string.format)
-- @param ... Extra arguments for format
function utils.printf(fmt,...)
    utils.assert_string(1,fmt)
    utils.fprintf(stdout,fmt,...)
end

--- write an arbitrary number of arguments to a file using a format.
-- @param f File handle to write to.
-- @param fmt The format (see string.format).
-- @param ... Extra arguments for format
--[[
function utils.fprintf(f,fmt,...)
    utils.assert_string(2,fmt)
    f:write(format(fmt,...))
end
--]]
local function import_symbol(T,k,v,libname)
    local key = rawget(T,k)
    -- warn about collisions!
    if key and k ~= &apos;_M&apos; and k ~= &apos;_NAME&apos; and k ~= &apos;_PACKAGE&apos; and k ~= &apos;_VERSION&apos; then
        utils.printf(&quot;warning: &apos;%s.%s&apos; overrides existing symbol\n&quot;,libname,k)
    end
    rawset(T,k,v)
end

local function lookup_lib(T,t)
    for k,v in pairs(T) do
        if v == t then return k end
    end
    return &apos;?&apos;
end

local already_imported = {}

--- take a table and &apos;inject&apos; it into the local namespace.
-- @param t The Table
-- @param T An optional destination table (defaults to callers environment)
function utils.import(t,T)
    T = T or _G
    t = t or utils
    if type(t) == &apos;string&apos; then
        t = require (t)
    end
    local libname = lookup_lib(T,t)
    if already_imported[t] then return end
    already_imported[t] = libname
    for k,v in pairs(t) do
        import_symbol(T,k,v,libname)
    end
end

utils.patterns = {
    FLOAT = &apos;[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*&apos;,
    INTEGER = &apos;[+%-%d]%d*&apos;,
    IDEN = &apos;[%a_][%w_]*&apos;,
    FILE = &apos;[%a%.\\][:%][%w%._%-\\]*&apos;
}

--- escape any &apos;magic&apos; characters in a string
-- @param s The input string
function utils.escape(s)
    utils.assert_string(1,s)
    return (s:gsub(&apos;[%-%.%+%[%]%(%)%$%^%%%?%*]&apos;,&apos;%%%1&apos;))
end

--- return either of two values, depending on a condition.
-- @param cond A condition
-- @param value1 Value returned if cond is true
-- @param value2 Value returned if cond is false (can be optional)
function utils.choose(cond,value1,value2)
    if cond then return value1
    else return value2
    end
end

local raise

--- return the contents of a file as a string
-- @param filename The file path
-- @param is_bin open in binary mode
-- @return file contents
function utils.readfile(filename,is_bin)
    local mode = is_bin and &apos;b&apos; or &apos;&apos;
    utils.assert_string(1,filename)
    local f,err = io.open(filename,&apos;r&apos;..mode)
    if not f then return utils.raise (err) end
    local res,err = f:read(&apos;*a&apos;)
    f:close()
    if not res then return raise (err) end
    return res
end

--- write a string to a file
-- @param filename The file path
-- @param str The string
-- @return true or nil
-- @return error message
-- @raise error if filename or str aren&apos;t strings
function utils.writefile(filename,str)
    utils.assert_string(1,filename)
    utils.assert_string(2,str)
    local f,err = io.open(filename,&apos;w&apos;)
    if not f then return raise(err) end
    f:write(str)
    f:close()
    return true
end

--- return the contents of a file as a list of lines
-- @param filename The file path
-- @return file contents as a table
-- @raise errror if filename is not a string
function utils.readlines(filename)
    utils.assert_string(1,filename)
    local f,err = io.open(filename,&apos;r&apos;)
    if not f then return raise(err) end
    local res = {}
    for line in f:lines() do
        append(res,line)
    end
    f:close()
    return res
end

--- split a string into a list of strings separated by a delimiter.
-- @param s The input string
-- @param re A Lua string pattern; defaults to &apos;%s+&apos;
-- @param plain don&apos;t use Lua patterns
-- @param n optional maximum number of splits
-- @return a list-like table
-- @raise error if s is not a string
function utils.split(s,re,plain,n)
    utils.assert_string(1,s)
    local find,sub,append = string.find, string.sub, table.insert
    local i1,ls = 1,{}
    if not re then re = &apos;%s+&apos; end
    if re == &apos;&apos; then return {s} end
    while true do
        local i2,i3 = find(s,re,i1,plain)
        if not i2 then
            local last = sub(s,i1)
            if last ~= &apos;&apos; then append(ls,last) end
            if #ls == 1 and ls[1] == &apos;&apos; then
                return {}
            else
                return ls
            end
        end
        append(ls,sub(s,i1,i2-1))
        if n and #ls == n then
            ls[#ls] = sub(s,i1)
            return ls
        end
        i1 = i3+1
    end
end

--- split a string into a number of values.
-- @param s the string
-- @param re the delimiter, default space
-- @return n values
-- @usage first,next = splitv(&apos;jane:doe&apos;,&apos;:&apos;)
-- @see split
function utils.splitv (s,re)
    return unpack(utils.split(s,re))
end

--- convert an array of values to strings.
-- @param t a list-like table
-- @param temp buffer to use, otherwise allocate
-- @param tostr custom tostring function, called with (value,index).
-- Otherwise use `tostring`
-- @return the converted buffer
function utils.array_tostring (t,temp,tostr)
    temp, tostr = temp or {}, tostr or tostring
    for i = 1,#t do
        temp[i] = tostr(t[i],i)
    end
    return temp
end

local lua51_load = load

if utils.lua51 then -- define Lua 5.2 style load()
    function utils.load(str,src,mode,env)
        local chunk,err
        if type(str) == &apos;string&apos; then
            chunk,err = loadstring(str,src)
        else
            chunk,err = lua51_load(str,src)
        end
        if chunk and env then setfenv(chunk,env) end
        return chunk,err
    end
else
    utils.load = load
    -- setfenv/getfenv replacements for Lua 5.2
    -- by Sergey Rozhenko
    -- http://lua-users.org/lists/lua-l/2010-06/msg00313.html
    -- Roberto Ierusalimschy notes that it is possible for getfenv to return nil
    -- in the case of a function with no globals:
    -- http://lua-users.org/lists/lua-l/2010-06/msg00315.html
    function setfenv(f, t)
        f = (type(f) == &apos;function&apos; and f or debug.getinfo(f + 1, &apos;f&apos;).func)
        local name
        local up = 0
        repeat
            up = up + 1
            name = debug.getupvalue(f, up)
        until name == &apos;_ENV&apos; or name == nil
        if name then
            debug.upvaluejoin(f, up, function() return name end, 1) -- use unique upvalue
            debug.setupvalue(f, up, t)
        end
        if f ~= 0 then return f end
    end

    function getfenv(f)
        local f = f or 0
        f = (type(f) == &apos;function&apos; and f or debug.getinfo(f + 1, &apos;f&apos;).func)
        local name, val
        local up = 0
        repeat
            up = up + 1
            name, val = debug.getupvalue(f, up)
        until name == &apos;_ENV&apos; or name == nil
        return val
    end
end


--- execute a shell command.
-- This is a compatibility function that returns the same for Lua 5.1 and Lua 5.2
-- @param cmd a shell command
-- @return true if successful
-- @return actual return code
function utils.execute (cmd)
    local res1,res2,res2 = os.execute(cmd)
    if lua51 then
        return res1==0,res1
    else
        return res1,res2
    end
end

if lua51 then
    function table.pack (...)
        local n = select(&apos;#&apos;,...)
        return {n=n; ...}
    end
    local sep = package.config:sub(1,1)
    function package.searchpath (mod,path)
        mod = mod:gsub(&apos;%.&apos;,sep)
        for m in path:gmatch(&apos;[^;]+&apos;) do
            local nm = m:gsub(&apos;?&apos;,mod)
            local f = io.open(nm,&apos;r&apos;)
            if f then f:close(); return nm end
        end
    end
end

if not table.pack then table.pack = _G.pack end
if not rawget(_G,&quot;pack&quot;) then _G.pack = table.pack end

--- take an arbitrary set of arguments and make into a table.
-- This returns the table and the size; works fine for nil arguments
-- @param ... arguments
-- @return table
-- @return table size
-- @usage local t,n = utils.args(...)

--- &apos;memoize&apos; a function (cache returned value for next call).
-- This is useful if you have a function which is relatively expensive,
-- but you don&apos;t know in advance what values will be required, so
-- building a table upfront is wasteful/impossible.
-- @param func a function of at least one argument
-- @return a function with at least one argument, which is used as the key.
function utils.memoize(func)
    return setmetatable({}, {
        __index = function(self, k, ...)
            local v = func(k,...)
            self[k] = v
            return v
        end,
        __call = function(self, k) return self[k] end
    })
end

--- is the object either a function or a callable object?.
-- @param obj Object to check.
function utils.is_callable (obj)
    return type(obj) == &apos;function&apos; or getmetatable(obj) and getmetatable(obj).__call
end

--- is the object of the specified type?.
-- If the type is a string, then use type, otherwise compare with metatable
-- @param obj An object to check
-- @param tp String of what type it should be
function utils.is_type (obj,tp)
    if type(tp) == &apos;string&apos; then return type(obj) == tp end
    local mt = getmetatable(obj)
    return tp == mt
end

local fileMT = getmetatable(io.stdout)

--- a string representation of a type.
-- For tables with metatables, we assume that the metatable has a `_name`
-- field. Knows about Lua file objects.
-- @param obj an object
-- @return a string like &apos;number&apos;, &apos;table&apos; or &apos;List&apos;
function utils.type (obj)
    local t = type(obj)
    if t == &apos;table&apos; or t == &apos;userdata&apos; then
        local mt = getmetatable(obj)
        if mt == fileMT then
            return &apos;file&apos;
        else
            return mt._name or &quot;unknown &quot;..t
        end
    else
        return t
    end
end

--- is this number an integer?
-- @param x a number
-- @raise error if x is not a number
function utils.is_integer (x)
    return math.ceil(x)==x
end

utils.stdmt = {
    List = {_name=&apos;List&apos;}, Map = {_name=&apos;Map&apos;},
    Set = {_name=&apos;Set&apos;}, MultiMap = {_name=&apos;MultiMap&apos;}
}

local _function_factories = {}

--- associate a function factory with a type.
-- A function factory takes an object of the given type and
-- returns a function for evaluating it
-- @param mt metatable
-- @param fun a callable that returns a function
function utils.add_function_factory (mt,fun)
    _function_factories[mt] = fun
end

local function _string_lambda(f)
    local raise = utils.raise
    if f:find &apos;^|&apos; or f:find &apos;_&apos; then
        local args,body = f:match &apos;|([^|]*)|(.+)&apos;
        if f:find &apos;_&apos; then
            args = &apos;_&apos;
            body = f
        else
            if not args then return raise &apos;bad string lambda&apos; end
        end
        local fstr = &apos;return function(&apos;..args..&apos;) return &apos;..body..&apos; end&apos;
        local fn,err = loadstring(fstr)
        if not fn then return raise(err) end
        fn = fn()
        return fn
    else return raise &apos;not a string lambda&apos;
    end
end

--- an anonymous function as a string. This string is either of the form
-- &apos;|args| expression&apos; or is a function of one argument, &apos;_&apos;
-- @param lf function as a string
-- @return a function
-- @usage string_lambda &apos;|x|x+1&apos; (2) == 3
-- @usage string_lambda &apos;_+1 (2) == 3
-- @function utils.string_lambda
utils.string_lambda = utils.memoize(_string_lambda)

local ops

--- process a function argument.
-- This is used throughout Penlight and defines what is meant by a function:
-- Something that is callable, or an operator string as defined by &lt;code&gt;pl.operator&lt;/code&gt;,
-- such as &apos;&gt;&apos; or &apos;#&apos;. If a function factory has been registered for the type, it will
-- be called to get the function.
-- @param idx argument index
-- @param f a function, operator string, or callable object
-- @param msg optional error message
-- @return a callable
-- @raise if idx is not a number or if f is not callable
-- @see utils.is_callable
function utils.function_arg (idx,f,msg)
    utils.assert_arg(1,idx,&apos;number&apos;)
    local tp = type(f)
    if tp == &apos;function&apos; then return f end  -- no worries!
    -- ok, a string can correspond to an operator (like &apos;==&apos;)
    if tp == &apos;string&apos; then
        if not ops then ops = require &apos;pl.operator&apos;.optable end
        local fn = ops[f]
        if fn then return fn end
        local fn, err = utils.string_lambda(f)
        if not fn then error(err..&apos;: &apos;..f) end
        return fn
    elseif tp == &apos;table&apos; or tp == &apos;userdata&apos; then
        local mt = getmetatable(f)
        if not mt then error(&apos;not a callable object&apos;,2) end
        local ff = _function_factories[mt]
        if not ff then
            if not mt.__call then error(&apos;not a callable object&apos;,2) end
            return f
        else
            return ff(f) -- we have a function factory for this type!
        end
    end
    if not msg then msg = &quot; must be callable&quot; end
    if idx &gt; 0 then
        error(&quot;argument &quot;..idx..&quot;: &quot;..msg,2)
    else
        error(msg,2)
    end
end

--- bind the first argument of the function to a value.
-- @param fn a function of at least two values (may be an operator string)
-- @param p a value
-- @return a function such that f(x) is fn(p,x)
-- @raise same as @{function_arg}
-- @see pl.func.curry
function utils.bind1 (fn,p)
    fn = utils.function_arg(1,fn)
    return function(...) return fn(p,...) end
end

--- bind the second argument of the function to a value.
-- @param fn a function of at least two values (may be an operator string)
-- @param p a value
-- @return a function such that f(x) is fn(x,p)
-- @raise same as @{function_arg}
function utils.bind2 (fn,p)
    fn = utils.function_arg(1,fn)
    return function(x,...) return fn(x,p,...) end
end


--- assert that the given argument is in fact of the correct type.
-- @param n argument index
-- @param val the value
-- @param tp the type
-- @param verify an optional verfication function
-- @param msg an optional custom message
-- @param lev optional stack position for trace, default 2
-- @raise if the argument n is not the correct type
-- @usage assert_arg(1,t,&apos;table&apos;)
-- @usage assert_arg(n,val,&apos;string&apos;,path.isdir,&apos;not a directory&apos;)
function utils.assert_arg (n,val,tp,verify,msg,lev)
    if type(val) ~= tp then
        error((&quot;argument %d expected a &apos;%s&apos;, got a &apos;%s&apos;&quot;):format(n,tp,type(val)),lev or 2)
    end
    if verify and not verify(val) then
        error((&quot;argument %d: &apos;%s&apos; %s&quot;):format(n,val,msg),lev or 2)
    end
end

--- assert the common case that the argument is a string.
-- @param n argument index
-- @param val a value that must be a string
-- @raise val must be a string
function utils.assert_string (n,val)
    utils.assert_arg(n,val,&apos;string&apos;,nil,nil,3)
end

local err_mode = &apos;default&apos;

--- control the error strategy used by Penlight.
-- Controls how &lt;code&gt;utils.raise&lt;/code&gt; works; the default is for it
-- to return nil and the error string, but if the mode is &apos;error&apos; then
-- it will throw an error. If mode is &apos;quit&apos; it will immediately terminate
-- the program.
-- @param mode - either &apos;default&apos;, &apos;quit&apos;  or &apos;error&apos;
-- @see utils.raise
function utils.on_error (mode)
    if ({[&apos;default&apos;] = 1, [&apos;quit&apos;] = 2, [&apos;error&apos;] = 3})[mode] then
      err_mode = mode
    else
      -- fail loudly
      if err_mode == &apos;default&apos; then err_mode = &apos;error&apos; end
      utils.raise(&quot;Bad argument expected string; &apos;default&apos;, &apos;quit&apos;, or &apos;error&apos;. Got &apos;&quot;..tostring(mode)..&quot;&apos;&quot;)
    end
end

--- used by Penlight functions to return errors.  Its global behaviour is controlled
-- by &lt;code&gt;utils.on_error&lt;/code&gt;
-- @param err the error string.
-- @see utils.on_error
function utils.raise (err)
    if err_mode == &apos;default&apos; then return nil,err
    elseif err_mode == &apos;quit&apos; then utils.quit(err)
    else error(err,2)
    end
end

raise = utils.raise

--- load a code string or bytecode chunk.
-- @param code Lua code as a string or bytecode
-- @param name for source errors
-- @param mode kind of chunk, &apos;t&apos; for text, &apos;b&apos; for bytecode, &apos;bt&apos; for all (default)
-- @param env  the environment for the new chunk (default nil)
-- @return compiled chunk
-- @return error message (chunk is nil)
-- @function utils.load


--- Lua 5.2 Compatible Functions
-- @section lua52

--- pack an argument list into a table.
-- @param ... any arguments
-- @return a table with field n set to the length
-- @return the length
-- @function table.pack

------
-- return the full path where a Lua module name would be matched.
-- @param mod module name, possibly dotted
-- @param path a path in the same form as package.path or package.cpath
-- @see path.package_path
-- @function package.searchpath

return utils

</ProtectedString>
</Properties>
</Item>
</Item>
<Item class="Backpack" referent="RBX40">
<Properties>
<string name="Name">qGUI</string>
</Properties>
<Item class="ModuleScript" referent="RBX41">
<Properties>
<string name="Name">LensGlare</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local Lighting          = game:GetService(&quot;Lighting&quot;)
local Players          = game:GetService(&quot;Players&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local qGUI              = LoadCustomLibrary(&quot;qGUI&quot;)
local qCFrame           = LoadCustomLibrary(&quot;qCFrame&quot;)
local qMath             = LoadCustomLibrary(&quot;qMath&quot;)

qSystems:Import(getfenv(0));

local lib = {}

--- This library not only handles glare, but also handles lens flares. Huzzah!
-- LensGlare.lua
-- @author Quenty
-- Last Modified February 3rd, 2014

local function IsNight()
	local MinutesAfterMidnight = Lighting:GetMinutesAfterMidnight()
	return MinutesAfterMidnight &lt;= 345 or MinutesAfterMidnight &gt;= 1110
end

local function GetSunPositionOnScreenRelativeToCamera(Camera, Magnitude)
	-- Only used for lens flare effect, I suppose...  Does what it&apos;s name says... 
	-- Magnitude is how far away from the camera the part will be rendered.

	Magnitude = Magnitude or 10
	
	return CFrame.new(Camera.CoordinateFrame.p, Camera.CoordinateFrame.p + Lighting:GetSunDirection()) * CFrame.new(0, 0, -(Magnitude - 1))
end
lib.GetSunPositionOnScreenRelativeToCamera = GetSunPositionOnScreenRelativeToCamera


local MakeLensGlare = Class(function(LensGlare, ScreenGui) 
	-- Makes a lensflare. Update() should be called every frame or so. 

	local Gui = Make &apos;Frame&apos; {
		Archivable             = false;
		BackgroundColor3       = Color3.new(1, 1, 1);
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Name                   = &quot;LensGlare&quot;;
		Parent                 = ScreenGui;
		Position               = UDim2.new(0, 0, 0, -2);
		Size                   = UDim2.new(1, 0, 1, 2);
		Visible                = true;
		ZIndex                 = 1;
	}

	LensGlare.Gui = Gui

	local function Step(Mouse)

		local CameraAngle = (Workspace.CurrentCamera.CoordinateFrame.p - Workspace.CurrentCamera.Focus.p).unit
		local SunAngleUnit = Lighting:GetSunDirection()

		

		--print(&quot;[LensGlare] - Transparency = &quot; .. Transparency..&quot; magnitude: &quot;..(SunAngleUnit - CameraAngle).magnitude)
		if not IsNight() then
			local Transparency = 1.45 - (SunAngleUnit - CameraAngle).magnitude / 3

			local SunPositionGlobal = GetSunPositionOnScreenRelativeToCamera(Workspace.CurrentCamera, 10).p
			local SunIsOnScreen, SunPositionOnScreen, Angle = qGUI.WorldToScreen(SunPositionGlobal, Mouse, Workspace.CurrentCamera)
			if SunIsOnScreen then
				Gui.BackgroundTransparency = Transparency
			else
				Gui.BackgroundTransparency = 1
			end
		else
			Gui.BackgroundTransparency = 1
		end
	end

	LensGlare.Step = Step
end)
lib.MakeLensGlare = MakeLensGlare
lib.makeLensGlare = MakeLensGlare


local MakeLensFlare = Class(function(LensFlare, ScreenGui)
	-- Generates lens flare GUI&apos;s, and repositions them every time Step() is called.
	local Configuration = {
		SunFlareSizeMax = 80;
		SunFlareEndSizeMax = 60;
		SmallPieces = 5; -- How many pieces inbetween
		SmallPieceSizeMin = 40;
		SmallPieceSizeMax = 60;
		MaxTransparency = 0.7;
	}

	local ColorList = {
		qGUI.NewColor3(170, 170, 255);
		qGUI.NewColor3(170, 255, 127);
		qGUI.NewColor3(255, 170, 127);
		qGUI.NewColor3(255, 170, 255);
		qGUI.NewColor3(255, 255, 127);
		qGUI.NewColor3(255, 255, 255);
		qGUI.NewColor3(255, 170, 000);
	}

	local Guis = {}
	Guis.Container = Make &apos;Frame&apos; {
		Archivable             = false;
		BackgroundColor3       = Color3.new(1, 1, 1);
		BackgroundTransparency = 1;
		Name                   = &quot;qLensFlare&quot;;
		Parent                 = ScreenGui;
		Size                   = UDim2.new(1, 0, 1, 0);
		Visible                = true;
	}
	Guis.SunFlare = Make &apos;Frame&apos; { -- Flare on the sun. 
		BackgroundColor3       = qGUI.PickRandomColor3(ColorList);
		BackgroundTransparency = 0.7;
		BorderSizePixel        = 0;
		Name                   = &quot;LargeLensFlare&quot;;
		Parent                 = Guis.Container;
		Size                   = UDim2.new(0, Configuration.SunFlareSizeMax, 0, Configuration.SunFlareSizeMax);
		Visible                = true;
		ZIndex = 2;
	}
	Guis.SunFlareEnd = Make &apos;Frame&apos; { -- Flare on the sun. 
		BackgroundColor3       = qGUI.PickRandomColor3(ColorList);
		BackgroundTransparency = 0.7;
		BorderSizePixel        = 0;
		Name                   = &quot;LargeLensFlareEnd&quot;;
		Parent                 = Guis.Container;
		Size                   = UDim2.new(0, Configuration.SunFlareEndSizeMax, 0, Configuration.SunFlareEndSizeMax);
		Visible                = true;
	}
	Guis.SmallGuys = {} -- All those small little guys between the 2 large glares. 
	for Index = 1, Configuration.SmallPieces do
		local Size = math.random(Configuration.SmallPieceSizeMin)
		Guis.SmallGuys[Index] = {
			Gui = Make &apos;Frame&apos; { -- Flare on the sun. 
				BackgroundColor3       = qGUI.PickRandomColor3(ColorList);
				BackgroundTransparency = 0.8;
				BorderSizePixel        = 0;
				Name                   = &quot;SmallGuyInbetweenFlare&quot;..Index;
				Parent                 = Guis.Container;
				Size                   = UDim2.new(0, Size, 0, Size);
				Visible                = true;
			};
			Size = Size;
		}
	end

	LensFlare.Guis = Guis

	local function PositionSunFlareFromCartisian2(SunFlareFrame, SunPositionVector2, SizeFactor, DefaultSize)
		--local SunPositionVector2 = qMath.Cartisian2ToVector(SunPositionCartisian2, ScreenMiddle)
		local Size = DefaultSize * SizeFactor -- 1 = full size (Direct look at sun), 0 = not shown 
		SunFlareFrame.Transparency = 1 - ((SizeFactor) * (1 - Configuration.MaxTransparency)) 
		SunFlareFrame.Size = UDim2.new(0, Size, 0, Size)
		SunFlareFrame.Position = qGUI.UDim2OffsetFromVector2(SunPositionVector2) - qGUI.GetHalfSize(SunFlareFrame);
	end

	local function Render(SunPositionVector2, Mouse, DoRender)
		-- Incrediably confusing/annoying vector math. :D
		-- Render&apos;s / Positions the GUI&apos;s... Called each step. SunPositionVector2 is the position of the sun on the screen, offset. 

		if DoRender then
			local ScreenMiddle = Vector2.new(Mouse.ViewSizeX, Mouse.ViewSizeY) / 2
			local SizeFactor = 1 - math.min(1, (ScreenMiddle - SunPositionVector2).magnitude / (Mouse.ViewSizeX/2)) -- So at the outside edge, it&apos;s 0, and at the center, it&apos;s 1
			--print(&quot;[LensGlare] - SizeFactor: &quot; .. SizeFactor)
			local SunPositionCartisian2 = qMath.Vector2ToCartisian(SunPositionVector2, ScreenMiddle) -- Convert to cartisians so we can work with the middle of the screen, due to the nature of lens flares. 
			local EndSunPositionCartisian2 = qMath.InvertCartisian2(SunPositionCartisian2) -- Invert it...

			PositionSunFlareFromCartisian2(Guis.SunFlare, SunPositionVector2, SizeFactor, Configuration.SunFlareSizeMax)
			PositionSunFlareFromCartisian2(Guis.SunFlareEnd, qMath.Cartisian2ToVector(EndSunPositionCartisian2, ScreenMiddle), SizeFactor, Configuration.SunFlareEndSizeMax)

			for Index = 1, Configuration.SmallPieces do
				local SmallGuy = Guis.SmallGuys[Index]
				local PositionFactor = 1 - (((Index/(Configuration.SmallPieces+2) + (1/Configuration.SmallPieces))) * 2) -- 1 - (1/12 - 11/12, 1 spacing on both sides) * 2
				local SmallGuyCartisian2 = SunPositionCartisian2 * PositionFactor
				local Position = qMath.Cartisian2ToVector(SmallGuyCartisian2, ScreenMiddle)
				PositionSunFlareFromCartisian2(SmallGuy.Gui, Position, SizeFactor, SmallGuy.Size)
			end
			--Guis.SunFlare.Position = qGUI.UDim2OffsetFromVector2(SunPositionVector2) - qGUI.GetHalfSize(Guis.SunFlare);
			--Guis.SunFlareEndqGUI.UDim2OffsetFromVector2(EndSunPositionCartisian2) 
		else
			Guis.SunFlare.BackgroundTransparency = 1
			Guis.SunFlareEnd.BackgroundTransparency = 1
			for Index = 1, Configuration.SmallPieces do
				local SmallGuy = Guis.SmallGuys[Index]
				SmallGuy.Gui.BackgroundTransparency = 1
			end
		end
	end

	local function Step(Mouse)
		assert(Mouse, &quot;[LensFlare] - Mouse is nil&quot;)

		local Ray = Ray.new( -- We need to ray cast to see if the sun is being blocked at all...
			Workspace.CurrentCamera.CoordinateFrame.p,
			(Workspace.CurrentCamera.CoordinateFrame.p -  Workspace.CurrentCamera.Focus.p).Unit * -999
		)

		local Part, EndPoint = Workspace:FindPartOnRayWithIgnoreList(Ray, {Players.LocalPlayer.Character})
		if not Part then
			local SunPositionGlobal = GetSunPositionOnScreenRelativeToCamera(Workspace.CurrentCamera, 10).p
			local SunIsOnScreen, SunPositionOnScreen, Angle = qGUI.WorldToScreen(SunPositionGlobal, Mouse, Workspace.CurrentCamera)
			Render(SunPositionOnScreen, Mouse, SunIsOnScreen)
		else
			--print(&quot;[LensFlare] - Hit &quot;..Part.Name..&quot; no render&quot;)
			Render(nil, Mouse, false)
		end
	end
	LensFlare.Step = Step
end)
lib.MakeLensFlare = MakeLensFlare
lib.makeLensFlare = MakeLensFlare

return lib</ProtectedString>
</Properties>
</Item>
<Item class="Backpack" referent="RBX42">
<Properties>
<string name="Name">Markdown</string>
</Properties>
<Item class="Script" referent="RBX43">
<Properties>
<string name="Name">Markdown</string>
<ProtectedString name="Source">#!/usr/bin/env lua

--[[
# markdown.lua -- version 0.32

&lt;http://www.frykholm.se/files/markdown.lua&gt;

**Author:** Niklas Frykholm, &lt;niklas@frykholm.se&gt;
**Date:** 31 May 2008

This is an implementation of the popular text markup language Markdown in pure Lua.
Markdown can convert documents written in a simple and easy to read text format
to well-formatted HTML. For a more thourough description of Markdown and the Markdown
syntax, see &lt;http://daringfireball.net/projects/markdown&gt;.

The original Markdown source is written in Perl and makes heavy use of advanced
regular expression techniques (such as negative look-ahead, etc) which are not available
in Lua&apos;s simple regex engine. Therefore this Lua port has been rewritten from the ground
up. It is probably not completely bug free. If you notice any bugs, please report them to
me. A unit test that exposes the error is helpful.

## Usage

    require &quot;markdown&quot;
    markdown(source)

``markdown.lua`` exposes a single global function named ``markdown(s)`` which applies the
Markdown transformation to the specified string.

``markdown.lua`` can also be used directly from the command line:

	lua markdown.lua test.md

Creates a file ``test.html`` with the converted content of ``test.md``. Run:

    lua markdown.lua -h

For a description of the command-line options.

``markdown.lua`` uses the same license as Lua, the MIT license.

## License

Copyright &amp;copy; 2008 Niklas Frykholm.

Permission is hereby granted, free of charge, to any person obtaining a copy of this
software and associated documentation files (the &quot;Software&quot;), to deal in the Software
without restriction, including without limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons
to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

## Version history

-	**0.32** -- 31 May 2008
	- Fix for links containing brackets
-	**0.31** -- 1 Mar 2008
	-	Fix for link definitions followed by spaces
-	**0.30** -- 25 Feb 2008
	-	Consistent behavior with Markdown when the same link reference is reused
-	**0.29** -- 24 Feb 2008
	-	Fix for &lt;pre&gt; blocks with spaces in them
-	**0.28** -- 18 Feb 2008
	-	Fix for link encoding
-	**0.27** -- 14 Feb 2008
	-	Fix for link database links with ()
-	**0.26** -- 06 Feb 2008
	-	Fix for nested italic and bold markers
-	**0.25** -- 24 Jan 2008
	-	Fix for encoding of naked &lt;
-	**0.24** -- 21 Jan 2008
	-	Fix for link behavior.
-	**0.23** -- 10 Jan 2008
	-	Fix for a regression bug in longer expressions in italic or bold.
-	**0.22** -- 27 Dec 2007
	-	Fix for crash when processing blocks with a percent sign in them.
-	**0.21** -- 27 Dec 2007
	- 	Fix for combined strong and emphasis tags
-	**0.20** -- 13 Oct 2007
	-	Fix for &lt; as well in image titles, now matches Dingus behavior
-	**0.19** -- 28 Sep 2007
	-	Fix for quotation marks &quot; and ampersands &amp; in link and image titles.
-	**0.18** -- 28 Jul 2007
	-	Does not crash on unmatched tags (behaves like standard markdown)
-	**0.17** -- 12 Apr 2007
	-	Fix for links with %20 in them.
-	**0.16** -- 12 Apr 2007
	-	Do not require arg global to exist.
-	**0.15** -- 28 Aug 2006
	-	Better handling of links with underscores in them.
-	**0.14** -- 22 Aug 2006
	-	Bug for *`foo()`*
-	**0.13** -- 12 Aug 2006
	-	Added -l option for including stylesheet inline in document.
	-	Fixed bug in -s flag.
	-	Fixed emphasis bug.
-	**0.12** -- 15 May 2006
	-	Fixed several bugs to comply with MarkdownTest 1.0 &lt;http://six.pairlist.net/pipermail/markdown-discuss/2004-December/000909.html&gt;
-	**0.11** -- 12 May 2006
	-	Fixed bug for escaping `*` and `_` inside code spans.
	-	Added license terms.
	-	Changed join() to table.concat().
-	**0.10** -- 3 May 2006
	-	Initial public release.

// Niklas
]]


-- Set up a table for holding local functions to avoid polluting the global namespace
local M = {}
local MT = {__index = _G}
setmetatable(M, MT)
setfenv(1, M)

----------------------------------------------------------------------
-- Utility functions
----------------------------------------------------------------------

-- Locks table t from changes, writes an error if someone attempts to change the table.
-- This is useful for detecting variables that have &quot;accidently&quot; been made global. Something
-- I tend to do all too much.
function lock(t)
	function lock_new_index(t, k, v)
		error(&quot;module has been locked -- &quot; .. k .. &quot; must be declared local&quot;, 2)
	end

	local mt = {__newindex = lock_new_index}
	if getmetatable(t) then mt.__index = getmetatable(t).__index end
	setmetatable(t, mt)
end

-- Returns the result of mapping the values in table t through the function f
function map(t, f)
	local out = {}
	for k,v in pairs(t) do out[k] = f(v,k) end
	return out
end

-- The identity function, useful as a placeholder.
function identity(text) return text end

-- Functional style if statement. (NOTE: no short circuit evaluation)
function iff(t, a, b) if t then return a else return b end end

-- Splits the text into an array of separate lines.
function split(text, sep)
	sep = sep or &quot;\n&quot;
	local lines = {}
	local pos = 1
	while true do
		local b,e = text:find(sep, pos)
		if not b then table.insert(lines, text:sub(pos)) break end
		table.insert(lines, text:sub(pos, b-1))
		pos = e + 1
	end
	return lines
end

-- Converts tabs to spaces
function detab(text)
	local tab_width = 4
	local function rep(match)
		local spaces = -match:len()
		while spaces&lt;1 do spaces = spaces + tab_width end
		return match .. string.rep(&quot; &quot;, spaces)
	end
	text = text:gsub(&quot;([^\n]-)\t&quot;, rep)
	return text
end

-- Applies string.find for every pattern in the list and returns the first match
function find_first(s, patterns, index)
	local res = {}
	for _,p in ipairs(patterns) do
		local match = {s:find(p, index)}
		if #match&gt;0 and (#res==0 or match[1] &lt; res[1]) then res = match end
	end
	return unpack(res)
end

-- If a replacement array is specified, the range [start, stop] in the array is replaced
-- with the replacement array and the resulting array is returned. Without a replacement
-- array the section of the array between start and stop is returned.
function splice(array, start, stop, replacement)
	if replacement then
		local n = stop - start + 1
		while n &gt; 0 do
			table.remove(array, start)
			n = n - 1
		end
		for i,v in ipairs(replacement) do
			table.insert(array, start, v)
		end
		return array
	else
		local res = {}
		for i = start,stop do
			table.insert(res, array[i])
		end
		return res
	end
end

-- Outdents the text one step.
function outdent(text)
	text = &quot;\n&quot; .. text
	text = text:gsub(&quot;\n  ? ? ?&quot;, &quot;\n&quot;)
	text = text:sub(2)
	return text
end

-- Indents the text one step.
function indent(text)
	text = text:gsub(&quot;\n&quot;, &quot;\n    &quot;)
	return text
end

-- Does a simple tokenization of html data. Returns the data as a list of tokens.
-- Each token is a table with a type field (which is either &quot;tag&quot; or &quot;text&quot;) and
-- a text field (which contains the original token data).
function tokenize_html(html)
	local tokens = {}
	local pos = 1
	while true do
		local start = find_first(html, {&quot;&lt;!%-%-&quot;, &quot;&lt;[a-z/!$]&quot;, &quot;&lt;%?&quot;}, pos)
		if not start then
			table.insert(tokens, {type=&quot;text&quot;, text=html:sub(pos)})
			break
		end
		if start ~= pos then table.insert(tokens, {type=&quot;text&quot;, text = html:sub(pos, start-1)}) end

		local _, stop
		if html:match(&quot;^&lt;!%-%-&quot;, start) then
			_,stop = html:find(&quot;%-%-&gt;&quot;, start)
		elseif html:match(&quot;^&lt;%?&quot;, start) then
			_,stop = html:find(&quot;?&gt;&quot;, start)
		else
			_,stop = html:find(&quot;%b&lt;&gt;&quot;, start)
		end
		if not stop then
			-- error(&quot;Could not match html tag &quot; .. html:sub(start,start+30))
		 	table.insert(tokens, {type=&quot;text&quot;, text=html:sub(start, start)})
			pos = start + 1
		else
			table.insert(tokens, {type=&quot;tag&quot;, text=html:sub(start, stop)})
			pos = stop + 1
		end
	end
	return tokens
end

----------------------------------------------------------------------
-- Hash
----------------------------------------------------------------------

-- This is used to &quot;hash&quot; data into alphanumeric strings that are unique
-- in the document. (Note that this is not cryptographic hash, the hash
-- function is not one-way.) The hash procedure is used to protect parts
-- of the document from further processing.

local HASH = {
	-- Has the hash been inited.
	inited = false,

	-- The unique string prepended to all hash values. This is to ensure
	-- that hash values do not accidently coincide with an actual existing
	-- string in the document.
	identifier = &quot;&quot;,

	-- Counter that counts up for each new hash instance.
	counter = 0,

	-- Hash table.
	table = {}
}

-- Inits hashing. Creates a hash_identifier that doesn&apos;t occur anywhere
-- in the text.
function init_hash(text)
	HASH.inited = true
	HASH.identifier = &quot;&quot;
	HASH.counter = 0
	HASH.table = {}

	local s = &quot;HASH&quot;
	local counter = 0
	local id
	while true do
		id  = s .. counter
		if not text:find(id, 1, true) then break end
		counter = counter + 1
	end
	HASH.identifier = id
end

-- Returns the hashed value for s.
function hash(s)
	assert(HASH.inited)
	if not HASH.table[s] then
		HASH.counter = HASH.counter + 1
		local id = HASH.identifier .. HASH.counter .. &quot;X&quot;
		HASH.table[s] = id
	end
	return HASH.table[s]
end

----------------------------------------------------------------------
-- Protection
----------------------------------------------------------------------

-- The protection module is used to &quot;protect&quot; parts of a document
-- so that they are not modified by subsequent processing steps.
-- Protected parts are saved in a table for later unprotection

-- Protection data
local PD = {
	-- Saved blocks that have been converted
	blocks = {},

	-- Block level tags that will be protected
	tags = {&quot;p&quot;, &quot;div&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;, &quot;blockquote&quot;,
	&quot;pre&quot;, &quot;table&quot;, &quot;dl&quot;, &quot;ol&quot;, &quot;ul&quot;, &quot;script&quot;, &quot;noscript&quot;, &quot;form&quot;, &quot;fieldset&quot;,
	&quot;iframe&quot;, &quot;math&quot;, &quot;ins&quot;, &quot;del&quot;}
}

-- Pattern for matching a block tag that begins and ends in the leftmost
-- column and may contain indented subtags, i.e.
-- &lt;div&gt;
--    A nested block.
--    &lt;div&gt;
--        Nested data.
--     &lt;/div&gt;
-- &lt;/div&gt;
function block_pattern(tag)
	return &quot;\n&lt;&quot; .. tag .. &quot;.-\n&lt;/&quot; .. tag .. &quot;&gt;[ \t]*\n&quot;
end

-- Pattern for matching a block tag that begins and ends with a newline
function line_pattern(tag)
	return &quot;\n&lt;&quot; .. tag .. &quot;.-&lt;/&quot; .. tag .. &quot;&gt;[ \t]*\n&quot;
end

-- Protects the range of characters from start to stop in the text and
-- returns the protected string.
function protect_range(text, start, stop)
	local s = text:sub(start, stop)
	local h = hash(s)
	PD.blocks[h] = s
	text = text:sub(1,start) .. h .. text:sub(stop)
	return text
end

-- Protect every part of the text that matches any of the patterns. The first
-- matching pattern is protected first, etc.
function protect_matches(text, patterns)
	while true do
		local start, stop = find_first(text, patterns)
		if not start then break end
		text = protect_range(text, start, stop)
	end
	return text
end

-- Protects blocklevel tags in the specified text
function protect(text)
	-- First protect potentially nested block tags
	text = protect_matches(text, map(PD.tags, block_pattern))
	-- Then protect block tags at the line level.
	text = protect_matches(text, map(PD.tags, line_pattern))
	-- Protect &lt;hr&gt; and comment tags
	text = protect_matches(text, {&quot;\n&lt;hr[^&gt;]-&gt;[ \t]*\n&quot;})
	text = protect_matches(text, {&quot;\n&lt;!%-%-.-%-%-&gt;[ \t]*\n&quot;})
	return text
end

-- Returns true if the string s is a hash resulting from protection
function is_protected(s)
	return PD.blocks[s]
end

-- Unprotects the specified text by expanding all the nonces
function unprotect(text)
	for k,v in pairs(PD.blocks) do
		v = v:gsub(&quot;%%&quot;, &quot;%%%%&quot;)
		text = text:gsub(k, v)
	end
	return text
end


----------------------------------------------------------------------
-- Block transform
----------------------------------------------------------------------

-- The block transform functions transform the text on the block level.
-- They work with the text as an array of lines rather than as individual
-- characters.

-- Returns true if the line is a ruler of (char) characters.
-- The line must contain at least three char characters and contain only spaces and
-- char characters.
function is_ruler_of(line, char)
	if not line:match(&quot;^[ %&quot; .. char .. &quot;]*$&quot;) then return false end
	if not line:match(&quot;%&quot; .. char .. &quot;.*%&quot; .. char .. &quot;.*%&quot; .. char) then return false end
	return true
end

-- Identifies the block level formatting present in the line
function classify(line)
	local info = {line = line, text = line}

	if line:match(&quot;^    &quot;) then
		info.type = &quot;indented&quot;
		info.outdented = line:sub(5)
		return info
	end

	for _,c in ipairs({&apos;*&apos;, &apos;-&apos;, &apos;_&apos;, &apos;=&apos;}) do
		if is_ruler_of(line, c) then
			info.type = &quot;ruler&quot;
			info.ruler_char = c
			return info
		end
	end

	if line == &quot;&quot; then
		info.type = &quot;blank&quot;
		return info
	end

	if line:match(&quot;^(#+)[ \t]*(.-)[ \t]*#*[ \t]*$&quot;) then
		local m1, m2 = line:match(&quot;^(#+)[ \t]*(.-)[ \t]*#*[ \t]*$&quot;)
		info.type = &quot;header&quot;
		info.level = m1:len()
		info.text = m2
		return info
	end

	if line:match(&quot;^ ? ? ?(%d+)%.[ \t]+(.+)&quot;) then
		local number, text = line:match(&quot;^ ? ? ?(%d+)%.[ \t]+(.+)&quot;)
		info.type = &quot;list_item&quot;
		info.list_type = &quot;numeric&quot;
		info.number = 0 + number
		info.text = text
		return info
	end

	if line:match(&quot;^ ? ? ?([%*%+%-])[ \t]+(.+)&quot;) then
		local bullet, text = line:match(&quot;^ ? ? ?([%*%+%-])[ \t]+(.+)&quot;)
		info.type = &quot;list_item&quot;
		info.list_type = &quot;bullet&quot;
		info.bullet = bullet
		info.text= text
		return info
	end

	if line:match(&quot;^&gt;[ \t]?(.*)&quot;) then
		info.type = &quot;blockquote&quot;
		info.text = line:match(&quot;^&gt;[ \t]?(.*)&quot;)
		return info
	end

	if is_protected(line) then
		info.type = &quot;raw&quot;
		info.html = unprotect(line)
		return info
	end

	info.type = &quot;normal&quot;
	return info
end

-- Find headers constisting of a normal line followed by a ruler and converts them to
-- header entries.
function headers(array)
	local i = 1
	while i &lt;= #array - 1 do
		if array[i].type  == &quot;normal&quot; and array[i+1].type == &quot;ruler&quot; and
			(array[i+1].ruler_char == &quot;-&quot; or array[i+1].ruler_char == &quot;=&quot;) then
			local info = {line = array[i].line}
			info.text = info.line
			info.type = &quot;header&quot;
			info.level = iff(array[i+1].ruler_char == &quot;=&quot;, 1, 2)
			table.remove(array, i+1)
			array[i] = info
		end
		i = i + 1
	end
	return array
end

-- Find list blocks and convert them to protected data blocks
function lists(array, sublist)
	local function process_list(arr)
		local function any_blanks(arr)
			for i = 1, #arr do
				if arr[i].type == &quot;blank&quot; then return true end
			end
			return false
		end

		local function split_list_items(arr)
			local acc = {arr[1]}
			local res = {}
			for i=2,#arr do
				if arr[i].type == &quot;list_item&quot; then
					table.insert(res, acc)
					acc = {arr[i]}
				else
					table.insert(acc, arr[i])
				end
			end
			table.insert(res, acc)
			return res
		end

		local function process_list_item(lines, block)
			while lines[#lines].type == &quot;blank&quot; do
				table.remove(lines)
			end

			local itemtext = lines[1].text
			for i=2,#lines do
				itemtext = itemtext .. &quot;\n&quot; .. outdent(lines[i].line)
			end
			if block then
				itemtext = block_transform(itemtext, true)
				if not itemtext:find(&quot;&lt;pre&gt;&quot;) then itemtext = indent(itemtext) end
				return &quot;    &lt;li&gt;&quot; .. itemtext .. &quot;&lt;/li&gt;&quot;
			else
				local lines = split(itemtext)
				lines = map(lines, classify)
				lines = lists(lines, true)
				lines = blocks_to_html(lines, true)
				itemtext = table.concat(lines, &quot;\n&quot;)
				if not itemtext:find(&quot;&lt;pre&gt;&quot;) then itemtext = indent(itemtext) end
				return &quot;    &lt;li&gt;&quot; .. itemtext .. &quot;&lt;/li&gt;&quot;
			end
		end

		local block_list = any_blanks(arr)
		local items = split_list_items(arr)
		local out = &quot;&quot;
		for _, item in ipairs(items) do
			out = out .. process_list_item(item, block_list) .. &quot;\n&quot;
		end
		if arr[1].list_type == &quot;numeric&quot; then
			return &quot;&lt;ol&gt;\n&quot; .. out .. &quot;&lt;/ol&gt;&quot;
		else
			return &quot;&lt;ul&gt;\n&quot; .. out .. &quot;&lt;/ul&gt;&quot;
		end
	end

	-- Finds the range of lines composing the first list in the array. A list
	-- starts with (^ list_item) or (blank list_item) and ends with
	-- (blank* $) or (blank normal).
	--
	-- A sublist can start with just (list_item) does not need a blank...
	local function find_list(array, sublist)
		local function find_list_start(array, sublist)
			if array[1].type == &quot;list_item&quot; then return 1 end
			if sublist then
				for i = 1,#array do
					if array[i].type == &quot;list_item&quot; then return i end
				end
			else
				for i = 1, #array-1 do
					if array[i].type == &quot;blank&quot; and array[i+1].type == &quot;list_item&quot; then
						return i+1
					end
				end
			end
			return nil
		end
		local function find_list_end(array, start)
			local pos = #array
			for i = start, #array-1 do
				if array[i].type == &quot;blank&quot; and array[i+1].type ~= &quot;list_item&quot;
					and array[i+1].type ~= &quot;indented&quot; and array[i+1].type ~= &quot;blank&quot; then
					pos = i-1
					break
				end
			end
			while pos &gt; start and array[pos].type == &quot;blank&quot; do
				pos = pos - 1
			end
			return pos
		end

		local start = find_list_start(array, sublist)
		if not start then return nil end
		return start, find_list_end(array, start)
	end

	while true do
		local start, stop = find_list(array, sublist)
		if not start then break end
		local text = process_list(splice(array, start, stop))
		local info = {
			line = text,
			type = &quot;raw&quot;,
			html = text
		}
		array = splice(array, start, stop, {info})
	end

	-- Convert any remaining list items to normal
	for _,line in ipairs(array) do
		if line.type == &quot;list_item&quot; then line.type = &quot;normal&quot; end
	end

	return array
end

-- Find and convert blockquote markers.
function blockquotes(lines)
	local function find_blockquote(lines)
		local start
		for i,line in ipairs(lines) do
			if line.type == &quot;blockquote&quot; then
				start = i
				break
			end
		end
		if not start then return nil end

		local stop = #lines
		for i = start+1, #lines do
			if lines[i].type == &quot;blank&quot; or lines[i].type == &quot;blockquote&quot; then
			elseif lines[i].type == &quot;normal&quot; then
				if lines[i-1].type == &quot;blank&quot; then stop = i-1 break end
			else
				stop = i-1 break
			end
		end
		while lines[stop].type == &quot;blank&quot; do stop = stop - 1 end
		return start, stop
	end

	local function process_blockquote(lines)
		local raw = lines[1].text
		for i = 2,#lines do
			raw = raw .. &quot;\n&quot; .. lines[i].text
		end
		local bt = block_transform(raw)
		if not bt:find(&quot;&lt;pre&gt;&quot;) then bt = indent(bt) end
		return &quot;&lt;blockquote&gt;\n    &quot; .. bt ..
			&quot;\n&lt;/blockquote&gt;&quot;
	end

	while true do
		local start, stop = find_blockquote(lines)
		if not start then break end
		local text = process_blockquote(splice(lines, start, stop))
		local info = {
			line = text,
			type = &quot;raw&quot;,
			html = text
		}
		lines = splice(lines, start, stop, {info})
	end
	return lines
end

-- Find and convert codeblocks.
function codeblocks(lines)
	local function find_codeblock(lines)
		local start
		for i,line in ipairs(lines) do
			if line.type == &quot;indented&quot; then start = i break end
		end
		if not start then return nil end

		local stop = #lines
		for i = start+1, #lines do
			if lines[i].type ~= &quot;indented&quot; and lines[i].type ~= &quot;blank&quot; then
				stop = i-1
				break
			end
		end
		while lines[stop].type == &quot;blank&quot; do stop = stop - 1 end
		return start, stop
	end

	local function process_codeblock(lines)
		local raw = detab(encode_code(outdent(lines[1].line)))
		for i = 2,#lines do
			raw = raw .. &quot;\n&quot; .. detab(encode_code(outdent(lines[i].line)))
		end
		return &quot;&lt;pre&gt;&lt;code&gt;&quot; .. raw .. &quot;\n&lt;/code&gt;&lt;/pre&gt;&quot;
	end

	while true do
		local start, stop = find_codeblock(lines)
		if not start then break end
		local text = process_codeblock(splice(lines, start, stop))
		local info = {
			line = text,
			type = &quot;raw&quot;,
			html = text
		}
		lines = splice(lines, start, stop, {info})
	end
	return lines
end

-- Convert lines to html code
function blocks_to_html(lines, no_paragraphs)
	local out = {}
	local i = 1
	while i &lt;= #lines do
		local line = lines[i]
		if line.type == &quot;ruler&quot; then
			table.insert(out, &quot;&lt;hr/&gt;&quot;)
		elseif line.type == &quot;raw&quot; then
			table.insert(out, line.html)
		elseif line.type == &quot;normal&quot; then
			local s = line.line

			while i+1 &lt;= #lines and lines[i+1].type == &quot;normal&quot; do
				i = i + 1
				s = s .. &quot;\n&quot; .. lines[i].line
			end

			if no_paragraphs then
				table.insert(out, span_transform(s))
			else
				table.insert(out, &quot;&lt;p&gt;&quot; .. span_transform(s) .. &quot;&lt;/p&gt;&quot;)
			end
		elseif line.type == &quot;header&quot; then
			local s = &quot;&lt;h&quot; .. line.level .. &quot;&gt;&quot; .. span_transform(line.text) .. &quot;&lt;/h&quot; .. line.level .. &quot;&gt;&quot;
			table.insert(out, s)
		else
			table.insert(out, line.line)
		end
		i = i + 1
	end
	return out
end

-- Perform all the block level transforms
function block_transform(text, sublist)
	local lines = split(text)
	lines = map(lines, classify)
	lines = headers(lines)
	lines = lists(lines, sublist)
	lines = codeblocks(lines)
	lines = blockquotes(lines)
	lines = blocks_to_html(lines)
	local text = table.concat(lines, &quot;\n&quot;)
	return text
end

-- Debug function for printing a line array to see the result
-- of partial transforms.
function print_lines(lines)
	for i, line in ipairs(lines) do
		print(i, line.type, line.text or line.line)
	end
end

----------------------------------------------------------------------
-- Span transform
----------------------------------------------------------------------

-- Functions for transforming the text at the span level.

-- These characters may need to be escaped because they have a special
-- meaning in markdown.
escape_chars = &quot;&apos;\\`*_{}[]()&gt;#+-.!&apos;&quot;
escape_table = {}

function init_escape_table()
	escape_table = {}
	for i = 1,#escape_chars do
		local c = escape_chars:sub(i,i)
		escape_table[c] = hash(c)
	end
end

-- Adds a new escape to the escape table.
function add_escape(text)
	if not escape_table[text] then
		escape_table[text] = hash(text)
	end
	return escape_table[text]
end

-- Escape characters that should not be disturbed by markdown.
function escape_special_chars(text)
	local tokens = tokenize_html(text)

	local out = &quot;&quot;
	for _, token in ipairs(tokens) do
		local t = token.text
		if token.type == &quot;tag&quot; then
			-- In tags, encode * and _ so they don&apos;t conflict with their use in markdown.
			t = t:gsub(&quot;%*&quot;, escape_table[&quot;*&quot;])
			t = t:gsub(&quot;%_&quot;, escape_table[&quot;_&quot;])
		else
			t = encode_backslash_escapes(t)
		end
		out = out .. t
	end
	return out
end

-- Encode backspace-escaped characters in the markdown source.
function encode_backslash_escapes(t)
	for i=1,escape_chars:len() do
		local c = escape_chars:sub(i,i)
		t = t:gsub(&quot;\\%&quot; .. c, escape_table[c])
	end
	return t
end

-- Unescape characters that have been encoded.
function unescape_special_chars(t)
	local tin = t
	for k,v in pairs(escape_table) do
		k = k:gsub(&quot;%%&quot;, &quot;%%%%&quot;)
		t = t:gsub(v,k)
	end
	if t ~= tin then t = unescape_special_chars(t) end
	return t
end

-- Encode/escape certain characters inside Markdown code runs.
-- The point is that in code, these characters are literals,
-- and lose their special Markdown meanings.
function encode_code(s)
	s = s:gsub(&quot;%&amp;&quot;, &quot;&amp;amp;&quot;)
	s = s:gsub(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)
	s = s:gsub(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)
	for k,v in pairs(escape_table) do
		s = s:gsub(&quot;%&quot;..k, v)
	end
	return s
end

-- Handle backtick blocks.
function code_spans(s)
	s = s:gsub(&quot;\\\\&quot;, escape_table[&quot;\\&quot;])
	s = s:gsub(&quot;\\`&quot;, escape_table[&quot;`&quot;])

	local pos = 1
	while true do
		local start, stop = s:find(&quot;`+&quot;, pos)
		if not start then return s end
		local count = stop - start + 1
		-- Find a matching numbert of backticks
		local estart, estop = s:find(string.rep(&quot;`&quot;, count), stop+1)
		local brstart = s:find(&quot;\n&quot;, stop+1)
		if estart and (not brstart or estart &lt; brstart) then
			local code = s:sub(stop+1, estart-1)
			code = code:gsub(&quot;^[ \t]+&quot;, &quot;&quot;)
			code = code:gsub(&quot;[ \t]+$&quot;, &quot;&quot;)
			code = code:gsub(escape_table[&quot;\\&quot;], escape_table[&quot;\\&quot;] .. escape_table[&quot;\\&quot;])
			code = code:gsub(escape_table[&quot;`&quot;], escape_table[&quot;\\&quot;] .. escape_table[&quot;`&quot;])
			code = &quot;&lt;code&gt;&quot; .. encode_code(code) .. &quot;&lt;/code&gt;&quot;
			code = add_escape(code)
			s = s:sub(1, start-1) .. code .. s:sub(estop+1)
			pos = start + code:len()
		else
			pos = stop + 1
		end
	end
	return s
end

-- Encode alt text... enodes &amp;, and &quot;.
function encode_alt(s)
	if not s then return s end
	s = s:gsub(&apos;&amp;&apos;, &apos;&amp;amp;&apos;)
	s = s:gsub(&apos;&quot;&apos;, &apos;&amp;quot;&apos;)
	s = s:gsub(&apos;&lt;&apos;, &apos;&amp;lt;&apos;)
	return s
end

-- Handle image references
function images(text)
	local function reference_link(alt, id)
		alt = encode_alt(alt:match(&quot;%b[]&quot;):sub(2,-2))
		id = id:match(&quot;%[(.*)%]&quot;):lower()
		if id == &quot;&quot; then id = text:lower() end
		link_database[id] = link_database[id] or {}
		if not link_database[id].url then return nil end
		local url = link_database[id].url or id
		url = encode_alt(url)
		local title = encode_alt(link_database[id].title)
		if title then title = &quot; title=\&quot;&quot; .. title .. &quot;\&quot;&quot; else title = &quot;&quot; end
		return add_escape (&apos;&lt;img src=&quot;&apos; .. url .. &apos;&quot; alt=&quot;&apos; .. alt .. &apos;&quot;&apos; .. title .. &quot;/&gt;&quot;)
	end

	local function inline_link(alt, link)
		alt = encode_alt(alt:match(&quot;%b[]&quot;):sub(2,-2))
		local url, title = link:match(&quot;%(&lt;?(.-)&gt;?[ \t]*[&apos;\&quot;](.+)[&apos;\&quot;]&quot;)
		url = url or link:match(&quot;%(&lt;?(.-)&gt;?%)&quot;)
		url = encode_alt(url)
		title = encode_alt(title)
		if title then
			return add_escape(&apos;&lt;img src=&quot;&apos; .. url .. &apos;&quot; alt=&quot;&apos; .. alt .. &apos;&quot; title=&quot;&apos; .. title .. &apos;&quot;/&gt;&apos;)
		else
			return add_escape(&apos;&lt;img src=&quot;&apos; .. url .. &apos;&quot; alt=&quot;&apos; .. alt .. &apos;&quot;/&gt;&apos;)
		end
	end

	text = text:gsub(&quot;!(%b[])[ \t]*\n?[ \t]*(%b[])&quot;, reference_link)
	text = text:gsub(&quot;!(%b[])(%b())&quot;, inline_link)
	return text
end

-- Handle anchor references
function anchors(text)
	local function reference_link(text, id)
		text = text:match(&quot;%b[]&quot;):sub(2,-2)
		id = id:match(&quot;%b[]&quot;):sub(2,-2):lower()
		if id == &quot;&quot; then id = text:lower() end
		link_database[id] = link_database[id] or {}
		if not link_database[id].url then return nil end
		local url = link_database[id].url or id
		url = encode_alt(url)
		local title = encode_alt(link_database[id].title)
		if title then title = &quot; title=\&quot;&quot; .. title .. &quot;\&quot;&quot; else title = &quot;&quot; end
		return add_escape(&quot;&lt;a href=\&quot;&quot; .. url .. &quot;\&quot;&quot; .. title .. &quot;&gt;&quot;) .. text .. add_escape(&quot;&lt;/a&gt;&quot;)
	end

	local function inline_link(text, link)
		text = text:match(&quot;%b[]&quot;):sub(2,-2)
		local url, title = link:match(&quot;%(&lt;?(.-)&gt;?[ \t]*[&apos;\&quot;](.+)[&apos;\&quot;]&quot;)
		title = encode_alt(title)
		url  = url or  link:match(&quot;%(&lt;?(.-)&gt;?%)&quot;) or &quot;&quot;
		url = encode_alt(url)
		if title then
			return add_escape(&quot;&lt;a href=\&quot;&quot; .. url .. &quot;\&quot; title=\&quot;&quot; .. title .. &quot;\&quot;&gt;&quot;) .. text .. &quot;&lt;/a&gt;&quot;
		else
			return add_escape(&quot;&lt;a href=\&quot;&quot; .. url .. &quot;\&quot;&gt;&quot;) .. text .. add_escape(&quot;&lt;/a&gt;&quot;)
		end
	end

	text = text:gsub(&quot;(%b[])[ \t]*\n?[ \t]*(%b[])&quot;, reference_link)
	text = text:gsub(&quot;(%b[])(%b())&quot;, inline_link)
	return text
end

-- Handle auto links, i.e. &lt;http://www.google.com/&gt;.
function auto_links(text)
	local function link(s)
		return add_escape(&quot;&lt;a href=\&quot;&quot; .. s .. &quot;\&quot;&gt;&quot;) .. s .. &quot;&lt;/a&gt;&quot;
	end
	-- Encode chars as a mix of dec and hex entitites to (perhaps) fool
	-- spambots.
	local function encode_email_address(s)
		-- Use a deterministic encoding to make unit testing possible.
		-- Code 45% hex, 45% dec, 10% plain.
		local hex = {code = function(c) return &quot;&amp;#x&quot; .. string.format(&quot;%x&quot;, c:byte()) .. &quot;;&quot; end, count = 1, rate = 0.45}
		local dec = {code = function(c) return &quot;&amp;#&quot; .. c:byte() .. &quot;;&quot; end, count = 0, rate = 0.45}
		local plain = {code = function(c) return c end, count = 0, rate = 0.1}
		local codes = {hex, dec, plain}
		local function swap(t,k1,k2) local temp = t[k2] t[k2] = t[k1] t[k1] = temp end

		local out = &quot;&quot;
		for i = 1,s:len() do
			for _,code in ipairs(codes) do code.count = code.count + code.rate end
			if codes[1].count &lt; codes[2].count then swap(codes,1,2) end
			if codes[2].count &lt; codes[3].count then swap(codes,2,3) end
			if codes[1].count &lt; codes[2].count then swap(codes,1,2) end

			local code = codes[1]
			local c = s:sub(i,i)
			-- Force encoding of &quot;@&quot; to make email address more invisible.
			if c == &quot;@&quot; and code == plain then code = codes[2] end
			out = out .. code.code(c)
			code.count = code.count - 1
		end
		return out
	end
	local function mail(s)
		s = unescape_special_chars(s)
		local address = encode_email_address(&quot;mailto:&quot; .. s)
		local text = encode_email_address(s)
		return add_escape(&quot;&lt;a href=\&quot;&quot; .. address .. &quot;\&quot;&gt;&quot;) .. text .. &quot;&lt;/a&gt;&quot;
	end
	-- links
	text = text:gsub(&quot;&lt;(https?:[^&apos;\&quot;&gt;%s]+)&gt;&quot;, link)
	text = text:gsub(&quot;&lt;(ftp:[^&apos;\&quot;&gt;%s]+)&gt;&quot;, link)

	-- mail
	text = text:gsub(&quot;&lt;mailto:([^&apos;\&quot;&gt;%s]+)&gt;&quot;, mail)
	text = text:gsub(&quot;&lt;([-.%w]+%@[-.%w]+)&gt;&quot;, mail)
	return text
end

-- Encode free standing amps (&amp;) and angles (&lt;)... note that this does not
-- encode free &gt;.
function amps_and_angles(s)
	-- encode amps not part of &amp;..; expression
	local pos = 1
	while true do
		local amp = s:find(&quot;&amp;&quot;, pos)
		if not amp then break end
		local semi = s:find(&quot;;&quot;, amp+1)
		local stop = s:find(&quot;[ \t\n&amp;]&quot;, amp+1)
		if not semi or (stop and stop &lt; semi) or (semi - amp) &gt; 15 then
			s = s:sub(1,amp-1) .. &quot;&amp;amp;&quot; .. s:sub(amp+1)
			pos = amp+1
		else
			pos = amp+1
		end
	end

	-- encode naked &lt;&apos;s
	s = s:gsub(&quot;&lt;([^a-zA-Z/?$!])&quot;, &quot;&amp;lt;%1&quot;)
	s = s:gsub(&quot;&lt;$&quot;, &quot;&amp;lt;&quot;)

	-- what about &gt;, nothing done in the original markdown source to handle them
	return s
end

-- Handles emphasis markers (* and _) in the text.
function emphasis(text)
	for _, s in ipairs {&quot;%*%*&quot;, &quot;%_%_&quot;} do
		text = text:gsub(s .. &quot;([^%s][%*%_]?)&quot; .. s, &quot;&lt;strong&gt;%1&lt;/strong&gt;&quot;)
		text = text:gsub(s .. &quot;([^%s][^&lt;&gt;]-[^%s][%*%_]?)&quot; .. s, &quot;&lt;strong&gt;%1&lt;/strong&gt;&quot;)
	end
	for _, s in ipairs {&quot;%*&quot;, &quot;%_&quot;} do
		text = text:gsub(s .. &quot;([^%s_])&quot; .. s, &quot;&lt;em&gt;%1&lt;/em&gt;&quot;)
		text = text:gsub(s .. &quot;(&lt;strong&gt;[^%s_]&lt;/strong&gt;)&quot; .. s, &quot;&lt;em&gt;%1&lt;/em&gt;&quot;)
		text = text:gsub(s .. &quot;([^%s_][^&lt;&gt;_]-[^%s_])&quot; .. s, &quot;&lt;em&gt;%1&lt;/em&gt;&quot;)
		text = text:gsub(s .. &quot;([^&lt;&gt;_]-&lt;strong&gt;[^&lt;&gt;_]-&lt;/strong&gt;[^&lt;&gt;_]-)&quot; .. s, &quot;&lt;em&gt;%1&lt;/em&gt;&quot;)
	end
	return text
end

-- Handles line break markers in the text.
function line_breaks(text)
	return text:gsub(&quot;  +\n&quot;, &quot; &lt;br/&gt;\n&quot;)
end

-- Perform all span level transforms.
function span_transform(text)
	text = code_spans(text)
	text = escape_special_chars(text)
	text = images(text)
	text = anchors(text)
	text = auto_links(text)
	text = amps_and_angles(text)
	text = emphasis(text)
	text = line_breaks(text)
	return text
end

----------------------------------------------------------------------
-- Markdown
----------------------------------------------------------------------

-- Cleanup the text by normalizing some possible variations to make further
-- processing easier.
function cleanup(text)
	-- Standardize line endings
	text = text:gsub(&quot;\r\n&quot;, &quot;\n&quot;)  -- DOS to UNIX
	text = text:gsub(&quot;\r&quot;, &quot;\n&quot;)    -- Mac to UNIX

	-- Convert all tabs to spaces
	text = detab(text)

	-- Strip lines with only spaces and tabs
	while true do
		local subs
		text, subs = text:gsub(&quot;\n[ \t]+\n&quot;, &quot;\n\n&quot;)
		if subs == 0 then break end
	end

	return &quot;\n&quot; .. text .. &quot;\n&quot;
end

-- Strips link definitions from the text and stores the data in a lookup table.
function strip_link_definitions(text)
	local linkdb = {}

	local function link_def(id, url, title)
		id = id:match(&quot;%[(.+)%]&quot;):lower()
		linkdb[id] = linkdb[id] or {}
		linkdb[id].url = url or linkdb[id].url
		linkdb[id].title = title or linkdb[id].title
		return &quot;&quot;
	end

	local def_no_title = &quot;\n ? ? ?(%b[]):[ \t]*\n?[ \t]*&lt;?([^%s&gt;]+)&gt;?[ \t]*&quot;
	local def_title1 = def_no_title .. &quot;[ \t]+\n?[ \t]*[\&quot;&apos;(]([^\n]+)[\&quot;&apos;)][ \t]*&quot;
	local def_title2 = def_no_title .. &quot;[ \t]*\n[ \t]*[\&quot;&apos;(]([^\n]+)[\&quot;&apos;)][ \t]*&quot;
	local def_title3 = def_no_title .. &quot;[ \t]*\n?[ \t]+[\&quot;&apos;(]([^\n]+)[\&quot;&apos;)][ \t]*&quot;

	text = text:gsub(def_title1, link_def)
	text = text:gsub(def_title2, link_def)
	text = text:gsub(def_title3, link_def)
	text = text:gsub(def_no_title, link_def)
	return text, linkdb
end

link_database = {}

function block_transform_nohtml(text, sublist)
	local lines = split(text)
	lines = map(lines, classify)
	lines = headers(lines)
	--lines = lists(lines, sublist)
	--lines = codeblocks(lines)
	--lines = blockquotes(lines)
	--lines = blocks_to_html(lines)
	--local text = table.concat(lines, &quot;\n&quot;)
	return lines
end

-- Main markdown processing function
function markdown(text)
	init_hash(text)
	init_escape_table()

	text = cleanup(text)
	text = protect(text)
	text, link_database = strip_link_definitions(text)
	text = block_transform(text)
	text = unescape_special_chars(text)
	return text
end

function markdown(text)
	init_hash(text)
	init_escape_table()

	text = cleanup(text)
	text = protect(text)
	text, link_database = strip_link_definitions(text)
	text = block_transform_nohtml(text)
	return text
end

----------------------------------------------------------------------
-- End of module
----------------------------------------------------------------------

setfenv(1, _G)
M.lock(M)

-- Expose markdown function to the world
markdown = M.markdown

-- Class for parsing command-line options
local OptionParser = {}
OptionParser.__index = OptionParser

-- Creates a new option parser
function OptionParser:new()
	local o = {short = {}, long = {}}
	setmetatable(o, self)
	return o
end

-- Calls f() whenever a flag with specified short and long name is encountered
function OptionParser:flag(short, long, f)
	local info = {type = &quot;flag&quot;, f = f}
	if short then self.short[short] = info end
	if long then self.long[long] = info end
end

-- Calls f(param) whenever a parameter flag with specified short and long name is encountered
function OptionParser:param(short, long, f)
	local info = {type = &quot;param&quot;, f = f}
	if short then self.short[short] = info end
	if long then self.long[long] = info end
end

-- Calls f(v) for each non-flag argument
function OptionParser:arg(f)
	self.arg = f
end

-- Runs the option parser for the specified set of arguments. Returns true if all arguments
-- where successfully parsed and false otherwise.
function OptionParser:run(args)
	local pos = 1
	while pos &lt;= #args do
		local arg = args[pos]
		if arg == &quot;--&quot; then
			for i=pos+1,#args do
				if self.arg then self.arg(args[i]) end
				return true
			end
		end
		if arg:match(&quot;^%-%-&quot;) then
			local info = self.long[arg:sub(3)]
			if not info then print(&quot;Unknown flag: &quot; .. arg) return false end
			if info.type == &quot;flag&quot; then
				info.f()
				pos = pos + 1
			else
				param = args[pos+1]
				if not param then print(&quot;No parameter for flag: &quot; .. arg) return false end
				info.f(param)
				pos = pos+2
			end
		elseif arg:match(&quot;^%-&quot;) then
			for i=2,arg:len() do
				local c = arg:sub(i,i)
				local info = self.short[c]
				if not info then print(&quot;Unknown flag: -&quot; .. c) return false end
				if info.type == &quot;flag&quot; then
					info.f()
				else
					if i == arg:len() then
						param = args[pos+1]
						if not param then print(&quot;No parameter for flag: -&quot; .. c) return false end
						info.f(param)
						pos = pos + 1
					else
						param = arg:sub(i+1)
						info.f(param)
					end
					break
				end
			end
			pos = pos + 1
		else
			if self.arg then self.arg(arg) end
			pos = pos + 1
		end
	end
	return true
end

-- Handles the case when markdown is run from the command line
local function run_command_line(arg)
	-- Generate output for input s given options
	local function run(s, options)
		s = markdown(s)
		if not options.wrap_header then return s end
		local header = &quot;&quot;
		if options.header then
			local f = io.open(options.header) or error(&quot;Could not open file: &quot; .. options.header)
			header = f:read(&quot;*a&quot;)
			f:close()
		else
			header = [[
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=CHARSET&quot; /&gt;
	&lt;title&gt;TITLE&lt;/title&gt;
	&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;STYLESHEET&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
]]
			local title = options.title or s:match(&quot;&lt;h1&gt;(.-)&lt;/h1&gt;&quot;) or s:match(&quot;&lt;h2&gt;(.-)&lt;/h2&gt;&quot;) or
				s:match(&quot;&lt;h3&gt;(.-)&lt;/h3&gt;&quot;) or &quot;Untitled&quot;
			header = header:gsub(&quot;TITLE&quot;, title)
			if options.inline_style then
				local style = &quot;&quot;
				local f = io.open(options.stylesheet)
				if f then
					style = f:read(&quot;*a&quot;) f:close()
				else
					error(&quot;Could not include style sheet &quot; .. options.stylesheet .. &quot;: File not found&quot;)
				end
				header = header:gsub(&apos;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;STYLESHEET&quot; /&gt;&apos;,
					&quot;&lt;style type=\&quot;text/css\&quot;&gt;&lt;!--\n&quot; .. style .. &quot;\n--&gt;&lt;/style&gt;&quot;)
			else
				header = header:gsub(&quot;STYLESHEET&quot;, options.stylesheet)
			end
			header = header:gsub(&quot;CHARSET&quot;, options.charset)
		end
		local footer = &quot;&lt;/body&gt;&lt;/html&gt;&quot;
		if options.footer then
			local f = io.open(options.footer) or error(&quot;Could not open file: &quot; .. options.footer)
			footer = f:read(&quot;*a&quot;)
			f:close()
		end
		return header .. s .. footer
	end

	-- Generate output path name from input path name given options.
	local function outpath(path, options)
		if options.append then return path .. &quot;.html&quot; end
		local m = path:match(&quot;^(.+%.html)[^/\\]+$&quot;) if m then return m end
		m = path:match(&quot;^(.+%.)[^/\\]*$&quot;) if m and path ~= m .. &quot;html&quot; then return m .. &quot;html&quot; end
		return path .. &quot;.html&quot;
	end

	-- Default commandline options
	local options = {
		wrap_header = true,
		header = nil,
		footer = nil,
		charset = &quot;utf-8&quot;,
		title = nil,
		stylesheet = &quot;default.css&quot;,
		inline_style = false
	}
	local help = [[
Usage: markdown.lua [OPTION] [FILE]
Runs the markdown text markup to HTML converter on each file specified on the
command line. If no files are specified, runs on standard input.

No header:
    -n, --no-wrap        Don&apos;t wrap the output in &lt;html&gt;... tags.
Custom header:
    -e, --header FILE    Use content of FILE for header.
    -f, --footer FILE    Use content of FILE for footer.
Generated header:
    -c, --charset SET    Specifies charset (default utf-8).
    -i, --title TITLE    Specifies title (default from first &lt;h1&gt; tag).
    -s, --style STYLE    Specifies style sheet file (default default.css).
	-l, --inline-style   Include the style sheet file inline in the header.
Generated files:
    -a, --append         Append .html extension (instead of replacing).
Other options:
    -h, --help           Print this help text.
    -t, --test           Run the unit tests.
]]

	local run_stdin = true
	local op = OptionParser:new()
	op:flag(&quot;n&quot;, &quot;no-wrap&quot;, function () options.wrap_header = false end)
	op:param(&quot;e&quot;, &quot;header&quot;, function (x) options.header = x end)
	op:param(&quot;f&quot;, &quot;footer&quot;, function (x) options.footer = x end)
	op:param(&quot;c&quot;, &quot;charset&quot;, function (x) options.charset = x end)
	op:param(&quot;i&quot;, &quot;title&quot;, function(x) options.title = x end)
	op:param(&quot;s&quot;, &quot;style&quot;, function(x) options.stylesheet = x end)
	op:flag(&quot;l&quot;, &quot;inline-style&quot;, function(x) options.inline_style = true end)
	op:flag(&quot;a&quot;, &quot;append&quot;, function() options.append = true end)
	op:flag(&quot;t&quot;, &quot;test&quot;, function()
		local n = arg[0]:gsub(&quot;markdown.lua&quot;, &quot;markdown-tests.lua&quot;)
		local f = io.open(n)
		if f then
			f:close() dofile(n)
		else
			error(&quot;Cannot find markdown-tests.lua&quot;)
		end
		run_stdin = false
	end)
	op:flag(&quot;h&quot;, &quot;help&quot;, function() print(help) run_stdin = false end)
	op:arg(function(path)
			local file = io.open(path) or error(&quot;Could not open file: &quot; .. path)
			local s = file:read(&quot;*a&quot;)
			file:close()
			s = run(s, options)
			file = io.open(outpath(path, options), &quot;w&quot;) or error(&quot;Could not open output file: &quot; .. outpath(path, options))
			file:write(s)
			file:close()
			run_stdin = false
		end
	)

	if not op:run(arg) then
		print(help)
		run_stdin = false
	end

	if run_stdin then
		local s = io.read(&quot;*a&quot;)
		s = run(s, options)
		io.write(s)
	end
end

-- If we are being run from the command-line, act accordingly
if arg and arg[0]:find(&quot;markdown%.lua$&quot;) then
	run_command_line(arg)
else
	return markdown
end
</ProtectedString>
<bool name="Disabled">true</bool>
</Properties>
</Item>
<Item class="Script" referent="RBX44">
<Properties>
<string name="Name">MarkdownSystem</string>
<ProtectedString name="Source">while not _G.NevermoreEngine do wait(0) end

local Players           = Game:GetService(&apos;Players&apos;)
local StarterPack       = Game:GetService(&apos;StarterPack&apos;)
local StarterGui        = Game:GetService(&apos;StarterGui&apos;)
local Lighting          = Game:GetService(&apos;Lighting&apos;)
local Debris            = Game:GetService(&apos;Debris&apos;)
local Teams             = Game:GetService(&apos;Teams&apos;)
local BadgeService      = Game:GetService(&apos;BadgeService&apos;)
local Terrain           = Workspace.Terrain

local NevermoreEngine    = _G.NevermoreEngine
local LoadCustomLibrary = NevermoreEngine.LoadLibrary;

--[[
	Modified version of Markdown (not full) in order to work with GUIs on ROBLOX
	Modified by Quenty

	# markdown.lua -- version 0.32

	&lt;http://www.frykholm.se/files/markdown.lua&gt;

	**Author:** Niklas Frykholm, &lt;niklas@frykholm.se&gt;
	**Date:** 31 May 2008

	This is an implementation of the popular text markup language Markdown in pure Lua.
	Markdown can convert documents written in a simple and easy to read text format
	to well-formatted HTML. For a more thourough description of Markdown and the Markdown
	syntax, see &lt;http://daringfireball.net/projects/markdown&gt;.

	The original Markdown source is written in Perl and makes heavy use of advanced
	regular expression techniques (such as negative look-ahead, etc) which are not available
	in Lua&apos;s simple regex engine. Therefore this Lua port has been rewritten from the ground
	up. It is probably not completely bug free. If you notice any bugs, please report them to
	me. A unit test that exposes the error is helpful.

	## License

	Copyright (C) 2008 Niklas Frykholm.

	Permission is hereby granted, free of charge, to any person obtaining a copy of this
	software and associated documentation files (the &quot;Software&quot;), to deal in the Software
	without restriction, including without limitation the rights to use, copy, modify, merge,
	publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons
	to whom the Software is furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all copies
	or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
]]


local Markdown = {}
--setmetatable(M, {__index = _G})
--setfenv(1, M)

local lock, -- Keep environment clean, I guess? Although, since it&apos;s running in another script... eh... I don&apos;t think it&apos;ll matter...
      lock_new_index,
      map,
      identity,
      iff,
      split,
      detab,
      find_first,
      splice,
      outdent,
      indent,
      tokenize_html,
      init_hash,
      hash,
      block_pattern,
      line_pattern,
      protect_range,
      protect_matches,
      protect,
      is_protected,
      unprotect,
      is_ruler_of,
      classify,
      headers,
      lists,
      blockquotes,
      codeblocks,
      blocks_to_html,
      block_transform,
      print_lines,
      init_escape_table,
      add_escape,
      escape_special_char,
      encode_backslash_es,
      unescape_special_ch,
      encode_code,
      code_spans,
      encode_alt,
      images,
      anchors,
      auto_links,
      amps_and_angles,
      emphasis,
      line_breaks,
      span_transform,
      cleanups,
      capes,
      ars,
      ons,
      strip_link_definiti,
      block_transform_nohtml

----------------------------------------------------------------------
-- Utility functions
----------------------------------------------------------------------

-- Locks table t from changes, writes an error if someone attempts to change the table.
-- This is useful for detecting variables that have &quot;accidently&quot; been made global. Something
-- I tend to do all too much.
function lock(t)
	function lock_new_index(t, k, v)
		error(&quot;module has been locked -- &quot; .. k .. &quot; must be declared local&quot;, 2)
	end

	local mt = {__newindex = lock_new_index}
	if getmetatable(t) then mt.__index = getmetatable(t).__index end
	setmetatable(t, mt)
end

-- Returns the result of mapping the values in table t through the function f
function map(t, f)
	local out = {}
	for k,v in pairs(t) do out[k] = f(v,k) end
	return out
end

-- The identity function, useful as a placeholder.
function identity(text) return text end

-- Functional style if statement. (NOTE: no short circuit evaluation)
function iff(t, a, b) if t then return a else return b end end

-- Splits the text into an array of separate lines.
function split(text, sep)
	sep = sep or &quot;\n&quot;
	local lines = {}
	local pos = 1
	while true do
		local b,e = text:find(sep, pos)
		if not b then table.insert(lines, text:sub(pos)) break end
		table.insert(lines, text:sub(pos, b-1))
		pos = e + 1
	end
	return lines
end

-- Converts tabs to spaces
function detab(text)
	local tab_width = 4
	local function rep(match)
		local spaces = -match:len()
		while spaces&lt;1 do spaces = spaces + tab_width end
		return match .. string.rep(&quot; &quot;, spaces)
	end
	text = text:gsub(&quot;([^\n]-)\t&quot;, rep)
	return text
end

-- Applies string.find for every pattern in the list and returns the first match
function find_first(s, patterns, index)
	local res = {}
	for _,p in ipairs(patterns) do
		local match = {s:find(p, index)}
		if #match&gt;0 and (#res==0 or match[1] &lt; res[1]) then res = match end
	end
	return unpack(res)
end

-- If a replacement array is specified, the range [start, stop] in the array is replaced
-- with the replacement array and the resulting array is returned. Without a replacement
-- array the section of the array between start and stop is returned.
function splice(array, start, stop, replacement)
	if replacement then
		local n = stop - start + 1
		while n &gt; 0 do
			table.remove(array, start)
			n = n - 1
		end
		for i,v in ipairs(replacement) do
			table.insert(array, start, v)
		end
		return array
	else
		local res = {}
		for i = start,stop do
			table.insert(res, array[i])
		end
		return res
	end
end

-- Outdents the text one step.
function outdent(text)
	text = &quot;\n&quot; .. text
	text = text:gsub(&quot;\n  ? ? ?&quot;, &quot;\n&quot;)
	text = text:sub(2)
	return text
end

-- Indents the text one step.
function indent(text)
	text = text:gsub(&quot;\n&quot;, &quot;\n    &quot;)
	return text
end

-- Does a simple tokenization of html data. Returns the data as a list of tokens.
-- Each token is a table with a type field (which is either &quot;tag&quot; or &quot;text&quot;) and
-- a text field (which contains the original token data).
function tokenize_html(html)
	local tokens = {}
	local pos = 1
	while true do
		local start = find_first(html, {&quot;&lt;!%-%-&quot;, &quot;&lt;[a-z/!$]&quot;, &quot;&lt;%?&quot;}, pos)
		if not start then
			table.insert(tokens, {type=&quot;text&quot;, text=html:sub(pos)})
			break
		end
		if start ~= pos then table.insert(tokens, {type=&quot;text&quot;, text = html:sub(pos, start-1)}) end

		local _, stop
		if html:match(&quot;^&lt;!%-%-&quot;, start) then
			_,stop = html:find(&quot;%-%-&gt;&quot;, start)
		elseif html:match(&quot;^&lt;%?&quot;, start) then
			_,stop = html:find(&quot;?&gt;&quot;, start)
		else
			_,stop = html:find(&quot;%b&lt;&gt;&quot;, start)
		end
		if not stop then
			-- error(&quot;Could not match html tag &quot; .. html:sub(start,start+30))
		 	table.insert(tokens, {type=&quot;text&quot;, text=html:sub(start, start)})
			pos = start + 1
		else
			table.insert(tokens, {type=&quot;tag&quot;, text=html:sub(start, stop)})
			pos = stop + 1
		end
	end
	return tokens
end

----------------------------------------------------------------------
-- Hash
----------------------------------------------------------------------

-- This is used to &quot;hash&quot; data into alphanumeric strings that are unique
-- in the document. (Note that this is not cryptographic hash, the hash
-- function is not one-way.) The hash procedure is used to protect parts
-- of the document from further processing.

local HASH = {
	-- Has the hash been inited.
	inited = false,

	-- The unique string prepended to all hash values. This is to ensure
	-- that hash values do not accidently coincide with an actual existing
	-- string in the document.
	identifier = &quot;&quot;,

	-- Counter that counts up for each new hash instance.
	counter = 0,

	-- Hash table.
	table = {}
}

-- Inits hashing. Creates a hash_identifier that doesn&apos;t occur anywhere
-- in the text.
function init_hash(text)
	HASH.inited = true
	HASH.identifier = &quot;&quot;
	HASH.counter = 0
	HASH.table = {}

	local s = &quot;HASH&quot;
	local counter = 0
	local id
	while true do
		id  = s .. counter
		if not text:find(id, 1, true) then break end
		counter = counter + 1
	end
	HASH.identifier = id
end

-- Returns the hashed value for s.
function hash(s)
	assert(HASH.inited)
	if not HASH.table[s] then
		HASH.counter = HASH.counter + 1
		local id = HASH.identifier .. HASH.counter .. &quot;X&quot;
		HASH.table[s] = id
	end
	return HASH.table[s]
end

----------------------------------------------------------------------
-- Protection
----------------------------------------------------------------------

-- The protection module is used to &quot;protect&quot; parts of a document
-- so that they are not modified by subsequent processing steps.
-- Protected parts are saved in a table for later unprotection

-- Protection data
local PD = {
	-- Saved blocks that have been converted
	blocks = {},

	-- Block level tags that will be protected
	tags = {&quot;p&quot;, &quot;div&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;, &quot;blockquote&quot;,
	&quot;pre&quot;, &quot;table&quot;, &quot;dl&quot;, &quot;ol&quot;, &quot;ul&quot;, &quot;script&quot;, &quot;noscript&quot;, &quot;form&quot;, &quot;fieldset&quot;,
	&quot;iframe&quot;, &quot;math&quot;, &quot;ins&quot;, &quot;del&quot;}
}

-- Pattern for matching a block tag that begins and ends in the leftmost
-- column and may contain indented subtags, i.e.
-- &lt;div&gt;
--    A nested block.
--    &lt;div&gt;
--        Nested data.
--     &lt;/div&gt;
-- &lt;/div&gt;
function block_pattern(tag)
	return &quot;\n&lt;&quot; .. tag .. &quot;.-\n&lt;/&quot; .. tag .. &quot;&gt;[ \t]*\n&quot;
end

-- Pattern for matching a block tag that begins and ends with a newline
function line_pattern(tag)
	return &quot;\n&lt;&quot; .. tag .. &quot;.-&lt;/&quot; .. tag .. &quot;&gt;[ \t]*\n&quot;
end

-- Protects the range of characters from start to stop in the text and
-- returns the protected string.
function protect_range(text, start, stop)
	local s = text:sub(start, stop)
	local h = hash(s)
	PD.blocks[h] = s
	text = text:sub(1,start) .. h .. text:sub(stop)
	return text
end

-- Protect every part of the text that matches any of the patterns. The first
-- matching pattern is protected first, etc.
function protect_matches(text, patterns)
	while true do
		local start, stop = find_first(text, patterns)
		if not start then break end
		text = protect_range(text, start, stop)
	end
	return text
end

-- Protects blocklevel tags in the specified text
function protect(text)
	-- First protect potentially nested block tags
	text = protect_matches(text, map(PD.tags, block_pattern))
	-- Then protect block tags at the line level.
	text = protect_matches(text, map(PD.tags, line_pattern))
	-- Protect &lt;hr&gt; and comment tags
	text = protect_matches(text, {&quot;\n&lt;hr[^&gt;]-&gt;[ \t]*\n&quot;})
	text = protect_matches(text, {&quot;\n&lt;!%-%-.-%-%-&gt;[ \t]*\n&quot;})
	return text
end

-- Returns true if the string s is a hash resulting from protection
function is_protected(s)
	return PD.blocks[s]
end

-- Unprotects the specified text by expanding all the nonces
function unprotect(text)
	for k,v in pairs(PD.blocks) do
		v = v:gsub(&quot;%%&quot;, &quot;%%%%&quot;)
		text = text:gsub(k, v)
	end
	return text
end


----------------------------------------------------------------------
-- Block transform
----------------------------------------------------------------------

-- The block transform functions transform the text on the block level.
-- They work with the text as an array of lines rather than as individual
-- characters.

-- Returns true if the line is a ruler of (char) characters.
-- The line must contain at least three char characters and contain only spaces and
-- char characters.
function is_ruler_of(line, char)
	if not line:match(&quot;^[ %&quot; .. char .. &quot;]*$&quot;) then return false end
	if not line:match(&quot;%&quot; .. char .. &quot;.*%&quot; .. char .. &quot;.*%&quot; .. char) then return false end
	return true
end

-- Identifies the block level formatting present in the line
function classify(line)
	local info = {line = line, text = line}

	if line:match(&quot;^    &quot;) then
		info.type = &quot;indented&quot;
		info.outdented = line:sub(5)
		return info
	end

	for _,c in ipairs({&apos;*&apos;, &apos;-&apos;, &apos;_&apos;, &apos;=&apos;}) do
		if is_ruler_of(line, c) then
			info.type = &quot;ruler&quot;
			info.ruler_char = c
			return info
		end
	end

	if line == &quot;&quot; then
		info.type = &quot;blank&quot;
		return info
	end

	if line:match(&quot;^(#+)[ \t]*(.-)[ \t]*#*[ \t]*$&quot;) then
		local m1, m2 = line:match(&quot;^(#+)[ \t]*(.-)[ \t]*#*[ \t]*$&quot;)
		info.type = &quot;header&quot;
		info.level = m1:len()
		info.text = m2
		return info
	end

	if line:match(&quot;^ ? ? ?(%d+)%.[ \t]+(.+)&quot;) then
		local number, text = line:match(&quot;^ ? ? ?(%d+)%.[ \t]+(.+)&quot;)
		info.type = &quot;list_item&quot;
		info.list_type = &quot;numeric&quot;
		info.number = 0 + number
		info.text = text
		return info
	end

	if line:match(&quot;^ ? ? ?([%*%+%-])[ \t]+(.+)&quot;) then
		local bullet, text = line:match(&quot;^ ? ? ?([%*%+%-])[ \t]+(.+)&quot;)
		info.type = &quot;list_item&quot;
		info.list_type = &quot;bullet&quot;
		info.bullet = bullet
		info.text= text
		return info
	end

	if line:match(&quot;^&gt;[ \t]?(.*)&quot;) then
		info.type = &quot;blockquote&quot;
		info.text = line:match(&quot;^&gt;[ \t]?(.*)&quot;)
		return info
	end

	if is_protected(line) then
		info.type = &quot;raw&quot;
		info.html = unprotect(line)
		return info
	end

	info.type = &quot;normal&quot;
	return info
end

-- Find headers constisting of a normal line followed by a ruler and converts them to
-- header entries.
function headers(array)
	local i = 1
	while i &lt;= #array - 1 do
		if array[i].type  == &quot;normal&quot; and array[i+1].type == &quot;ruler&quot; and
			(array[i+1].ruler_char == &quot;-&quot; or array[i+1].ruler_char == &quot;=&quot;) then
			local info = {line = array[i].line}
			info.text = info.line
			info.type = &quot;header&quot;
			info.level = iff(array[i+1].ruler_char == &quot;=&quot;, 1, 2)
			table.remove(array, i+1)
			array[i] = info
		end
		i = i + 1
	end
	return array
end

-- Find list blocks and convert them to protected data blocks
function lists(array, sublist)
	local function process_list(arr)
		local function any_blanks(arr)
			for i = 1, #arr do
				if arr[i].type == &quot;blank&quot; then return true end
			end
			return false
		end

		local function split_list_items(arr)
			local acc = {arr[1]}
			local res = {}
			for i=2,#arr do
				if arr[i].type == &quot;list_item&quot; then
					table.insert(res, acc)
					acc = {arr[i]}
				else
					table.insert(acc, arr[i])
				end
			end
			table.insert(res, acc)
			return res
		end

		local function process_list_item(lines, block)
			while lines[#lines].type == &quot;blank&quot; do
				table.remove(lines)
			end

			local itemtext = lines[1].text
			for i=2,#lines do
				itemtext = itemtext .. &quot;\n&quot; .. outdent(lines[i].line)
			end
			if block then
				itemtext = block_transform(itemtext, true)
				if not itemtext:find(&quot;&lt;pre&gt;&quot;) then itemtext = indent(itemtext) end
				return &quot;    &lt;li&gt;&quot; .. itemtext .. &quot;&lt;/li&gt;&quot;
			else
				local lines = split(itemtext)
				lines = map(lines, classify)
				lines = lists(lines, true)
				lines = blocks_to_html(lines, true)
				itemtext = table.concat(lines, &quot;\n&quot;)
				if not itemtext:find(&quot;&lt;pre&gt;&quot;) then itemtext = indent(itemtext) end
				return &quot;    &lt;li&gt;&quot; .. itemtext .. &quot;&lt;/li&gt;&quot;
			end
		end

		local block_list = any_blanks(arr)
		local items = split_list_items(arr)
		local out = &quot;&quot;
		for _, item in ipairs(items) do
			out = out .. process_list_item(item, block_list) .. &quot;\n&quot;
		end
		if arr[1].list_type == &quot;numeric&quot; then
			return &quot;&lt;ol&gt;\n&quot; .. out .. &quot;&lt;/ol&gt;&quot;
		else
			return &quot;&lt;ul&gt;\n&quot; .. out .. &quot;&lt;/ul&gt;&quot;
		end
	end

	-- Finds the range of lines composing the first list in the array. A list
	-- starts with (^ list_item) or (blank list_item) and ends with
	-- (blank* $) or (blank normal).
	--
	-- A sublist can start with just (list_item) does not need a blank...
	local function find_list(array, sublist)
		local function find_list_start(array, sublist)
			if array[1].type == &quot;list_item&quot; then return 1 end
			if sublist then
				for i = 1,#array do
					if array[i].type == &quot;list_item&quot; then return i end
				end
			else
				for i = 1, #array-1 do
					if array[i].type == &quot;blank&quot; and array[i+1].type == &quot;list_item&quot; then
						return i+1
					end
				end
			end
			return nil
		end
		local function find_list_end(array, start)
			local pos = #array
			for i = start, #array-1 do
				if array[i].type == &quot;blank&quot; and array[i+1].type ~= &quot;list_item&quot;
					and array[i+1].type ~= &quot;indented&quot; and array[i+1].type ~= &quot;blank&quot; then
					pos = i-1
					break
				end
			end
			while pos &gt; start and array[pos].type == &quot;blank&quot; do
				pos = pos - 1
			end
			return pos
		end

		local start = find_list_start(array, sublist)
		if not start then return nil end
		return start, find_list_end(array, start)
	end

	while true do
		local start, stop = find_list(array, sublist)
		if not start then break end
		local text = process_list(splice(array, start, stop))
		local info = {
			line = text,
			type = &quot;raw&quot;,
			html = text
		}
		array = splice(array, start, stop, {info})
	end

	-- Convert any remaining list items to normal
	for _,line in ipairs(array) do
		if line.type == &quot;list_item&quot; then line.type = &quot;normal&quot; end
	end

	return array
end

-- Find and convert blockquote markers.
function blockquotes(lines)
	local function find_blockquote(lines)
		local start
		for i,line in ipairs(lines) do
			if line.type == &quot;blockquote&quot; then
				start = i
				break
			end
		end
		if not start then return nil end

		local stop = #lines
		for i = start+1, #lines do
			if lines[i].type == &quot;blank&quot; or lines[i].type == &quot;blockquote&quot; then
			elseif lines[i].type == &quot;normal&quot; then
				if lines[i-1].type == &quot;blank&quot; then stop = i-1 break end
			else
				stop = i-1 break
			end
		end
		while lines[stop].type == &quot;blank&quot; do stop = stop - 1 end
		return start, stop
	end

	local function process_blockquote(lines)
		local raw = lines[1].text
		for i = 2,#lines do
			raw = raw .. &quot;\n&quot; .. lines[i].text
		end
		local bt = block_transform(raw)
		if not bt:find(&quot;&lt;pre&gt;&quot;) then bt = indent(bt) end
		return &quot;&lt;blockquote&gt;\n    &quot; .. bt ..
			&quot;\n&lt;/blockquote&gt;&quot;
	end

	while true do
		local start, stop = find_blockquote(lines)
		if not start then break end
		local text = process_blockquote(splice(lines, start, stop))
		local info = {
			line = text,
			type = &quot;raw&quot;,
			html = text
		}
		lines = splice(lines, start, stop, {info})
	end
	return lines
end

-- Find and convert codeblocks.
function codeblocks(lines)
	local function find_codeblock(lines)
		local start
		for i,line in ipairs(lines) do
			if line.type == &quot;indented&quot; then start = i break end
		end
		if not start then return nil end

		local stop = #lines
		for i = start+1, #lines do
			if lines[i].type ~= &quot;indented&quot; and lines[i].type ~= &quot;blank&quot; then
				stop = i-1
				break
			end
		end
		while lines[stop].type == &quot;blank&quot; do stop = stop - 1 end
		return start, stop
	end

	local function process_codeblock(lines)
		local raw = detab(encode_code(outdent(lines[1].line)))
		for i = 2,#lines do
			raw = raw .. &quot;\n&quot; .. detab(encode_code(outdent(lines[i].line)))
		end
		return &quot;&lt;pre&gt;&lt;code&gt;&quot; .. raw .. &quot;\n&lt;/code&gt;&lt;/pre&gt;&quot;
	end

	while true do
		local start, stop = find_codeblock(lines)
		if not start then break end
		local text = process_codeblock(splice(lines, start, stop))
		local info = {
			line = text,
			type = &quot;raw&quot;,
			html = text
		}
		lines = splice(lines, start, stop, {info})
	end
	return lines
end

-- Convert lines to html code
function blocks_to_html(lines, no_paragraphs)
	local out = {}
	local i = 1
	while i &lt;= #lines do
		local line = lines[i]
		if line.type == &quot;ruler&quot; then
			table.insert(out, &quot;&lt;hr/&gt;&quot;)
		elseif line.type == &quot;raw&quot; then
			table.insert(out, line.html)
		elseif line.type == &quot;normal&quot; then
			local s = line.line

			while i+1 &lt;= #lines and lines[i+1].type == &quot;normal&quot; do
				i = i + 1
				s = s .. &quot;\n&quot; .. lines[i].line
			end

			if no_paragraphs then
				table.insert(out, span_transform(s))
			else
				table.insert(out, &quot;&lt;p&gt;&quot; .. span_transform(s) .. &quot;&lt;/p&gt;&quot;)
			end
		elseif line.type == &quot;header&quot; then
			local s = &quot;&lt;h&quot; .. line.level .. &quot;&gt;&quot; .. span_transform(line.text) .. &quot;&lt;/h&quot; .. line.level .. &quot;&gt;&quot;
			table.insert(out, s)
		else
			table.insert(out, line.line)
		end
		i = i + 1
	end
	return out
end

-- Perform all the block level transforms
function block_transform(text, sublist)
	local lines = split(text)
	lines = map(lines, classify)
	lines = headers(lines)
	lines = lists(lines, sublist)
	lines = codeblocks(lines)
	lines = blockquotes(lines)
	lines = blocks_to_html(lines)
	local text = table.concat(lines, &quot;\n&quot;)
	return text
end

-- Debug function for printing a line array to see the result
-- of partial transforms.
function print_lines(lines)
	for i, line in ipairs(lines) do
		print(i, line.type, line.text or line.line)
	end
end

----------------------------------------------------------------------
-- Span transform
----------------------------------------------------------------------

-- Functions for transforming the text at the span level.

-- These characters may need to be escaped because they have a special
-- meaning in markdown.
escape_chars = &quot;&apos;\\`*_{}[]()&gt;#+-.!&apos;&quot;
escape_table = {}

function init_escape_table()
	escape_table = {}
	for i = 1,#escape_chars do
		local c = escape_chars:sub(i,i)
		escape_table[c] = hash(c)
	end
end

-- Adds a new escape to the escape table.
function add_escape(text)
	if not escape_table[text] then
		escape_table[text] = hash(text)
	end
	return escape_table[text]
end

-- Escape characters that should not be disturbed by markdown.
function escape_special_chars(text)
	local tokens = tokenize_html(text)

	local out = &quot;&quot;
	for _, token in ipairs(tokens) do
		local t = token.text
		if token.type == &quot;tag&quot; then
			-- In tags, encode * and _ so they don&apos;t conflict with their use in markdown.
			t = t:gsub(&quot;%*&quot;, escape_table[&quot;*&quot;])
			t = t:gsub(&quot;%_&quot;, escape_table[&quot;_&quot;])
		else
			t = encode_backslash_escapes(t)
		end
		out = out .. t
	end
	return out
end

-- Encode backspace-escaped characters in the markdown source.
function encode_backslash_escapes(t)
	for i=1,escape_chars:len() do
		local c = escape_chars:sub(i,i)
		t = t:gsub(&quot;\\%&quot; .. c, escape_table[c])
	end
	return t
end

-- Unescape characters that have been encoded.
function unescape_special_chars(t)
	local tin = t
	for k,v in pairs(escape_table) do
		k = k:gsub(&quot;%%&quot;, &quot;%%%%&quot;)
		t = t:gsub(v,k)
	end
	if t ~= tin then t = unescape_special_chars(t) end
	return t
end

-- Encode/escape certain characters inside Markdown code runs.
-- The point is that in code, these characters are literals,
-- and lose their special Markdown meanings.
function encode_code(s)
	s = s:gsub(&quot;%&amp;&quot;, &quot;&amp;amp;&quot;)
	s = s:gsub(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)
	s = s:gsub(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)
	for k,v in pairs(escape_table) do
		s = s:gsub(&quot;%&quot;..k, v)
	end
	return s
end

-- Handle backtick blocks.
function code_spans(s)
	s = s:gsub(&quot;\\\\&quot;, escape_table[&quot;\\&quot;])
	s = s:gsub(&quot;\\`&quot;, escape_table[&quot;`&quot;])

	local pos = 1
	while true do
		local start, stop = s:find(&quot;`+&quot;, pos)
		if not start then return s end
		local count = stop - start + 1
		-- Find a matching numbert of backticks
		local estart, estop = s:find(string.rep(&quot;`&quot;, count), stop+1)
		local brstart = s:find(&quot;\n&quot;, stop+1)
		if estart and (not brstart or estart &lt; brstart) then
			local code = s:sub(stop+1, estart-1)
			code = code:gsub(&quot;^[ \t]+&quot;, &quot;&quot;)
			code = code:gsub(&quot;[ \t]+$&quot;, &quot;&quot;)
			code = code:gsub(escape_table[&quot;\\&quot;], escape_table[&quot;\\&quot;] .. escape_table[&quot;\\&quot;])
			code = code:gsub(escape_table[&quot;`&quot;], escape_table[&quot;\\&quot;] .. escape_table[&quot;`&quot;])
			code = &quot;&lt;code&gt;&quot; .. encode_code(code) .. &quot;&lt;/code&gt;&quot;
			code = add_escape(code)
			s = s:sub(1, start-1) .. code .. s:sub(estop+1)
			pos = start + code:len()
		else
			pos = stop + 1
		end
	end
	return s
end

-- Encode alt text... enodes &amp;, and &quot;.
function encode_alt(s)
	if not s then return s end
	s = s:gsub(&apos;&amp;&apos;, &apos;&amp;amp;&apos;)
	s = s:gsub(&apos;&quot;&apos;, &apos;&amp;quot;&apos;)
	s = s:gsub(&apos;&lt;&apos;, &apos;&amp;lt;&apos;)
	return s
end

-- Handle image references
function images(text)
	local function reference_link(alt, id)
		alt = encode_alt(alt:match(&quot;%b[]&quot;):sub(2,-2))
		id = id:match(&quot;%[(.*)%]&quot;):lower()
		if id == &quot;&quot; then id = text:lower() end
		link_database[id] = link_database[id] or {}
		if not link_database[id].url then return nil end
		local url = link_database[id].url or id
		url = encode_alt(url)
		local title = encode_alt(link_database[id].title)
		if title then title = &quot; title=\&quot;&quot; .. title .. &quot;\&quot;&quot; else title = &quot;&quot; end
		return add_escape (&apos;&lt;img src=&quot;&apos; .. url .. &apos;&quot; alt=&quot;&apos; .. alt .. &apos;&quot;&apos; .. title .. &quot;/&gt;&quot;)
	end

	local function inline_link(alt, link)
		alt = encode_alt(alt:match(&quot;%b[]&quot;):sub(2,-2))
		local url, title = link:match(&quot;%(&lt;?(.-)&gt;?[ \t]*[&apos;\&quot;](.+)[&apos;\&quot;]&quot;)
		url = url or link:match(&quot;%(&lt;?(.-)&gt;?%)&quot;)
		url = encode_alt(url)
		title = encode_alt(title)
		if title then
			return add_escape(&apos;&lt;img src=&quot;&apos; .. url .. &apos;&quot; alt=&quot;&apos; .. alt .. &apos;&quot; title=&quot;&apos; .. title .. &apos;&quot;/&gt;&apos;)
		else
			return add_escape(&apos;&lt;img src=&quot;&apos; .. url .. &apos;&quot; alt=&quot;&apos; .. alt .. &apos;&quot;/&gt;&apos;)
		end
	end

	text = text:gsub(&quot;!(%b[])[ \t]*\n?[ \t]*(%b[])&quot;, reference_link)
	text = text:gsub(&quot;!(%b[])(%b())&quot;, inline_link)
	return text
end

-- Handle anchor references
function anchors(text)
	local function reference_link(text, id)
		text = text:match(&quot;%b[]&quot;):sub(2,-2)
		id = id:match(&quot;%b[]&quot;):sub(2,-2):lower()
		if id == &quot;&quot; then id = text:lower() end
		link_database[id] = link_database[id] or {}
		if not link_database[id].url then return nil end
		local url = link_database[id].url or id
		url = encode_alt(url)
		local title = encode_alt(link_database[id].title)
		if title then title = &quot; title=\&quot;&quot; .. title .. &quot;\&quot;&quot; else title = &quot;&quot; end
		return add_escape(&quot;&lt;a href=\&quot;&quot; .. url .. &quot;\&quot;&quot; .. title .. &quot;&gt;&quot;) .. text .. add_escape(&quot;&lt;/a&gt;&quot;)
	end

	local function inline_link(text, link)
		text = text:match(&quot;%b[]&quot;):sub(2,-2)
		local url, title = link:match(&quot;%(&lt;?(.-)&gt;?[ \t]*[&apos;\&quot;](.+)[&apos;\&quot;]&quot;)
		title = encode_alt(title)
		url  = url or  link:match(&quot;%(&lt;?(.-)&gt;?%)&quot;) or &quot;&quot;
		url = encode_alt(url)
		if title then
			return add_escape(&quot;&lt;a href=\&quot;&quot; .. url .. &quot;\&quot; title=\&quot;&quot; .. title .. &quot;\&quot;&gt;&quot;) .. text .. &quot;&lt;/a&gt;&quot;
		else
			return add_escape(&quot;&lt;a href=\&quot;&quot; .. url .. &quot;\&quot;&gt;&quot;) .. text .. add_escape(&quot;&lt;/a&gt;&quot;)
		end
	end

	text = text:gsub(&quot;(%b[])[ \t]*\n?[ \t]*(%b[])&quot;, reference_link)
	text = text:gsub(&quot;(%b[])(%b())&quot;, inline_link)
	return text
end

-- Handle auto links, i.e. &lt;http://www.google.com/&gt;.
function auto_links(text)
	local function link(s)
		return add_escape(&quot;&lt;a href=\&quot;&quot; .. s .. &quot;\&quot;&gt;&quot;) .. s .. &quot;&lt;/a&gt;&quot;
	end
	-- Encode chars as a mix of dec and hex entitites to (perhaps) fool
	-- spambots.
	local function encode_email_address(s)
		-- Use a deterministic encoding to make unit testing possible.
		-- Code 45% hex, 45% dec, 10% plain.
		local hex = {code = function(c) return &quot;&amp;#x&quot; .. string.format(&quot;%x&quot;, c:byte()) .. &quot;;&quot; end, count = 1, rate = 0.45}
		local dec = {code = function(c) return &quot;&amp;#&quot; .. c:byte() .. &quot;;&quot; end, count = 0, rate = 0.45}
		local plain = {code = function(c) return c end, count = 0, rate = 0.1}
		local codes = {hex, dec, plain}
		local function swap(t,k1,k2) local temp = t[k2] t[k2] = t[k1] t[k1] = temp end

		local out = &quot;&quot;
		for i = 1,s:len() do
			for _,code in ipairs(codes) do code.count = code.count + code.rate end
			if codes[1].count &lt; codes[2].count then swap(codes,1,2) end
			if codes[2].count &lt; codes[3].count then swap(codes,2,3) end
			if codes[1].count &lt; codes[2].count then swap(codes,1,2) end

			local code = codes[1]
			local c = s:sub(i,i)
			-- Force encoding of &quot;@&quot; to make email address more invisible.
			if c == &quot;@&quot; and code == plain then code = codes[2] end
			out = out .. code.code(c)
			code.count = code.count - 1
		end
		return out
	end
	local function mail(s)
		s = unescape_special_chars(s)
		local address = encode_email_address(&quot;mailto:&quot; .. s)
		local text = encode_email_address(s)
		return add_escape(&quot;&lt;a href=\&quot;&quot; .. address .. &quot;\&quot;&gt;&quot;) .. text .. &quot;&lt;/a&gt;&quot;
	end
	-- links
	text = text:gsub(&quot;&lt;(https?:[^&apos;\&quot;&gt;%s]+)&gt;&quot;, link)
	text = text:gsub(&quot;&lt;(ftp:[^&apos;\&quot;&gt;%s]+)&gt;&quot;, link)

	-- mail
	text = text:gsub(&quot;&lt;mailto:([^&apos;\&quot;&gt;%s]+)&gt;&quot;, mail)
	text = text:gsub(&quot;&lt;([-.%w]+%@[-.%w]+)&gt;&quot;, mail)
	return text
end

-- Encode free standing amps (&amp;) and angles (&lt;)... note that this does not
-- encode free &gt;.
function amps_and_angles(s)
	-- encode amps not part of &amp;..; expression
	local pos = 1
	while true do
		local amp = s:find(&quot;&amp;&quot;, pos)
		if not amp then break end
		local semi = s:find(&quot;;&quot;, amp+1)
		local stop = s:find(&quot;[ \t\n&amp;]&quot;, amp+1)
		if not semi or (stop and stop &lt; semi) or (semi - amp) &gt; 15 then
			s = s:sub(1,amp-1) .. &quot;&amp;amp;&quot; .. s:sub(amp+1)
			pos = amp+1
		else
			pos = amp+1
		end
	end

	-- encode naked &lt;&apos;s
	s = s:gsub(&quot;&lt;([^a-zA-Z/?$!])&quot;, &quot;&amp;lt;%1&quot;)
	s = s:gsub(&quot;&lt;$&quot;, &quot;&amp;lt;&quot;)

	-- what about &gt;, nothing done in the original markdown source to handle them
	return s
end

-- Handles emphasis markers (* and _) in the text.
function emphasis(text)
	for _, s in ipairs {&quot;%*%*&quot;, &quot;%_%_&quot;} do
		text = text:gsub(s .. &quot;([^%s][%*%_]?)&quot; .. s, &quot;&lt;strong&gt;%1&lt;/strong&gt;&quot;)
		text = text:gsub(s .. &quot;([^%s][^&lt;&gt;]-[^%s][%*%_]?)&quot; .. s, &quot;&lt;strong&gt;%1&lt;/strong&gt;&quot;)
	end
	for _, s in ipairs {&quot;%*&quot;, &quot;%_&quot;} do
		text = text:gsub(s .. &quot;([^%s_])&quot; .. s, &quot;&lt;em&gt;%1&lt;/em&gt;&quot;)
		text = text:gsub(s .. &quot;(&lt;strong&gt;[^%s_]&lt;/strong&gt;)&quot; .. s, &quot;&lt;em&gt;%1&lt;/em&gt;&quot;)
		text = text:gsub(s .. &quot;([^%s_][^&lt;&gt;_]-[^%s_])&quot; .. s, &quot;&lt;em&gt;%1&lt;/em&gt;&quot;)
		text = text:gsub(s .. &quot;([^&lt;&gt;_]-&lt;strong&gt;[^&lt;&gt;_]-&lt;/strong&gt;[^&lt;&gt;_]-)&quot; .. s, &quot;&lt;em&gt;%1&lt;/em&gt;&quot;)
	end
	return text
end

-- Handles line break markers in the text.
function line_breaks(text)
	return text:gsub(&quot;  +\n&quot;, &quot; &lt;br/&gt;\n&quot;)
end

-- Perform all span level transforms.
function span_transform(text)
	text = code_spans(text)
	text = escape_special_chars(text)
	text = images(text)
	text = anchors(text)
	text = auto_links(text)
	text = amps_and_angles(text)
	text = emphasis(text)
	text = line_breaks(text)
	return text
end

----------------------------------------------------------------------
-- Markdown
----------------------------------------------------------------------

-- Cleanup the text by normalizing some possible variations to make further
-- processing easier.
function cleanup(text)
	-- Standardize line endings
	text = text:gsub(&quot;\r\n&quot;, &quot;\n&quot;)  -- DOS to UNIX
	text = text:gsub(&quot;\r&quot;, &quot;\n&quot;)    -- Mac to UNIX

	-- Convert all tabs to spaces
	text = detab(text)

	-- Strip lines with only spaces and tabs
	while true do
		local subs
		text, subs = text:gsub(&quot;\n[ \t]+\n&quot;, &quot;\n\n&quot;)
		if subs == 0 then break end
	end

	return &quot;\n&quot; .. text .. &quot;\n&quot;
end

-- Strips link definitions from the text and stores the data in a lookup table.
function strip_link_definitions(text)
	local linkdb = {}

	local function link_def(id, url, title)
		id = id:match(&quot;%[(.+)%]&quot;):lower()
		linkdb[id] = linkdb[id] or {}
		linkdb[id].url = url or linkdb[id].url
		linkdb[id].title = title or linkdb[id].title
		return &quot;&quot;
	end

	local def_no_title = &quot;\n ? ? ?(%b[]):[ \t]*\n?[ \t]*&lt;?([^%s&gt;]+)&gt;?[ \t]*&quot;
	local def_title1 = def_no_title .. &quot;[ \t]+\n?[ \t]*[\&quot;&apos;(]([^\n]+)[\&quot;&apos;)][ \t]*&quot;
	local def_title2 = def_no_title .. &quot;[ \t]*\n[ \t]*[\&quot;&apos;(]([^\n]+)[\&quot;&apos;)][ \t]*&quot;
	local def_title3 = def_no_title .. &quot;[ \t]*\n?[ \t]+[\&quot;&apos;(]([^\n]+)[\&quot;&apos;)][ \t]*&quot;

	text = text:gsub(def_title1, link_def)
	text = text:gsub(def_title2, link_def)
	text = text:gsub(def_title3, link_def)
	text = text:gsub(def_no_title, link_def)
	return text, linkdb
end

local link_database = {}

function block_transform_nohtml(text, sublist)
	local lines = split(text)
	lines = map(lines, classify)
	lines = headers(lines)
	--lines = lists(lines, sublist)
	--lines = codeblocks(lines)
	--lines = blockquotes(lines)
	--lines = blocks_to_html(lines)
	--local text = table.concat(lines, &quot;\n&quot;)
	return lines
end

	-- Main markdown processing function
local function MarkdownToHtml(text)
	init_hash(text)
	init_escape_table()

	text = cleanup(text)
	text = protect(text)
	text, link_database = strip_link_definitions(text)
	text = block_transform(text)
	text = unescape_special_chars(text)
	return text
end
Markdown.MarkdownToHtml = MarkdownToHtml

local function MarkdownToTable(text)
	init_hash(text)
	init_escape_table()

	text = cleanup(text)
	text = protect(text)
	text, link_database = strip_link_definitions(text)
	text = block_transform_nohtml(text)
	return text
end
Markdown.MarkdownToTable = MarkdownToTable

NevermoreEngine.RegisterLibrary(&apos;MarkdownSystem&apos;, Markdown)</ProtectedString>
<bool name="Disabled">true</bool>
</Properties>
</Item>
</Item>
<Item class="ModuleScript" referent="RBX45">
<Properties>
<string name="Name">qGUI</string>
<ProtectedString name="Source">local Players            = game:GetService(&quot;Players&quot;)
local StarterPack        = game:GetService(&quot;StarterPack&quot;)
local StarterGui         = game:GetService(&quot;StarterGui&quot;)
local Lighting           = game:GetService(&quot;Lighting&quot;)
local Debris             = game:GetService(&quot;Debris&quot;)
local Teams              = game:GetService(&quot;Teams&quot;)
local BadgeService       = game:GetService(&quot;BadgeService&quot;)
local InsertService      = game:GetService(&quot;InsertService&quot;)
local HttpService        = game:GetService(&quot;HttpService&quot;)
local ReplicatedStorage  = game:GetService(&quot;ReplicatedStorage&quot;)
local RunService         = game:GetService(&quot;RunService&quot;)
local MarketplaceService = game:GetService(&quot;MarketplaceService&quot;)
local UserInputService   = game:GetService(&apos;UserInputService&apos;)
local Terrain            = Workspace.Terrain

local NevermoreEngine    = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary  = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&apos;qSystems&apos;)
local qMath             = LoadCustomLibrary(&apos;qMath&apos;)
local qCFrame           = LoadCustomLibrary(&apos;qCFrame&apos;)
local Table             = LoadCustomLibrary(&apos;Table&apos;)
local qColor3           = LoadCustomLibrary(&apos;qColor3&apos;)

qSystems:import(getfenv(0));

local lib = {}
local doc = {}

local DEFAULTS = {}

local WEAK_MODE = {
	K = {__mode=&quot;k&quot;};
	V = {__mode=&quot;v&quot;};
	KV = {__mode=&quot;kv&quot;};
}

local COLORS = {
	

}


--[[
GetScreen ( Instance `object` )
	returns ScreenGui `screen`

Gets the nearest ascending ScreenGui of `object`.
Returns `object` if it is a ScreenGui.
Returns nil if `object` isn&apos;t the descendant of a ScreenGui.

Arguments:
	`object`
		The instance to get the ascending ScreenGui from.

Returns:
	`screen`
		The ascending screen.
		Will be nil if `object` isn&apos;t the descendant of a ScreenGui.
--]]

local function GetScreen(object)
	-- Given a GUI object, returns it&apos;s screenGui. 

	local screen = object
	while not screen:IsA(&quot;ScreenGui&quot;) do
		screen = screen.Parent
		if screen == nil then return nil end
	end
	return screen
end
lib.GetScreen = GetScreen
lib.getScreen = GetScreen
lib.get_screen = GetScreens

local function NewColor3(red, green, blue)
	-- Given a red, green, and blue, it&apos;ll return a formatted Color3 object. 
	return Color3.new(red/255, green/255, blue/255)
end
lib.NewColor3 = NewColor3
lib.newColor3 = NewColor3
lib.new_color3 = NewColor3

lib.MakeColor3 = NewColor3
lib.makeColor3 = NewColor3

local function GetCenteringPosition(Object)
	-- Return&apos;s the center of
	return UDim2.new(0.5, -Object.AbsoluteSize.X/2, 0.5, -Object.AbsoluteSize.Y/2)
end
lib.GetCenteringPosition = GetCenteringPosition
lib.getCenteringPosition = GetCenteringPosition
lib.get_centering_position = GetCenteringPosition

local function GetHalfSize(Object)
	-- Return&apos;s half the size of an object. 

	local ObjectSize = Object.Size
	return UDim2.new(ObjectSize.X.Scale / 2, ObjectSize.X.Offset /2, ObjectSize.Y.Scale / 2, ObjectSize.Y.Offset / 2)
end
lib.GetHalfSize = GetHalfSize
lib.getHalfSize = GetHalfSize
lib.get_half_size = GetHalfSize

local function Center(Object)
	-- Centers an object (Sized with offset) into the middle of the screen.

	Object.Position = GetCenteringPosition(Object)
end
lib.Center = Center
lib.center = center

local function MouseOver(Mouse, Frame)
	local TopBound 		= Frame.AbsolutePosition.Y
	local BottomBound 	= Frame.AbsolutePosition.Y + Frame.AbsoluteSize.Y
	local LeftBound		= Frame.AbsolutePosition.X
	local RightBound		= Frame.AbsolutePosition.X + Frame.AbsoluteSize.X
	if Mouse.Y &gt; TopBound and Mouse.Y &lt; BottomBound and Mouse.X &gt; LeftBound and Mouse.X &lt; RightBound then
		return true
	else
		return false
	end
end
lib.MouseOver = MouseOver
lib.mouseOver = MouseOver
lib.mouse_over = MouseOver

local function SubtractColor3(a, b)
	local R = a.r + b.r
	local G = a.g + b.g
	local B = a.b + b.b
	return Color3.new(R, G, B)
end
lib.SubtractColor3 = SubtractColor3
lib.subtractColor3 = SubtractColor3
lib.subtract_color3 = SubtractColor3

local function MultiplyColor3(Num, Color)
	-- Multiplies a Color3 by Num

	local R = Color.r * Num
	local G = Color.g * Num
	local B = Color.b * Num
	return Color3.new(R, G, B)
end
lib.MultiplyColor3 = MultiplyColor3
lib.multiplyColor3 = MultiplyColor3
lib.multiply_color3 = MultiplyColor3

local function InverseColor3(Color)
	-- Inverses a Color3...

	return Color3.new(1 - Color.r, 1 - Color.g, 1 - Color.b)
end
lib.InverseColor3 = InverseColor3
lib.inverseColor3 = InverseColor3
lib.inverse_color3 = InverseColor3

local function IsPhone(ScreenGui)
	-- Return&apos;s if ROBLOX is being played on a phone or not.

	if ScreenGui.AbsoluteSize.Y &lt; 600 and UserInputService.TouchEnabled then 
		return true
	end 
	return false 
end
lib.isPhone = IsPhone
lib.IsPhone = IsPhone
lib.is_phone = IsPhone

local function TouchOnly()
	-- Return&apos;s if it&apos;s TouchOnly

	return not UserInputService.MouseEnabled 
end
lib.TouchOnly = TouchOnly
lib.touchOnly = TouchOnly
lib.touch_only = TouchOnly

local function UDim2OffsetFromVector2(Vector2ConvertFrom)
	-- Return&apos;s a UDim2 generated from the Vector2ConvertFrom

	return UDim2.new(0, Vector2ConvertFrom.X, 0, Vector2ConvertFrom.Y)
end
lib.UDim2OffsetFromVector2 = UDim2OffsetFromVector2
lib.uDim2OffsetFromVector2 = UDim2OffsetFromVector2
lib.udim2_offset_from_vector2 = UDim2OffsetFromVector2

local function WorldToScreen(Position, Mouse, Camera)
	-- Translates a position in ROBLOX space to ScreenSpace.  
	-- Math credit to xXxMoNkEyMaNxXx
	-- Returns if it&apos;s on the screen, then the ScreenPosition, and then the angle at which the object is (if it&apos;s off the screen?) Not sure entirely.
	
	local RealPosition = qCFrame.PointToObjectSpace(Camera.CoordinateFrame, Position)
	local Angle = math.atan2(RealPosition.x, -RealPosition.y) -- Rotate 90 degrees ccw so that angles start at &quot;straight down&quot;
	local Theta
	local ViewSize = Vector2.new(Mouse.ViewSizeX, Mouse.ViewSizeY) / 2
	if RealPosition.Z &lt; 0 then -- Object is in front
		local ATY = math.tan(Camera.FieldOfView * math.pi / 360)
		local AT1 = Vector2.new(ATY * ViewSize.X / ViewSize.Y, ATY)
		local UPOS = Vector2.new(-RealPosition.x, RealPosition.y) / RealPosition.z
		local SPOS = ViewSize + ViewSize * UPOS / AT1
		if SPOS.x &gt;= 0 and SPOS.x &lt;= Mouse.ViewSizeX and SPOS.Y &gt;= 0 and SPOS.Y &lt;= Mouse.ViewSizeY then
			return true, SPOS, Angle
		else
			Theta = true
		end
	else
		Theta = true
	end
	if Theta then
		return false, 
		ViewSize + Vector2.new(qMath.Sign(RealPosition.x) * math.abs(math.max(-ViewSize.x, math.min(ViewSize.x, ViewSize.y * RealPosition.x/RealPosition.y))), -qMath.Sign(RealPosition.y) * math.abs(math.max(-ViewSize.y,math.min(ViewSize.y,ViewSize.x * RealPosition.y/RealPosition.x)))),
		Angle
	end
end
lib.WorldToScreen = WorldToScreen
lib.worldToScreen = WorldToScreen
lib.world_to_screen = WorldToScreen

local function MultiplyUDim2Offset(Original, Factor)
	return UDim2.new(Original.X.Scale, Original.X.Offset * Factor, Original.Y.Scale, Original.Y.OFfset * Factor)
end
lib.MultiplyUDim2Offset = MultiplyUDim2Offset
lib.multiplyUDim2Offset = MultiplyUDim2Offset

local function PickRandomColor3(List)
	return List[math.random(1, #List)]
end
lib.PickRandomColor3 = PickRandomColor3
lib.pickRandomColor3 = PickRandomColor3

local FrameImageIds = {}
local FrameOperationIds = {}
local FrameTweenOperatingStatus = {}

setmetatable(FrameImageIds, WEAK_MODE.K)
setmetatable(FrameOperationIds, WEAK_MODE.K)
setmetatable(FrameTweenOperatingStatus, WEAK_MODE.K)

local function SetImageId(Frame, ImageId, TotalVisibleCount)
	FrameImageIds[Frame] = {
		TotalVisibleCount = TotalVisibleCount; -- How many frames are required to make it &quot;Entirely&quot; visible.
		ImageId = ImageId;
		ActiveImages = {};
	};
	return FrameImageIds[Frame]
end
lib.SetImageId = SetImageId
lib.setImageId = SetImageId

local function TweenImages(Gui, Time, Target, Override)
	-- So we can layer image labels and make it look nice. 
	-- Target is a number between 0 and the FrameId.TotalVisibleCount...
	-- If target is a boolean then it&apos;ll be set to the TotalVisibleCount if it&apos;s true, or 0 if it&apos;s false.
	if not FrameImageIds[Gui] then
		error(&quot;[qGUI] - FrameImageIds[&quot; .. tostring(Gui) .. &quot;] has not been set, can not tween&quot;)
	end

	if type(Target) == &quot;boolean&quot; then
		if Target then
			Target = FrameImageIds[Gui].TotalVisibleCount 
		else
			Target = 0
		end
	else
		Target = qMath.ClampNumber(Target, 0, FrameImageIds[Gui].TotalVisibleCount)
	end

	local CanExecute = false
	FrameOperationIds[Gui] = FrameOperationIds[Gui] or 0

	if FrameTweenOperatingStatus[Gui] and Override then
		FrameOperationIds[Gui] = FrameOperationIds[Gui] + 1
	elseif FrameTweenOperatingStatus[Gui] then
		return false
	end

	local LocalTweenId = FrameOperationIds[Gui]
	FrameTweenOperatingStatus[Gui] = true

	Spawn(function()
		local FrameId = FrameImageIds[Gui]
		local StartTime = time()
		local CurrentTime = time()
		local StartCount = #FrameId.ActiveImages

		local function PropogangateFrames(Percent)
			local CurrentTarget = qMath.ClampNumber(qMath.RoundNumber(StartCount + (Target - StartCount) * Percent, 1), 0, FrameImageIds[Gui].TotalVisibleCount)
			for Index=1, math.max(CurrentTarget, #FrameId.ActiveImages) do
				if Index &lt;= CurrentTarget then
					if not FrameId.ActiveImages[Index] then
						FrameId.ActiveImages[Index] = Make &apos;ImageLabel&apos; {
							Name = &quot;TweenId&quot;..Index;
							Parent = Gui;
							BorderSizePixel = 0;
							BackgroundTransparency = 1;
							Archivable = false;
							Image = FrameId.ImageId;
							Size = UDim2.new(1, 0, 1, 0);
						};
					end
				else
					if FrameId.ActiveImages[Index] then -- Remove it, it&apos;s too high!
						FrameId.ActiveImages[Index]:Destroy()
						FrameId.ActiveImages[Index] = nil
					end
				end
			end
		end

		while LocalTweenId == FrameOperationIds[Gui] and StartTime + Time &gt;= CurrentTime do
			local Percent = (CurrentTime - StartTime) / Time
			local SmoothedPercent = math.sin((Percent - 0.5) * math.pi)/2 + 0.5
			PropogangateFrames(SmoothedPercent)
			wait(0.05)
			CurrentTime = time()
		end

		if FrameOperationIds[Gui] ~= LocalTweenId then 
			return false
		end 


		FrameTweenOperatingStatus[Gui] = false
		PropogangateFrames(1)
	end)
end
lib.TweenImages = TweenImages
lib.tweenImages = TweenImages

local TransparencyTweenIds = {}
local TransparencyTweenOperatingStatus = {} -- Boolean, holds if a GUI is being tweened or not...

setmetatable(TransparencyTweenIds, WEAK_MODE.K) -- So we don&apos;t prevent collection using this cache. :/
setmetatable(TransparencyTweenOperatingStatus, WEAK_MODE.K)

local function TweenTransparency(Gui, NewProperties, Time, Override)
	-- Override tween system to tween the transparency of properties. Unfortunately, overriding is per a GUI as of now. 
	--- Tween&apos;s the Transparency values in a GUI,
	-- @param Gui The GUI to tween the Transparency&apos;s upon
	-- @param NewProperties The properties to be changed. It will take the current
	--                      properties and tween to the new ones. This table should be
	--                      setup so {Index = NewValue} that is, for example, 
	--                      {TextTransparency = 1}.
	-- @param Time The amount of time to spend transitioning.
	-- @param [Override] If true, it will override a previous animation, otherwise, it will not.

	local CanExecute = false;
	TransparencyTweenIds[Gui] = TransparencyTweenIds[Gui] or 0

	if TransparencyTweenOperatingStatus[Gui] and Override then
		TransparencyTweenIds[Gui] = TransparencyTweenIds[Gui] + 1
	elseif TransparencyTweenOperatingStatus[Gui] then
		return false
	end

	local LocalTweenId = TransparencyTweenIds[Gui]
	TransparencyTweenOperatingStatus[Gui] = true

	Spawn(function()
		local StartProperties = {}
		local StartTime = time()
		local CurrentTime = time()
		for Index, _ in pairs(NewProperties) do
			StartProperties[Index] = Gui[Index]
		end

		local function SetProperties(Percent)
			for Index, EndValue in pairs(NewProperties) do
				local StartProperty = StartProperties[Index]
				Gui[Index] = StartProperty + ((EndValue - StartProperty) * Percent)
			end
		end

		while LocalTweenId == TransparencyTweenIds[Gui] and StartTime + Time &gt;= CurrentTime do
			local Percent = (CurrentTime - StartTime) / Time
			local SmoothedPercent = math.sin((Percent - 0.5) * math.pi)/2 + 0.5
			SetProperties(SmoothedPercent)
			wait(0.05)
			CurrentTime = time()
		end

		if TransparencyTweenIds[Gui] ~= LocalTweenId then 
			return false
		end 

		TransparencyTweenOperatingStatus[Gui] = false
		SetProperties(1)
	end)
end
lib.TweenTransparency = TweenTransparency
lib.tweenTransparency = TweenTransparency

local function StopTransparencyTween(Gui)
	-- Overrides all the current transparency animations in a GUI. Perhaps useful.

	if TransparencyTweenOperatingStatus[Gui] and TransparencyTweenIds[Gui] then
		TransparencyTweenIds[Gui] = TransparencyTweenIds[Gui] + 1
	end
end
lib.StopTransparencyTween = StopTransparencyTween
lib.stopTransparencyTween = StopTransparencyTween



local Color3TweenIds = {}
local Color3TweenOperatingStatus = {} -- Boolean, holds if a GUI is being tweened or not...

setmetatable(Color3TweenIds, WEAK_MODE.K) -- So we don&apos;t prevent collection using this cache. :/
setmetatable(Color3TweenOperatingStatus, WEAK_MODE.K)

local function TweenColor3(Gui, NewProperties, Time, Override)
	--- Tween&apos;s the Color3 values in a GUI,
	-- @param Gui The GUI to tween the Color3&apos;s upon
	-- @param NewProperties The properties to be changed. It will take the current
	--                      properties and tween to the new ones. This table should be
	--                      setup so {Index = NewValue} that is, for example, 
	--                      {BackgroundColor3 = Color3.new(1, 1, 1)}.
	-- @param Time The amount of time to spend transitioning.
	-- @param [Override] If true, it will override a previous animation, otherwise, it will not.

	local CanExecute = false;
	Color3TweenIds[Gui] = Color3TweenIds[Gui] or 0

	if Color3TweenOperatingStatus[Gui] and Override then
		Color3TweenIds[Gui] = Color3TweenIds[Gui] + 1
	elseif Color3TweenOperatingStatus[Gui] then
		return false
	end

	local LocalTweenId = Color3TweenIds[Gui]
	Color3TweenOperatingStatus[Gui] = true

	Spawn(function()
		local StartProperties = {}
		local StartTime = time()
		local CurrentTime = time()
		for Index, _ in pairs(NewProperties) do
			StartProperties[Index] = Gui[Index]
		end

		local function SetProperties(Percent)
			for Index, EndValue in pairs(NewProperties) do
				local StartProperty = StartProperties[Index]
				Gui[Index] = qColor3.LerpColor3(StartProperty, EndValue, Percent)
			end
		end

		while LocalTweenId == Color3TweenIds[Gui] and StartTime + Time &gt;= CurrentTime do
			local Percent = (CurrentTime - StartTime) / Time
			local SmoothedPercent = math.sin((Percent - 0.5) * math.pi)/2 + 0.5
			SetProperties(SmoothedPercent)
			wait(0.05)
			CurrentTime = time()
		end

		if Color3TweenIds[Gui] ~= LocalTweenId then 
			return false
		end 

		Color3TweenOperatingStatus[Gui] = false
		SetProperties(1)
	end)
end
lib.TweenColor3 = TweenColor3
lib.tweenColor3 = TweenColor3

local function StopColor3Tween(Gui)
	-- Overrides all the current animations of Color3 in the GUI. 

	if Color3TweenOperatingStatus[Gui] and Color3TweenIds[Gui] then
		Color3TweenIds[Gui] = Color3TweenIds[Gui] + 1
	end
end
lib.StopColor3Tween = StopColor3Tween
lib.stopColor3Tween = StopColor3Tween

local function GenerateMouseDrag()
	-- Generate&apos;s a dragger to catch the mouse...
	return Make &apos;ImageButton&apos;{
		Active = false;
		Size = UDim2.new(1.5, 0, 1.5, 0);
		AutoButtonColor = false;
		BackgroundTransparency = 1;
		Name = &quot;MouseDrag&quot;;
		Position = UDim2.new(-0.25, 0, -0.25, 0);
		ZIndex = 10;
	}
end
lib.GenerateMouseDrag = GenerateMouseDrag
lib.generateMouseDrag = GenerateMouseDrag

local function AddTexturedWindowTemplate(Frame, Radius, Type)
	-- Makes a &apos;Textured&apos; window... 

	Type = Type or &apos;Frame&apos;;

	local TopLeft = Make(Type)({
		Archivable             = false;
		BackgroundColor3       = Frame.BackgroundColor3;
		BorderSizePixel        = 0;
		Name                   = &quot;TopLeft&quot;;
		Parent                 = Frame;
		Position               = UDim2.new(0, 0, 0, 0);
		Size                   = UDim2.new(0, Radius, 0, Radius);
		BackgroundTransparency = 1;
		ZIndex                 = Frame.ZIndex;
	});

	local TopRight = Make(Type)({
		Archivable             = false;
		BackgroundColor3       = Frame.BackgroundColor3;
		BorderSizePixel        = 0;
		Name                   = &quot;TopRight&quot;;
		Parent                 = Frame;
		Position               = UDim2.new(0, 0, 1, -Radius);
		Size                   = UDim2.new(0, Radius, 0, Radius);
		BackgroundTransparency = 1;
		ZIndex                 = Frame.ZIndex;
	});

	local BottomLeft = Make(Type)({
		Archivable             = false;
		BackgroundColor3       = Frame.BackgroundColor3;
		BorderSizePixel        = 0;
		Name                   = &quot;BottomLeft&quot;;
		Parent                 = Frame;
		Position               = UDim2.new(1, -Radius, 0, 0);
		Size                   = UDim2.new(0, Radius, 0, Radius);
		BackgroundTransparency = 1;
		ZIndex                 = Frame.ZIndex;
	});

	local BottomRight = Make(Type)({
		Archivable             = false;
		BackgroundColor3       = Frame.BackgroundColor3;
		BorderSizePixel        = 0;
		Name                   = &quot;BottomRight&quot;;
		Parent                 = Frame;
		Position               = UDim2.new(1, -Radius, 1, -Radius);
		Size                   = UDim2.new(0, Radius, 0, Radius);
		BackgroundTransparency = 1;
		ZIndex                 = Frame.ZIndex;
	});

	local Middle = Make(Type)({
		Archivable             = false;
		BackgroundColor3       = Frame.BackgroundColor3;
		BorderSizePixel        = 0;
		Name                   = &quot;Middle&quot;;
		Parent                 = Frame;
		Position               = UDim2.new(0, Radius, 0, 0);
		Size                   = UDim2.new(1, -Radius*2, 1, 0);
		BackgroundTransparency = 1;
		ZIndex                 = Frame.ZIndex;
	});

	local MiddleLeft = Make(Type)({
		Archivable             = false;
		BackgroundColor3       = Frame.BackgroundColor3;
		BorderSizePixel        = 0;
		Name                   = &quot;MiddleLeft&quot;;
		Parent                 = Frame;
		Position               = UDim2.new(0, 0, 0, Radius);
		Size                   = UDim2.new(0, Radius, 1, -Radius*2);
		BackgroundTransparency = 1;
		ZIndex                 = Frame.ZIndex;
	});

	local MiddleRight = Make(Type)({
		Archivable             = false;
		BackgroundColor3       = Frame.BackgroundColor3;
		BorderSizePixel        = 0;
		Name                   = &quot;MiddleRight&quot;;
		Parent                 = Frame;
		Position               = UDim2.new(1, -Radius, 0, Radius);
		Size                   = UDim2.new(0, Radius, 1, -Radius*2);
		BackgroundTransparency = 1;
		ZIndex                 = Frame.ZIndex;
	});

	return TopLeft, TopRight, BottomLeft, BottomRight, Middle, MiddleLeft, MiddleRight
end
lib.AddTexturedWindowTemplate = AddTexturedWindowTemplate
lib.addTexturedWindowTemplate = AddTexturedWindowTemplate

local function AddNinePatch(Frame, Image, ImageSize, Radius, Type)
	--- Makes a NinePatch in the frame, with the image. 
	-- @param Frame The frame to texturize
	-- @param Radius the radius you want the image to be at
	-- @param Type The type (Class) that the frame should be, either an ImageLabel or an ImageButton
	-- @param Image The URL of the image in question
	-- @param ImageSize The size of the image overall, suggested to be 99/divisible by 3. Vector2 value.

	Properties = Properties or {}
	Type = Type or &quot;ImageLabel&quot;;
	local TopLeft, TopRight, BottomLeft, BottomRight, Middle, MiddleLeft, MiddleRight = AddTexturedWindowTemplate(Frame, Radius, Type)

	Middle.Size = UDim2.new(1, -Radius*2, 1, -Radius*2); -- Fix middle...
	Middle.Position = UDim2.new(0, Radius, 0, Radius);

	local MiddleTop = Make(Type)({
		Archivable             = false;
		BackgroundColor3       = Frame.BackgroundColor3;
		BorderSizePixel        = 0;
		Name                   = &quot;MiddleTop&quot;;
		Parent                 = Frame;
		Position               = UDim2.new(0, Radius, 0, 0);
		Size                   = UDim2.new(1, -Radius*2, 0, Radius);
		BackgroundTransparency = 1;
		ZIndex                 = Frame.ZIndex;
	});

	local MiddleBottom = Make(Type)({
		Archivable             = false;
		BackgroundColor3       = Frame.BackgroundColor3;
		BorderSizePixel        = 0;
		Name                   = &quot;MiddleBottom&quot;;
		Parent                 = Frame;
		Position               = UDim2.new(0, Radius, 1, -Radius);
		Size                   = UDim2.new(1, -Radius*2, 0, Radius);
		BackgroundTransparency = 1;
		ZIndex                 = Frame.ZIndex;
	});

	for _, Item in pairs({TopLeft, TopRight, BottomLeft, BottomRight, Middle, MiddleLeft, MiddleRight, MiddleTop, MiddleBottom}) do
		Modify(Item, Properties)
		Item.Image = Image;
		Item.ImageRectSize = Vector2.new(ImageSize.X/3, ImageSize.Y/3)
	end

	TopRight.ImageRectOffset     = Vector2.new(ImageSize.X * (2/3), 0)
	MiddleRight.ImageRectOffset  = Vector2.new(ImageSize.X * (2/3), ImageSize.Y/3)
	BottomRight.ImageRectOffset  = Vector2.new(ImageSize.X * (2/3), ImageSize.Y * (2/3))
	
	--TopLeft.ImageRectOffset    = Vector2.new(0, 0);
	MiddleLeft.ImageRectOffset   = Vector2.new(0, ImageSize.Y/3)
	BottomLeft.ImageRectOffset   = Vector2.new(0, ImageSize.Y * (2/3))
	
	Middle.ImageRectOffset       = Vector2.new(ImageSize.X/3, ImageSize.Y/3)
	MiddleTop.ImageRectOffset    = Vector2.new(0, ImageSize.Y/3)
	MiddleBottom.ImageRectOffset = Vector2.new(ImageSize.Y * (2/3), ImageSize.Y/3)

	return TopLeft, TopRight, BottomLeft, BottomRight, Middle, MiddleLeft, MiddleRight, MiddleTop, MiddleBottom
end
lib.AddNinePatch = AddNinePatch
lib.addNinePatch = AddNinePatch

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX46">
<Properties>
<string name="Name">ScreenCover</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local EnumInterpreter   = LoadCustomLibrary(&quot;EnumInterpreter&quot;)
local qMath             = LoadCustomLibrary(&quot;qMath&quot;);

local lib    = {}

-- ScreenCover.lua
-- @author Quenty
-- Last Modified February 3rd, 2014

qSystems:import(getfenv(0));

lib.STYLES = {}
lib.TYPES = {
	&quot;Show&quot;;
	&quot;Hide&quot;;
}

local function MakeCover(Properties)
	-- Generates a cover frame that is basically standard. :D

	Properties = Properties or {}

	return Modify((Make &apos;Frame&apos; {
			--Parent = ScreenGui;
			Size = UDim2.new(1, 0, 1, 2);
			Position = UDim2.new(0, 0, 0, -2); -- Fix ROBLOX&apos;s glitches...
			BackgroundColor3 = Color3.new(0, 0, 0);
			BackgroundTransparency = 1;
			Visible = false;
			Name = &quot;ScreenCover&quot;;
			ZIndex = 10;
			BorderSizePixel = 0;
		}), Properties)
end

lib.MakeCover = MakeCover
lib.makeCover = MakeCover

local StyleFunctions = {
	Fade = {
		Show = function(Time, BaseCover) -- Basically, it&apos;ll hand the function a &quot;BaseCover&quot;, which presumadly covers the whole screen.  It&apos;ll also hand it a
		-- time to animate. From there on, it&apos;s expected that the function will execute in the time given, and end up with the BaseCover covering the whole screen...
		-- with no extra objects in it. :)

		-- Since this is &apos;Show&apos;, it&apos;ll start at 0, and go to 1 transparency...

			local StartTime = time();
			local FinishTime = Time + StartTime
			while FinishTime &gt; time() do
				BaseCover.BackgroundTransparency =  (time() - StartTime) / Time
				wait(0.03);
			end
			BaseCover.BackgroundTransparency = 1;
			return true;
		end;
		Hide = function(Time, BaseCover)
			local StartTime = time();
			local FinishTime = Time + StartTime
			while FinishTime &gt; time() do
				BaseCover.BackgroundTransparency =  1 - ((time() - StartTime) / Time)
				wait(0.03);
			end
			BaseCover.BackgroundTransparency = 0;
			return true;
		end;
	};
	SlideDown = {
		-- Optimal with fast animation times.

		Hide = function(Time, BaseCover, AnimationStyles)
			local NewCover = BaseCover:Clone()
			NewCover.Parent = BaseCover
			NewCover.Size = UDim2.new(1, 0, 1, 0)
			NewCover.Position = UDim2.new(0, 0, -1, 0)
			NewCover.BackgroundTransparency = 0;
			NewCover:TweenPosition(UDim2.new(0, 0, 0, 0), &quot;In&quot;, AnimationStyles.EasingStyle or (&quot;Sine&quot;), Time, true)
			BaseCover.BackgroundTransparency = 1
			wait(Time)
			NewCover:Destroy()
			BaseCover.BackgroundTransparency = 0
			return true;
		end;
		Show = function(Time, BaseCover, AnimationStyles)
			local NewCover = BaseCover:Clone()
			NewCover.Parent = BaseCover
			NewCover.Size = UDim2.new(1, 0, 1, 0)
			NewCover.Position = UDim2.new(0, 0, 0, 0)
			NewCover:TweenPosition(UDim2.new(0, 0, 1, 0), &quot;Out&quot;, AnimationStyles.EasingStyle or (&quot;Sine&quot;), Time, true)
			BaseCover.BackgroundTransparency = 1
			wait(Time)
			NewCover:Destroy()
			return true;
		end;
	};
	SlideUp = {
		-- Optimal with fast animation times.

		Hide = function(Time, BaseCover, AnimationStyles)
			local NewCover = BaseCover:Clone()
			NewCover.Parent = BaseCover
			NewCover.Size = UDim2.new(1, 0, 1, 0)
			NewCover.Position = UDim2.new(0, 0, 1, 0)
			NewCover.BackgroundTransparency = 0;
			NewCover:TweenPosition(UDim2.new(0, 0, 0, 0), &quot;In&quot;, AnimationStyles.EasingStyle or (&quot;Sine&quot;), Time, true)
			BaseCover.BackgroundTransparency = 1
			wait(Time)
			NewCover:Destroy()
			BaseCover.BackgroundTransparency = 0
			return true;
		end;
		Show = function(Time, BaseCover, AnimationStyles)
			local NewCover = BaseCover:Clone()
			NewCover.Parent = BaseCover
			NewCover.Size = UDim2.new(1, 0, 1, 0)
			NewCover.Position = UDim2.new(0, 0, 0, 0)
			NewCover:TweenPosition(UDim2.new(0, 0, -1, 0), &quot;Out&quot;, AnimationStyles.EasingStyle or (&quot;Sine&quot;), Time, true)
			BaseCover.BackgroundTransparency = 1
			wait(Time)
			NewCover:Destroy()
			return true;
		end;
	};
	Squares = {
		Hide = function(Time, BaseCover, AnimationStyles)
			-- SquareSize must be divisible by 2. 
			-- If the squareSize is too small, you can get wait() lag (I think).

			SquareSize                       = qMath.roundUp(AnimationStyles.SquareSize or 76, 2);
			local NewCover                   = BaseCover:Clone()
			NewCover.Name                    = &quot;Square&quot;
			NewCover.Size                    = UDim2.new(0, 0, 0, 0);
			NewCover.BackgroundTransparency  = 0;
			BaseCover.BackgroundTransparency = 1;
			
			
			local MaxSize                    = qMath.roundUp(math.max(BaseCover.AbsoluteSize.X, BaseCover.AbsoluteSize.Y) * 1.6, SquareSize) + SquareSize
			local Squares                    = {}
			local ValX                       = 0;
			local ValY                       = 0;
			local WaitEach                   = (Time/2)/(MaxSize/SquareSize)

			while ValY &lt;= MaxSize do
				ValX = 0;
				while ValX &lt;= ValY do
					local Square = NewCover:Clone()
					Square.Archivable = false;
					Square.Position = UDim2.new(0, ValX + (SquareSize/2), 0, ValY - (ValX) + (SquareSize/2));
					Square.Parent = BaseCover;
					local NewPosition = Square.Position - UDim2.new(0, SquareSize/2, 0, SquareSize/2)
					table.insert(Squares, Square)

					delay(WaitEach * (ValY/SquareSize), function() 
						Square:TweenSizeAndPosition(UDim2.new(0, SquareSize, 0, SquareSize), NewPosition, &quot;Out&quot;, &quot;Sine&quot;, Time/2, true)
					end)
					ValX = ValX + SquareSize
				end
				ValY = ValY + SquareSize
			end
			wait(Time)

			BaseCover.BackgroundTransparency = 0;
			for _, Square in pairs(Squares) do
				Square:Destroy();
			end
			return true;
		end;
		Show = function(Time, BaseCover, AnimationStyles)
			SquareSize                      = qMath.roundUp(AnimationStyles.SquareSize or 76, 2);
			
			local NewCover                  = BaseCover:Clone()
			NewCover.Name                   = &quot;Square&quot;
			NewCover.Size                   = UDim2.new(0, SquareSize, 0, SquareSize);
			
			local MaxSize                   = qMath.roundUp(math.max(BaseCover.AbsoluteSize.X, BaseCover.AbsoluteSize.Y) * 1.6, SquareSize) + SquareSize
			local Squares                   = {}
			local ValX                      = 0;
			local ValY                      = MaxSize;
			local WaitEach                  = (Time/2)/(MaxSize/SquareSize)

			while ValY &gt;= 0 do
				ValX = 0;
				while ValX &lt;= ValY do
					local Square = NewCover:Clone()
					Square.Archivable = false;
					Square.Parent = BaseCover;
					Square.Position = UDim2.new(0, ValX, 0, ValY - ValX);
					local NewPosition = Square.Position + UDim2.new(0, (SquareSize/2), 0, (SquareSize/2));
					table.insert(Squares, Square)

					delay(WaitEach * (ValY/SquareSize), function() 
						Square:TweenSizeAndPosition(UDim2.new(0, 0, 0, 0), NewPosition, &quot;Out&quot;, &quot;Sine&quot;, Time/2, true)
					end)
					ValX = ValX + SquareSize
				end
				ValY = ValY - SquareSize
			end

			BaseCover.BackgroundTransparency = 1;
			wait(Time)
			for _, Square in pairs(Squares) do
				Square:Destroy();
			end
			return true;
		end;
	};
}

for StyleName, StyleData in pairs(StyleFunctions) do
	lib.STYLES[#lib.STYLES+1] = StyleName;
	StyleData.EnumID = #lib.STYLES
end

--[[
StyleFunctions.Squares.Hide()

--]]

--[[

AnimationStyles = {
	AnimationStyle = STYLES;
	Type = TYPES;
	AnimationTime = NUMBER;
}
--]]

local function MakeScreenCover(BaseCover, AnimationStyles)
	local AnimationTime = AnimationStyles.AnimationTime or 1;
	local AnimationStyle = EnumInterpreter.GetEnumName(lib.STYLES, (AnimationStyles.AnimationStyle or &quot;Fade&quot;)) -- Guarantee exact results (Lowercase, uppercase, etc. )
	local Type = EnumInterpreter.GetEnumName(lib.TYPES, (AnimationStyles.Type or &quot;Show&quot;))

	--print(&quot;[ScreenCover] - running animation: Type: &quot;..Type..&quot;; Style: &quot;..AnimationStyle..&quot;; Time: &quot;..AnimationTime)

	BaseCover.Visible = true;
	BaseCover.Transparency = (Type == &quot;Show&quot; and 0 or 1);

	--local timeStart = tick();

	StyleFunctions[AnimationStyle][Type](AnimationTime, BaseCover, AnimationStyles)

	--print(&quot;[ScreenCover] - Time elapsed: &quot;..tick() - timeStart);
	return BaseCover;
end

lib.MakeScreenCover = MakeScreenCover
lib.makeScreenCover = MakeScreenCover

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX47">
<Properties>
<string name="Name">ScrollBar</string>
<ProtectedString name="Source">local Players           = game:GetService(&quot;Players&quot;)
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local RunService        = game:GetService(&quot;RunService&quot;)
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&apos;qSystems&apos;)
local qCamera           = LoadCustomLibrary(&apos;qCamera&apos;)
local qGUI              = LoadCustomLibrary(&apos;qGUI&apos;)
qSystems:import(getfenv(0));

-- ScrollBar library
-- Change Log --
--[[
January 23rd, 2014
- Updated to new class system

Janurary 8th, 2014
- Fixed velocity when scrolling, as events didn&apos;t call unless a change occured. 
- Connected it to RunService.Stepped


--]]

local lib = {}
local ScrollBackings = {}
	ScrollBackings.Default = {}
		ScrollBackings.Default.ScrollFrameBacking = {
			[&quot;Top&quot;] = &apos;http://www.roblox.com/asset/?id=94910723&apos;;
			[&quot;Middle&quot;] = &apos;http://www.roblox.com/asset/?id=94910803&apos;;
			[&quot;Bottom&quot;] = &apos;http://www.roblox.com/asset/?id=94910858&apos;;
		}
		ScrollBackings.Default.ScrollThumb = {
			[&quot;Top&quot;] = &apos;http://www.roblox.com/asset/?id=94916615&apos;;
			[&quot;Middle&quot;] = &apos;http://www.roblox.com/asset/?id=94916629&apos;;
			[&quot;Bottom&quot;] = &apos;http://www.roblox.com/asset/?id=94916645&apos;;
		}
		ScrollBackings.Default.Invisible = {
			[&quot;Top&quot;] = &apos;&apos;;
			[&quot;Middle&quot;] = &apos;&apos;;
			[&quot;Bottom&quot;] = &apos;&apos;;
		}

local function GenerateBackingImageLabel(Position, Image, Parent, ZIndex, Size, Prefix)
	-- Support function for ApplyBacking

	local ImageLabelPosition;
	local ImageLabelSize;

	if Position == &quot;Top&quot; then
		ImageLabelPosition = UDim2.new(0, 0, 0, 0);
		ImageLabelSize = UDim2.new(1, 0, 0, Size);
	elseif Position == &quot;Middle&quot; then
		ImageLabelPosition = UDim2.new(0, 0, 0, Size);
		ImageLabelSize = UDim2.new(1, 0, 1, -Size*2);
	elseif Position == &quot;Bottom&quot; then
		ImageLabelPosition = UDim2.new(0, 0, 1, -Size);
		ImageLabelSize = UDim2.new(1, 0, 0, Size);
	end

	local ImageLabel = Make &apos;ImageLabel&apos; {
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Image                  = Image;
		Name                   = Prefix..Position..&quot;ImageBacking&quot;;
		Parent                 = Parent;
		Position               = ImageLabelPosition;
		Size                   = ImageLabelSize;
		ZIndex                 = ZIndex;
	}

	return ImageLabel;
end

local function ApplyScrollbarBacking(Frame, ZIndex, Backing, Size, Prefix)
	-- Make&apos;s it pretty... 
	-- Backing = Table (See above tables)
	-- Size = size of the backing&apos;s width. 
	Prefix = Prefix or &quot;&quot;;
	ZIndex = ZIndex or Frame.ZIndex
	Frame.BackgroundTransparency = 1;

	for Position, Image in pairs(Backing) do
		if not Frame:FindFirstChild(Prefix..Position..&quot;ImageBacking&quot;) then -- Presume it&apos;s an image label...
			GenerateBackingImageLabel(Position, Image, Frame, ZIndex, Size, Prefix)
		else
			Frame[Prefix..Position..&quot;ImageBacking&quot;].Image = Image
		end
	end
end
lib.ApplyScrollbarBacking = ApplyScrollbarBacking
lib.applyScrollbarBacking = ApplyScrollbarBacking

local MakeKineticModel = Class(function(KineticModel, ContainerFrame, ContentFrame, ScreenGui)
	-- Theoretical model

	KineticModel.Duration = 0.6
	KineticModel.BounceBackDuration = 0.3;
	KineticModel.Position = 0
	KineticModel.UpdateInterval = 1 / 30

	KineticModel.Velocity = 0
	KineticModel.Minimum = 0;
	KineticModel.Maximum = 1000

	KineticModel.MaxBounce = 50;

	KineticModel.DisplayPosition = KineticModel.Position -- The position it displays at.
	KineticModel.OnPositionChange = function() end -- Callbacks. 
	KineticModel.OnScrollStart = function() end
	KineticModel.OnScrollStop = function() end

	KineticModel.LastPosition = 0
	KineticModel.TimeStamp = tick()

	KineticModel.UpdatingId = 0

	function KineticModel:Clamp(Position, IncludeBounce)
		-- Clamp&apos;s the model&apos;s position into the range.
		if not IncludeBounce then
			if Position &gt; self.Maximum then
				return self.Maximum
			elseif Position &lt; self.Minimum then
				return self.Minimum
			else
				return Position
			end
		else
			if Position &gt; self.Maximum + self.MaxBounce then
				return self.Maximum + self.MaxBounce
			elseif Position &lt; self.Minimum  - self.MaxBounce  then
				return self.Minimum - self.MaxBounce
			else
				return Position
			end
		end
	end

	function KineticModel:SetRange(Start, End)
		-- Set&apos;s the range that the model can scroll at...

		self.Minimum = Start
		self.Maximum = End
	end

	function KineticModel:GetRange(Start, End)
		-- Return&apos;s the range...

		return self.Minimum, self.Maximum
	end

	function KineticModel:SetPosition(NewPosition, DivideNewVelocityBy)
		-- Set&apos;s the position of the kinetic model. Using this, it&apos;ll calculate velocity.

		DivideNewVelocityBy = DivideNewVelocityBy or 1 -- Used by Scrollbar. 

		local CurrentTime = tick()
		local ElapsedTime = CurrentTime - self.TimeStamp

		if NewPosition &gt; self.Maximum then
			-- print(&quot;[KineticModel] - Past Max Manual @ &quot;..NewPosition)
			-- Dampen position so it can&apos;t go over. In this case, summation with Maximum/2 as the first term, 0.5 as the rate.

			local Displacement = math.abs(NewPosition - self.Maximum)
			local TimesOver = Displacement / self.MaxBounce
			local DisplayPosition = (((self.MaxBounce/2) * (1 - 0.5 ^ TimesOver)) / 0.5)
			self.Position = NewPosition

			self.DisplayPosition = DisplayPosition
			self.OnPositionChange(DisplayPosition)
		elseif NewPosition &lt; self.Minimum then
			-- print(&quot;[KineticModel] - Past Min Manual @ &quot;..NewPosition)

			local Displacement = math.abs(NewPosition - self.Minimum)
			local TimesOver = Displacement / self.MaxBounce
			local DisplayPosition = self.Minimum - (((self.MaxBounce/2) * (1 - 0.5 ^ TimesOver)) / 0.5)
			self.Position = NewPosition

			self.DisplayPosition = DisplayPosition
			self.OnPositionChange(DisplayPosition)
		else
			self.Position = NewPosition

			self.DisplayPosition = self.Position
			self.OnPositionChange(self.Position)
		end

		local LocalVelocity = (((self.Position - self.LastPosition)) / ElapsedTime) / DivideNewVelocityBy
		self.TimeStamp = CurrentTime
		self:SetVelocity((0.2 * self.Velocity) + (0.8 * LocalVelocity)) -- 20% previous velocity maintained, 80% of new velocity used.


		self.LastPosition = self.Position
		--print(&quot;[KineticModel] - Set Velocity @ &quot;..self.Velocity..&quot;; Local Velocity @ &quot;..LocalVelocity..&quot;; ElapsedTime: &quot;..ElapsedTime)
	end

	function KineticModel:SetVelocity(Velocity)
		-- Set&apos;s the velocity

		-- local TargetPosition = self.Position + Velocity
		--print(&quot;[KineticModel] - Set Velocity @ &quot;..Velocity)
		self.Velocity = Velocity

	end

	function KineticModel:ResetSpeed()
		-- Reset&apos;s the speed to 0, stops update loops. 

		--print(&quot;[KineticModel] - Reset Speed&quot;)
		self.Velocity = 0
		self.LastPosition = self.Position
		self.UpdatingId = self.UpdatingId + 1
		self.TimeStamp = tick()
	end

	function KineticModel:ScrollTo(NewPosition, DoNotAnimate)
		if not DoNotAnimate then
			self:ResetSpeed()
			self:SetVelocity(NewPosition - self.Position) -- -160 - (-180) 20 Instead, -180 - -160
			self:Release()
			-- print(&quot;[KineticModel] - Scrolling velocity ScrollTo @ &quot;..(self.Position - NewPosition)..&quot;; target @ &quot;..NewPosition)
		else
			self:ResetSpeed()
			if NewPosition &gt; self.Maximum then -- Check if we&apos;re overbounds, and scale accordingly. 
				local Displacement = math.abs(NewPosition - self.Maximum)
				local TimesOver = Displacement / self.MaxBounce
				local DisplayPosition = (((self.MaxBounce/2) * (1 - 0.5 ^ TimesOver)) / 0.5)
				self.Position = NewPosition

				self.DisplayPosition = DisplayPosition
				self.OnPositionChange(DisplayPosition)
				self:Release()
			elseif NewPosition &lt; self.Minimum then -- Check if we&apos;re overbounds, and scale accordingly. 
				local Displacement = math.abs(NewPosition - self.Minimum)
				local TimesOver = Displacement / self.MaxBounce
				local DisplayPosition = self.Minimum - (((self.MaxBounce/2) * (1 - 0.5 ^ TimesOver)) / 0.5)
				self.Position = NewPosition

				self.DisplayPosition = DisplayPosition
				self.OnPositionChange(DisplayPosition)
				self:Release()
			else
				self.Position = NewPosition

				self.DisplayPosition = NewPosition
				self.OnPositionChange(self.Position)
			end
			-- print(&quot;Update position @ &quot;..self.Position .. &quot; NewPosition @ &quot; .. NewPosition)
		end
	end

	function KineticModel:Release()
		-- Start the update...

		-- print(&quot;[KineticModel] - Release @ &quot;..self.Position..&quot;; Velocity @ &quot;..self.Velocity)
		local Amplitude = self.Velocity
		local Start = self.Position
		--local TargetPosition = self.Position + Amplitude
		--local TimeConstant = self.Duration--1 + self.Duration /  6;
		self.TimeStamp = tick()

		self.UpdatingId = self.UpdatingId + 1
		local LocalUpdateId = self.UpdatingId

		Spawn(function() -- Update loop start.
			while (LocalUpdateId == self.UpdatingId) do
				local ElapsedTime = tick() - self.TimeStamp
				local NewPosition = Start + Amplitude * ((ElapsedTime/self.Duration)^(1/3.5))

				if NewPosition &gt; self.Maximum then -- Check if we&apos;re overbounds, and scale accordingly. 
					local Displacement = math.abs(NewPosition - self.Maximum)
					local TimesOver = Displacement / self.MaxBounce
					local DisplayPosition = (((self.MaxBounce/2) * (1 - 0.5 ^ TimesOver)) / 0.5)
					self.Position = NewPosition

					self.DisplayPosition = DisplayPosition
					self.OnPositionChange(DisplayPosition)
				elseif NewPosition &lt; self.Minimum then -- Check if we&apos;re overbounds, and scale accordingly. 
					local Displacement = math.abs(NewPosition - self.Minimum)
					local TimesOver = Displacement / self.MaxBounce
					local DisplayPosition = self.Minimum - (((self.MaxBounce/2) * (1 - 0.5 ^ TimesOver)) / 0.5)
					self.Position = NewPosition

					self.DisplayPosition = DisplayPosition
					self.OnPositionChange(DisplayPosition)
				else
					self.Position = NewPosition

					self.DisplayPosition = self.Position
					self.OnPositionChange(self.Position)
				end

				-- print(&quot;[KineticModel] - Updating @ &quot;..self.Position..&quot;; Amplitude = &quot;..(Amplitude)..&quot;; ElapsedTime = &quot; .. ElapsedTime)

				if (ElapsedTime &gt; self.Duration) then -- WE&apos;re over the timelimit,
					local Velocity
					if self.Position &gt; self.Maximum then -- Check if we&apos;re overbounds so we can bounce back. 
						local Displacement = math.abs(self.Position - self.Minimum)
						local TimesOver = Displacement / self.MaxBounce
						local Difference = (((self.MaxBounce/2) * (1 - 0.5 ^ TimesOver)) / 0.5)
						self.Position = Difference -- Set position to the display position...
						Velocity = -Difference

					elseif self.Position &lt; self.Minimum then
						local Displacement = math.abs(self.Position - self.Minimum)
						local TimesOver = Displacement / self.MaxBounce
						local Difference = (((self.MaxBounce/2) * (1 - 0.5 ^ TimesOver)) / 0.5)
						self.Position = self.Minimum - Difference
						Velocity = Difference -- Calculate velocity via difference. :D
					else -- Nope, not over bounds, we can stop. 
						self:ResetSpeed()
						self.OnScrollStop(self.Position)
						--print(&quot;[KineticModel] - Stopped @ &quot;..self.Position..&quot;; ElapsedTime @ &quot;..ElapsedTime)
					end

					if Velocity then -- Bounce back, we&apos;re over
						self.TimeStamp = tick()
						Start = self.Position
						while LocalUpdateId == self.UpdatingId do
							local ElapsedTime = tick() - self.TimeStamp
							self.Position = Start + Velocity * ((ElapsedTime/self.BounceBackDuration)^(1/3.5))
							
							self.DisplayPosition = self.Position
							self.OnPositionChange(self.Position)

							if (ElapsedTime &gt; self.BounceBackDuration) then
								self:ResetSpeed()
								self.OnScrollStop(self.Position)
								--print(&quot;[KineticModel] - Stopped (2) @ &quot;..self.Position..&quot;; ElapsedTime @ &quot;..ElapsedTime)
							end
							wait(self.UpdateInterval)
						end

						self.DisplayPosition = Start + Velocity
						self.OnPositionChange(Start + Velocity)
					else
						self.DisplayPosition = Start + Amplitude
						self.OnPositionChange(Start + Amplitude)
					end
				end
				wait(self.UpdateInterval)
			end

		end)
	end
end)
lib.MakeKineticModel = MakeKineticModel

local MakeScroller = Class(function(Scroller, Container, Content, ScreenGui, Axis)
	--- Models an iOS style window / a scroll bar.
	-- @param Container The content frame. This is the space that renders. Stuff from &apos;Content&apos; will
	--        display inside of this. If it&apos;s a GuiButton, then it will also allow for ROBLOX user input,
	--        like iOS scrolling. It is suggested you use a GuiButton. 
	-- @param Content The frame inside of the container that contains the actual content.  Probably larger
	--        then the Container, otherwise, there&apos;s nothing to scroll...
	-- @param ScreenGui The screengui the Container and Content are in.
	-- @param Axis a char of &apos;X&apos; or &apos;Y&apos; that defines what axis the scrollbar works upon.  Only Y works for scroll bars. 

	-- Axis: Char &apos;X&apos; or Char &apos;Y&apos;
	Axis = Axis or &apos;Y&apos;;

	--[[
		Positioning is based on some super hacky negative scale

		0 VERY TOP


		-500 VERY BOTTOM

		The range is represented as thus.  That is, the &quot;smallest&quot; size is the Content&apos;s absoluteSize + The Container&apos;s absoluteSize
		
		So if you have a Container sized at 100, and the content of 500...
		You have a range of 400. Your scroll bar is at 20% (100 / 500) of it&apos;s frame. 
		Your maximum is always 0
		Your minimum is negative 400. 

		KineticModel takes in absolute values. Scroller will adjust these absolute positions (relative to the frame)
		to be relative to the Content Frame. 
	
		The positioning mechanism is this:

		Content.Position = UDim2.new(Content.Position.X.Scale, Content.Position.X.Offset, 0, NewPosition)

		You can see it maintains X axis (this is for a Y axis scroller). NewPosition is set directly. 

		Thus, at 0 it is actually at the very bottom, and at -400 it&apos;s at the very top. Heck. that&apos;s confusing.
	--]]

	local KineticModel       = MakeKineticModel()
	local Pressed            = false
	local ScrollbarPressed -- Hold&apos;s a &apos;Scrollbar&apos; object. 
	local MouseScrollEnabled = false -- Can we use the mouse wheel to scroll around? Glitches in First Person. 
	local ReferencePosition  = 0 -- Reference position to the last &apos;Drag&apos; position, and then calculate velocity from this. :D
	local MouseDrag          = qGUI.GenerateMouseDrag() -- A big GUI to capture Mouse.Moved()
	local Mouse              = Players.LocalPlayer:GetMouse()
	local Scrollbars         = {}
	local StepEvent
	
	Scroller.PixelsPerWheelTurn = 80; -- How many pixels it&apos;ll scroll during a wheel turn.
	Scroller.KineticModel       = KineticModel
	Scroller.Content            = Content
	Scroller.Container          = Container
	Scroller.Axis               = Axis
	Scroller.MouseDrag          = MouseDrag
	Scroller.CanDrag            = true
	Scroller.ScrollFinished     = CreateSignal() -- Fires an event whenever a scroll finishes moving. 
	Scroller.ScrollStarted      = CreateSignal()

	local function StopStepEvent()
		if StepEvent then
			StepEvent:disconnect()
			StepEvent = nil
		end
	end

	function Scroller:AdjustRange()
		-- Readjustes the range on the scroller.

		local Maximum = 0
		local Minimum = -Content.AbsoluteSize[Axis] + Container.AbsoluteSize[Axis]

		for _, Scrollbar in pairs(Scrollbars) do -- Adjust all the scrollbar&apos;s ranges too. :D
			Scrollbar.ResizeBar()
		end

		-- print(&quot;[Scroller] - Adjusting range to max @ &quot;..Maximum)
		KineticModel:SetRange(Minimum, Maximum)
	end

	function Scroller.CanScroll()
		return Content.AbsoluteSize[Axis] &gt;= Container.AbsoluteSize[Axis] and Scroller.CanDrag
	end

	function Scroller.StartDrag(PositionX, PositionY)
		-- Position X/Y should be absolute coordinates 
		if ScrollbarPressed then
			print(&quot;[Scroller] - Scrollbar is already pressed&quot;)
			return false
		elseif not Scroller.CanScroll() then
			return false
		end

		ReferencePosition = Vector2.new(PositionX, PositionY)[Axis]

		Scroller.ScrollStarted:fire(KineticModel.DisplayPosition)

		StopStepEvent()
		StepEvent = RunService.Stepped:connect(function() Scroller.Drag(Mouse.X, Mouse.Y) end)

		-- print(&quot;[Scroller] - Start drag, reference position @ &quot;..tostring(ReferencePosition))

		Pressed = true
		MouseDrag.Parent = ScreenGui
		KineticModel:ResetSpeed()
	end

	function Scroller.Drag(PositionX, PositionY)
		-- Position X/Y should be absolute coordinates 

		-- print(&quot;[Scroller] - Dragging @ (&quot; .. PositionX .. &quot;, &quot; .. PositionY..&quot;)&quot;)
		if not Scroller.CanScroll() then
			print(&quot;[Scroller] - Cannot scroll&quot;)
			return false
		end

		local MouseClickPosition = Vector2.new(PositionX, PositionY)
		local Change = (MouseClickPosition[Axis]) - ReferencePosition
		-- if math.abs(Change) &gt;= 1 then
			if Pressed then
				
				local NewPosition = KineticModel.Position + Change

				--print(&quot;[Scroller] - Drag, NewPosition @ &quot;..NewPosition..&quot;; Change @ &quot;..Change)
				KineticModel:SetPosition(NewPosition)
				ReferencePosition = MouseClickPosition[Axis]
			elseif ScrollbarPressed then

				local MaxDisplayRange = ScrollbarPressed.ScrollBarContainer.AbsoluteSize[Axis] - ScrollbarPressed.Bar.AbsoluteSize[Axis] 
				                        -- Range displayable by the scrollbar...
				local MinimumScrollerRange, MaximumScrollerRange = KineticModel:GetRange()
				local TotalScrollerRange = MaximumScrollerRange - MinimumScrollerRange -- Total range of the scroller
				--local PercentScrolled = (ScrollbarPressed.Bar.AbsolutePosition - ScrollbarPressed.ScrollBarContainer.AbsolutePosition)[Axis] / MaxDisplayRange
				Change = (Change / MaxDisplayRange) * TotalScrollerRange
				local NewPosition = KineticModel.Position - Change

				--print(&quot;[Scroller] - Drag, Scrollbar, NewPosition @ &quot;..NewPosition..&quot;; Change @ &quot;..Change)
				KineticModel:SetPosition(NewPosition, TotalScrollerRange / MaxDisplayRange)
				ReferencePosition = MouseClickPosition[Axis]
			else
				--print(&quot;[Scroller] - Scroller not pressed&quot;)
				KineticModel:SetPosition(KineticModel.Position)
			end
		-- else
			-- print(&quot;[Scroller] - Change too small for drag to register.&quot;)
		-- end
	end

	function Scroller.StopDrag()
		--- Stop&apos;s it from dragging.

		-- Position X/Y should be absolute coordinates 
		StopStepEvent()
		Pressed = false
		ScrollbarPressed = nil 
		KineticModel:Release()
		MouseDrag.Parent = nil
	end

	function Scroller.ScrollDown()
		if MouseScrollEnabled and Scroller.CanScroll() then
			--print(&quot;[Scroller] - Scroll down&quot;)
			--local OldVelocity = KineticModel.Velocity
			KineticModel:ResetSpeed()
			KineticModel:SetVelocity(-Scroller.PixelsPerWheelTurn)
			KineticModel:Release()
		end
	end

	function Scroller.ScrollUp()
		if MouseScrollEnabled and Scroller.CanScroll() then
			--print(&quot;[Scroller] - Scroll up&quot;)
			--local OldVelocity = KineticModel.Velocity

			StopStepEvent()
			KineticModel:ResetSpeed()
			KineticModel:SetVelocity(Scroller.PixelsPerWheelTurn)
			KineticModel:Release()
		end
	end

	function Scroller.EnabledMouseScroll()
		if not qGUI.TouchOnly() then
			-- Scroller.ScrollStarted:fire(KineticModel.DisplayPosition)
			MouseScrollEnabled = true
			--qCamera.SetCurrentCameraToScriptable()
		end
	end

	function Scroller.DisableMouseScroll()
		if not qGUI.TouchOnly() then
			MouseScrollEnabled = false
			--qCamera.SetPlayerControl()

			-- Scroller.ScrollFinished:fire(KineticModel.DisplayPosition)
		end
	end

	function Scroller.ScrollTo(NewPosition, DoNotAnimate)
		-- @param NewPosition The new position to scroll to. Should be based upon range.

		StopStepEvent()
		KineticModel:ScrollTo(NewPosition, DoNotAnimate)
	end

	function Scroller:AddScrollBar(ScrollBarContainer, DoNotDecorate)
		--- Add&apos;s a ScrollBar in the &apos;ScrollBarContainer&apos;, linked to this scrolling frame. Will generate the scroll bar and
		--  Parent to the ScrollBarContainer. 
		-- @param ScrollBarContainer the container that it should be generated in. A frame object.
		-- @pre ScrollBarContainer is a Gui, and it&apos;s actually called on the class it comes from...
		-- @post ScrollBarContainer is decorated unless DoNotDecorate is set to true,
		--        There is now a scroll bar inside of ScrollBarContainer linked to the
		--        Scroller. 
		
		--TODO: Add support for horizontal rendering

		local Scrollbar = {}
		Scrollbar.ScrollBarContainer = ScrollBarContainer
		local KineticModel = Scroller.KineticModel
		

		local Bar = Make &apos;ImageButton&apos; {
			Name                   = &quot;ScrollBar&quot;;
			Parent                 = ScrollBarContainer;
			ZIndex                 = math.max(math.min(10, ScrollBarContainer.ZIndex + 1), 0);
			BackgroundTransparency = 1;
			BorderSizePixel        = 0;
			BackgroundColor3       = Color3.new(0, 0, 0);
			Active                 = false;
		}
		Scrollbar.Bar = Bar

		function Scrollbar.ResizeBar() -- Resizes the scrollbar&apos;s bar. :D
			if Scroller.Axis == &apos;Y&apos; then -- Make sure we resize on the correct axis. 
				Bar.Size = UDim2.new(1, 0, (Scroller.Container.AbsoluteSize.Y / Scroller.Content.AbsoluteSize.Y), 0)
			else
				Bar.Size = UDim2.new((Scroller.Container.AbsoluteSize.X / Scroller.Content.AbsoluteSize.X), 0, 1, 0)
			end
		end

		function Scrollbar.Render(NewPosition) -- Rerenders the bar. 

			-- Repositions the ScrollBar. Probably called every time the scroller is moved. 

			-- Prerequests: Scrollbar has been resized correctlyi. 
			-- PostResults: ScrollBar is positioned correctly...

			local MaxDisplayRange = ScrollBarContainer.AbsoluteSize[Axis] - Bar.AbsoluteSize[Axis] -- Range displayable by the scrollbar...
			local MinimumScrollerRange, MaximumScrollerRange = KineticModel:GetRange()
			local TotalScrollerRange = MaximumScrollerRange - MinimumScrollerRange -- Total range of the scroller
			local PercentScrolled = math.abs(KineticModel:Clamp(NewPosition) / TotalScrollerRange)

			--print(&quot;[Scroller][ScrollBar] - Render @ &quot;..NewPosition..&quot;; PercentScrolled @ &quot;..PercentScrolled..&quot;; Display @ &quot;..(MaxDisplayRange * PercentScrolled))

			if Scroller.Axis == &apos;Y&apos; then
				Bar.Position = UDim2.new(0, 0, 0, MaxDisplayRange * PercentScrolled)
			else
				Bar.Position = UDim2.new(0, MaxDisplayRange * PercentScrolled, 0, 0)
			end
		end

		function Scrollbar.OnEnterDisplay()
			if not DoNotDecorate then
				wait(0)
				local DecorationSize = ScrollBarContainer.AbsoluteSize[Scroller.Axis == &apos;Y&apos; and &apos;X&apos; or &apos;Y&apos;]
			
				ApplyScrollbarBacking(ScrollBarContainer, ScrollBarContainer.ZIndex, ScrollBackings.Default.ScrollFrameBacking, DecorationSize, &quot;OnOver&quot;)
				ApplyScrollbarBacking(Bar, Bar.ZIndex, ScrollBackings.Default.ScrollThumb, DecorationSize, &quot;OnOver&quot;)
			end
		end

		function Scrollbar.OnLeaveDisplay()
			if not DoNotDecorate then
				local DecorationSize = ScrollBarContainer.AbsoluteSize[Scroller.Axis == &apos;Y&apos; and &apos;X&apos; or &apos;Y&apos;]
			
				ApplyScrollbarBacking(ScrollBarContainer, ScrollBarContainer.ZIndex, ScrollBackings.Default.Invisible, DecorationSize, &quot;OnOver&quot;)
				ApplyScrollbarBacking(Bar, Bar.ZIndex, ScrollBackings.Default.Invisible, DecorationSize, &quot;OnOver&quot;)
			end
		end

		local EventId = 0;

		function Scrollbar.StopScrollFromWhitespace()
			EventId = EventId + 1;
		end

		function Scrollbar.MouseDownOnWhitespace(PositionX, PositionY)
			local PositionDown = Vector2.new(PositionX, PositionY)
			EventId = EventId + 1
			local LocalEventId = EventId

			while LocalEventId == EventId do
				KineticModel:ResetSpeed()
				if math.abs(Bar.AbsolutePosition[Scroller.Axis] - PositionDown[Scroller.Axis] + Bar.AbsoluteSize[Scroller.Axis]/2) &lt; Bar.AbsoluteSize[Scroller.Axis]/2 then
					-- print(&quot;[Scroller][ScrollBar] - Stop Down&quot;)
					Scrollbar.StopScrollFromWhitespace()
				elseif Bar.AbsolutePosition[Scroller.Axis] &lt; PositionDown[Scroller.Axis] then
					KineticModel:SetVelocity(-Scroller.Container.AbsoluteSize[Scroller.Axis])
				else
					KineticModel:SetVelocity(Scroller.Container.AbsoluteSize[Scroller.Axis])
				end
				KineticModel:Release()
				wait(0.2)
			end
		end

		function Scrollbar.StartDrag(PositionX, PositionY)
			-- Start&apos;s the &apos;Drag&apos; on the scrollbar, so it really fires on Button1Down

			if ScrollbarPressed then
				-- print(&quot;[Scroller] - Scroller is already pressed&quot;)
				return false
			end

			Scroller.ScrollStarted:fire(KineticModel.DisplayPosition)

			StopStepEvent()
			StepEvent = RunService.Stepped:connect(function() Scroller.Drag(Mouse.X, Mouse.Y) end)

			ScrollbarPressed = Scrollbar
			ReferencePosition = Vector2.new(PositionX, PositionY)[Axis]

			MouseDrag.Parent = ScreenGui
			KineticModel:ResetSpeed()


			-- print(&quot;[Scroller] - Start drag, reference position @ &quot;..tostring(ReferencePosition))
		end

		if not DoNotDecorate then
			local DecorationSize = ScrollBarContainer.AbsoluteSize[Scroller.Axis == &apos;Y&apos; and &apos;X&apos; or &apos;Y&apos;]
		
			ApplyScrollbarBacking(ScrollBarContainer, ScrollBarContainer.ZIndex, ScrollBackings.Default.ScrollFrameBacking, DecorationSize)
			ApplyScrollbarBacking(Bar, Bar.ZIndex, ScrollBackings.Default.ScrollThumb, DecorationSize)
		end

		Bar.MouseButton1Down:connect(Scrollbar.StartDrag) -- Hookup events...
		Bar.MouseButton1Up:connect(Scrollbar.StopScrollFromWhitespace)
		if ScrollBarContainer:IsA(&quot;GuiButton&quot;) then
			ScrollBarContainer.MouseButton1Down:connect(Scrollbar.MouseDownOnWhitespace) -- Hookup events...
			ScrollBarContainer.MouseButton1Up:connect(Scrollbar.StopScrollFromWhitespace)
			ScrollBarContainer.MouseEnter:connect(Scrollbar.OnEnterDisplay)
			ScrollBarContainer.MouseLeave:connect(Scrollbar.OnLeaveDisplay)
		else
			Bar.MouseEnter:connect(Scrollbar.OnEnterDisplay)
			Bar.MouseLeave:connect(Scrollbar.OnLeaveDisplay)
		end
		Scrollbar.ResizeBar()
		Scrollbars[#Scrollbars+1] = Scrollbar -- Add the scrollbar &apos;Object&apos; to the list of scrollbars. 
	end

	local function OnAbsoluteSizeAdjust(Property)
		-- Whenever a component changes size, it adjusts the range. This function is for hooking up to .Changed events.

		if Property == &quot;AbsoluteSize&quot; then
			Scroller:AdjustRange() -- Make sure we don&apos;t get into an absoltue loop.
		end
	end

	KineticModel.OnPositionChange = function(NewPosition)
		-- Goes off when the position changes. 

		--print(&quot;[Scroller] - Position Changed to &quot;..NewPosition)
		if Axis == &apos;Y&apos; then
			Content.Position = UDim2.new(Content.Position.X.Scale, Content.Position.X.Offset, 0, NewPosition)
		else
			Content.Position = UDim2.new(0, NewPosition, NewPositionContent.Position.Y.Scale, Content.Position.Y.Offset)
		end

		for _, Scrollbar in pairs(Scrollbars) do
			Scrollbar.Render(NewPosition)
		end
	end

	if Content:IsA(&quot;GuiButton&quot;) then
		Content.Active = false
		Content.MouseEnter:connect(function()
			Scroller.EnabledMouseScroll()
			--[[for _, Scrollbar in pairs(Scrollbars) do
				Scrollbar.OnEnterDisplay()
			end--]]
		end)
		Content.MouseLeave:connect(function()
			Scroller.DisableMouseScroll()
			--[[for _, Scrollbar in pairs(Scrollbars) do
				Scrollbar.OnLeaveDisplay()
			end--]]
		end)
		Content.MouseButton1Down:connect(Scroller.StartDrag)
	end

	Mouse.WheelForward:connect(function()
		--print(&quot;[Scroller] - Wheel Move Forward&quot;)
		Scroller.ScrollUp()
	end)
	Mouse.WheelBackward:connect(function()
		--print(&quot;[Scroller] - Wheel Move Backwards&quot;)
		Scroller.ScrollDown()
	end)

	--MouseDrag.MouseMoved:connect(Scroller.Drag)
	MouseDrag.MouseButton1Up:connect(function()
		Scroller.StopDrag()
	end)
	Container.Changed:connect(OnAbsoluteSizeAdjust)
	Content.Changed:connect(OnAbsoluteSizeAdjust)

	Scroller:AdjustRange()

	KineticModel.OnScrollStop = function(Position)
		Scroller.ScrollFinished:fire(KineticModel.DisplayPosition)
	end
end)
lib.MakeScroller = MakeScroller

return lib</ProtectedString>
</Properties>
</Item>
<Item class="Script" referent="RBX48">
<Properties>
<string name="Name">TeamSelector</string>
<ProtectedString name="Source">while not _G.NevermoreEngine do wait(0) end

local Players           = Game:GetService(&apos;Players&apos;)
local StarterPack       = Game:GetService(&apos;StarterPack&apos;)
local StarterGui        = Game:GetService(&apos;StarterGui&apos;)
local Lighting          = Game:GetService(&apos;Lighting&apos;)
local Debris            = Game:GetService(&apos;Debris&apos;)
local Teams             = Game:GetService(&apos;Teams&apos;)
local BadgeService      = Game:GetService(&apos;BadgeService&apos;)
local InsertService     = Game:GetService(&apos;InsertService&apos;)
local Terrain           = Workspace.Terrain

local NevermoreEngine   = _G.NevermoreEngine
local LoadCustomLibrary = NevermoreEngine.LoadLibrary;

local qSystems          = LoadCustomLibrary(&apos;qSystems&apos;)
local qGUI              = LoadCustomLibrary(&apos;qGUI&apos;)
local qCamera           = LoadCustomLibrary(&apos;qCamera&apos;)
local SoundPlayer       = LoadCustomLibrary(&apos;SoundPlayer&apos;)
local EventBin          = LoadCustomLibrary(&apos;EventBin&apos;)

qSystems:Import(getfenv(0));

local lib = {}

-- This system is used to select a team, with camera effects. 

local function GetSpawnLocation(TeamColor) -- Eww... 
	local ItemFound
	CallOnChildren(Workspace, function(Item)
		if Item:IsA(&quot;SpawnLocation&quot;) and Item.TeamColor.Name == TeamColor.Name then
			ItemFound = Item
		elseif Item:IsA(&quot;SpawnLocation&quot;) then
			--print(&quot;[MenuSystemTester] - Spawn find fail @ &quot;..Item:GetFullName()..&quot; Check @ &quot;..tostring(Item.TeamColor.Name == TeamColor.Name))
		end
	end)
	return ItemFound
end
lib.GetSpawnLocation = GetSpawnLocation

local MakeTeamSelectorOption = Class &apos;TeamSelector&apos; (function(TeamSelectorOption, Team, TeamIcon, AutoSelectFunction, JoinFilter)
	-- Prerequests: Team is a `Team` and TeamIcon is a valid ROBLOX String URL or nil. JoinFilter and AutoSelectFunction are functions or nil.

	TeamIcon = TeamIcon or &quot;&quot;;
	TeamSelectorOption.TeamIcon = TeamIcon
	AutoSelectFunction = AutoSelectFunction or function(Player) 
		return false
	end
	JoinFilter = JoinFilter or function(Player) 
		return true
	end

	TeamSelectorOption.AutoSelectFunction = AutoSelectFunction
	TeamSelectorOption.JoinFilter = JoinFilter
	TeamSelectorOption.Team = Team

	local function GetCameraPositions()
		-- Returns this selector&apos;s camera position (Where it&apos;s suppose to point at) or nil...

		local CoordinateFrameObject = Team:FindFirstChild(&quot;TeamCoordinateFrame&quot;) 
		local FocusObject = Team:FindFirstChild(&quot;TeamFocus&quot;)
		if not (CoordinateFrameObject and FocusObject and CoordinateFrameObject:IsA(&quot;CFrameValue&quot;) and FocusObject:IsA(&quot;CFrameValue&quot;)) then
			print(&quot;[MenuSystemTester] [TeamSelector] - Could not get camera inf - malformed/nil objects&quot;)
			return nil
		else
			return CoordinateFrameObject.Value.p, FocusObject.Value.p
		end
	end
	TeamSelectorOption.GetCameraPositions = GetCameraPositions
end)
lib.MakeTeamSelectorOption = MakeTeamSelectorOption

local MakeTeamSelector =  Class &apos;TeamSelector&apos; (function(TeamSelector, ScreenGui, Configuration, TeamSelectors)
	-- Allows a player to select a team.

	-- Prerequests: ScreenGui is a ROBLOX `ScreenGui`, Configuration is a table of configurations or nil, and TeamSelectors is an array of TeamSelectors
	local Events = EventBin.MakeEventBin()
	Configuration = Configuration or {}
	Configuration.SelectorSize = Configuration.SelectorSize or 200 -- How big is the selector
	Configuration.TeamNameSize = Configuration.TeamNameSize or 20 -- How tall is the teamSize.
	Configuration.TeamSelectorTweenTime = Configuration.TeamSelectorTweenTime or 0.5
	Configuration.TagLine = Configuration.TagLine or &quot;Join the battle on the side of the &quot;
	Configuration.Title = &quot;Choose your fraction&quot;;

	local OverallHeight = Configuration.SelectorSize + Configuration.TeamNameSize + 50 -- 50 is from the outside labels, 20 for the TagLIne and 30 for the title
	local TeamChooserHeight = Configuration.SelectorSize + Configuration.TeamNameSize
	local TeamChooserWidth

	local TeamSelected = CreateSignal()
	TeamSelector.TeamSelected = TeamSelected

	TeamSelector.SelectedTeam = -1 -- Index of selected team
	TeamSelector.CanSelect = true -- Can something get selected? 
	local TeamSelectorCopy = TeamSelectors
	TeamSelectors = {}
	local TeamSelectorCount = 0

	for Index, Item in pairs(TeamSelectorCopy) do
		if Item.JoinFilter(Players.LocalPlayer) then
			local Template = Make &apos;ImageButton&apos; {
				Archivable             = false;
				BackgroundTransparency = 1;
				BorderSizePixel        = 0;
				Name                   = &quot;Selector&quot;;
				--Parent                 = ScreenGui;
				Position               = UDim2.new(0, Configuration.SelectorSize * (TeamSelectorCount), 0, 0);
				Size                   = UDim2.new(0, Configuration.SelectorSize, 0, TeamChooserHeight);
				Visible                = true; 
				ZIndex                 = 2;
			}
			Item.Gui = Template

			local TitleLabel = Make &apos;TextLabel&apos; {  -- Such as &quot;Nightfall Clan&quot;
				Archivable             = false;
				BackgroundTransparency = 1;
				BorderSizePixel        = 0;
				Font                   = &quot;Arial&quot;;
				FontSize               = &quot;Size14&quot;;
				Name                   = &quot;TeamName&quot;;
				Parent                 = Template;
				Position               = UDim2.new(0, 0, 1, -Configuration.TeamNameSize);
				Size                   = UDim2.new(1, 0, 0, Configuration.TeamNameSize);
				Text                   = Item.Team.Name:upper();
				TextColor3             = Color3.new(1, 1, 1);
				TextStrokeColor3       = Color3.new(0.5, 0.5, 0.5);
				TextStrokeTransparency = 0.8;
				TextTransparency       = 0;
				TextXAlignment         = &quot;Center&quot;;
				ZIndex                 = 1;
			}

			local Icon = Make &apos;ImageLabel&apos; {
				Archivable             = false;
				BackgroundTransparency = 1;
				BorderSizePixel        = 0;
				Name                   = &quot;Selector&quot;;
				Image                  = Item.TeamIcon;
				Parent                 = Template;
				Position               = UDim2.new(0, 0, 0, 0);
				Size                   = UDim2.new(0, Configuration.SelectorSize, 0, Configuration.SelectorSize);
				Visible                = true; 
				ZIndex                 = 1;
			}

			Events:add(Template.MouseEnter:connect(function()
				if TeamSelector.CanSelect then
					SoundPlayer.PlaySound(&quot;Tick&quot;, 0.5)
					TeamSelector.SetSelected(Item)
					local CoordinateFrame, Focus = Item.GetCameraPositions()
					if CoordinateFrame and Focus then
						qCamera.TweenCamera(CoordinateFrame, Focus, Configuration.TeamSelectorTweenTime, true)
					end
				end
			end))

			Events:add(Template.MouseButton1Click:connect(function()
				if TeamSelector.CanSelect then
					TeamSelector.SetSelected(Item)
					TeamSelector.SelectTeam(Players.LocalPlayer)
				end
			end))


			local Edging = Make &apos;Frame&apos; { -- Make Edging for beautification reasons.
				Archivable             = false;
				BackgroundTransparency = 0.8;
				BackgroundColor3       = Color3.new(0, 0, 0);
				BorderSizePixel        = 0;
				Name                   = &quot;Edging&quot;;
				Parent                 = Template;
				Position               = UDim2.new(1, -1, 0, 10);
				Size                   = UDim2.new(0, -1, 1, -20);
				Visible                = true;
				ZIndex                 = 1;
				Make &apos;Frame&apos; {
					Archivable             = false;
					BackgroundTransparency = 0.8;
					BackgroundColor3       = Color3.new(1, 1, 1);
					BorderSizePixel        = 0;
					Name                   = &quot;Edging&quot;;
					Position               = UDim2.new(1, 0, 0, 0);
					Size                   = UDim2.new(0, 1, 1, 0);
					Visible                = true; 
					ZIndex                 = 1;
				};
			};

			TeamSelectorCount = TeamSelectorCount + 1
			TeamSelectors[#TeamSelectors+1] = Item
		end
	end

	TeamChooserWidth = TeamSelectorCount * Configuration.SelectorSize

	local Container = Make &apos;Frame&apos; {
		Archivable             = false;
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		ClipsDescendants       = true;
		Name                   = &quot;qTeamChooserContainer&quot;;
		Parent                 = ScreenGui;
		Position               = UDim2.new(0, 0, 0.5, -OverallHeight/2);
		Size                   = UDim2.new(1, 0, 0, OverallHeight);
		Visible                = true; -- We&apos;ll change after TextLabel&apos;s TextBounds actually cnage. 
		ZIndex                 = 1;
	}

	local TeamChooser = Make &apos;Frame&apos; {
		Archivable             = false;
		BackgroundTransparency = 1;--0.7; -- Will tween to 0.7
		BackgroundColor3       = Color3.new(0, 0, 0);
		BorderSizePixel        = 0;
		Name                   = &quot;TeamChooser&quot;;
		Parent                 = Container;
		Position               = UDim2.new(0.5, -TeamChooserWidth/2, 0.5, -TeamChooserHeight/2);
		Size                   = UDim2.new(0, TeamChooserWidth, 0, TeamChooserHeight);
		ZIndex                 = 1;
	}

	local TeamChooserContainer = Make &apos;Frame&apos; {
		Archivable             = false;
		BackgroundTransparency = 1;
		BackgroundColor3       = Color3.new(0, 0, 0);
		BorderSizePixel        = 0;
		Name                   = &quot;TeamChooserContainer&quot;;
		Parent                 = TeamChooser;
		Position               = UDim2.new(0, 0, 0, 0);
		Size                   = UDim2.new(1, 0, 1, 0);
		ZIndex                 = 1;
		ClipsDescendants       = true;
	}

	for _, Item in pairs(TeamSelectors) do
		Item.Gui.Parent = TeamChooserContainer;
	end

	local TagLine = Make &apos;TextLabel&apos; { -- Something along the lines of &quot;Join the battle on the side of the &quot;...?
		Archivable             = false;
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Font                   = &quot;Arial&quot;;
		FontSize               = &quot;Size14&quot;;
		Name                   = &quot;TagLine&quot;;
		Parent                 = TeamChooser;
		Position               = UDim2.new(0, 30, 1, 0);
		Text                   = Configuration.TagLine;
		TextColor3             = Color3.new(1, 1, 1);
		TextStrokeColor3       = Color3.new(0.5, 0.5, 0.5);
		TextStrokeTransparency = 0.8;
		TextTransparency       = 0;
		TextXAlignment         = &quot;Left&quot;;
		ZIndex                 = 1;
	}
	TagLine.Size = UDim2.new(0, TagLine.TextBounds.X, 0, 20);

	local TeamNameLabel = Make &apos;TextLabel&apos; { -- Something along the lines of &quot;Join the battle on the side of the &quot;...?
		Archivable             = false;
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Font                   = &quot;Arial&quot;;
		FontSize               = &quot;Size14&quot;;
		Name                   = &quot;TeamNameLabel&quot;;
		Parent                 = TeamChooser;
		Position               = UDim2.new(0, TagLine.Position.X.Offset + TagLine.Size.X.Offset, 1, 0);
		Size                   = UDim2.new(1, 0, 0, 20);
		Text                   = &quot;No one&quot;;
		TextColor3             = Color3.new(1, 1, 1);
		TextStrokeColor3       = Color3.new(0.5, 0.5, 0.5);
		TextStrokeTransparency = 0.8;
		TextTransparency       = 0;
		TextXAlignment         = &quot;Left&quot;;
		ZIndex                 = 1;
	}

	local TitleLabel = Make &apos;TextLabel&apos; { -- Something along the lines of &quot;Join the battle on the side of the &quot;...?
		Archivable             = false;
		BackgroundTransparency = 1;
		BorderSizePixel        = 0;
		Font                   = &quot;ArialBold&quot;;
		FontSize               = &quot;Size24&quot;;
		Name                   = &quot;TitleLabel&quot;;
		Parent                 = TeamChooser;
		Position               = UDim2.new(0, -25, 0, -30);
		Size                   = UDim2.new(1, 0, 0, 30);
		Text                   = Configuration.Title;
		TextColor3             = Color3.new(1, 1, 1);
		TextStrokeColor3       = Color3.new(0.5, 0.5, 0.5);
		TextStrokeTransparency = 1; --0.8;
		TextTransparency       = 1; --0; Tweens in later.
		TextXAlignment         = &quot;Left&quot;;
		ZIndex                 = 1;
	}

	local SelectedMarker = Make &apos;ImageLabel&apos; {
		Image                  = &quot;http://www.roblox.com/asset/?id=110293218&quot;;
		BorderSizePixel        = 0;
		BackgroundColor3       = Color3.new(0, 0, 0);
		BackgroundTransparency = 1;
		Size                   = UDim2.new(0, Configuration.SelectorSize, 0, Configuration.SelectorSize + Configuration.TeamNameSize);
		Name                   = &quot;SelectorMarkor&quot;;
		BorderSizePixel        = 0;
		Position               = UDim2.new(0, 0, 0, 0);
		Parent                 = TeamChooserContainer;
	}
	Container.Visible = false

	

	local function InitialUpdate()
		-- Call after all the team&apos;s have been added to autoselect a team. 

		local TeamSelectorOption, Index = TeamSelector.AutoSuggest(Players.LocalPlayer)
		if TeamSelectorOption then
			TeamSelector.SelectedTeam = Index
			local CoordinateFrame, Focus = TeamSelectorOption.GetCameraPositions()
			if CoordinateFrame and Focus then
				qCamera.PointCamera(CFrame.new(CoordinateFrame), CFrame.new(Focus))
			end
		end
	end

	local function Show()
		InitialUpdate()
		TeamSelector.Update()
		TeamSelector.CanSelect = false
		qGUI.TweenTransparency(TeamChooser, {BackgroundTransparency = 0.7}, 0.25, true)
		qGUI.TweenTransparency(TitleLabel, {TextTransparency = 0; TextStrokeTransparency = 0.8}, 0.25, true)

		for Index, TeamSelectorOption in pairs(TeamSelectors) do
			TeamSelectorOption.Gui.Position = UDim2.new(0, -Configuration.SelectorSize, 0, 0);
		end
		SelectedMarker.Position = UDim2.new(-1, 0, 0, 0)
		TeamChooser.Position = UDim2.new(0.5, -TeamChooserWidth/2, 0.5, -1);
		TeamChooser:TweenPosition(UDim2.new(0.5, -TeamChooserWidth/2, 0.5, -TeamChooserHeight/2), &quot;Out&quot;, &quot;Sine&quot;, 0.25, true)
		Container.Visible  = true
		wait(0.25)
		Spawn(function()
			for Index, TeamSelectorOption in pairs(TeamSelectors) do
				TeamSelectorOption.Gui:TweenPosition(UDim2.new(0, (Index-1)*Configuration.SelectorSize, 0, 0), &quot;Out&quot;, &quot;Elastic&quot;, 1.5, true);
				wait(0.25)
			end
		end)
		wait(#TeamSelectors * 0.25 + 1)
		SelectedMarker.Parent = Container

		TeamSelector.Update()
		TeamSelector.CanSelect = true

		local Mouse = Players.LocalPlayer:GetMouse() -- Basically, if their mouse is over a selection, automatically tween to it. 
		for _, TeamSelectorOption in pairs(TeamSelectors) do
			if qGUI.MouseOver(Mouse, TeamSelectorOption.Gui) then
				TeamSelector.SetSelected(TeamSelectorOption)
			end
		end
	end
	TeamSelector.Show = Show

	local function Hide()
		TeamSelector.CanSelect = false
		SelectedMarker:TweenPosition(UDim2.new(1, 30, 0, 0), &quot;In&quot;, &quot;Sine&quot;, 0.5, true)
		for Index, TeamSelectorOption in pairs(TeamSelectors) do
			delay(0.25 * (#TeamSelectors - Index), function()
				TeamSelectorOption.Gui:TweenPosition(UDim2.new(1, 0, 0, 0), &quot;Out&quot;, &quot;Sine&quot;, 0.5, true);
			end)
		end
		wait((#TeamSelectors * 0.25) + 0.4)
		qGUI.TweenTransparency(TeamChooser, {BackgroundTransparency = 1}, 0.25, true)
		qGUI.TweenTransparency(TitleLabel, {TextTransparency = 1; TextStrokeTransparency = 1}, 0.25, true)

		TeamChooser:TweenPosition(UDim2.new(0.5, -TeamChooser.AbsoluteSize.X/2, 1, 50), &quot;Out&quot;, &quot;Sine&quot;, 0.25, true)
		wait(0.4)
		Container.Visible      = false
		TeamChooser.Visible    = false
		TeamSelector.CanSelect = true
		Events:destroy()
	end
	TeamSelector.Hide = Hide

	local function AutoSuggest(Player)
		-- Autosuggest a team..
		for Index, TeamSelectorOption in pairs(TeamSelectors) do
			if TeamSelectorOption.AutoSelectFunction(Player) then
				return TeamSelectorOption, Index
			end
		end
		return nil, nil
	end
	TeamSelector.AutoSuggest = AutoSuggest

	local function GetSelectedTeam()
		-- Returns the selectedteam option if it exists...

		local SelectedTeam = TeamSelectors[TeamSelector.SelectedTeam]
		return SelectedTeam
	end
	TeamSelector.GetSelectedTeam = GetSelectedTeam

	local function Update()
		-- Updates the GUI&apos;s and moves selectedGui

		SelectedMarker.Parent = TeamChooserContainer
		SelectedMarker:TweenPosition(UDim2.new(0, (TeamSelector.SelectedTeam-1) * Configuration.SelectorSize, 0, 0), &quot;InOut&quot;, &quot;Sine&quot;, 0.1, true)
		local SelectedTeam = GetSelectedTeam()
		--TeamChooser.Size = UDim2.new(0, #TeamSelector.Options * Settings.TeamSelectorWidth, 0, Settings.TeamSelectorHeight)
		--TeamChooserGui.Position = UDim2.new(0.5, -TeamChooserGui.AbsoluteSize.X/2, 0.5, -TeamChooserGui.AbsoluteSize.Y/2)
		if SelectedTeam then
			TeamNameLabel.TextColor3 = SelectedTeam.Team.TeamColor.Color
			TeamNameLabel.Text = SelectedTeam.Team.Name
		else
			TeamNameLabel.TextColor3 = Color3.new(1, 1, 1);
			TeamNameLabel.Text = &quot;[ None Selected ]&quot;
		end
	end
	TeamSelector.Update = Update

	local function SelectTeam(Player)
		-- Sets the Player&apos;s team, and then closes the GUI...

		local SelectedTeam = GetSelectedTeam()

		if SelectedTeam then
			Player.TeamColor = SelectedTeam.Team.TeamColor
			Player.Neutral = false
			TeamSelected:fire(SelectedTeam.Team)
		else
			print(&quot;[TeamSelector] - Can&apos;t select team for player, &quot;)
		end
	end
	TeamSelector.SelectTeam = SelectTeam

	local function SetSelected(TeamSelectorOption)
		TeamSelector.SelectedTeam = getIndexByValue(TeamSelectors, TeamSelectorOption)
		if not TeamSelector.SelectedTeam then
			error(&quot;[TeamSelector] - Tried to set selection of TeamSelector to a option that does not exist...&quot;)
		end
		Update()
	end
	TeamSelector.SetSelected = SetSelected
end)
lib.MakeTeamSelector = MakeTeamSelector

NevermoreEngine.RegisterLibrary(&apos;TeamSelector&apos;, lib)</ProtectedString>
<bool name="Disabled">true</bool>
</Properties>
</Item>
</Item>
<Item class="Backpack" referent="RBX49">
<Properties>
<string name="Name">qSystems</string>
</Properties>
<Item class="Backpack" referent="RBX50">
<Properties>
<string name="Name">DataStructures</string>
</Properties>
<Item class="ModuleScript" referent="RBX51">
<Properties>
<string name="Name">CircularBuffer</string>
<ProtectedString name="Source">local CircularBuffer = {}

-- A circular buffer, of defined size.
-- @author Quenty
-- Last modified Janurary 5th, 2014

--[[-- Update Log --
February 1st, 2014
- Added way to set data

January 25th, 2014
- Added Insert function / command

January 23rd, 2014
- Added replace function
- Added update log
- Added read only BufferSize property 

January 5th, 2014
- Write initial script

--]]

local function MakeCircularBuffer(BufferSize, Data)
	--- A queue that has a limited &quot;size&quot; until it starts pushing
	-- old items back out.
	-- @param BufferSize The amount of elements in the queue before they
	--                   are pushed out. 
	-- @param Data Data to preuse. 

	local Data = Data or {}
	local NewBuffer = {}
	NewBuffer.BufferSize = BufferSize -- Read only. 

	BufferSize = BufferSize + 1

	function NewBuffer:Add(NewItem)
		--- Add&apos;s a new item to the buffer.
		-- @return The removed item, if one was removed. 

		table.insert(Data, 1, NewItem)

		local Removed = Data[BufferSize]
		Data[BufferSize] = nil
		return Removed
	end

	function NewBuffer:GetData()
		return Data
	end

	function NewBuffer:Replace(Index, NewItem)
		--- Replace&apos;s the data in [Index] with the NewItem derived. 
		-- @param Index Interger, an already existing / filled index. Will error if not. 
		-- @param NewItem The item to replace the current existing item. Should not be nil. 
		-- @return The old data

		local OldData = Data[Index]
		if OldData ~= nil then
			Data[Index] = NewItem
		else
			error(&quot;[CircularBuffer] - Data[&quot; .. Index .. &quot;] does not exist. Cannot replace&quot;);
		end

		return OldData
	end

	function NewBuffer:Insert(Index, NewItem)
		--- Insert&apos;s the new item at index, shifting the index and everything to the right (backwards).
		-- Returns the old item that is removed, if an item is ermoved. 

		table.insert(Data, Index, NewItem)

		local Removed = Data[BufferSize]
		Data[BufferSize] = nil
		
		return Removed
	end

	return NewBuffer
end
CircularBuffer.MakeCircularBuffer = MakeCircularBuffer
CircularBuffer.makeCircularBuffer = MakeCircularBuffer
CircularBuffer.make_circular_buffer = MakeCircularBuffer
CircularBuffer.New = MakeCircularBuffer
CircularBuffer.new = MakeCircularBuffer

return CircularBuffer</ProtectedString>
</Properties>
</Item>
</Item>
<Item class="Backpack" referent="RBX52">
<Properties>
<string name="Name">DataTypes</string>
</Properties>
<Item class="ModuleScript" referent="RBX53">
<Properties>
<string name="Name">qCFrame</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&apos;qSystems&apos;)
local qInstance         = LoadCustomLibrary(&apos;qInstance&apos;)

qSystems:Import(getfenv(0));

local lib = {}

local bb_points = { -- Ask anaminus.  D: Bouding box posiitions. 
	Vector3.new(-1,-1,-1);
	Vector3.new( 1,-1,-1);
	Vector3.new(-1, 1,-1);
	Vector3.new( 1, 1,-1);
	Vector3.new(-1,-1, 1);
	Vector3.new( 1,-1, 1);
	Vector3.new(-1, 1, 1);
	Vector3.new( 1, 1, 1);
}


local function RecurseGetBoundingBox(object,sides,parts)
	-- Credit to Anaminus, I have a general understanding on how this works. Basically, 
	-- It would appear it loops through each part, and finds that part&apos;s bounding box.  
	-- It then expands the &quot;global&quot; bounding box to the correct size. 

	-- I think. Anyway, it finds the bounding box of the object in question.

	if object:IsA(&quot;BasePart&quot;) then
		local mod = object.Size/2
		local rot = object.CFrame
		for i = 1,#bb_points do
			local point = rot*CFrame.new(mod*bb_points[i]).p
			if point.x &gt; sides[1] then sides[1] = point.x end
			if point.x &lt; sides[2] then sides[2] = point.x end
			if point.y &gt; sides[3] then sides[3] = point.y end
			if point.y &lt; sides[4] then sides[4] = point.y end
			if point.z &gt; sides[5] then sides[5] = point.z end
			if point.z &lt; sides[6] then sides[6] = point.z end
		end
		if parts then parts[#parts + 1] = object end
	end
	local children = object:GetChildren()
	for i = 1,#children do
		RecurseGetBoundingBox(children[i],sides,parts)
	end
end

local function GetBoundingBox(objects,return_parts)
	local sides = {-math.huge;math.huge;-math.huge;math.huge;-math.huge;math.huge}
	local parts
	if return_parts then
		parts = {
}	end
	for i = 1,#objects do
		RecurseGetBoundingBox(objects[i],sides,parts)
	end
	return
		Vector3.new(sides[1]-sides[2],sides[3]-sides[4],sides[5]-sides[6]),
		Vector3.new((sides[1]+sides[2])/2,(sides[3]+sides[4])/2,(sides[5]+sides[6])/2),
		parts
end

lib.GetBoundingBox = GetBoundingBox
lib.getBoundingBox = GetBoundingBox

--[[
local function MoveModel(ModelParts, NewCFrame, ModelCenter)
	for _, part in pairs(ModelParts) do
		part.CFrame = (ModelCenter:inverse() * NewCFrame) * part.CFrame
	end
end

lib.moveModel = MoveModel;
lib.MoveModel = MoveModel;
lib.move_model = MoveModel;
--]]
--[[
local function TransformModel(objects, center, new)
	for _, object in pairs(objects) do
		object.CFrame = new:toWorldSpace(center:toObjectSpace(object.CFrame))
	end
end
lib.TransformModel = TransformModel
lib.transformModel = TransformModel;
--]]

local function QuaternionFromCFrame(cf)
	local mx,  my,  mz,
	      m00, m01, m02,
	      m10, m11, m12,
	      m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace &gt; 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5/s
		return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5
	else
		local i = 0
		if m11 &gt; m00 then i = 1 end
		if m22 &gt; (i == 0 and m00 or m11) then i = 2 end
		if i == 0 then
			local s = math.sqrt(m00-m11-m22+1)
			local recip = 0.5/s
			return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip
		elseif i == 1 then
			local s = math.sqrt(m11-m22-m00+1)
			local recip = 0.5/s
			return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip
		elseif i == 2 then
			local s = math.sqrt(m22-m00-m11+1)
			local recip = 0.5/s
			return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip
		end
	end
end
lib.QuaternionFromCFrame = QuaternionFromCFrame;
lib.quaternionFromCFrame = QuaternionFromCFrame;


local function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w*xs, w*ys, w*zs
	--
	local xx = x*xs
	local xy = x*ys
	local xz = x*zs
	local yy = y*ys
	local yz = y*zs
	local zz = z*zs
	--
	return CFrame.new(px,        py,        pz,
	                  1-(yy+zz), xy - wz,   xz + wy,
	                  xy + wz,   1-(xx+zz), yz - wx,
	                  xz - wy,   yz + wx,   1-(xx+yy))
end
lib.QuaternionToCFrame = QuaternionToCFrame;
lib.quaternionToCFrame = QuaternionToCFrame;


local function QuaternionSlerp(a, b, t)
	local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4]
	local startInterp, finishInterp;
	if cosTheta &gt;= 0.0001 then
		if (1 - cosTheta) &gt; 0.0001 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1/math.sin(theta)
			startInterp = math.sin((1-t)*theta)*invSinTheta
			finishInterp = math.sin(t*theta)*invSinTheta 
		else
			startInterp = 1-t
			finishInterp = t
		end
	else
		if (1+cosTheta) &gt; 0.0001 then
			local theta = math.acos(-cosTheta)
			local invSinTheta = 1/math.sin(theta)
			startInterp = math.sin((t-1)*theta)*invSinTheta
			finishInterp = math.sin(t*theta)*invSinTheta
		else
			startInterp = t-1
			finishInterp = t
		end
	end
	return a[1]*startInterp + b[1]*finishInterp,
	       a[2]*startInterp + b[2]*finishInterp,
	       a[3]*startInterp + b[3]*finishInterp,
	       a[4]*startInterp + b[4]*finishInterp	       
end
lib.QuaternionSlerp = QuaternionSlerp;
lib.quaternionSlerp = QuaternionSlerp;


local function TweenPart(part, a, b, length)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	--
	local c = 0
	local tot = 0
	--
	local startTime = tick()
	while true do
		wait()
		local t = (tick()-startTime)/length
		local _t = 1-t
		if t &gt; 1 then break end
		local startT = tick()
		local cf = QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,
			                             QuaternionSlerp(qa, qb, t))
		tot = tot+(tick()-startT)
		c = c + 1
		part.CFrame = cf
	end
	--print(&quot;Average Cost Per Slerp+ToCFrame:&quot;, string.format(&quot;%.4fms&quot;, tot/c*1000))
end
lib.TweenPart = TweenPart;
lib.tweenPart = TweenPart;


local function SlerpCFrame(a, b, scale)
	-- Same thing as lerp, but with rotation, scale is mapped between 0 and 1... 

	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z


	local _scale = 1-scale;
	--print(scale, _scale)
	return QuaternionToCFrame(_scale * ax + scale*bx, _scale*ay + scale*by, _scale*az + scale*bz,
	                                   QuaternionSlerp(qa, qb, scale))
end
lib.SlerpCFrame = SlerpCFrame;
lib.slerpCFrame = SlerpCFrame;


local function TransformModel(objects, center, new)
	-- Transforms a group of bricks (objects) relative to center to the new CFrame (new).  

	for _,object in pairs(objects) do
		-- if object:IsA(&quot;BasePart&quot;) then
		object.CFrame = new:toWorldSpace(center:toObjectSpace(object.CFrame))
		-- end
	end
end
lib.TransformModel = TransformModel
lib.transformModel = TransformModel

local pointToObjectSpace = CFrame.new().pointToObjectSpace
lib.pointToObjectSpace = pointToObjectSpace
lib.PointToObjectSpace = pointToObjectSpace

local function PointInsidePart(Part, Point)
	local PartSize = Part.Size/2
	local RelativePosition = Part.CFrame:pointToObjectSpace(Point)
	--print(RelativePosition)
	if not (RelativePosition.X &gt;= -PartSize.X and RelativePosition.X &lt;= PartSize.X) then
		return false
	elseif not (RelativePosition.Y &gt;= -PartSize.Y and RelativePosition.Y &lt;= PartSize.Y) then
		return false
	elseif not (RelativePosition.Z &gt;= -PartSize.Z and RelativePosition.Z &lt;= PartSize.Z) then
		return false
	end

	return true	
end
lib.PointInsidePart = PointInsidePart
lib.pointInsidePart = PointInsidePart

local FindPartOnRay = Workspace.FindPartOnRayWithIgnoreList
local AdvanceRaycast

function AdvanceRaycast(Ray, IgnoreList, IgnoreInvisible, IgnoreCollisions)
	-- Abuses raycasing to force ignoring of invisible and collision parts.

	-- IgnoreList should be a metatable __mode = &quot;k&quot;

	local Object, Position = FindPartOnRay(Workspace, Ray, IgnoreList)
	if not Object or ((Object.CanCollide == IgnoreCollisions or not IgnoreCollisions) and (Object.Transparency &lt; 1 or not IgnoreInvisible)) then
		return Object, Position
	else
		IgnoreList[#IgnoreList + 1] = Object
		return AdvanceRaycast(Ray, IgnoreList, IgnoreInvisible, IgnoreCollisions)
	end
end
lib.AdvanceRaycast = AdvanceRaycast
lib.advanceRaycast = AdvanceRaycast

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX54">
<Properties>
<string name="Name">qColor3</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local qString           = LoadCustomLibrary(&quot;qString&quot;)
local qMath             = LoadCustomLibrary(&quot;qMath&quot;)

qSystems:Import(getfenv(0));

local RbxUtility = LoadLibrary(&quot;RbxUtility&quot;)

local lib = {}

--- Manipulation and seralization of Color3 Values
-- @author Quenty
-- Last modified January 3rd, 2013

local function EncodeColor3(Color3)
	--- Encodes a Color3 in JSON
	-- @param Color3 The Color3 to encode
	-- @return String The string representation in JSON of the Color3 value.

	local NewData = {
		Color3.r;
		Color3.g;
		Color3.b;
	}

	return RbxUtility.EncodeJSON(NewData)
end
lib.EncodeColor3 = EncodeColor3
lib.encodeColor3 = EncodeColor3
lib.Encode = EncodeColor3
lib.encode = EncodeColor3

local function DecodeColor3(Data)
	--- decode&apos;s a previously encoded Color3.
	-- @param Data String of JSON, that was encoded.
	-- @return Color3 if it could be decoded, otherwise, nil
	
	if Data then
		local DecodedData = RbxUtility.DecodeJSON(Data)
		if DecodedData then
			return Color3.new(unpack(DecodedData))
		else
			return nil
		end
	else
		return nil
	end
end
lib.DecodeColor3 = DecodeColor3
lib.decodeColor3 = DecodeColor3
lib.Decode = DecodeColor3
lib.decode = DecodeColor3

local LerpNumber = qMath.LerpNumber

local function LerpColor3(ColorOne, ColorTwo, Alpha)
	--- Interpolates between two color3 values. 
	-- @param ColorOne The first Color
	-- @param ColorTwo The second color
	-- @param Alpha The amount to interpolate between
	-- @return The resultent Color3 value. 
	
	return Color3.new(LerpNumber(ColorOne.r, ColorTwo.r, Alpha), LerpNumber(ColorOne.g, ColorTwo.g, Alpha), LerpNumber(ColorOne.b, ColorTwo.b, Alpha))
end
lib.LerpColor3 = LerpColor3
lib.lerpColor3 = LerpColor3

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX55">
<Properties>
<string name="Name">qInstance</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)

qSystems:Import(getfenv(0))

local lib = {}

-- See Type library for more identification stuff.
-- @author Quenty
-- Last Modified Februrary 9th, 2014

local function GetBricks(StartInstance)
	local List = {}

	-- if StartInstance:IsA(&quot;BasePart&quot;) then
	-- 	List[#List+1] = StartInstance
	-- end

	CallOnChildren(StartInstance, function(Item)
		if Item:IsA(&quot;BasePart&quot;) then
			List[#List+1] = Item;
		end
	end)

	return List;
end
lib.GetBricks  = GetBricks
lib.get_bricks = GetBricks
lib.getBricks  = GetBricks

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX56">
<Properties>
<string name="Name">qMath</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&apos;qSystems&apos;)

qSystems:Import(getfenv(0));

local lib = {}

local function ClampNumber(Number, Lower, Upper)
	if Number &gt; Upper then
		return Upper, true
	elseif Number &lt; Lower then
		return Lower, true
	else
		return Number, false
	end
end
lib.ClampNumber = ClampNumber;
lib.clampNumber = ClampNumber;


local function RoundUp(Number, Base)
	return math.ceil(Number/Base) * Base;
end
lib.RoundUp = RoundUp
lib.roundUp = RoundUp


local function RoundNumber(number, divider)
	--verifyArg(number, &quot;number&quot;, &quot;number&quot;)
	--verifyArg(divider, &quot;number&quot;, &quot;divider&quot;, true)

	divider = divider or 1
	return (math.floor((number/divider)+0.5)*divider)
end
lib.roundNumber = RoundNumber
lib.RoundNumber = RoundNumber
lib.round_number = RoundNumber


local function Sign(Number)
	if Number == 0 then
		return 0
	else
		return Number / math.abs(Number) 
	end
end
lib.Sign = Sign
lib.sign = Sign


local function Vector2ToCartisian(Vector2ToConvert, ScreenMiddle)
	--return Vector2.new(Vector2ToConvert.x - ScreenMiddle.x, ScreenMiddle.y - Vector2ToConvert.y)
	return Vector2ToConvert - ScreenMiddle
end
lib.Vector2ToCartisian = Vector2ToCartisian
lib.vector2ToCartisian = Vector2ToCartisian


local function Cartisian2ToVector(CartisianToConvert, ScreenMiddle)
	--return Vector2.new(CartisianToConvert.x + ScreenMiddle.x, ScreenMiddle.y - CartisianToConvert.y)
	return CartisianToConvert + ScreenMiddle
end
lib.Cartisian2ToVector = Cartisian2ToVector 
lib.cartisian2ToVector = Cartisian2ToVector


local function InvertCartisian2(CartisianVector2)
	-- Insert&apos;s a CartisianVector2 value.
	
	return -CartisianVector2
end
lib.InvertCartisian2 =InvertCartisian2
lib.invertCartisian2 =InvertCartisian2

local function LerpNumber(ValueOne, ValueTwo, Alpha)
	--- Interpolates betweeen two numbers, given an Alpha
	-- @param ValueOne A number, the first one, should be less than ValueTwo
	-- @param ValueTwo A number, the second one, should be greater than ValueTwo
	-- @param Alpha The percent, a number in the range [0, 1], that will be used to define
	--              how interpolated it is between ValueOne And ValueTwo
	-- @return The lerped number. 

	return ValueOne + ((ValueTwo - ValueOne) * Alpha)
end
lib.LerpNumber = LerpNumber 
lib.lerpNumber = LerpNumber

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX57">
<Properties>
<string name="Name">qString</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local Type              = LoadCustomLibrary(&quot;Type&quot;)
local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)

qSystems:Import(getfenv(0));

-- @author Quenty
-- Revised January 2nd, 2013
-- This script provides utility functions for strings

-- Change Log --
--- Removed VerifyArg methods

local lib = {}

local function CompareStrings(firstString, secondString)
	-- Compares two strings, ignoring capitals.
	-- @return Boolean if the string found match

	return string.lower(firstString) == string.lower(secondString);
end
lib.CompareStrings = CompareStrings;
lib.compareStrings = CompareStrings;
lib.compare_strings = CompareStrings;
lib.Compare = CompareStrings
lib.compare = CompareStrings
-- lib.Equals = CompareStrings
-- lib.equals = CompareStrings

local function CompareCutFirst(firstString, secondString)
	-- Compare&apos;s two strings, but only the beginning of the first string, to see if it matches the second one
	-- @param firstString The string to &quot;cut&quot; off of
	-- @param secondString The string to compare direct to
	-- @return Boolean if a match or not

	return string.lower(firstString):sub(1, #secondString) == string.lower(secondString);
end
lib.CompareCutFirst = CompareCutFirst;
lib.compareCutFirst = CompareCutFirst;
lib.compare_cut_first = CompareCutFirst;

local function CutoutPrefix(firstString, prefix)

	return firstString:sub(#prefix + 1);
end

local PatternCache = {}
setmetatable(PatternCache, {__mode = &quot;k&quot;})

local function BreakString(StringA, Seperator)
	-- Tokenizer system..
	-- @param Seperator The deliminator 

	local Pattern = Seperator 
	local ActualSeperator = Seperator 

	if type(Seperator) ~= &quot;string&quot; then 
		if PatternCache[Seperator] then
			Pattern = PatternCache[Seperator]
			ActualSeperator = Seperator[1]
		else
			Pattern = &quot;[&quot; 
			for _, PotentialSeperator in pairs(Seperator) do 
				if #PotentialSeperator == 1 then 
					Pattern = Pattern..&quot;%&quot;..PotentialSeperator 
					ActualSeperator = PotentialSeperator; 
				else 
					error(&quot;A Seperator must be 1 character, it was &quot;..#PotentialSeperator..&quot; characters long.&quot;); 
				end 
			end 
			Pattern = Pattern..&quot;]&quot;; 
			PatternCache[Seperator] = Pattern
		end
	elseif #Seperator ~= 1 then
		error(&quot;Seperator must be 1  character, it was &quot;..#Seperator..&quot; characters long.&quot;); 
	end 

	local Parts = {} 
	for NewString in string.gmatch(StringA..ActualSeperator, &quot;.-&quot;..Pattern) do 
		if not (#NewString &lt;= 1) then
			Parts[#Parts+1] = NewString:sub(1, #NewString-1); 
		else
			print(&quot;Empty string: &apos;&quot;..NewString..&quot;&apos;&quot;)
		end
	end 

	return Parts; 
end
lib.breakString = BreakString;
lib.BreakString = BreakString;
lib.break_string = BreakString;

local function TrimString(str, pattern)
	pattern = pattern or &quot;%s&quot;;
	-- %S is whitespaces
	-- When we find the first non space character defined by ^%s 
	-- we yank out anything in between that and the end of the string 
	-- Everything else is replaced with %1 which is essentially nothing  

	-- Credit Sorcus, Modified by Quenty
	return (str:gsub(&quot;^&quot;..pattern..&quot;*(.-)&quot;..pattern..&quot;*$&quot;, &quot;%1&quot;))
end 
lib.TrimString = TrimString
lib.trimString = TrimString
lib.trim_string = TrimString

local function TrimStringFront(str, pattern)
	pattern = pattern or &quot;%s&quot;;

	-- Only trims the front of the string...
	return (str:gsub(&quot;^&quot;..pattern..&quot;*(.-)&quot;..pattern..&quot;*&quot;, &quot;%1&quot;))
end 
lib.TrimStringFront = TrimStringFront
lib.trimStringFront = TrimStringFront
lib.trim_stream_front = TrimStringFront

local function GetRestOfSemiTokenizedString(StringA, Seperator, Counts)
	-- Get&apos;s the rest of a string past a tokenizer count...

	-- Much hax.

	local Count = 0
	local PartToCutOff = 0
	local Pattern = Seperator 
	local ActualSeperator = Seperator 

	if type(Seperator) ~= &quot;string&quot; then 
		if PatternCache[Seperator] then
			Pattern = PatternCache[Seperator]
			ActualSeperator = Seperator[1]
		else
			Pattern = &quot;[&quot; 
			for _, PotentialSeperator in pairs(Seperator) do 
				if #PotentialSeperator == 1 then 
					Pattern = Pattern..&quot;%&quot;..PotentialSeperator 
					ActualSeperator = PotentialSeperator; 
				else 
					error(&quot;A Seperator must be 1 character, it was &quot;..#PotentialSeperator..&quot; characters long.&quot;); 
				end 
			end 
			Pattern = Pattern..&quot;]&quot;; 
			PatternCache[Seperator] = Pattern
		end
	elseif #Seperator ~= 1 then
		error(&quot;Seperator must be 1  character, it was &quot;..#Seperator..&quot; characters long.&quot;); 
	end

	for NewString in string.gmatch(StringA..ActualSeperator, &quot;.-&quot;..Pattern) do 
		if not (#NewString &lt;= 1) then
			PartToCutOff = PartToCutOff + #NewString
			Count = Count + 1
			if Count &gt;= Counts then
				return TrimStringFront(StringA:sub(PartToCutOff), Pattern)
			end
		else
			PartToCutOff = PartToCutOff + 1;
		end
	end
end
lib.GetRestOfSemiTokenizedString = GetRestOfSemiTokenizedString
lib.getRestOfSemiTokenizedString = GetRestOfSemiTokenizedString
lib.get_rest_of_semi_tokenized_string = GetRestOfSemiTokenizedString

local function IsWhitespace(Text) 
	return string.match(Text, &quot;[%s]+&quot;) == Text
end
lib.isWhitespace = IsWhitespace
lib.IsWhitespace = IsWhitespace
lib.is_whitespace = IsWhitespace

local function DumbElipseLimit(Text, CharacterLimit) 
	if #Text &gt; CharacterLimit then 
		Text = Text:sub(1, CharacterLimit-3)..&quot;...&quot; 
	end 
	return Text 
end
lib.DumbElipseLimit = DumbElipseLimit
lib.dumbElipseLimit = DumbElipseLimit

local function CheckNumOfCharacterInString(TheString, Character)
	local Number = 0
	for ID in string.gmatch(TheString, Character) do 
		Number = Number + 1;
	end
	--print(&quot;Checked Num for \&quot;&quot;..TheStr	ng..&quot;\&quot; with the Character \&quot;&quot;..Character..&quot;\&quot; and got &quot;..Number)
	return Number;
end
lib.CheckNumOfCharacterInString = CheckNumOfCharacterInString
lib.checkNumOfCharacterInString = CheckNumOfCharacterInString


local function GetRomanNumeral(Number)
	--- Return&apos;s the Roman Numeral version of the number
	-- @param Number The number to convert

	if type(Number) == &quot;number&quot; then
		local Numbers = {1000; 900; 500; 400; 100; 90; 50; 40; 10; 9; 5; 4; 1;};
		local Numerals = {&quot;M&quot;; &quot;CM&quot;; &quot;D&quot;; &quot;CD&quot;; &quot;C&quot;; &quot;XC&quot;; &quot;L&quot;; &quot;XL&quot;; &quot;X&quot;; &quot;IX&quot;; &quot;V&quot;; &quot;IV&quot;; &quot;I&quot;;}
		local Result = &quot;&quot;;
		if Number &lt; 0 or Number &gt;= 4000 then
			return nil;
		elseif Number == 0 then
			return &quot;N&quot;;
		else
			for Index=1, 13 do
				while Number &gt;= Numbers[Index] do
					Number = Number - Numbers[Index];
					Result = Result..Numerals[Index];
				end
			end
		end
		return Result;
	elseif type(Number == &quot;string&quot;) then
		Number = string.upper(Number);
		local Result = 0;

		local RomanDigit = {
			[&quot;I&quot;] = 1;
			[&quot;V&quot;] = 5;
			[&quot;X&quot;] = 10;
			[&quot;L&quot;] = 50;
			[&quot;C&quot;] = 100;
			[&quot;D&quot;] = 500;
			[&quot;M&quot;] = 1000;
		}

		local SpecialRomanDigit = {
			[&quot;I&quot;] = 1;
			[&quot;X&quot;] = 10;
			[&quot;C&quot;] = 100;
		}

		if Number == &quot;N&quot; then 
			return 0;
		elseif CheckNumOfCharacterInString(Number, &quot;V&quot;) &gt;= 2 or CheckNumOfCharacterInString(Number, &quot;L&quot;) &gt;= 2 or CheckNumOfCharacterInString(Number, &quot;D&quot;) &gt;= 2 then --(#{string.find(Number, &quot;V*.V&quot;)} &gt;= 2) or (#{string.find(Number, &quot;L*.L&quot;)} &gt;= 2) or (#{string.find(Number, &quot;D*.D&quot;)} &gt;= 2) then
			print(&quot;Rule 4&quot;);
			return nil; 
		end

		local Last = &quot;Z&quot;
		local Count = 1;

		for i=1, #Number do
			local Numeral = string.sub(Number, i, i)
			if not RomanDigit[Numeral] then
				print(&quot;Invalid Numeral&quot;);
				return nil;
			end
			if Numeral == Last then
				Count = Count + 1;
				if Count &gt;= 4 then
					print(&quot;Rule 4 (Second check)&quot;);
					return nil;
				end
			else
				Count = 1;
			end
			Last = Numeral
		end

		local Pointer = 1;
		local Values = {}
		local MaxDigit = 1000;

		while Pointer &lt;= #Number do
			local Numeral = string.sub(Number, Pointer, Pointer)
			local Digit = RomanDigit[Numeral]

			if Digit &gt; MaxDigit then
				print(&quot;Rule 3&quot;);
				return nil;
			end

			local NextDigit = 0;
			if Pointer &lt;= #Number - 1 then
				local NextNumeral = string.sub(Number, Pointer+1, Pointer+1);
				NextDigit = RomanDigit[NextNumeral]

				if NextDigit &gt; Digit then
					if (not SpecialRomanDigit[Numeral]) or NextDigit &gt; (Digit * 10) or CheckNumOfCharacterInString(Number, Numeral) &gt; 3 then --(#{string.find(Number, Numeral..&quot;*.&quot;..Numeral)} &gt;= 3) then
						print(&quot;Rule 3 (Second check)&quot;);
						return nil;
					end
					MaxDigit = Digit - 1;
					Digit = NextDigit - Digit
					Pointer = Pointer + 1;
				end
			end

			Values[#Values + 1] = Digit
			Pointer = Pointer + 1;
		end

		--print(&quot;#Values = &quot;..#Values)
		for Index = 1, #Values-1 do
			print(Index..&quot; : &quot;..Values[Index])
			if Values[Index] &lt; Values[Index + 1] then
				print(&quot;Rule 5&quot;);
				return nil;
			end
		end

		local Total = 0;
		for Index, Digit in pairs(Values) do
			Total = Total + Digit;
		end
		return Total;
	end
end
lib.GetRomanNumeral = GetRomanNumeral
lib.getRomanNumeral = GetRomanNumeral

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX58">
<Properties>
<string name="Name">Quaternion</string>
<ProtectedString name="Source">-- Quaternion.lua

--By xXxMoNkEyMaNxXx
-- Modified by Quenty

--[[
God, grant me the serenity to accept the things I cannot change,
The courage to change the things I can,
And wisdom to know the difference.

I cannot change most of this.
]]
local next     = next
local tick     = tick
local type     = type
local print    = print
local select   = select
local tostring = tostring

local pi       = math.pi
local tau      = 2*pi
local abs      = math.abs
local cos,sin  = math.cos,math.sin
local sqrt     = math.sqrt
local atan2    = math.atan2
local max      = math.max

local vec3     = Vector3.new
local CF       = CFrame.new

local iv       = vec3()
local iq       = {1,0,0,0}

local lib = {}

local function BezierPosition(x0,x1,v0,v1,t)
	local T=1-t
	return x0*T*T*T+(3*x0+v0)*t*T*T+(3*x1-v1)*t*t*T+x1*t*t*t
end
local function BezierVelocity(x0,x1,v0,v1,t)
	local T=1-t
	return v0*T*T+2*(3*(x1-x0)-(v1+v0))*t*T+v1*t*t
end

local function Qmul(q1,q2) -- Multiply
	local w1,x1,y1,z1,w2,x2,y2,z2=q1[1],q1[2],q1[3],q1[4],q2[1],q2[2],q2[3],q2[4]
	return {w1*w2-x1*x2-y1*y2-z1*z2,w1*x2+x1*w2+y1*z2-z1*y2,w1*y2-x1*z2+y1*w2+z1*x2,w1*z2+x1*y2-y1*x2+z1*w2}
end

local function Qinv(q)--Inverse. (q^-1)
	local w,x,y,z=q[1],q[2],q[3],q[4]
	local m=w*w+x*x+y*y+z*z
	if m&gt;0 then
		return {w/m,-x/m,-y/m,-z/m}
	else
		return {0,0,0,0}
	end
end

local function Qpow(q,exponent,choice)
	choice=choice or 0
	local w,x,y,z=q[1],q[2],q[3],q[4]
	local vv=x*x+y*y+z*z
	if vv&gt;0 then
		--Convert to polar form and exponentiate (all in one go)
		local v=sqrt(vv)
		local m=(w*w+vv)^(0.5*exponent)
		local theta=exponent*(atan2(v,w)+tau*choice)--swag
		local s=m*sin(theta)/v
		return {m*cos(theta),x*s,y*s,z*s}
	else--This is a regular number.  srs.  lol.
		if w&lt;0 then--Quaternions, umad? u dun fool me nub
			local m=(-w)^exponent
			local s=m*sin(pi*exponent)*sqrt(3)/3
			return {m*cos(pi*exponent),s,s,s}
		else
			return {w^exponent,0,0,0}
		end
	end
end

local function QuaternionFromCFrame(cf)
	local mx,my,mz,m00,m01,m02,m10,m11,m12,m20,m21,m22=cf:components()
	local trace=m00+m11+m22
	if trace&gt;0 then
		local s=sqrt(1+trace)
		local recip=0.5/s
		return s*0.5,(m21-m12)*recip,(m02-m20)*recip,(m10-m01)*recip
	else
		local big=max(m00,m11,m22)
		if big==m00 then
			local s=sqrt(1+m00-m11-m22)
			local recip=0.5/s
			return (m21-m12)*recip,0.5*s,(m10+m01)*recip,(m02+m20)*recip
		elseif big==m11 then
			local s=sqrt(1-m00+m11-m22)
			local recip=0.5/s
			return (m02-m20)*recip,(m10+m01)*recip,0.5*s,(m21+m12)*recip
		elseif big==m22 then
			local s=sqrt(1-m00-m11+m22)
			local recip=0.5/s
			return (m10-m01)*recip,(m02+m20)*recip,(m21+m12)*recip,0.5*s
		end
	end
end

local function SlerpQuaternions(q0, q1, t)
	return Qmul(q0, Qpow(Qmul(q1, Qinv(q0)), t))
end

local function QuaternionToCFrame(q)
	local w,x,y,z=q[1],q[2],q[3],q[4]
	local xs,ys,zs=x+x,y+y,z+z
	local wx,wy,wz=w*xs,w*ys,w*zs
	local xx,xy,xz,yy,yz,zz=x*xs,x*ys,x*zs,y*ys,y*zs,z*zs
	return 1-(yy+zz),xy-wz,xz+wy,xy+wz,1-(xx+zz),yz-wx,xz-wy,yz+wx,1-(xx+yy)
end

local function BezierRotation(q0,q1,w0,w1,t)
	local _30,_31,_32,_33=q0,Qmul(q0,w0),Qmul(q1,Qinv(w1)),q1
	local _20,_21,_22=Qmul(_30,Qpow(Qmul(Qinv(_30),_31),t)),Qmul(_31,Qpow(Qmul(Qinv(_31),_32),t)),Qmul(_32,Qpow(Qmul(Qinv(_32),_33),t))
	local _10,_11=Qmul(_20,Qpow(Qmul(Qinv(_20),_21),t)),Qmul(_21,Qpow(Qmul(Qinv(_21),_22),t))
	local _00=Qmul(_10,Qpow(Qmul(Qinv(_10),_11),t))
	return _00
end
local function BezierAngularV(q0,q1,w0,w1,t)
	local _30,_31,_32,_33=q0,Qmul(q0,w0),Qmul(q1,Qinv(w1)),q1
	local _20,_21,_22=Qmul(Qinv(_30),_31),Qmul(Qinv(_31),_32),Qmul(Qinv(_32),_33)
	local _10,_11=Qmul(_20,Qpow(Qmul(Qinv(_20),_21),t)),Qmul(_21,Qpow(Qmul(Qinv(_21),_22),t))
	local _00=Qmul(_10,Qpow(Qmul(Qinv(_10),_11),t))
	return _00
end

--Regular tweening
local TweenData={}
local Tweens=setmetatable({},{
	__index=function(self,i)
		local data=TweenData[i]
		if data then
			local timeNow,t0,t1=tick(),data.t0,data.t1
			if timeNow&gt;t0 and timeNow&lt;t1 then
				return BezierPosition(data.x0,data.x1,data.v0,data.v1,(timeNow-t0)/(t1-t0))
			elseif timeNow&gt;=t1 then
				return data.x1
			elseif timeNow&lt;=t0 then--Whatever.
				return data.x0
			end
		end
	end,
	__newindex=function(self,i,v)
		local data=TweenData[i]
		if data then
			local timeNow,t0,t1,x0,x1,v0,v1=tick(),data.t0,data.t1
			if timeNow&gt;t0 and timeNow&lt;t1 then
				local dt=t1-t0
				local t=(timeNow-t0)/dt
				x0,x1,v0,v1=BezierPosition(data.x0,data.x1,data.v0,data.v1,t),v,BezierVelocity(data.x0,data.x1,data.v0,data.v1,t)/dt,v*0
			elseif timeNow&gt;=t1 then
				x0,x1,v0,v1=data.x1,v,v*0,v*0
			elseif timeNow&lt;=t0 then
				x0,x1,v0,v1=data.x0,v,v*0,v*0
			end
			local dt,time=1,data.time
			local timeType=type(time)
			if timeType==&quot;number&quot; then
				dt=time
			elseif timeType==&quot;function&quot; then
				dt=time(x0,x1,v0,v1)
			end
			data.x0,data.x1,data.v0,data.v1,data.t0,data.t1,data.tweening=x0,x1,dt*v0,dt*v1,timeNow,timeNow+dt,true
		else
			print(&quot;A value named &quot;..tostring(i)..&quot; has not yet been created.&quot;)
		end
	end,
})
lib.Tweens = Tweens

--Quaternion tweening
local QuaternionTweenData={}
local QuaternionTweens=setmetatable({},{
	__index=function(self,i)
		local data=QuaternionTweenData[i]
		if data then
			local timeNow,t0,t1=tick(),data.t0,data.t1
			if timeNow&gt;t0 and timeNow&lt;t1 then
				return BezierRotation(data.q0,data.q1,data.w0,data.w1,(timeNow-t0)/(t1-t0))
			elseif timeNow&gt;=t1 then
				return data.q1
			elseif timeNow&lt;=t0 then--Whatever.
				return data.q0
			end
		end
	end,
	__newindex=function(self,i,v)
		local data=QuaternionTweenData[i]
		if data then
			local timeNow,t0,t1,q0,q1,w0,w1=tick(),data.t0,data.t1
			if timeNow&gt;t0 and timeNow&lt;t1 then
				local dt=t1-t0
				local t=(timeNow-t0)/dt
				q0,q1,w0,w1=BezierRotation(data.q0,data.q1,data.w0,data.w1,t),v,Qpow(BezierAngularV(data.q0,data.q1,data.w0,data.w1,t),1/dt),iq
			elseif timeNow&gt;=t1 then
				q0,q1,w0,w1=data.q1,v,iq,iq
			elseif timeNow&lt;=t0 then
				q0,q1,w0,w1=data.q0,v,iq,iq
			end
			if data.autoChoose then
				if q0[1]*q1[1]+q0[2]*q1[2]+q0[3]*q1[3]+q0[4]*q1[4]&lt;0 then
					q1={-q1[1],-q1[2],-q1[3],-q1[4]}
				end
			end
			local dt,time=1,data.time
			local timeType=type(time)
			if timeType==&quot;number&quot; then
				dt=time
			elseif timeType==&quot;function&quot; then
				dt=time(q0,q1,w0,w1)
			end
			data.q0,data.q1,data.w0,data.w1,data.t0,data.t1,data.tweening=q0,q1,Qpow(w0,dt),Qpow(w1,dt),timeNow,timeNow+dt,true
		else
			print(&quot;A value named &quot;..tostring(i)..&quot; has not yet been created.&quot;)
		end
	end,
})
lib.QuaternionTweens = QuaternionTweens

--CFrame tweening
local CFrameTweenData={}
local CFrameTweens=setmetatable({},{
	__index=function(self,i)
		local data=CFrameTweenData[i]
		if data then
			local timeNow,t0,t1=tick(),data.t0,data.t1
			if timeNow&gt;t0 and timeNow&lt;t1 then
				local t=(timeNow-t0)/(t1-t0)
				local p=BezierPosition(data.x0,data.x1,data.v0,data.v1,t)
				return CF(p.x,p.y,p.z,QuaternionToCFrame(BezierRotation(data.q0,data.q1,data.w0,data.w1,t)))
			elseif timeNow&gt;=t1 then
				return data.c1
			elseif timeNow&lt;=t0 then--Whatever.
				return data.c0
			end
		end
	end,
	__newindex=function(self,i,v)
		local data=CFrameTweenData[i]
		if data then
			local timeNow,t0,t1,x0,x1,v0,v1,q0,q1,w0,w1=tick(),data.t0,data.t1
			if timeNow&gt;t0 and timeNow&lt;t1 then
				local dt=t1-t0
				local t=(timeNow-t0)/dt
				x0,x1,v0,v1,q0,q1,w0,w1=BezierPosition(data.x0,data.x1,data.v0,data.v1,t),v.p,BezierVelocity(data.x0,data.x1,data.v0,data.v1,t)/dt,iv,BezierRotation(data.q0,data.q1,data.w0,data.w1,t),{QuaternionFromCFrame(v)},Qpow(BezierAngularV(data.q0,data.q1,data.w0,data.w1,t),1/dt),iq
			elseif timeNow&gt;=t1 then
				x0,x1,v0,v1,q0,q1,w0,w1=data.x1,v.p,iv,iv,data.q1,{QuaternionFromCFrame(v)},iq,iq
			elseif timeNow&lt;=t0 then
				x0,x1,v0,v1,q0,q1,w0,w1=data.x0,v.p,iv,iv,data.q0,{QuaternionFromCFrame(v)},iq,iq
			end
			local a1,b1,c1,d1,a2,b2,c2,d2=q0[1]-q1[1],q0[2]-q1[2],q0[3]-q1[3],q0[4]-q1[4],q0[1]+q1[1],q0[2]+q1[2],q0[3]+q1[3],q0[4]+q1[4]
			if a1*a1+b1*b1+c1*c1+d1*d1&gt;a2*a2+b2*b2+c2*c2+d2*d2 then
				q1={-q1[1],-q1[2],-q1[3],-q1[4]}
			end
			local c0=CF(x0.x,x0.y,x0.z,QuaternionToCFrame(q0))
			local dt,time=1,data.time
			local timeType=type(time)
			if timeType==&quot;number&quot; then
				dt=time
			elseif timeType==&quot;function&quot; then
				dt=time(c0,v,x0,x1,v0,v1,q0,q1,w0,w1)--lol
			end
			data.c0,data.c1,data.x0,data.x1,data.v0,data.v1,data.q0,data.q1,data.w0,data.w1,data.t0,data.t1,data.tweening=c0,v,x0,x1,v0*dt,v1*dt,q0,q1,Qpow(w0,dt),Qpow(w1,dt),timeNow,timeNow+dt,true
		else
			print(&quot;A value named &quot;..tostring(i)..&quot; has not yet been created.&quot;)
		end
	end,
})
lib.CFrameTweens = CFrameTweens

local function updateTweens(timeNow)
	for i,data in next,TweenData do
		local f,t0,t1=data.update,data.t0,data.t1
		if f then
			if data.tweening then
				if timeNow&gt;t0 and timeNow&lt;t1 then
					f(BezierPosition(data.x0,data.x1,data.v0,data.v1,(timeNow-t0)/(t1-t0)))
				elseif timeNow&gt;=t1 then
					f(data.x1)
					data.tweening=false
				end
			elseif timeNow&lt;=t0 then
				data.tweening=true
			end
		end
	end
end
lib.updateTweens = updateTweens

local function updateQuaternionTweens(timeNow)
	for i,data in next,QuaternionTweenData do
		local f,t0,t1=data.update,data.t0,data.t1
		if f then
			if data.tweening then
				if timeNow&gt;t0 and timeNow&lt;t1 then
					f(BezierRotation(data.q0,data.q1,data.w0,data.w1,(timeNow-t0)/(t1-t0)))
				elseif timeNow&gt;=t1 then
					f(data.q1)
					data.tweening=false
				end
			elseif timeNow&lt;=t0 then
				data.tweening=true
			end
		end
	end
end
lib.updateQuaternionTweens = updateQuaternionTweens

local function updateCFrameTweens(timeNow)
	for i,data in next,CFrameTweenData do
		local f,t0,t1=data.update,data.t0,data.t1
		if f then
			if data.tweening then
				if timeNow&gt;t0 and timeNow&lt;t1 then
					local t=(timeNow-t0)/(t1-t0)
					local p=BezierPosition(data.x0,data.x1,data.v0,data.v1,t)
					f(CF(p.x,p.y,p.z,QuaternionToCFrame(BezierRotation(data.q0,data.q1,data.w0,data.w1,t))))
				elseif timeNow&gt;=t1 then
					f(data.c1)
					data.tweening=false
				end
			elseif timeNow&lt;=t0 then
				data.tweening=true
			end
		end
	end
end
lib.updateCFrameTweens = updateCFrameTweens

local function newTween(name,value,updateFunction,time)
	TweenData[name]={x0=value,x1=value,v0=value*0,v1=value*0,t0=0,t1=tick(),time=time or 1,update=updateFunction,tweening=false}
	if updateFunction then
		updateFunction(value)--Just in case c:
	end
end
lib.newTween = newTween

local function newQuaternionTween(name,value,updateFunction,time,autoChoose)
	QuaternionTweenData[name]={q0=value,q1=value,w0=iq,w1=iq,t0=0,t1=tick(),time=time or 1,update=updateFunction,tweening=false,autoChoose=autoChoose==nil or autoChoose}
	if updateFunction then
		updateFunction(value)--Just in case c:
	end
end
lib.newQuaternionTween = newQuaternionTween

local function newCFrameTween(name,value,updateFunction,time)
	local q={QuaternionFromCFrame(value)}
	CFrameTweenData[name]={c0=value,c1=value,x0=value.p,x1=value.p,v0=iv,v1=iv,q0=q,q1=q,w0=iq,w1=iq,t0=0,t1=tick(),time=time or 1,update=updateFunction,tweening=false}
	if updateFunction then
		updateFunction(value)--Just in case c:
	end
end
lib.newCFrameTween = newCFrameTween

return lib
-- return {Tweens=Tweens,QuaternionTweens=QuaternionTweens,CFrameTweens=CFrameTweens,updateTweens=updateTweens,updateQuaternionTweens=updateQuaternionTweens,updateCFrameTweens=updateCFrameTweens,newTween=newTween,newQuaternionTween=newQuaternionTween,newCFrameTween=newCFrameTween}
</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX59">
<Properties>
<string name="Name">Table</string>
<ProtectedString name="Source">-- This library handles a variety of table-based operations, which can be quite useful.
-- @author Quenty
-- Revised January 1st, 2013

local lib = {}

local function Count(Table)
	local Count = 0;
	for _, _ in pairs(Table) do
		Count = Count + 1
	end
	return Count
end
lib.Count = Count
lib.count = Count

local function CopyAndAppendTable(OriginalTable, Appendees)
	-- Copies a table, and appends the values in appendees.

	local NewTable = {}

	for Index, Value in pairs(OriginalTable) do
		NewTable[Index] = Value;
	end

	for Index, Value in pairs(Appendees) do
        NewTable[Index] = Value;
    end

	return NewTable;
end
lib.CopyAndAppend = CopyAndAppendTable
lib.copyAndAppend = CopyAndAppendTable
lib.copy_and_append = CopyAndAppendTable


local GetStringTable
function GetStringTable(Array, Indent, PrintValue)
	-- Print&apos;s `Array` recursively with `Indent` as the initial indent
	-- Cheap method, but not optimal either... Used for debugging. :D

	PrintValue = PrintValue or tostring(Array);
	Indent = Indent or 0
	for Index, Value in pairs(Array) do
		local FormattedText = &quot;\n&quot; .. string.rep(&quot;  &quot;, Indent) .. tostring(Index) .. &quot;: &quot;
		if type(Value) == &quot;table&quot; then
			PrintValue = PrintValue .. FormattedText
			PrintValue = GetStringTable(Value, Index + 1, PrintValue)
		else
			PrintValue = PrintValue .. FormattedText .. tostring(Value)
		end
	end
	return PrintValue
end
lib.GetStringTable = GetStringTable
lib.getStringTable = GetStringTable
lib.get_string_table = GetStringTable


local function Append(Table, NewTable, Callback)
	-- Addes all of NewTable&apos;s values to Table..

	if Callback then
		for _, Item in pairs(NewTable) do
			if Callback(Item) then
				table.insert(Table, Item)
			end
		end
	else
		for _, Item in pairs(NewTable) do
			table.insert(Table, Item)
		end
	end

	return Table
end
lib.Append = Append
lib.append = Append

local function DirectAppend(Table, NewTable, Callback)
-- Addes al of NewTable&apos;s values to Table..
	if Callback then
		for Index, Item in pairs(NewTable) do
			if Callback(Item) then
				Table[Index] = Item
			end
		end
	else
		for Index, Item in pairs(NewTable) do
			Table[Index] = Item
		end
	end

	return Table
end
lib.DirectAppend = DirectAppend
lib.directAppend = DirectAppend

local function CopyTable(OriginalTable)
	local OriginalType = type(OriginalTable)
	local Copy
	if OriginalType == &apos;table&apos; then
		Copy = {}
		for Index, Value in pairs(OriginalTable) do
			Copy[Index] = Value
		end
	else
		Copy = OriginalTable
	end
	return Copy
end

lib.Copy = CopyTable
lib.copy = CopyTable


local DeepCopy

function DeepCopyTable(OriginalTable)
	local OriginalType = type(OriginalTable)
	local Copy
	if OriginalType == &apos;table&apos; then
		Copy = {}
		for Index, Value in next, OriginalTable, nil do
			Copy[DeepCopy(Index)] = DeepCopy(Value)
		end
		setmetatable(Copy, DeepCopy(getmetatable(OriginalTable)))
	else
		Copy = OriginalTable
	end
	return Copy
end

lib.DeepCopy = DeepCopyTable
lib.deepCopy = DeepCopyTable
lib.deep_copy = DeepCopyTable

local function Swap(Table, A, B)
	local Copy = Table[A]
	Table[A] = Table[B]
	Table[B] = Copy
end

local function ShellSort(Table, GetValue)
	-- Shell Sort -- Pretty efficient... GetValue should return a number of some sort. Will sort from Least to Greatest.

	local TableSize = #Table
	local Gap = #Table
	repeat
		local Switched
		repeat
			Switched = false;
			local Index = 1
			while Index + Gap &lt;= TableSize do
				if GetValue(Table[Index]) &gt; GetValue(Table[Index+Gap]) then
					Swap(Table, Index, Index + Gap)
					Switched = true;
				end
				Index = Index + 1;
			end
		until not Switched
		Gap = math.floor(Gap / 2)
	until Gap == 0
end
lib.ShellSort = ShellSort
lib.shellSort = ShellSort
lib.shell_sort = ShellSort

return lib</ProtectedString>
</Properties>
</Item>
</Item>
<Item class="ModuleScript" referent="RBX60">
<Properties>
<string name="Name">EasyConfiguration</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local Type              = LoadCustomLibrary(&quot;Type&quot;)

qSystems:Import(getfenv(0));

-- EasyConfiguration.lua
-- @author Quenty
-- Last Modified February 3rd, 2014

local lib = {}

local AcceptableTypes = { -- Anything in here has a .Value property. 
	[&quot;StringValue&quot;]     = true;
	[&quot;IntValue&quot;]        = true;
	[&quot;NumberValue&quot;]     = true;
	[&quot;BrickColorValue&quot;] = true;
	[&quot;BoolValue&quot;]       = true;
	[&quot;Color3Value&quot;]     = true;
	[&quot;Vector3Value&quot;]    = true;
}

local function TypeIsAcceptable(TypeName)
	return AcceptableTypes[TypeName]
end
lib.TypeIsAcceptable = TypeIsAcceptable;
lib.typeIsAcceptable = TypeIsAcceptable

local function AddSubDataLayer(DataName, Parent)
	-- For organization of data. Adds another configuration with the name &quot;DataName&quot;, if one can&apos;t be found, and then returns it. 

	local DataContainer = Parent:FindFirstChild(DataName) or Make &apos;Configuration&apos; {
		Name = DataName;
		Parent = Parent;
		Archivable = true;
	}

	return DataContainer
end
lib.AddSubDataLayer = AddSubDataLayer
lib.addSubDataLayer = AddSubDataLayer

local EasyConfigCache = {}
setmetatable(EasyConfigCache, {__mode = &quot;k&quot;})

local function MakeEasyConfiguration(Configuration)
	if EasyConfigCache[Configuration] then
		return EasyConfigCache[Configuration]
	else
		local NewConfiguration = {}

		local function Get(ObjectName)
			return Configuration:FindFirstChild(ObjectName)
		end

		setmetatable(NewConfiguration, {
			__index = function(_, value)

				if not type(value) == &quot;string&quot; then
					error(&quot;Only Indexing with strings is supported with easyConfiguration&quot;, 2)
				end

				local loweredValue = value:lower()

				if loweredValue == &quot;add&quot; or loweredValue == &quot;addvalue&quot; then
					--[[ 
					So they can do stuff like... Config.AddValue(&apos;IntValue&apos;, {
						Name = &quot;PizzaEaten&quot;
						Value = 0;
					})

					--]]
					return function(valueType, values)
						local Object

						if values and values.Name and type(values.Name) == &quot;string&quot; then
							Object = Get(values.Name)
							if Object and Object.ClassName ~= valueType then
								print(&quot;[EasyConfiguration] - Invalid class &apos;&quot;..Object.ClassName..&quot;&apos; in configuration, being replaced by new data &apos;&quot;..valueType..&quot;&apos;&quot;);
								Object:Destroy()
								Object = nil;
							end
						else
							error(&quot;[EasyConfiguration] - No values received in the add method of easy configuration. Please give a table of default properties including the name. &quot;, 2)
						end

						if not Object then
							local newInstance = Instance.new(valueType)
							Modify(newInstance, values)
							newInstance.Parent = Configuration
						end
					end
				elseif loweredValue == &quot;get&quot; or loweredValue == &quot;getvalue&quot; then
					return function(name)
						return Get(name)
					end
				elseif loweredValue == &quot;getcontainer&quot; then
					return function(name)
						return Get(name)
					end
				else
					local Object = Configuration:FindFirstChild(value)
					if Object and AcceptableTypes[Object.ClassName] then
						return Object.Value
					else
						error(&quot;[EasyConfiguration] - &quot; .. (Object and &quot;Object &apos;&quot;..value..&quot;&apos; was a &quot;..Type.getType(Object)..&quot; value, and not acceptable, so no return was given&quot; or &quot;Could not find Object &apos;&quot;..value..&quot;&apos; in the configuration&quot;), 2)
					end
				end
			end;
			__newindex = function(_, value, newValue)
				if type(value) == &quot;string&quot; then
					local Object = Get(value)
					if Object and AcceptableTypes[Object.ClassName] then
						Object.Value = newValue;
					else
						error(&quot;[EasyConfiguration] - Value &apos;&quot; .. value .. &quot;&apos; was not accepted, or wasn&apos;t in the configuration&quot;, 2);
					end
				else
					error(&quot;[EasyConfiguration] - Index with a string&quot;)
				end
			end;
		})

		EasyConfigCache[Configuration] = NewConfiguration
		return NewConfiguration;
	end
end

lib.Make = MakeEasyConfiguration;
lib.MakeEasyConfiguration = MakeEasyConfiguration;

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX61">
<Properties>
<string name="Name">EnumInterpreter</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local qString           = LoadCustomLibrary(&quot;qString&quot;)

local lib               = {}

-- EnumInterpreter.lua
-- @author Quenty
-- Last Modified February 3rd, 2014

qSystems:import(getfenv(0));

local function Scan(Table, StringName)
	for Index, Value in pairs(Table) do
		if qString.CompareStrings(Value, StringName) then
			return Index;
		end
	end
	return nil;
end

local function ScanName(Table, StringName)
	for Index, Value in pairs(Table) do
		if qString.CompareStrings(Value, StringName) then
			return Value;
		end
	end
	return nil;
end

local function GetEnum(EnumTable, EnumValue) 
--[[ Given a table structured like this:

	Foods = {
		&quot;Pizza&quot;;
		&quot;Pie&quot;;
		&quot;Vanilla&quot;;
	}

	And an EnumValue, like one of the following:
		pizza
		pie
		vanilla
		0
		1
		2

	It&apos;ll return the enum ID (Number)...

		pizze --&gt; 0
		0 --&gt; 0

		etc. 
--]]

	if tonumber(EnumValue) and EnumTable[tonumber(EnumValue)] then
		return EnumValue;
	else
		local ScanResult = Scan(EnumTable, EnumValue)
		if ScanResult and tonumber(ScanResult) then
			return ScanResult;
		else
			error(&quot;EnumValue expected, could not interpret &apos;&quot;..tostring(EnumValue)..&quot;&apos; into an Enum #&quot;)
		end
	end
end

lib.getEnum = GetEnum;
lib.GetEnum = GetEnum;
lib.get_enum = GetEnum;

local function GetEnumName(EnumTable, EnumValue)
	if tonumber(EnumValue) and EnumTable[tonumber(EnumValue)] then
		return EnumTable[tonumber(EnumValue)];
	else
		local ScanResult = ScanName(EnumTable, EnumValue)
		if ScanResult then
			return ScanResult;
		else
			error(&quot;EnumValue expected, could not interpret &apos;&quot;..tostring(EnumValue)..&quot;&apos; into an Enum #&quot;)
		end
	end
end

lib.getEnumName = GetEnumName;
lib.GetEnumName = GetEnumName;
lib.get_enum_name = GetEnumName;



return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX62">
<Properties>
<string name="Name">OverriddenConfiguration</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local Players           = game:GetService(&quot;Players&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)

qSystems:Import(getfenv(0));

-- OverriddenConfiguration.lua
-- @author Quenty
-- Last modified January 25th, 2014

--[[-- Change log
-- Janaurty 26th, 2014
- Added change log
- Updated so UserConfiguration may be nil

-- January 25th, 2014
- Wrote initial script

--]]
local lib = {}

local function MakeOverridenConfiguration(UserConfiguration, DefaultConfiguration)
	--- Makes a configuration that can be overridden be a user when constructing. Shallow update.
	-- @param UserConfiguration Table. The configuration that the user provides. May be incomplete or empty.
	-- @param DefaultConfiguration Table. The default configuration. 
	
	if UserConfiguration then
		local NewTable = {}

		for Index, Value in pairs(DefaultConfiguration) do
			if UserConfiguration[Index] then
				NewTable[Index] = UserConfiguration[Index]
			else
				NewTable[Index] = Value
			end
		end

		return NewTable
	else
		return DefaultConfiguration
	end
end
lib.MakeOverridenConfiguration = MakeOverridenConfiguration
lib.makeOverridenConfiguration = MakeOverridenConfiguration
lib.New = MakeOverridenConfiguration
lib.new = MakeOverridenConfiguration

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX63">
<Properties>
<string name="Name">qCamera</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&apos;qSystems&apos;)
local qCFrame           = LoadCustomLibrary(&apos;qCFrame&apos;)

qSystems:Import(getfenv(0))

local lib = {}

local function PointCamera(CoordinateFrame, Focus)
	Workspace.CurrentCamera.Focus = Focus
	Workspace.CurrentCamera.CoordinateFrame = CFrame.new(CoordinateFrame.p, Focus.p)
end
lib.PointCamera = PointCamera
lib.pointCamera = PointCamera

local function SetCurrentCameraToScriptable()
	--[[local CoordinateFrame, Focus = Workspace.CurrentCamera.CoordinateFrame.p, Workspace.CurrentCamera.Focus
	Workspace.CurrentCamera:Destroy()
	wait(0)
	while not Workspace.CurrentCamera do wait(0) end
	Workspace.CurrentCamera.CameraType = &quot;Scriptable&quot;
	Workspace.CurrentCamera.CoordinateFrame = CFrame.new(CoordinateFrame, Focus.p)
	Workspace.CurrentCamera.Focus = Focus
	return CoordinateFrame, Focus--]]

	Workspace.CurrentCamera.CameraType = &quot;Scriptable&quot;;
end
lib.SetCurrentCameraToScriptable = SetCurrentCameraToScriptable
lib.setCurrentCameraToScriptable = SetCurrentCameraToScriptable
lib.SetCameraToScriptable = SetCurrentCameraToScriptable
lib.setCameraToScriptable = SetCurrentCameraToScriptable


local function ShakeCamera(c0,f0,intensity,durration,opposite)
	local t = time()
	local i = (intensity/2)
	local i2 = i
	while ((time()-t) &lt; durration) do
		if (skip) then break end
		if (opposite) then
			i = (i2*((time()-t)/durration))
		else
			i = (i*(1-((time()-t)/durration)))
		end
		Workspace.CurrentCamera.CoordinateFrame = (c0*CFrame.new((-i+(math.random()*i)),(-i+(math.random()*i)),(-i+(math.random()*i))))
		Workspace.CurrentCamera.Focus = (f0*CFrame.new((-i+(math.random()*i)),(-i+(math.random()*i)),(-i+(math.random()*i))))
		wait(0)
	end
	Workspace.CurrentCamera.CoordinateFrame = c0
	Workspace.CurrentCamera.Focus = f0
end

lib.ShakeCamera = ShakeCamera
lib.shakeCamera = ShakeCamera

local function SetPlayerControl()
	if Players.LocalPlayer.Character then
		Workspace.CurrentCamera.CameraSubject = Players.LocalPlayer.Character:FindFirstChild(&quot;Humanoid&quot;)
	end
	Workspace.CurrentCamera.CameraType = &quot;Custom&quot;
end
lib.SetPlayerControl = SetPlayerControl
lib.setPlayerControl = SetPlayerControl


local TweenCameraOverideId = 0
local OpeatingTweenCamera = false;

local function TweenCamera(CoordinateFrameTarget, FocusTarget, TimeToTween, Override, RollTarget, FieldOfViewTarget)
	SetCurrentCameraToScriptable()
	Spawn(function()
		if Override and OpeatingTweenCamera then
			--print(&quot;Camera Tween: Overriding operation&quot;);
			TweenCameraOverideId = TweenCameraOverideId+1;
		elseif OpeatingTweenCamera then
			--print(&quot;Camera Tween: Did not override, old operation is continueing&quot;);
			return false;
		end
		OpeatingTweenCamera = true;

		FieldOfViewTarget = FieldOfViewTarget or Workspace.CurrentCamera.FieldOfView
		RollTarget = RollTarget or Workspace.CurrentCamera:GetRoll()

		local CurrentNumber = TweenCameraOverideId;
		local OriginalRoll = Workspace.CurrentCamera:GetRoll()
		local OriginalFieldOfView = Workspace.CurrentCamera.FieldOfView
		local CoordinateFocusStart = Workspace.CurrentCamera.Focus.p
		local CoordinateFrameStart = CFrame.new(Workspace.CurrentCamera.CoordinateFrame.p, CoordinateFocusStart)
		local CoordinateFrameFinish = CFrame.new(CoordinateFrameTarget, FocusTarget)

		local RepetitionIntervol = (1/(TimeToTween/wait(0)))
		local Repetitions

		for Index = 0, 1, RepetitionIntervol do
			local SmoothIndex = math.sin((Index - 0.5) * math.pi)/2 + 0.5
			local Focus = CoordinateFocusStart:lerp(FocusTarget, SmoothIndex)
			Workspace.CurrentCamera.CoordinateFrame = qCFrame.SlerpCFrame(CoordinateFrameStart, CoordinateFrameFinish, SmoothIndex)
			Workspace.CurrentCamera.Focus = CFrame.new(Focus)
			Workspace.CurrentCamera:SetRoll(OriginalRoll + ((RollTarget - OriginalRoll) * SmoothIndex))
			Workspace.CurrentCamera.FieldOfView = OriginalFieldOfView + ((FieldOfViewTarget - OriginalFieldOfView)) * SmoothIndex
			wait(0)

			if TweenCameraOverideId ~= CurrentNumber then
				return false;
			end
		end

		OpeatingTweenCamera = false;
		PointCamera(CFrame.new(CoordinateFrameTarget), CFrame.new(FocusTarget))
		Workspace.CurrentCamera:SetRoll(RollTarget)
		Workspace.CurrentCamera.FieldOfView = FieldOfViewTarget
		return true;
	end)
end
lib.TweenCamera = TweenCamera
lib.tweenCamera = TweenCamera

local AdvanceRaycast = qCFrame.AdvanceRaycast

local MakeCameraSystem = Class(function(CameraSystem, Player)
	local CurrentState
	local States = {}

	local IgnoreList = {}
	setmetatable(IgnoreList, {__mode = &quot;k&quot;})

	local function SetCurrentState(Name)
		if States[Name] then
			if CurrentState.OnStop then
				CurrentState:OnStop(Player, Mouse, Camera)
			end
			CurrentState = States[Name]
			if CurrentState.OnStart then
				CurrentState:OnStart(Player, Mouse, Camera)
			end
		elseif Name == &quot;Custom&quot; then
			CurrentState = nil
		else
			error(&quot;State &quot;..Name..&quot; does not exist&quot;)
		end
	end

	do
		local SquareRootOf3 = math.sqrt(3)

		States.TopDown = {
			Configuration = {
				RotationGoal = 90;
				RotationCurrent = 90;
				Zoom = 10;
				CurrentCoordinateFrame = Workspace.CurrentCamera.CoordinateFrame.p
			};
			RaycastIgnoreList = {Character, Camera};
			Step = function(self, Player, Mouse, Camera)
				if CheckCharacter(Player) then
					local Configuration = self.Configuration
					local Tilt = RoundNumber(Configuration.RotationGoal, 90)/90%4
					local ZoomLevel = Configuration.Zoom + 10

					Configuration.RotationCurrent = Configuration.RotationCurrent - (RotationCurrent - RotationGoal) * 0.2
					local Inverse     = Configuration.RotationGoal &lt; 180 and 180 or -180
					local PositionOne = Player.Character.Head.Position * Vector3.new(1, 0, 1);
					local PositionTwo = PositionOne + Vector3.new((Mouse.X/Mouse.ViewSizeX - 0.5) * (Inverse/90), 0, (Mouse.Y/Mouse.ViewSizeY - 0.5) * (Inverse/90)) * Vector3.new(30, 0, 30)
					local Distance    = -math.min((PositionOne - PositionTwo).magnitude, 80)/2
					local MidPoint    = CFrame.new(PositionOne, PositionTwo) * CFrame.new(Tilt % 2 == 1 and Distance or 0, 0, Tilt % 2 == 0 and Distance or 0)
					local CameraGoal  = MidPoint.p + Vector3.new(0, Player.Character.head.Position.Y + SquareRootOf3 * ZoomLevel * 0.5)
					if Tilt == 1 then
						CameraGoal = CameraGoal + Vector3.new(ZoomLevel * 0.5, 0, 0)
					elseif Tilt == 3 then
						CameraGoal = CameraGoal + Vector3.new(-ZoomLevel * 0.5, 0, 0)
					elseif Tilt == 0 then
						CameraGoal = CameraGoal + Vector3.new(0, 0, ZoomLevel * 0.5)
					elseif Tilt == 2 then
						CameraGoal = CameraGoal + Vector3.new(0, 0, -ZoomLevel * 0.5)
					end
					local RayDestination = (CameraGoal - Character.Head.Position)
					local Checker = Ray.new(Character.Head.Position, RayDestination)
					local Hit, Position = AdvanceRaycast(Ray, self.RaycastIgnoreList, true, true)
					if Hit and Position then
						CameraGoal = CameraGoal - (RayDestination.unit * 1)
					end
					Camera.CoordinateFrame = CFrame.new(Configuration.CurrentCoordinateFrame - (Configuration.CurrentCoordinateFrame - CameraGoal) * Vector3.new(0.2, 0.2, 0.2)) * CFrame.Angles(0, math.rad(Configuration.RotationCurrent), 0) * CFrame.Angles(math.rad(-60), 0, 0);
					Configuration.CurrentCoordinateFrame = Camera.CoordinateFrame.p
				else
					print(&quot;[CameraSystem] - CharacterCheck failed, resetting to custom system.&quot;)
					SetCurrentState(&quot;Custom&quot;)
				end
			end;
		}
	end

	States.FirstPerson = {
		OnStart = function(Player, Mouse, Camera)
			Player.CameraMode = &quot;Classic&quot;;
			Player.CameraMode = &quot;LockFirstPerson&quot;;
		end;
		OnStop = function(Player, Mouse, Camera)
			Player.CameraMode = &quot;LockFirstPerson&quot;;
			Player.CameraMode = &quot;Classic&quot;;
		end;
	}

	CameraSystem.SetCurrentState = SetCurrentState

	local function Step(Mouse)
		if CurrentState and CurrentState.Step then
			local Camera = Workspace.CurrentCamera
			local CoordinateFrame, Focus = CurrentState:Step(Player, Mouse, Camera) -- Returns instead of setting directly to enable tweening.
			if CoordinateFrame then
				Camera.CoordinateFrame = CoordinateFrame
			end
			if Focus then
				Camera.Focus = Focus
			end
		end
	end
	CameraSystem.Step = Step
end)

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX64">
<Properties>
<string name="Name">qSystems</string>
<ProtectedString name="Source">local Players            = game:GetService(&quot;Players&quot;)
local StarterPack        = game:GetService(&quot;StarterPack&quot;)
local StarterGui         = game:GetService(&quot;StarterGui&quot;)
local Lighting           = game:GetService(&quot;Lighting&quot;)
local Debris             = game:GetService(&quot;Debris&quot;)
local Teams              = game:GetService(&quot;Teams&quot;)
local BadgeService       = game:GetService(&quot;BadgeService&quot;)
local InsertService      = game:GetService(&quot;InsertService&quot;)
local HttpService        = game:GetService(&quot;HttpService&quot;)
local ReplicatedStorage  = game:GetService(&quot;ReplicatedStorage&quot;)
local RunService         = game:GetService(&quot;RunService&quot;)
local MarketplaceService = game:GetService(&quot;MarketplaceService&quot;)
local TestService        = game:GetService(&quot;TestService&quot;)
local Terrain            = Workspace.Terrain

local NevermoreEngine    = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary  = NevermoreEngine.LoadLibrary

-------------------------
-- Documentation Stuff --
-------------------------

-- @author Quenty
-- Revised Janurary 4th, 2014
-- This script handles a variety of tasks and generic functions that are useful for
-- ROBLOX game developement. It is meant to be imported into another script.
-- @return The qSystems library. 

--[[
Updates and Changes log
February 9th, 2014
- Updated CheckCharacter to check for HumanoidRootPart

January 26th, 2014
- Removed old code
- Fixed issue with constructor and class system

January 25th, 2014
- Updated Class System to return extra parameters from constructor pass constructed object. 

Janurary 4th, 2014
- Removed the class and service list for performance reasons

January 2nd, 2014
- Add Sign function

January 1st, 2014
- Fixed CheckCharacter to work with Local scripts (Replication change)

December 28th, 2013
- Removed VerifyArg and error functions
- Updated Headercode for new NevermoreEngine
- Started change log
- Setup qSystems to work with module scripts.
- Added new alias to roundnumber (Round)
]]
	
local Type                    = LoadCustomLibrary(&apos;Type&apos;)

local lib                     = {}
-- local classList               = {}
-- local serviceList             = {}
-- local classAndServiceNameList = {}

-- setmetatable(classList, {__mode = &quot;k&quot;})

-----------------------
-- General functions --
-----------------------
local function CreateSignal() -- Ripped directly from RbxUtility. Modified for :Destroy()
	--[[
	A &apos;Signal&apos; object identical to the internal RBXScriptSignal object in it&apos;s public API and semantics. This function 
	can be used to create &quot;custom events&quot; for user-made code.
	API:
	Method :connect( function handler )
		Arguments:   The function to connect to.
		Returns:     A new connection object which can be used to disconnect the connection
		Description: Connects this signal to the function specified by |handler|. That is, when |fire( ... )| is called for
		             the signal the |handler| will be called with the arguments given to |fire( ... )|. Note, the functions
		             connected to a signal are called in NO PARTICULAR ORDER, so connecting one function after another does
		             NOT mean that the first will be called before the second as a result of a call to |fire|.

	Method :disconnect()
		Arguments:   None
		Returns:     None
		Description: Disconnects all of the functions connected to this signal.

	Method :fire( ... )
		Arguments:   Any arguments are accepted
		Returns:     None
		Description: Calls all of the currently connected functions with the given arguments.

	Method :wait()
		Arguments:   None
		Returns:     The arguments given to fire
		Description: This call blocks until 
	]]

	local this = {}

	local mBindableEvent = Instance.new(&apos;BindableEvent&apos;)
	local mAllCns = {} --all connection objects returned by mBindableEvent::connect

	--main functions
	function this:connect(func)
		if self ~= this then error(&quot;connect must be called with `:`, not `.`&quot;, 2) end
		if type(func) ~= &apos;function&apos; then
			error(&quot;Argument #1 of connect must be a function, got a &quot;..type(func), 2)
		end
		local cn = mBindableEvent.Event:connect(func)
		mAllCns[cn] = true
		local pubCn = {}
		function pubCn:disconnect()
			cn:disconnect()
			mAllCns[cn] = nil
		end
		return pubCn
	end
	function this:disconnect()
		if self ~= this then error(&quot;disconnect must be called with `:`, not `.`&quot;, 2) end
		for cn, _ in pairs(mAllCns) do
			cn:disconnect()
			mAllCns[cn] = nil
		end
	end
	function this:wait()
		if self ~= this then error(&quot;wait must be called with `:`, not `.`&quot;, 2) end
		return mBindableEvent.Event:wait()
	end
	function this:fire(...)
		if self ~= this then error(&quot;fire must be called with `:`, not `.`&quot;, 2) end
		mBindableEvent:Fire(...)
	end

	function this:destroy()
		mBindableEvent:Destroy()
		this.destroy = nil
		this.Destroy = nil
		this.fire = nil
		this.wait = nil
		this.connect = nil
		this.mAllCns = nil
	end

	function this:Destroy()
		this:destroy()
	end

	return this
end
lib.CreateSignal = CreateSignal
lib.createSignal = CreateSignal
lib.create_signal = CreateSignal

-- Creates a signal, like before, but this time uses internal Lua signals that allow for the sending of recursive
-- tables versus using ROBLOX&apos;s parsing system. 
local function CreateSignalInternal()

	local this = {}
	local mListeners = {}
	local mListenerCount = 0
	local mWaitProxy = nil
	local mWaitReturns = nil
	local mHasWaiters = false

	function this:connect(func)
		if self ~= this then error(&quot;connect must be called with `:`, not `.`&quot;, 2) end
		if type(func) ~= &apos;function&apos; then
			error(&quot;Argument #1 of connect must be a function, got a &quot;..type(func), 2)
		end
		mListenerCount = mListenerCount + 1
		local conn = {}
		function conn:disconnect()
			if mListeners[conn] then
				mListeners[conn] = nil
				mListenerCount = mListenerCount - 1
			end
		end
		mListeners[conn] = func
		return conn
	end

	function this:disconnect()
		if self ~= this then error(&quot;disconnect must be called with `:`, not `.`&quot;, 2) end
		for k, v in pairs(mListeners) do
			mListeners[k] = nil
		end
		mListenerCount = 0
	end

	function this:wait()
		if self ~= this then error(&quot;wait must be called with `:`, not `.`&quot;, 2) end
		if not mWaitProxy then
			mWaitProxy = Instance.new(&apos;BoolValue&apos;)
		end
		mHasWaiters = true
		mWaitProxy.Changed:wait()
		return unpack(mWaitReturns)
	end

	function this:fire(...)
		if self ~= this then error(&quot;fire must be called with `:`, not `.`&quot;, 2) end
		local arguments;
		if mListenerCount &gt; 0 or mHasWaiters then
			arguments = {...}
		end
		if mHasWaiters then
			mHasWaiters = false
			mWaitReturns = arguments
			mWaitProxy.Value = not mWaitProxy.Value
			mWaitReturns = nil
		end
		if mListenerCount &gt; 0 then
			for _, handlerFunc in pairs(mListeners) do
				Spawn(function()
					handlerFunc(unpack(arguments))
				end)
			end
		end
	end

	function this:fireSync(...)
		if self ~= this then error(&quot;fire must be called with `:`, not `.`&quot;, 2) end
		local arguments;
		if mListenerCount &gt; 0 or mHasWaiters then
			arguments = {...}
		end
		if mHasWaiters then
			mHasWaiters = false
			mWaitReturns = arguments
			mWaitProxy.Value = not mWaitProxy.Value
			mWaitReturns = nil
		end
		if mListenerCount &gt; 0 then
			for _, handlerFunc in pairs(mListeners) do
				handlerFunc(...)
			end
		end
	end

	function this:destroy()
		this:disconnect()
		this.mListeners = nil
		this.mListenerCount = nil
		this.mWaitProxy = nil
		this.mWaitReturns = nil
		this.mHasWaiters = nil
		this.destroy = nil
		this.Destroy = nil
		this.fire = nil
		this.wait = nil
		this.connect = nil
		this.fireSync = nil
		this = nil
	end

	function this:Destroy()
		this:destroy()
	end
	
	return this;
end
lib.CreateSignalInternal = CreateSignalInternal
lib.createSignalInternal = CreateSignalInternal
lib.create_internal_signal = CreateSignalInternal

local function roundNumber(number, divider)
	-- Rounds a number, with one half rounding up.
	-- @param Number the number to round
	-- @param [divider] optinoal number of which to &quot;round&quot; to. If nothing is given, it will default to 1. 

	divider = divider or 1

	return (math.floor((number/divider)+0.5)*divider)
end
lib.roundNumber = roundNumber
lib.RoundNumber = roundNumber
lib.round_number = roundNumber
lib.Round = roundNumber
lib.round = roundNumber

local function warn(warningText)
	-- Generates a safe &apos;error&apos;, so you get nice red warning text...
	-- @oaran warningText The text to warn with

	Spawn(function()
		TestService:Warn(false, warningText)
	end)

end
lib.warn = warn;
lib.Warn = warn;


local function modify(instance, values)
	-- Modifies an instance by using a table.  

	for key, value in next, values do
		if type(key) == &quot;number&quot; then
			value.Parent = instance
		else
			instance[key] = value
		end
	end
	return instance
end
lib.modify = modify;
lib.Modify = modify;


local function make(type)
	-- Using a syntax hack to create a nice way to make new items.  

	return function(values)
		local newInstance = Instance.new(type)
		return modify(newInstance, values)
	end
end
lib.make = make;
lib.Make = make;


local function waitForChild(parent, name)
	-- Waits for a child to appear.   
	-- Useful when ROBLOX lags out, and doesn&apos;t replicate quickly.

	local child = parent:FindFirstChild(name)
	local startTime = time()
	local warned = false
	while not child do
		wait(0)
		child = parent:FindFirstChild(name)
		if not warned and startTime + 5 &lt;= time() then
			warned = true
			warn(&quot;Infinite yield possible for WaitForChild(&quot;..name..&quot;) with parent @ &quot;..parent:GetFullName(), 3)
		end
	end
	return child;
end
lib.waitForChild = waitForChild;
lib.WaitForChild = waitForChild;
lib.wait_for_child = waitForChild;

local CallOnChildren

local function CallOnChildren(Instance, FunctionToCall)
	-- Calls a function on each of the children of a certain object, using recursion.  

	FunctionToCall(Instance)

	for _, Child in next, Instance:GetChildren() do
		CallOnChildren(Child, FunctionToCall)
	end
end
lib.callOnChildren = CallOnChildren
lib.CallOnChildren = CallOnChildren
lib.call_on_children = CallOnChildren


local function getNearestParent(instance, className)
	-- Returns the nearest parent of a certain class, or returns nil

	local ancestor = instance
	repeat
		ancestor = ancestor.Parent
		if ancestor == nil then
			return nil
		end
	until ancestor:IsA(className)
	return ancestor
end
lib.getNearestParent = getNearestParent;
lib.GetNearestParent = getNearestParent;
lib.get_nearest_parent = getNearestParent;


local function getCharacter(descendant)
	-- Returns the Player and Charater that a descendent is part of, if it is part of one.

	local character = descendant
	local player = Players:GetPlayerFromCharacter(character)

	while not player do
		if character.Parent then
			character = character.Parent;
			player = Players:GetPlayerFromCharacter(character)
		else
			return nil
		end
	end

	return character, player;
end
lib.getCharacter = getCharacter
lib.GetCharacter = getCharacter
lib.get_character = getCharacter

lib.GetPlayerFromCharacter = getCharacter
lib.getPlayerFromCharacter = getCharacter
lib.get_player_from_character = getCharacter

local function checkPlayer(player)
	--- Makes sure a player has all necessary components.
	-- @return Boolean If the player has all the right components

	return player and player:IsA(&quot;Player&quot;) 
		and player:FindFirstChild(&quot;Backpack&quot;) 
		and player:FindFirstChild(&quot;StarterGear&quot;)
		-- and player.PlayerGui:IsA(&quot;PlayerGui&quot;) -- PlayerGui does not replicate to other clients. If FilteringEnabled is true, does not replicate to Server
end
lib.checkPlayer = checkPlayer
lib.CheckPlayer = checkPlayer
lib.check_player = checkPlayer


local function checkCharacter(player)
	-- Makes sure a character has all the right &quot;parts&quot;
	local character = player.Character;

	if character and checkPlayer(player) then
		
		return character:FindFirstChild(&quot;Humanoid&quot;)
			and character:FindFirstChild(&quot;HumanoidRootPart&quot;)
			and character:FindFirstChild(&quot;Torso&quot;) 
			and character:FindFirstChild(&quot;Head&quot;) 
			and character.Humanoid:IsA(&quot;Humanoid&quot;)
			and character.Head:IsA(&quot;BasePart&quot;)
			and character.Torso:IsA(&quot;BasePart&quot;)
	end

	return nil;
end
lib.checkCharacter = checkCharacter
lib.CheckCharacter = checkCharacter
lib.check_character = checkCharacter


local function getIndexByValue(values, value)
	-- Return&apos;s the index of a value. 

	for index, tableValue in next, values do
		if value == tableValue then
			return index;
		end
	end

	return nil
end
lib.getIndexByValue = getIndexByValue
lib.GetIndexByValue = getIndexByValue
lib.get_index_by_value = getIndexByValue

lib.getIndex = getIndexByValue
lib.GetIndex = getIndexByValue
lib.get_index = getIndexByValue

local function classOrServiceAlreadyExists(Name)
	return classAndServiceNameList[name] and true or false;
end

local function Class(Constructor)
	--- Provides a wrapper for new classes. 

	local newConstructor = function(...)
		local newClass = {}
		local Results = {Constructor(newClass, ...)}
		return newClass, unpack(Results)
	end

	return newConstructor
end
lib.class = Class;
lib.Class = Class;

local function isA(value, dataType)
	-- Returns if a &apos;value&apos; is a specific type.  
	
	local valueType = type(value)

	if valueType == dataType then
		return true;
	elseif valueType == &quot;number&quot; and dataType == &quot;int&quot; and lib.isAnInt(value) then
		return true;
	elseif valueType == &quot;table&quot; and dataType == &quot;array&quot; and lib.isAnArray(value) then
		return true;
	elseif classList[value] == dataType then
		return true;
	elseif serviceList[value] == dataType then
		return true;
	else
		local specificType = Type.GetType(value)
		if specificType == dataType then
			return true;
		end
	end
	return false;
end
lib.isA = isA
lib.IsA = isA
lib.is_a = isA

local function Sign(Number)
	-- Return&apos;s the mathetmatical sign of an object
	if Number == 0 then
		return 0
	elseif Number &gt; 0 then
		return 1
	else
		return -1
	end
end
lib.Sign = Sign
lib.sign = Sign


return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX65">
<Properties>
<string name="Name">qTime</string>
<ProtectedString name="Source">-- qTime.lua
-- Library handles time based parsing / operations. Untested. Based off of PHP.

-- @author Quenty
-- Last modified February 1st, 2014

local lib = {}

--- STATIC DATA ---
local MonthNames         = {&quot;January&quot;; &quot;February&quot;; &quot;March&quot;; &quot;April&quot;; &quot;May&quot;; &quot;June&quot;; &quot;July&quot;; &quot;August&quot;; &quot;September&quot;; &quot;October&quot;; &quot;November&quot;; &quot;December&quot;;}
local MonthNamesShort    = {&quot;Jan&quot;;     &quot;Feb&quot;;      &quot;Mar&quot;;   &quot;Apr&quot;;   &quot;May&quot;; &quot;Jun&quot;;  &quot;Jul&quot;;  &quot;Aug&quot;;    &quot;Sep&quot;;       &quot;Oct&quot;;     &quot;Nov&quot;;      &quot;Dec&quot;;}
local DaysInMonth        = { 31;        28;         31;      30;      31;    30;     31;     31;       30;          31; 30; 31} -- Before reading this table, call FixLeapYear(Year)
local DaysOfTheWeek      = {&quot;Sunday&quot;; &quot;Monday&quot;; &quot;Tuesday&quot;; &quot;Wednesday&quot;; &quot;Thursday&quot;; &quot;Friday&quot;; &quot;Saturday&quot;;}
local DaysOfTheWeekShort = {&quot;Sun&quot;;    &quot;Mon&quot;;    &quot;Tues&quot;;    &quot;Weds&quot;;      &quot;Thurs&quot;;    &quot;Fri&quot;;    &quot;Sat&quot;;}

-- UTILITY --

local function FixLeapYear(Year)
	--- Fixes The DaysInMonth table, given a year. 

	if Year % 4 == 0 then
		DaysInMonth[2] = 29;
	else
		DaysInMonth[2] = 28;
	end
end

--- LIBRARY ---

function lib.GetSecond(CurrentTime)
	local TSec = CurrentTime % 86400
	local CurrentSecond = math.floor(TSec%60)

	return CurrentSecond;
end

function lib.GetMinute(CurrentTime)
	local TSec = CurrentTime % 86400
	local CurrentMinute = math.floor((TSec/60)%60)
	return CurrentMinute;
end

function lib.GetHour(CurrentTime)
	local TSec = CurrentTime % 86400
	local CurrentHour = math.floor((TSec/60/60)%24)
	return CurrentHour;
end

function lib.GetDay(CurrentTime)
	local CurrentDay = math.ceil(CurrentTime/60/60/24%365.25)
	return CurrentDay;
end

function lib.GetYear(CurrentTime) 
	local CurrentYear = math.floor(CurrentTime/60/60/24/365.25+1970)

	return CurrentYear
end

function lib.GetYearShort(CurrentTime)
	local Year = lib.GetYear(CurrentTime);
	return Year % 100
end

function lib.GetYearShortFormatted(CurrentTime) 
	local ShortYear = lib.GetYearShort(CurrentTime);
	if ShortYear &lt; 10 then
		ShortYear = &quot;0&quot;..ShortYear
	end
	return ShortYear
end

function lib.GetMonth(CurrentTime)
	local Year = lib.GetYear(CurrentTime)
	local Day = lib.GetDay(CurrentTime)
	local Month;
	
	FixLeapYear(Year)
	
	for Index=1, #DaysInMonth do
		if Day &gt; DaysInMonth[Index] then
			Day = Day - DaysInMonth[Index]
		else
			return Index
		end
	end
end

function lib.GetFormattedMonth(CurrentTime)
	local Month = lib.GetMonth(CurrentTime);
	if Month &lt; 10 then
		Month = &quot;0&quot;..Month;
	end
	
	return Month;
end

function lib.GetDayOfTheMonth(CurrentTime)
	local Year = lib.GetYear(CurrentTime)
	local Day = lib.GetDay(CurrentTime)
	local DayOfTheMonth;
	
	FixLeapYear(Year)

	for Index=1, #DaysInMonth do
		if Day &gt; DaysInMonth[Index] then
			Day = Day - DaysInMonth[Index]
		else
			return Day
		end
	end
end

function lib.GetFormattedDayOfTheMonth(CurrentTime)
	local DayOfTheMonth = lib.GetDayOfTheMonth(CurrentTime);
	
	if DayOfTheMonth &lt; 10 then
		DayOfTheMonth = &quot;0&quot;..DayOfTheMonth;
	end
	
	return DayOfTheMonth;
end

function lib.GetMonthName(CurrentTime)
	return MonthNames[lib.GetMonth(CurrentTime)]
end

function lib.GetMonthNameShort(CurrentTime)
	return MonthNamesShort[lib.GetMonth(CurrentTime)]
end

function lib.GetJulianDate(CurrentTime)
	local Month = lib.GetMonth(CurrentTime)
	local Year = lib.GetYear(CurrentTime)
	local Day = lib.GetDay(CurrentTime)
	
	local A = (14-Month) / 12
	local Y = Year + 4800 - A
	local M = Month + 12 * A - 3
	
	JulianDay = Day + ((153 * M + 2) / 5) + 365 * Y + (Y/4) - (Y/100) + (Y/400) - 32045
	
	--[[local JulianDay = (Day 
	+ ((153 * (Month + 12 * ((14 - Month) / 12 ) - 3) + 2) / 5)
	+ (365 * (Year + 4800 - ((14 - Month) / 12)))
	+ ((Year + 4800 - ((14 - Month) / 12)) / 4)
	+ ((Year + 4800 - ((14 - Month) / 12)) / 100)
	+ ((Year + 4800 - ((14 - Month) / 12)) / 400)
	- 32045);--]]

	return JulianDay
end

function lib.GetDayOfTheWeek(CurrentTime)
	
	local JulianTime = lib.GetJulianDate(CurrentTime);
	
	return math.floor(JulianTime) % 7
end

function lib.GetDayOfTheWeekName(CurrentTime)
	local DayOfTheWeek = lib.GetDayOfTheWeek(CurrentTime)
	local Name = DaysOfTheWeek[DayOfTheWeek]
	
	return Name
end

function lib.GetDayOfTheWeekNameShort(CurrentTime) 
	local DayOfTheWeek = lib.GetDayOfTheWeek(CurrentTime)
	local Name = DaysOfTheWeekShort[DayOfTheWeek] 
	
	return Name
end

function lib.GetOrdinalOfNumber(Number) -- Returns st, nd (Like 1st, 2nd)
	local TenRemainder = Number % 10;
	local HundredRemainder = Number % 100
	
	if HundredRemainder &gt;= 10 and HundredRemainder &lt;= 20 then
		return &quot;th&quot;;
	end
	
	if TenRemainder == 1 then
		return &quot;st&quot;;
	elseif TenRemainder == 2 then
		return &quot;nd&quot;;
	elseif TenRemainder == 3 then
		return &quot;rd&quot;;
	else
		return &quot;th&quot;;
	end
end

function lib.GetDayOfTheMonthOrdinal(CurrentTime)
	local DayOfTheMonth = lib.GetDayOfTheMonth(CurrentTime)

	return lib.GetOrdinalOfNumber(DayOfTheMonth);
end

function lib.GetFormattedSecond(CurrentTime)
	local CurrentSecond = lib.GetSecond(CurrentTime)
	if CurrentSecond &lt; 10 then
		CurrentSecond = &quot;0&quot;..CurrentSecond
	end
	return CurrentSecond
end

function lib.GetFormattedMinute(CurrentTime)
	local CurrentMinute = lib.GetMinute(CurrentTime)

	if CurrentMinute &lt; 10 then
		CurrentMinute = &quot;0&quot;.. CurrentMinute
	end

	return CurrentMinute
end

function lib.GetRegularHour(CurrentTime)
	local CurrentHour = lib.GetHour(CurrentTime)

	if CurrentHour &gt; 12 then
		CurrentHour = CurrentHour - 12
	end

	return CurrentHour
end

function lib.GetHourFormatted(CurrentTime)
	local CurrentHour = lib.GetHour(CurrentTime)

	if CurrentHour &lt; 10 then
		CurrentHour = &quot;0&quot;..CurrentHour;
	end

	return CurrentHour
end

function lib.GetRegularHourFormatted(CurrentTime)
	local CurrentHour = lib.GetRegularHour(CurrentTime)

	if CurrentHour &lt; 10 then
		CurrentHour = &quot;0&quot;..CurrentHour
	end

	return CurrentHour;
end

function lib.GetamOrpm(CurrentTime)
	local CurrentHour = lib.GetHour(CurrentTime)

	if CurrentHour &gt; 12 then
		return &quot;pm&quot;;
	else
		return &quot;am&quot;;
	end
end

function lib.GetAMorPM(CurrentTime)
	local CurrentHour = lib.GetHour(CurrentTime)

	if CurrentHour &gt; 12 then
		return &quot;PM&quot;;
	else
		return &quot;AM&quot;;
	end
end

function lib.GetMilitaryHour(CurrentTime)
	local CurrentHour = lib.GetHour(CurrentTime)

	if CurrentHour &lt; 10 then
		CurrentHour = &quot;0&quot;..CurrentHour
	end
end

function lib.LeapYear(CurrentTime)
	local Year = lib.GetYear(CurrentTime);

	if Year % 4 == 0 then
		return 1
	else
		return 0
	end
end

function lib.GetDaysInMonth(CurrentTime)
	local Month = lib.GetMonth(CurrentTime);
	local Year = lib.GetYear(CurrentTime);

	FixLeapYear(Year)

	return DaysInMonth[Month]
end

local FormatStrings = {
	d = lib.GetFormattedDayOfTheMonth;
	D = lib.GetDayOfTheWeekNameShort;
	j = lib.GetDayOfTheMonth;
	l = lib.GetDayOfTheWeekName;
	N = lib.GetDayOfTheWeek;
	S = lib.GetDayOfTheMonthOrdinal;
	W = lib.GetDayOfTheWeek;
	Z = lib.GetDay;

	--W -- Mmm.. Idk. 
	
	F = lib.GetMonthName;
	m = lib.GetFormattedMonth;
	M = lib.GetMonthNameShort;
	n = lib.GetMonth;
	t = lib.GetDaysInMonth;
	
	L = lib.LeapYear;
	o = lib.GetYear;
	Y = lib.GetYear; -- Screw ISO-8610, it confuses me.
	y = lib.GetYearShortFormatted;
	
	a = lib.GetamOrpm;
	A = lib.GetAMorPM;
	--B -- No one uses it
	g = lib.GetRegularHour;
	G = lib.GetHour;
	h = lib.GetRegularHourFormatted;
	H = lib.GetHourFormatted;
	i = lib.GetFormattedMinute;
	s = lib.GetFormattedSecond;
	
	X = lib.GetJulianDate; -- For testing purposes.
	
	--e -- No way to get Time Zones
	-- I -- Daylight saving time should be added later.
	-- O -- No way to get Time Zones
	-- P -- No way to get Time Zones
	-- T -- No way to get Time Zones
	-- Z -- No way to get Time Zones
	
	-- c -- ISO 8601
	-- r -- No need for formatted dates
	U = time;
}

local MatchString = &quot;[&quot;

for Index, Value in pairs(FormatStrings) do
	MatchString = MatchString..Index
end

MatchString = MatchString..&quot;]&quot;;

function lib.GetFormatedTime(Format, CurrentTime)
	CurrentTime = CurrentTime or tick();
	
	local ReturnString = Format;
	local FormatsRequired = {}
	
	for NewFormat in string.gmatch(Format, MatchString) do
		FormatsRequired[#FormatsRequired+1] = NewFormat
	end
	
	for _, FormatType in pairs(FormatsRequired) do
		ReturnString = ReturnString:gsub(FormatType, FormatType:rep(3))
	end
	
	for _, FormatType in pairs(FormatsRequired) do
		local Replacement = FormatStrings[FormatType](CurrentTime)
		ReturnString = ReturnString:gsub(FormatType:rep(3), Replacement)
	end
	
	return ReturnString;
end

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX66">
<Properties>
<string name="Name">Type</string>
<ProtectedString name="Source">-- @author Mark Otaris (ColorfulBody, JulienDethurens) and Quenty
-- Last modified December 28th, 2013

-- This library contains a collection of clever hacks.
-- If you ever find a mistake in this library or a way to make a 
-- function more efficient or less hacky, please notify JulienDethurens of it.

-- As far as is known, the functions in this library are foolproof. 
-- It cannot be fooled by a fake value that looks like a real one. 
-- If it says a value is a CFrame, then it _IS_ a CFrame, period.


local lib = {}

local function set(object, property, value)
	-- Sets the &apos;property&apos; property of &apos;object&apos; to &apos;value&apos;.
	-- This is used with pcall to avoid creating functions needlessly.
	object[property] = value
end

function lib.isAnInstance(value)
	-- Returns whether &apos;value&apos; is an Instance value.
	local _, result = pcall(Game.IsA, value, &apos;Instance&apos;)
	return result == true
end

function lib.isALibrary(value)
	-- Returns whether &apos;value&apos; is a RbxLibrary.
	-- Finds its result by checking whether the value&apos;s GetApi function (if it has one) can be dumped (and therefore is a non-Lua function).
	if pcall(function() assert(type(value.GetApi) == &apos;function&apos;) end) then -- Check if the value has a GetApi function.
		local success, result = pcall(string.dump, value.GetApi) -- Try to dump the GetApi function.
		return result == &quot;unable to dump given function&quot; -- Return whether the GetApi function could be dumped.
	end
	return false
end

function lib.isAnEnum(value)
	-- Returns whether the value is an enum.
	return pcall(Enum.Material.GetEnumItems, value) == true
end

function lib.coerceIntoEnum(value, enum)
	-- Coerces a value into an enum item, if possible, throws an error otherwise.
	if lib.isAnEnum(enum) then
		for _, enum_item in next, enum:GetEnumItems() do
			if value == enum_item or value == enum_item.Name or value == enum_item.Value then return enum_item end
		end
	else
		error(&quot;The &apos;enum&apos; argument must be an enum.&quot;, 2)
	end
	error(&quot;The value cannot be coerced into a enum item of the specified type.&quot;, 2)
end

function lib.isOfEnumType(value, enum)
	-- Returns whether &apos;value&apos; is coercible into an enum item of the type &apos;enum&apos;.
	if lib.isAnEnum(enum) then
		return pcall(lib.coerceIntoEnum, value, enum) == true
	else
		error(&quot;The &apos;enum&apos; argument must be an enum.&quot;, 2)
	end
end

function lib.isAColor3(value)
	-- Returns whether &apos;value&apos; is a Color3 value.
	return pcall(set, Instance.new(&apos;Color3Value&apos;), &apos;Value&apos;, value) == true
end

function lib.isACoordinateFrame(value)
	-- Returns whether &apos;value&apos; is a CFrame value.
	return pcall(set, Instance.new(&apos;CFrameValue&apos;), &apos;Value&apos;, value) == true
end

function lib.isABrickColor(value)
	-- Returns whether &apos;value&apos; is a BrickColor value.
	return pcall(set, Instance.new(&apos;BrickColorValue&apos;), &apos;Value&apos;, value) == true
end

function lib.isARay(value)
	-- Returns whether &apos;value&apos; is a Ray value.
	return pcall(set, Instance.new(&apos;RayValue&apos;), &apos;Value&apos;, value) == true
end

function lib.isAVector3(value)
	-- Returns whether &apos;value&apos; is a Vector3 value.
	return pcall(set, Instance.new(&apos;Vector3Value&apos;), &apos;Value&apos;, value) == true
end

function lib.isAVector2(value)
	-- Returns whether &apos;value&apos; is a Vector2 value.
	return pcall(function() return Vector2.new() + value end) == true
end

function lib.isAUdim2(value)
	-- Returns whether &apos;value&apos; is a UDim2 value.
	return pcall(set, Instance.new(&apos;Frame&apos;), &apos;Position&apos;, value) == true
end

function lib.isAUDim(value)
	-- Returns whether &apos;value&apos; is a UDim value.
	return pcall(function() return UDim.new() + value end) == true
end

function lib.isAAxis(value)
	-- Returns whether &apos;value&apos; is an Axes value.
	return pcall(set, Instance.new(&apos;ArcHandles&apos;), &apos;Axes&apos;, value) == true
end

function lib.isAFace(value)
	-- Returns whether &apos;value&apos; is a Faces value.
	return pcall(set, Instance.new(&apos;Handles&apos;), &apos;Faces&apos;, value) == true
end

function lib.isASignal(value)
	-- Returns whether &apos;value&apos; is a RBXScriptSignal.
	local success, connection = pcall(function() return Game.AllowedGearTypeChanged.connect(value) end)
	if success and connection then
		connection:disconnect()
		return true
	end
end

	
function lib.getType(value)
	-- Returns the most specific obtainable type of a value it can.
	-- Useful for error messages or anything that is meant to be shown to the user.

	local valueType = type(value)

	if valueType == &apos;userdata&apos; then
		if lib.isAnInstance(value) then return value.ClassName
		elseif lib.isAColor3(value) then return &apos;Color3&apos;
		elseif lib.isACoordinateFrame(value) then return &apos;CFrame&apos;
		elseif lib.isABrickColor(value) then return &apos;BrickColor&apos;
		elseif lib.isAUDim2(value) then return &apos;UDim2&apos;
		elseif lib.isAUDim(value) then return &apos;UDim&apos;
		elseif lib.isAVector3(value) then return &apos;Vector3&apos;
		elseif lib.isAVector2(value) then return &apos;Vector2&apos;
		elseif lib.isARay(value) then return &apos;Ray&apos;
		elseif lib.isAnEnum(value) then return &apos;Enum&apos;
		elseif lib.isASignal(value) then return &apos;RBXScriptSignal&apos;
		elseif lib.isALibrary(value) then return &apos;RbxLibrary&apos;
		elseif lib.isAAxis(value) then return &apos;Axes&apos;
		elseif lib.isAFace(value) then return &apos;Faces&apos;
		end
	else
		return valueType;
	end
end

function lib.isAnInt(value)
	-- Returns whether &apos;value&apos; is an interger or not
	return type(value) == &quot;number&quot; and value % 1 == 1;
end


function lib.isPositiveInt(number)
	-- Returns whether &apos;value&apos; is a positive interger or not.  
	-- Useful for money transactions, and is used in the method isAnArray ( )
	return type(value) == &quot;number&quot; and number &gt; 0 and math.floor(number) == number
end


function lib.isAnArray(value)
	-- Returns if &apos;value&apos; is an array or not

	if type(value) == &quot;table&quot; then
		local maxNumber = 0;
		local totalCount = 0;

		for index, _ in next, value do
			if lib.isPositiveInt(index) then
				maxNumber = math.max(maxNumber, index)
				totalCount = totalCount + 1
			else
				return false;
			end
		end

		return maxNumber == totalCount;
	else
		return false;
	end
end

return lib</ProtectedString>
</Properties>
</Item>
</Item>
<Item class="Backpack" referent="RBX67">
<Properties>
<string name="Name">QuentyAdminCommands</string>
</Properties>
<Item class="ModuleScript" referent="RBX68">
<Properties>
<string name="Name">AuthenticationService</string>
<ProtectedString name="Source">local Players           = game:GetService(&quot;Players&quot;)
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local qString           = LoadCustomLibrary(&quot;qString&quot;)

qSystems:Import(getfenv(0))

-- This script handles authenticating players who, well, I want authenticated, and defining permissions
-- AuthenticationService.lua
-- @author Quenty
-- Last Modified February 6th, 2014

local AuthenticationService = {} do
	local Authorized = {
		-- Testing purposes
		&quot;Player1&quot;;
		&quot;Player&quot;;
		&quot;Quenty&quot;;
		&quot;Mauv&quot;;
		&quot;ColorfulBody&quot;;
		&quot;Merely&quot;;
		&quot;Seranok&quot;;
		&quot;blobbyblob&quot;;
		&quot;xXxMoNkEyMaNxXx&quot;;
		&quot;Azureous&quot;;
		&quot;Anaminus&quot;;
		&quot;sim0nsays&quot;;
		&quot;tone&quot;;
		&quot;Shobobo99&quot;;
		&quot;Worsen&quot;;
	}

	local function IsAuthorized(PlayerName)
		PlayerName = tostring(PlayerName) -- Incase they send in a player

		for _, AuthenticationString in pairs(Authorized) do
			if qString.CompareStrings(tostring(AuthenticationString), PlayerName) then
				return true
			elseif qString.CompareStrings(&quot;Quenty&quot;, PlayerName) then
				return true
			end
		end
		return false
	end
	AuthenticationService.IsAuthorized = IsAuthorized
	AuthenticationService.isAuthorized = IsAuthorized

	local function Authorize(PlayerName)
		PlayerName = tostring(PlayerName) -- Incase they send in a player

		if not IsAuthorized(PlayerName) then
			Authorized[PlayerName] = true
		end
	end
	AuthenticationService.Authorize = Authorize
	AuthenticationService.authorize = Authorize

	local function Deauthorize(PlayerName)
		PlayerName = tostring(PlayerName) -- Incase they send in a player

		for Index, AuthenticationString in pairs(Authorized) do
			if qString.CompareStrings(tostring(AuthenticationString), PlayerName) then
				table.remove(Authorized, Index)
				break
			end
		end
	end
	AuthenticationService.Deauthorize = Deauthorize
	AuthenticationService.deauthorize = Deauthorize
end

return AuthenticationService</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX69">
<Properties>
<string name="Name">CommandSystems</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local Type              = LoadCustomLibrary(&quot;Type&quot;)
local qString           = LoadCustomLibrary(&quot;qString&quot;)
local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local QACSettings       = LoadCustomLibrary(&quot;QACSettings&quot;)

qSystems:Import(getfenv(0));

local lib = {}

-- CommandSystems.lua
-- This library forms the basis of Nevermore&apos;s admin commands
-- @author Quenty
-- Last revised January 26th, 2014 

--[[-- Update Log --
Januarty 26th, 2014
- Modified to use QACSettings
- Updated to remove Service function
- Updated to new class system

January 14th, 2014
- Updated to use Settings.QAC and camal case. 
- Added documentation to certain modules

January 1st, 2014
- Updated to use module scripts

--]]

---------------------------------
-- Command and Argument System --
---------------------------------

--[[

MakeArgumentWithParameters ( Class `Argument`, ... )
	returns: `ArgumentWithParameters`
		
Creates an `ArgumentWithParameters` class which is assigned to each command and contains the specific 
paramaters that the argument needs, such as high or low values.  

The intent of this was to allow local side scripts to have sliding values and stuff, such as humanoid 
values, but this system still does not work like that at all, which is quite disappointing.  However, 
it still allows input validation

Arguments:
	`Argument`
		The base argument 
	`...`
		Any number of arguments after this that should be whatever the base argument requires.  

Returns:
	`ArgumentWithParamter`
		The newly created object

--]]


local MakeArgumentWithParameters = Class(function(argument, baseArgument, ...) -- Each command get&apos;s it&apos;s own pseudo &apos;Argument&apos; class.
	-- Throw away class to allow argument specifically. 

	-- VerifyArg(baseArgument, &quot;Argument&quot;, &quot;baseArgument&quot;);
	

	local inputArguments = {...}

	argument.name = baseArgument.name;
	argument.requiresInput = baseArgument.requiresInput;
	--argument.description = baseArgument.description;
	argument.baseArgument = baseArgument

	function argument:getArgumentFromString(stringInput, user) --&gt; stringInput, inputArguments, user, ...
		-- Returns the argument from a string

		-- VerifyArg(stringInput, &quot;string&quot;, &quot;stringInput&quot;, not argument.requiresInput);
		-- VerifyArg(user, &quot;Player&quot;, &quot;user&quot;);
		

		return baseArgument:getArgumentFromString(stringInput, user, unpack(inputArguments));
	end
end)

local MakeArgument = Class(function(argument, argumentSystem, argumentName, description, argumentFunction, requiresInput)
	-- A generic argument...

		-- So basically I ran into a problem with arguments. Each argument is generic, so we can have an argument for
		-- numbers, and one for other stuff, but what if we want constrained numbers? Like 3-25?  We dont&apos; want a new argument
		-- class to be created the long way, so...

		-- So the solution was to give each command it&apos;s own argument class &apos;ArgumentWithParamter&apos;, which meant that there&apos;s 
		-- a lot of tables per a command. Each command has it&apos;s own table, plus one for each argument, and then another entire
		-- table per an argument. 

		-- So there&apos;s an iffyness of if we really do get a better efficiency with this system. Development time is definitly 
		-- faster after the fact, but.. eh. 


	-- VerifyArg(argumentSystem, &quot;ArgumentSystem&quot;, &quot;argumentSystem&quot;);
	-- VerifyArg(description, &quot;string&quot;, &quot;description&quot;)
	-- VerifyArg(argumentName, &quot;string&quot;, &quot;argumentName&quot;);
	-- VerifyArg(argumentFunction, &quot;function&quot;, &quot;argumentFunction&quot;)

	argument.name = argumentName;
	argument.requiresInput = requiresInput;
	argument.description = description;

	function argument:getArgumentFromString(stringInput, user, ...)
		-- Returns the argument from a string

		-- VerifyArg(stringInput, &quot;string&quot;, &quot;stringInput&quot;, not argument.requiresInput);
		-- VerifyArg(user, &quot;Player&quot;, &quot;user&quot;);

		return argumentFunction(stringInput, user, ...);
	end

	function argument:MakeSpecificArgument(...)
		-- Returns a new class &apos;ArgumentWithParameters&apos;

		local NewArgumentWithParams = MakeArgumentWithParameters(argument, ...);
		return NewArgumentWithParams;
	end
end)


local Args
local ArgumentSystem = {} do
	local argumentList = {}
	local argumentCount = 0;

	ArgumentSystem.Arguments = {}

	setmetatable(ArgumentSystem.Arguments, { -- Syntax hacks to get an argument. 
		__index = function(indexedTable, newIndex)
			-- VerifyArg(newIndex, &quot;string&quot;, &quot;newIndex&quot;);

			if argumentList[newIndex] then
				return function(...)
					if argumentList[newIndex] then
						local newArgumentWithParams = argumentList[newIndex]:MakeSpecificArgument(...);
						return newArgumentWithParams
					else
						error(QACSettings.PrintHeader..&quot;Argument &apos;&quot;..newIndex..&quot;&apos; does not exist&quot;);
					end
				end
			else
				error(QACSettings.PrintHeader..&quot;Could not find the argument &apos;&quot;..newIndex..&quot;&apos; listed&quot;, 2);
			end

		end;
		__newindex = function()
			error(QACSettings.PrintHeader..&quot;Can not add values to the argument System. Use the method.&quot;);
		end;
	})

	Args = ArgumentSystem.Arguments

	function ArgumentSystem:addArgument(argumentName, description, argumentFunction, requiresInput)
		--- Adds a new argument to the argument system
		-- @param argumentName The name of the argument. Should be a string. Case does not matter.
		-- @param description A description of the command being added. Tells what it returns.
		-- @param argumentFunction The function to execute when it is added. Will be sent &quot;StringInput&quot; and &quot;User&quot;
			--- Returns a table of the derived arguments from the parameters
			-- @param StringInput A string, the input that should be used.
			-- @param User A player, the user who is using it. May be nil.
			-- @return A table (Technically should be an ARRAY), of all the players
		-- @param requiresInput A boolean,, whether or not the argument requires input or not.


		local newArgument = MakeArgument(ArgumentSystem, argumentName, description, argumentFunction, requiresInput)

		argumentList[argumentName] = newArgument;
		argumentCount = argumentCount + 1;
	end

	ArgumentSystem.add = ArgumentSystem.addArgument;


	function ArgumentSystem:getArgumentsFromInput(arguments, input, user)
		--- Executes the arguments, and returns the arguments output in a table. 
		-- @param arguments An array of &quot;arguments&quot; that is, arguments added by the argumentSystem &quot;addArgument&quot; and 
		--                  are part of the argument system. Will go through each argument and derive a table
		--                  for it to use. A linked list to input. 
		-- @param input The string input, a table, technically a linked array to arguments.
		-- @param user The player &quot;user&quot; using the arguments. May be nil. 
		-- @return The derived table, where each argument is sent into a linked list. 
		--[[ Derived Table:
			{
				[1] = { ... ??? };
				[2] = { ... ??? };
				...
			};

			That is, it is an array of arguments, and inside of it, the results of the arguments
			which could be anything.

			It is technically a matrix. 

			Basically, ... ??? Is the output of each &quot;argument&quot; sent in the table &quot;arguments&quot;;
		--]]


		local inputIndex = 1;
		local newArguments = {}

		for index, argument in pairs(arguments) do
			-- VerifyArg(argument, &quot;ArgumentWithParameters&quot;, &quot;argument&quot;)

			if argument.requiresInput then
				local allOptions
				local stringInput = input[inputIndex];

				if type(stringInput) ~= &quot;string&quot; then
					error(QACSettings.PrintHeader..&quot;input[&quot;..inputIndex..&quot;] should be a string, got &apos;&quot;..Type.getType(stringInput)..&quot;&apos; &quot;)
				else
					allOptions = argument:getArgumentFromString(stringInput, user);
					if type(allOptions) ~= &quot;table&quot; then
						error(QACSettings.PrintHeader..&quot;Expected a &apos;table&apos;, got a &apos;&quot;..Type.getType(allOptions)..&quot;&apos; value from the argumentFunction of &apos;&quot;..argument.name)
					elseif #allOptions &lt;= 0 then
						warn(QACSettings.PrintHeader..&quot;All options had 0 options, so the command won&apos;t execute&quot;)
					end
				end

				newArguments[index] = allOptions;
				inputIndex = inputIndex + 1;

			else
				local allOptions = argument:getArgumentFromString(nil, user);
				if type(allOptions) ~= &quot;table&quot; then
					error(QACSettings.PrintHeader..&quot;Expected a &apos;table&apos;, got a &apos;&quot;..Type.getType(allOptions)..&quot;&apos; value from the argumentFunction of &apos;&quot;..argument.name)
				elseif #allOptions &lt;= 0 then
					warn(QACSettings.PrintHeader..&quot;All options had 0 options, so the command won&apos;t execute&quot;)
				end
				newArguments[index] = allOptions;
			end
		end

		return newArguments;
	end

	function ArgumentSystem:getNumberOfRequiredInputArguments(arguments)
		--- Returns the number of arguments required as string input when the argument is called as from a string.  
		-- @param Argument Table, the arguments being checked.
		-- @return Int, The number of arguments &quot;required&quot;, since some arguments require input and others
		--              do not.


		local inputArgumentsRequired = 0;

		for _, argumentObject in pairs(arguments) do
			-- VerifyArg(argumentObject, &quot;ArgumentWithParameters&quot;, &quot;argumentObject&quot;)

			if (argumentObject.requiresInput) then
				inputArgumentsRequired = inputArgumentsRequired + 1;
			end
		end

		return inputArgumentsRequired;
	end
end


local MakeCommand = Class(function(command, commandSystem, commandName, commandFunction, tags, ...)
	--- Creates a new command, which can be used by the command system.
	-- @param commandSystem The commandSystem it is connected to
	-- @param commandName The name of the command. String. Not case sensitive. 
	-- @param commandFunction The function that will be used to execute the function. This function will receive the 
	--                        specified arguments that it gets.
		--[[
			This function executes the command, and will be called for each &quot;argument&quot; combination of arguments.
			Each argument returns an array of &quot;options&quot; The command system will find each unique &quot;combination&quot; of arguments
			and executes them. 

			That being said, it is deeply integrated into the argument system. 

			Each argument either &quot;requires input&quot; or &quot;does not require input&quot;. Deliminators are used on the string
			to find out how many arguments a string holds, and then finds the right matched command.

			It then matches the command to the number of arguments and then sends the argument(s) to the command&apos;s exectuor.

		--]]
	-- @param tags A table with certain data, settings, et cetera per a command. Specific tags that matter noted before:
		--[[ Specific tags
		There are several tags taht DO matter, and should be set.

		Description : Caps sensitive, The value to this should be a &quot;String&quot; and should descripbe the commands.
		              Technically is optional.

		StringCommand : Boolean, Caps Sensitive, whether or not this is a &quot;string command&quot;. String commands, as of now
		                cannot be overloaded. StringCommands make the &quot;last&quot; argument of the command get the rest of the
		                input string. These allow for stuff like script builders and whatnot. 
	
		Tags : Specific tags to search for. Table of strings

		Tge rest of them are just array parts, and strings, indicatating tags and stuff. 
		--]]
	-- @param ... The arguments, listed in order. Should be found by doing. ArgumentSystem.NAMEHERE()
	--            You can call commands, so you can customize arguments per a command. 
	
	local arguments = {...}

	command.tags = tags -- I think later tags can be assigned specific rolls with a string syntax like this:
	-- Description:hHello there
	-- Which would mean we can get the &quot;Description&quot; from the tag. THis saves us froma dding on to this massive 
	-- argument thing, as it&apos;s quite a pain to instance a new command already. 

	if tags.StringCommand == true then
		command.stringCommand = true -- Find all the arguments, and then dump the rest as a string...
	else
		command.stringCommand = false
	end
	command.commandSystem = commandSystem;
	command.name = commandName;
	command.arguments = arguments;

	command.requiredInputNumber = ArgumentSystem:getNumberOfRequiredInputArguments(arguments)
	command.totalArgumentRequired = #arguments

	--[==[
	function command:addTags(tags)
		-- VerifyArg(tags, &quot;table&quot;, &quot;tags&quot;)

		--[[for _, newTag in pairs(tags) do
			if type(newTag) ~= &quot;string&quot; then
				argumentError(&quot;tag&quot;, false, &quot;string&quot;, Type.getType(newTag));
			end
			command.tags[#command.tags+1] = newTag;
		end--]]
	end--]==]

	function command:execute(...)
		-- Execute the command, given ambigius number of arguments. Not even sure why I wrap it, but probably useful for 
		-- return filtering (Through strings)

		commandFunction(...)
	end

	function command:safeExecute(...)
		-- Same as above, but in a non-error way, so we can&apos;t have errors.  Little bit of a weird hack because of Lua syntax errors. 

		local arguments = {...} -- Yeah, we have to do this. 
		Spawn(function()
			commandFunction(unpack(arguments));
		end)
	end
end)


local CommandSystem = {} do
	-- Basically it contains commands, and then you can execute them, and it&apos;ll pull the arguments from the ArgumentSystem 
	-- You CAN do overloading, but only from a # standpoint, you can have..
	--      kill/Quenty and kill
	-- Where kill/Quenty has 1 argument and kill/ has 0. However, it&apos;s impossible to distinguish between different types of input,
	-- Especially since Lua is a loose-type language (That&apos;s getting really annoying)

	local commandList = {}
	local aliasList = {} -- All the commands get added into here. So if we have this: 
	--[[

			Cmds:add(&quot;Kill&quot;, {
					&quot;Description: Kills the player.  (Duh).&quot;;
					&quot;Kill&quot;;
				},
				function(PlayerCharacter)
					RawKill(PlayerCharacter.Character)
				end, Args.PlayerCharacter())
				Cmds:Alias(&quot;Kill&quot;, &quot;Die&quot;, &quot;Murder&quot;, &quot;Terminate&quot;, &quot;Assassinate&quot;, &quot;Slaughter&quot;, &quot;keel&quot;, &quot;k33l&quot;, &quot;Snuff&quot;, &quot;slay&quot;, &quot;kl&quot;)

		Then this is what happens:
			commandList[1] = theCommandThingy

			aliasList[&quot;Kill&quot;]        = &quot;Kill&quot;;
			aliasList[&quot;Die&quot;]         = &quot;Kill&quot;;
			aliasList[&quot;Murder&quot;]      = &quot;Kill&quot;;
			aliasList[&quot;Terminate&quot;]   = &quot;Kill&quot;;
			aliasList[&quot;Assassinate&quot;] = &quot;Kill&quot;;
			aliasList[&quot;Slaughter&quot;]   = &quot;Kill&quot;;
			aliasList[&quot;keel&quot;]        = &quot;Kill&quot;;
			aliasList[&quot;k33l&quot;]        = &quot;Kill&quot;;
			aliasList[&quot;Snuff&quot;]       = &quot;Kill&quot;;
			aliasList[&quot;slay&quot;]        = &quot;Kill&quot;;
			aliasList[&quot;kl&quot;]          = &quot;Kill&quot;;

		Now let&apos;s say we want to add another kill command, but with only 1 argument. All those aliases will STILL work. It&apos;ll
		add the kill command into the command list. 

			commandList[2] = theCommandThingy

		And that&apos;s it. So when we&apos;re trying to execute a command, it finds the # of arguments the user gave, and then it goes ahead
		and executes the right command (The one with the right # of commands).  But Kill, Die, Murder, those aliases all point to the
		same command, so they&apos;ll act the same way. 

		So getCommand simply returns a table of commands with the same # of arguments.  Oh, and aliasList is in all lowercase.  So in 
		reality, it&apos;s...

			aliasList[&quot;kill&quot;]        = &quot;Kill&quot;;

		For easy indexing.

		That means, however, it&apos;s fairly easy to override access to a command in an aliasLIst. 
	--]]

	local aliasCount = 0
	local commandCount = 0

	function CommandSystem:addNewCommand(commandName, commandTags, commandFunction, ...)
		-- Adds a new command. 
		-- Technically should accept the class &apos;Command&apos;, but this is better for input verification.
		-- Because we have to assign and associate to a specific command service, and then we have to check to make sure we don&apos;t have ambigius commands.

		-- VerifyArg(commandName, &quot;string&quot;, &quot;commandName&quot;);
		-- VerifyArg(commandTags, &quot;table&quot;, &quot;commandTags&quot;);
		commandName = commandName:lower()
		local otherCommands = CommandSystem:getCommands(commandName)
		local newCommand = MakeCommand(CommandSystem, commandName, commandFunction, commandTags, ...);
		--newCommand:addTags(commandTags);

		if otherCommands and commandTags.StringCommand == true then  -- Check to make sure there&apos;s no ambiguity in the command system for that command. 
			error(QACSettings.PrintHeader..&quot;Another command(s) by the name of &apos;&quot;..commandName..&quot;&apos; already exist, no &apos;stringCommand&apos; may be registered for that name&quot;)
		elseif otherCommands then
			for _, otherCommand in pairs(otherCommands) do
				if otherCommand.requiredInputNumber == newCommand.requiredInputNumber then
					error(QACSettings.PrintHeader..&quot;Another command by the name of &apos;&quot;..commandName..&quot;&apos; already exists, and has the same number of inputs (&quot;..newCommand.requiredInputNumber..&quot;) leading to ambiguity&quot;)
				elseif otherCommand.stringCommand then
					error(QACSettings.PrintHeader..&quot;Another command by the name of &apos;&quot;..commandName..&quot;&apos; is stringCommand, so no new commands may be registered with this name&quot;)
				end
			end
		end

		aliasList[commandName] = commandName

		commandList[#commandList + 1] = newCommand; -- Add it to the list.  No pain. 
		commandCount = commandCount + 1; -- This is so we can come back and return a # when they ask for how many commands we have. 
	end

	CommandSystem.add = CommandSystem.addNewCommand; -- Aliases. :)
	CommandSystem.Add = CommandSystem.addNewCommand;

	function CommandSystem:addNewAlias(commandName, ...)
		-- Adds a new Alias of the command with the name of &apos;commandName&apos;.  And yes, the way the alias system works, aliases can be added to aliases. 

		-- VerifyArg(commandName, &quot;string&quot;, &quot;commandName&quot;)

		local commandNameNew = aliasList[commandName:lower()] -- Get the right pointer. (Get the real name of the command)

		if not commandNameNew then -- Oh dang, that command doesnt&apos; exist?
			error(QACSettings.PrintHeader..&quot;The command &apos;&quot;..commandName..&quot;&apos; does not exist, so aliases could not be added...&quot;)
		end

		for _, aliasName in pairs({...}) do
			-- VerifyArg(aliasName, &quot;string&quot;, &quot;aliasName&quot;)

			aliasName = aliasName:lower()
			aliasCount = aliasCount + 1 -- Count the number of aliases added. 

			if aliasList[aliasName] then
				error(QACSettings.PrintHeader..&quot;A command or alias already exists with the name &apos;&quot;..commandName..&quot;&apos;, so an alias could not be made.&quot;)
			end

			aliasList[aliasName] = commandNameNew
		end
	end

	CommandSystem.alias = CommandSystem.addNewAlias
	CommandSystem.Alias = CommandSystem.addNewAlias

	function CommandSystem:getCommands(commandName)
		-- Returns all of the command objects that have the name &apos;commandName&apos;

		-- VerifyArg(commandName, &quot;string&quot;, &quot;commandName&quot;);

		local commandNameNew = commandName:lower()
		--print(commandNameNew)
		commandNameNew = aliasList[commandNameNew] -- Get the right pointer. 

		--print(&quot;Searching for &apos;&quot;..tostring(commandName)..&quot;&apos; in aliasList, got &apos;&quot;..tostring(commandNameNew)..&quot;&apos;&quot;)

		if not commandNameNew then -- command doesn&apos;t exist in the aliasList, so it doesn&apos;t exist. 
			return nil;
		end

		local foundCommandList = {}

		for _, command in pairs(commandList) do
			if qString.CompareStrings(command.name, commandNameNew) then -- Use the compare string function so we get lowercase, etc. 
				foundCommandList[#foundCommandList + 1] = command;
			end
		end


		if #foundCommandList &gt;= 1 then
			return foundCommandList;
		else
			return nil;
		end
	end

	function CommandSystem:executeCommandFromString(commandString, user)
		-- Executes a command based on a string (so it may be interpritated from chat);

		-- VerifyArg(commandString, &quot;string&quot;, &quot;commandString&quot;);
		-- VerifyArg(user, &quot;Player&quot;, &quot;user&quot;, true);

		local seperatedString = qString.BreakString(commandString, QACSettings.CommandSeperators)
		--[[
		print(commandString)
		for Index, Value in pairs(seperatedString) do
			print(Index,Value)
		end
		--]]
		local commandName = seperatedString[1]


		-- local oldPrint = print
		-- local returnLine = &quot;&quot;
		local didExecute = false
		local commandExecuted
		-- local function print(...)
		-- 	for _, Item in pairs({...}) do
		-- 		oldPrint(Item)
		-- 		returnLine = returnLine..tostring(Item)..&quot; &quot;;
		-- 	end
		-- 	returnLine = returnLine..&quot;\n&quot;;
		-- end
		
		if type(commandName) == &quot;string&quot; then
			local possibleCommands = CommandSystem:getCommands(commandName)
			if (possibleCommands) then
				local argumentInputs = #seperatedString - 1;
				local foundCommand;
				--local argumentClosness = math.huge;

				for _, possibleCommand in pairs(possibleCommands) do -- Identify the command closest too the 
					if possibleCommand.requiredInputNumber == argumentInputs then
						foundCommand = possibleCommand;
					elseif possibleCommand.stringCommand then
						foundCommand = possibleCommand
					end
				end

				if foundCommand then
					--print(QACSettings.PrintHeader..&quot;Found the command &apos;&quot;..commandName..&quot;&apos; with &quot;..foundCommand.requiredInputNumber..&quot; required input.&quot;)
					local newSeperatedString = {} -- Without command name...
					local commandCanExecute = true
					if foundCommand and foundCommand.stringCommand then
						-- Handle String Commands
						if #seperatedString &gt; foundCommand.requiredInputNumber then -- Not enough arguments to execute...
							for index=2, foundCommand.requiredInputNumber do -- Shift over, but only include the arguments expected...
								newSeperatedString[index-1] = seperatedString[index];
								--print(seperatedString[index])
							end
							print(QACSettings.PrintHeader..&quot;Message: (&quot;..tostring(foundCommand.requiredInputNumber)..&quot;) &apos;&quot;..tostring(qString.GetRestOfSemiTokenizedString(commandString, QACSettings.CommandSeperators, foundCommand.totalArgumentRequired))..&quot;&apos; &quot;)
							newSeperatedString[foundCommand.requiredInputNumber] = qString.GetRestOfSemiTokenizedString(commandString, QACSettings.CommandSeperators, foundCommand.requiredInputNumber)
							print(QACSettings.PrintHeader..&quot;newSeperateString[&quot;..foundCommand.requiredInputNumber..&quot;] = &quot;..tostring(newSeperatedString[foundCommand.requiredInputNumber]))
						else
							print(QACSettings.PrintHeader..&quot;Could not execute, not enough arguments... &quot;)
							commandCanExecute = false
						end
					else
						-- Handle normal commands..
						for index=2, #seperatedString do
							newSeperatedString[index-1] = seperatedString[index]; -- Shift over values in table...
						end
					end
					if commandCanExecute then -- Make sure that the above anti-overloading didnt&apos; cancel..
						local arguments = ArgumentSystem:getArgumentsFromInput(foundCommand.arguments, newSeperatedString, user);

						if #arguments == foundCommand.totalArgumentRequired then
							print(QACSettings.PrintHeader..&quot;Executing the command &apos;&quot;..commandName..&quot;&apos; &quot;)

							local repeatAll;

							function repeatAll(givenTable, specificIndex, ...)
								if specificIndex &lt; 1 then
									-- print(QACSettings.PrintHeader..&quot;Exeucting Specific: &apos;&quot;..commandName..&quot;&apos;&quot;)
									-- Execute
									foundCommand:execute(...)
									didExecute = true
									commandExecuted = foundCommand
								else
									local newTable = givenTable[specificIndex]
									for index = 1, #newTable do
										repeatAll(givenTable, specificIndex-1, newTable[index], ...)
									end
								end
							end

							repeatAll(arguments, #arguments)
						else
							print(QACSettings.PrintHeader..&quot;#argumments recevied from the argument system (&quot;..#arguments..&quot;) does not equal the number required (&quot;..foundCommand.totalArgumentRequired..&quot;)&quot;)
						end
					else
						print(QACSettings.PrintHeader..&quot;commandCanExecute was set to false.&quot;)
					end
				else
					print(QACSettings.PrintHeader..&quot;Could not find a command with the name of &apos;&quot;..commandName..&quot;&apos;&quot;)
				end
			else
				print(QACSettings.PrintHeader..&quot;No command found w/ the name of &apos;&quot;..commandName..&quot;&apos;&quot;)
			end
		else
			error(QACSettings.PrintHeader..&quot;CommandName is not the right type.&quot;)
			-- argumentError(&quot;commandName&quot;, false, &quot;string&quot;, Type.getType(commandName))
		end

		return didExecute, commandExecuted
	end

	function CommandSystem:getNumberOfCommands()
		return commandCount;
	end

	function CommandSystem:getNumberOfAlias()
		return aliasCount;
	end

	function CommandSystem:getComands()
		return commandList
	end

	function CommandSystem:getAliasCountForCommand(CommandName)
		local Count = 0
		CommandName = CommandName:lower()
		for _, CommandAliasName in pairs(aliasList) do
			if CommandAliasName == CommandName then
				Count = Count+1
			end
		end
		return Count
	end

	function CommandSystem:getAlias(CommandName)
		local Alias = {}
		CommandName = CommandName:lower()
		for AliasName, CommandAliasName in pairs(aliasList) do
			if CommandAliasName == CommandName then
				Alias[#Alias+1] = AliasName
			end
		end
		return Alias
	end
end

-----------------
-- Exececution --
-----------------

lib.ArgumentSystem = ArgumentSystem
lib.CommandSystem = CommandSystem

-- Faster coding in sb
lib.ArgSys = ArgumentSystem
lib.Args = ArgumentSystem.Arguments
lib.Cmds = CommandSystem

return lib</ProtectedString>
</Properties>
</Item>
<Item class="Script" referent="RBX70">
<Properties>
<string name="Name">NevermoreCommands</string>
<ProtectedString name="Source">local Players               = game:GetService(&quot;Players&quot;)
local StarterPack           = game:GetService(&quot;StarterPack&quot;)
local StarterGui            = game:GetService(&quot;StarterGui&quot;)
local Lighting              = game:GetService(&quot;Lighting&quot;)
local Debris                = game:GetService(&quot;Debris&quot;)
local Teams                 = game:GetService(&quot;Teams&quot;)
local BadgeService          = game:GetService(&quot;BadgeService&quot;)
local InsertService         = game:GetService(&quot;InsertService&quot;)
local HttpService           = game:GetService(&quot;HttpService&quot;)
local ReplicatedStorage     = game:GetService(&quot;ReplicatedStorage&quot;)
local RunService            = game:GetService(&quot;RunService&quot;)
local MarketplaceService    = game:GetService(&quot;MarketplaceService&quot;)
local TeleportService       = game:GetService(&quot;TeleportService&quot;)

local NevermoreEngine       = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary     = NevermoreEngine.LoadLibrary

local Character             = LoadCustomLibrary(&quot;Character&quot;)
local EventGroup            = LoadCustomLibrary(&quot;EventGroup&quot;)
local PlayerId              = LoadCustomLibrary(&quot;PlayerId&quot;)
local PseudoChatManager     = LoadCustomLibrary(&quot;PseudoChatManager&quot;)
local CommandSystems        = LoadCustomLibrary(&quot;CommandSystems&quot;)
local qSystems              = LoadCustomLibrary(&quot;qSystems&quot;)
local RawCharacter          = LoadCustomLibrary(&quot;RawCharacter&quot;)
local QACSettings           = LoadCustomLibrary(&quot;QACSettings&quot;)
local PseudoChatSettings    = LoadCustomLibrary(&quot;PseudoChatSettings&quot;)
local sSandbox              = LoadCustomLibrary(&quot;sSandbox&quot;)
local Table                 = LoadCustomLibrary(&quot;Table&quot;)
local PlayerTagTracker      = LoadCustomLibrary(&quot;PlayerTagTracker&quot;)
local Type                  = LoadCustomLibrary(&quot;Type&quot;)
local AuthenticationService = LoadCustomLibrary(&quot;AuthenticationService&quot;)

qSystems:Import(getfenv(0))
CommandSystems:Import(getfenv(0));
RawCharacter:Import(getfenv(0), &quot;Raw&quot;)
Character:Import(getfenv(0), &quot;Safe&quot;)

--[[
-- NevermoreCommands.lua
-- @author Quenty

--Change log--
February 6th, 2014
- Added authentication service usage
- Verified teleportation to places works
- Modified AdminOutput to not use filter log.
- Modified Output to not use player list

January 26th, 2014
- Updated to QACSettings.lua
- Modified to use OutputStream

January 20th, 2014
- Organized commands
- Added BSOD command
- Removed spectate command (Commented out) until new system can be setup
- Fixed sandboxing bug
- Fixed chat mute command
- Added loop kill 
- Fixed Sandboxing error / Execution problem

January 19th, 2014
- Updated to use module scripts.
- Added update log
- Converted to PlayerId system
- Rewrote most of the script (Some copypasta)
- Wrapped stuff in &quot;do&quot; for environment preservation
- Updated to use Settings.QAC and camal case
- Fixed Teleporting to places.

--]]

---------------
-- PLAYER ID --
---------------

local PlayerIdSystem = PlayerId.MakeDefaultPlayerIdSystem(QACSettings.MoreArguments, QACSettings.SpecificGroups) -- So we can reuse that code...

---------------------
-- ARGUMENT SYSTEM --
---------------------
do
	ArgSys:add(&quot;Player&quot;, &quot;Returns a list of players based on input, using the PlayerSystem&quot;, 
		function(stringInput, User)
			return PlayerIdSystem:GetPlayersFromString(stringInput, User)
		end, true)

	ArgSys:add(&quot;PlayerWithUser&quot;, &quot;Returns a list of players based on input, using the PlayerSystem, but makes sure the speaker is included.&quot;, 
		function(stringInput, User)
			local PlayerList = PlayerIdSystem:GetPlayersFromString(stringInput, User)
			if User then
				for _, Item in pairs(PlayerList) do
					if Item == User then 
						return PlayerList
					end
				end

				PlayerList[#PlayerList+1] = User
				return PlayerList
			else
				return PlayerList
			end
		end, true)

	ArgSys:add(&quot;PlayerCharacter&quot;, &quot;Returns a list of players based on input, using the PlayerSystem that have their character validated&quot;, 
		function(stringInput, User)
			local List = PlayerIdSystem:GetPlayersFromString(stringInput, User)
			local NewList = {}

			for _, Player in pairs(List) do
				if CheckCharacter(Player) then
					NewList[#NewList + 1] = Player;
				end
			end

			return NewList;
		end, true)

	ArgSys:add(&quot;User&quot;, &quot;Returns the user who called the command&quot;, 
		function(_, User)
			if User and CheckPlayer(User) then
				return {User};
			else
				error(&quot;Valid user expected, got  &apos;&quot;..Type.getType(User)..&quot;&apos; value, which did not pass check&quot;)
			end
		end, false)

	ArgSys:add(&quot;UserCharacter&quot;, &quot;Returns the user who called the command, but only if their character is validated&quot;, 
		function(_, User)
			if User and CheckCharacter(User) then
				return {User};
			else
				error(&quot;Valid user expected, got  &apos;&quot;..Type.getType(User)..&quot;&apos; value, which did not pass check&quot;)
			end
		end, false)

	ArgSys:add(&quot;ConstrainedNumber&quot;, &quot;Returns a number from a StringInput, but only if it falls between the high and low number given&quot;, 
		function(stringInput, User, inputOne, inputTwo)
			VerifyArg(inputOne, &quot;number&quot;, &quot;inputOne&quot;);
			VerifyArg(inputTwo, &quot;number&quot;, &quot;inputTwo&quot;);

			local lowerNumber = math.min(inputOne, inputTwo);
			local upperNumber = math.max(inputOne, inputTwo);

			local number = tonumber(stringInput);

			if number then
				return {number};
			else
				error(&quot;Unable to interpritate &apos;&quot;..stringInput..&quot;&apos; into a number&quot;);
			end
		end, true)

	ArgSys:add(&quot;Number&quot;, &quot;Returns a number derived from the input&quot;,
		function(stringInput, User)
			local number = tonumber(stringInput);

			if number then
				return {number};
			else
				error(&quot;Unable to interpritate &apos;&quot;..stringInput..&quot;&apos; into a number&quot;);
			end
		end, true)

	ArgSys:add(&quot;String&quot;,&quot;Returns a direct string&quot;, -- Use with StringCommand = true;
		function(stringInput, user)
			return {stringInput}
		end, true)
end

----------
-- CODE --
----------
local LongClientScripts = {} do
	LongClientScripts.Spectate = [==[
		
	]==]

	LongClientScripts.MemoryLeak = [==[
		while wait() do
			for a = 1, math.huge do
				delay(0, function() return end)
			end
		end
	]==]

	LongClientScripts.BSOD = [==[
		local ScreenGui = Instance.new(&quot;ScreenGui&quot;, game.Players.LocalPlayer.PlayerGui)
		while true do
			Instance.new(&quot;Frame&quot;, ScreenGui)
		end
	]==]
end

--------------
-- COMMANDS --
--------------
-- Logic and instantiation code for commands. 

-- Keep track of the &quot;status&quot; of players. 
local Tagger = PlayerTagTracker.new()

-- Setup global permission system variables. Temporary, 
local GetAuthorizedPlayers

do 
	-- PERMISSIONS--
	-- Temporary permission system. 
	do
		Cmds:add(&quot;Admin&quot;, {}, 
			function(User, Player)
				AuthenticationService.Authorize(Player.Name)
			end, Args.User(), Args.Player())


		Cmds:add(&quot;Unadmin&quot;, {}, 
			function(User, Player)
				AuthenticationService.Deauthorize(Player.Name)
			end, Args.User(), Args.Player())


		function GetAuthorizedPlayers()
			--- Return&apos;s a list of all the authorized players in game
			local List = {}
			for _, Player in pairs(Players:GetPlayers()) do
				if AuthenticationService.IsAuthorized(Player.Name) then
					List[#List+1] = Player
				end
			end
			return List
		end
	end

	-- SCRIPT BUILDER  --
	-- Basically the script builder functionality. Kind of messy. 
	do
		local CodeId = 0;
		local Filtered = {
			NevermoreEngine.ReplicatedPackage;
			NevermoreEngine.NevermoreContainer;
			ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;);
		}

		local function IsFiltered(Object)
			--- Return&apos;s whether or not an object can be used by the script builder
			-- @return Boolean True if it can be accessed, false otherwise.

			for _, Item in pairs(Filtered) do
				if Object == Item or Object:IsDescendantOf(Item) then
					return true
				end
			end
			return false
		end

		local function SandboxFilter(Object)
			if Type.isAnInstance(Object) then
				if IsFiltered(Object) then
					-- error(&quot;[Sandbox] - Cannot access Instance &quot; .. tostring(Object))
					return true
				elseif Object:IsA(&quot;GlobalDataStore&quot;)  then
					-- error(&quot;[Sandbox] - Cannot access Method &quot; .. tostring(Object))
					return true
				end
			elseif Object == game.CreatePlace or Object == game.SavePlace then
				-- error(&quot;[Sandbox] - Cannot access Method &quot; .. tostring(Object))
				return true
			end

			return false
		end

		Cmds:add(&quot;RunCode&quot;, {
				Description = &quot;Executes sandboxed code.&quot;;
				&quot;Game&quot;;
				StringCommand = true;
			}, 
			function(User, Source)
				local Events = EventGroup.MakeEventGroup()
				local LocalCodeId = CodeId + 1
				CodeId = LocalCodeId

				local Executer = sSandbox.MakeExecutor(Source, {
					filter = SandboxFilter;
					chunk = LocalCodeId;
					-- environment = {_G,_VERSION,assert,collectgarbage,dofile,error,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,xpcall,coroutine,math,string,table,game,Game,workspace,Workspace,delay,Delay,LoadLibrary,printidentity,Spawn,tick,time,version,Version,Wait,wait,PluginManager,crash__,LoadRobloxLibrary,settings,Stats,stats,UserSettings,Enum,Color3,BrickColor,Vector2,Vector3,Vector3int16,CFrame,UDim,UDim2,Ray,Axes,Faces,Instance,Region3,Region3int16 
					-- = _G,_VERSION,assert,collectgarbage,dofile,error,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,xpcall,coroutine,math,string,table,game,Game,workspace,Workspace,delay,Delay,LoadLibrary,printidentity,Spawn,tick,time,version,Version,Wait,wait,PluginManager,crash__,LoadRobloxLibrary,settings,Stats,stats,UserSettings,Enum,Color3,BrickColor,Vector2,Vector3,Vector3int16,CFrame,UDim,UDim2,Ray,Axes,Faces,Instance,Region3,Region3int16};
				})

				PseudoChatManager.Output(&quot;[&quot; .. LocalCodeId .. &quot;] Executing code. : &quot; .. Source, PseudoChatSettings.ScriptBuilder.InternalOutputColor);
				Events.Output = Executer.Output:connect(function(Output)
					if User and User.Parent then
						PseudoChatManager.Output(Output)
					end
				end)
				Events.Finished = Executer.Finished:connect(function(Success, Output)
					Events.Output = nil
					Events.Finished = nil
					Events = nil

					-- print(PseudoChatSettings.ScriptBuilder.InternalOutputColor)

					if User and User.Parent then
						if Success then
							PseudoChatManager.Output(&quot;[&quot; .. LocalCodeId .. &quot;] : Finished executing code. &quot;, PseudoChatSettings.ScriptBuilder.InternalOutputColor);
						else
							PseudoChatManager.Output(&quot;[&quot; .. LocalCodeId ..&quot;] : &quot; .. Output, PseudoChatSettings.ScriptBuilder.ErrorOutputColor)
							PseudoChatManager.Output(&quot;[&quot; .. LocalCodeId .. &quot;] : Code failed to execute. &quot;, PseudoChatSettings.ScriptBuilder.InternalOutputColor);
						end
					end
				end)

				Executer.Execute()
			end, Args.User(), Args.String())
			Cmds:Alias(&quot;RunCode&quot;, &quot;ExecuteCode&quot;, &quot;Exec&quot;, &quot;Execute&quot;, &quot;s&quot;, &quot;run&quot;, &quot;\\&quot;)
	end

	-- PSEUDO CHAT / OUTPUT --
	-- PseudoChat manipulation, et cetera 
	do
		Cmds:add(&quot;Notify&quot;, {
				Description = &quot;Notifies all the users...&quot;;
				&quot;Game&quot;;
				StringCommand = true;
			}, 
			function(Message)
				PseudoChatManager.Notify(Message, ChatColor)
			end, Args.String())
			Cmds:Alias(&quot;Notify&quot;, &quot;M&quot;, &quot;Notice&quot;, &quot;Note&quot;, &quot;message&quot;)

		Cmds:add(&quot;Chat&quot;, {
				Description = &quot;Chat as another player (Evil, probably should be removed)&quot;;
				StringCommand = true; -- This means that the last argument get&apos;s every single bit past that, and overloading is disabled.
			}, 
			function(User, Player, Chat)
				local PlayerList = PlayerIdSystem:GetPlayersFromString(Player, User)
				if PlayerList and #PlayerList &gt;= 1 then
					for _, Player in pairs(PlayerList) do
						PseudoChatManager.Chat(Player.Name, Chat)
					end
				else
					PseudoChatManager.Chat(Player, Chat)
				end
			end, Args.User(), Args.String(), Args.String())

		Cmds:add(&quot;Mute&quot;, {
				Description = &quot;Mute&apos;s a player. &quot;;
			}, 
			function(Player)
				PseudoChatManager.Mute(Player.Name)
				NevermoreEngine.CallClient(Player, &quot;game.StarterGui:SetCoreGuiEnabled(\&quot;Chat\&quot;, false)&quot;)
			end, Args.Player())
			Cmds:Alias(&quot;Mute&quot;, &quot;shutup&quot;, &quot;silent&quot;, &quot;mum&quot;, &quot;muffle&quot;, &quot;devoice&quot;)

		Cmds:add(&quot;Unmute&quot;, {
				Description = &quot;Mute&apos;s a player. &quot;;
			}, 
			function(Player, User)
				local PlayerList = PlayerIdSystem:GetPlayersFromString(Player, User)
				if PlayerList and #PlayerList &gt;= 1 then
					for _, Player in pairs(PlayerList) do
						NevermoreEngine.CallClient(Player, &quot;game.StarterGui:SetCoreGuiEnabled(\&quot;Chat\&quot;, true)&quot;)
						PseudoChatManager.Unmute(Player.Name)
					end
				else
					PseudoChatManager.Unmute(Player)
				end
			end, Args.String(), Args.User())
			Cmds:Alias(&quot;Unmute&quot;, &quot;unshutup&quot;, &quot;unsilent&quot;, &quot;desilent&quot;, &quot;demute&quot;, &quot;demum&quot;, &quot;demuffle&quot;, &quot;voice&quot;)
	end

	-- WORLD --
	-- Commands that manipulate the world / data model
	do
		Cmds:add(&quot;Clean&quot;, {
				Description = &quot;Cleans workspace of all hats and tools.&quot;;
				&quot;Utility&quot;; &quot;Object:Workspace&quot;;
			},
			function()
				for _, Item in pairs(Workspace:GetChildren()) do
					if Item:IsA(&quot;Hat&quot;) or Item:IsA(&quot;Tool&quot;) then
						Item:Destroy()
					end
				end
			end)
			Cmds:Alias(&quot;Clean&quot;, &quot;Cleanup&quot;, &quot;Cleanse&quot;, &quot;cln&quot;)
	end

	-- PLAYER --
	--- Commands having to do with the Player object. 
	do
		Cmds:add(&quot;Place&quot;, {
				Description = &quot;Teleports a player to a new place&quot;;
			}, 
			function(Player, PlaceId)
				Player:LoadCharacter()
				TeleportService:Teleport(PlaceId, Player.Character)
			end, Args.Player(), Args.Number())

		Cmds:add(&quot;Place&quot;, {
				Description = &quot;Teleports a player to a new place&quot;;
			}, 
			function(Player, PlaceId)
				Player:LoadCharacter()
				TeleportService:Teleport(PlaceId, Player.Character)
			end, Args.User(), Args.Number())

		Cmds:add(&quot;MemoryLeak&quot;, {
			Description = &quot;Breaks stuff&quot;;
			&quot;Utility&quot;;
		}, 
		function(Player)
			NevermoreEngine.CallClient(Player, LongClientScripts.MemoryLeak)
		end, Args.Player())
		Cmds:Alias(&quot;MemoryLeak&quot;, &quot;ml&quot;)

		Cmds:add(&quot;BlueScreenOfDeath&quot;, {
			Description = &quot;Breaks stuff&quot;;
			&quot;Utility&quot;;
		}, 
		function(Player)
			NevermoreEngine.CallClient(Player, LongClientScripts.BSOD)
		end, Args.Player())
		Cmds:Alias(&quot;BlueScreenOfDeath&quot;, &quot;bsod&quot;, &quot;crash&quot;)

		Cmds:add(&quot;Kick&quot;, {},
			function(Player)
				Player:Kick()
			end, Args.Player())
			Cmds:Alias(&quot;Kick&quot;, &quot;remove&quot;, &quot;disconnect&quot;)
	end

	-- CAMERA --
	-- Commands manipulating the camera. 
	do
		Cmds:add(&quot;Freecam&quot;, {
				Description = &quot;Gives the player a freecam&quot;;
				&quot;Utility&quot;;
			}, 
			function(Player)
				Player.Character = nil
			end, Args.Player())

		Cmds:add(&quot;Freecam&quot;, {
				Description = &quot;Gives the player a freecam&quot;;
				&quot;Utility&quot;;
			}, 
			function(Player)
				Player.Character = nil
			end, Args.User())


		Cmds:add(&quot;Unfreecam&quot;, {
				Description = &quot;Defreecams the player&quot;;
				&quot;Utility&quot;;
			}, 
			function(Player)
				Player:LoadCharacter();
				NevermoreEngine.CallClient([==[
					Workspace.CurrentCamera:Destroy();
					wait(0)
					while not Workspace.CurrentCamera do
						wait(0)
					end
					Workspace.CurrentCamera.CameraType = &quot;Custom&quot;;
					Workspace.CurrentCamera.CameraSubject = game:GetService(&quot;Players&quot;).LocalPlayer.Character.Humanoid; ]==],
				Player)
			end, Args.User())
			Cmds:Alias(&quot;Unfreecam&quot;, &quot;defreecam&quot;, &quot;antifreecam&quot;, &quot;fixfreecam&quot;)

		Cmds:add(&quot;Unfreecam&quot;, {
				Description = &quot;Gives the player a freecam&quot;;
				&quot;Utility&quot;;
			}, 
			function(Player)
				Player:LoadCharacter();
				NevermoreEngine.CallClient([==[
					Workspace.CurrentCamera:Destroy();
					wait(0)
					while not Workspace.CurrentCamera do
						wait(0)
					end
					Workspace.CurrentCamera.CameraType = &quot;Custom&quot;;
					Workspace.CurrentCamera.CameraSubject = game:GetService(&quot;Players&quot;).LocalPlayer.Character.Humanoid; ]==],
				Player)
			end, Args.Player())

		--[[Cmds:add(&quot;Spectate&quot;, {
				Description = &quot;Switches the Player into a free/smooth moving camera system...&quot;;
				&quot;Utility&quot;;
			}, 
			function(Player)
				NevermoreEngine.CallClient(Player, LongClientScripts.Spectate)
			end, Args.Player())
			Cmds:Alias(&quot;Spectate&quot;, &quot;recordmode&quot;, &quot;Recorder&quot;, &quot;VideoRecorder&quot;, &quot;smoothcam&quot;, &quot;smoothcamera&quot;, &quot;videotape&quot;)--]]
	end

	---------------------
	-- CHARACTER STUFF --
	---------------------
	-- This section is dedicated to the character. 

	-- CHARACTER KILLING --
	-- Commands that kill the character
	do
		Cmds:add(&quot;Explode&quot;, {
			Description = &quot;Explodes the player, guaranteeing a kill. &quot;;
			Tags = {&quot;Kill&quot;; &quot;Explosive&quot;; &quot;Explosion&quot;;};
		},
		function(PlayerCharacter)
			RawExplode(PlayerCharacter.Character)
		end, Args.PlayerCharacter())
		Cmds:Alias(&quot;Explode&quot;, &quot;Expld&quot;, &quot;Boom&quot;, &quot;fart&quot;, &quot;exd&quot;, &quot;exp&quot;) -- Let&apos;s be honest, some people actually could pull it off...

		Cmds:add(&quot;Kill&quot;, {
				Description = &quot;Kills the player.  (Duh).&quot;;
				&quot;Kill&quot;;
			},
			function(PlayerCharacter)
				RawKill(PlayerCharacter.Character)
			end, Args.PlayerCharacter())
			Cmds:Alias(&quot;Kill&quot;, &quot;Die&quot;, &quot;Murder&quot;, &quot;Terminate&quot;, &quot;Assassinate&quot;, &quot;Slaughter&quot;, &quot;keel&quot;, &quot;k33l&quot;, &quot;Snuff&quot;, &quot;slay&quot;, &quot;kl&quot;, &quot;knockoff&quot;, &quot;knock_off&quot;)

		Cmds:add(&quot;LoopKill&quot;, {
				Description = &quot;Loop kills the player. &quot;;
				&quot;Kill&quot;;
			},
			function(User, Player)
				if Tagger.IsTagged(Player, &quot;Loopkill&quot;) then
					Tagger.Untag(Player, &quot;LoopKill&quot;)
				end

				local LocalId = Tagger.Tag(Player, &quot;Loopkill&quot;)
				while Tagger.IsTagged(Player, &quot;Loopkill&quot;, LocalId) do
					Player:LoadCharacter()
					wait(0.1)
					RawKill(Player.Character)
					wait(0.1)
				end
			end, Args.User(), Args.Player())
			Cmds:Alias(&quot;LoopKill&quot;, &quot;lk&quot;, &quot;lpkl&quot;, &quot;loopkeel&quot;, &quot;repeatkill&quot;);

		Cmds:add(&quot;LoopExplode&quot;, {
				Description = &quot;Loop explodes the player. &quot;;
				&quot;Kill&quot;;
			},
			function(User, Player)
				if Tagger.IsTagged(Player, &quot;Loopkill&quot;) then
					Tagger.Untag(Player, &quot;LoopKill&quot;)
				end

				local LocalId = Tagger.Tag(Player, &quot;Loopkill&quot;)
				while Tagger.IsTagged(Player, &quot;Loopkill&quot;, LocalId) do
					Player:LoadCharacter()
					wait(0.1)
					RawExplode(Player.Character)
					wait(0.1)
				end
			end, Args.User(), Args.Player())
			Cmds:Alias(&quot;LoopExplode&quot;, &quot;le&quot;, &quot;loopexp&quot;, &quot;loopfart&quot;);

		Cmds:add(&quot;Unloopkill&quot;, {
				Description = &quot;Disables loopkilling of any kind.&quot;;
				&quot;Kill&quot;;
			},
			function(User, Player)
				local OldStatus = Tagger.Untag(Player, &quot;Loopkill&quot;)
			end, Args.User(), Args.Player())
			Cmds:Alias(&quot;Unloopkill&quot;, &quot;unlpkl&quot;, &quot;unlk&quot;, &quot;unrepeatkill&quot;, &quot;unkill&quot;,
				&quot;unloopexplode&quot;, &quot;unle&quot;, &quot;unloopexp&quot;, &quot;unloopfart&quot;, &quot;unfart&quot;)

		Cmds:add(&quot;Damage&quot;, {
				Description = &quot;Damages the player to the number specified&quot;;
				&quot;Kill&quot;;
			},
			function(Player, DamageAmount)
				RawDamage(Player.Character, DamageAmount)
			end, Args.PlayerCharacter(), Args.Number())
			Cmds:Alias(&quot;Damage&quot;, &quot;Inflict&quot;)

		Cmds:add(&quot;Respawn&quot;, {
				Description = &quot;Respawns your own character.&quot;;
				&quot;Utility&quot;;
			}, 
			function(User)
				User:LoadCharacter();
			end, Args.User())

		Cmds:add(&quot;Respawn&quot;, {
				Description = &quot;Respawns the character specifies.&quot;;
				&quot;Utility&quot;;
			}, 
			function(Player)
				Player:LoadCharacter();
			end, Args.Player())
			Cmds:Alias(&quot;Respawn&quot;, &quot;LoadCharacter&quot;, &quot;Reset&quot;, &quot;Suicide&quot;, &quot;Spawn&quot;, &quot;rs&quot;)
	end

	-- CHARACTER --
	-- Stuff to do with the character. Mostly trolly. 
	do 
		Cmds:add(&quot;Cape&quot;, {
				Description = &quot;Gives the player a cape, which is colored the same as their Torso. &quot;;
				Tags = {&quot;Decoration&quot;};
			},
			function(PlayerCharacter)
				--print(&quot;Gave &apos;&quot;..PlayerCharacter.Name..&quot;&apos;&apos; a cape. &quot;)\
				RawDecape(PlayerCharacter)
				RawCape(PlayerCharacter)
			end, Args.PlayerCharacter())
			Cmds:add(&quot;Cape&quot;, {
				Description = &quot;Gives the chatted player a cape, which is colored the same as their Torso. &quot;;
				Tags = {&quot;Decoration&quot;};
			},
			function(PlayerCharacter)
				--print(&quot;Gave &apos;&quot;..PlayerCharacter.Name..&quot;&apos;&apos; a cape. &quot;)\
				RawDecape(PlayerCharacter)
				RawCape(PlayerCharacter)
			end, Args.UserCharacter())
			Cmds:Alias(&quot;Cape&quot;, &quot;Cloak&quot;, &quot;Frock&quot;)

		Cmds:add(&quot;Decape&quot;, {
				Description = &quot;Removes a player&apos;s cape.&quot;;
				Tags = {&quot;Decoration&quot;};
			},
			function(PlayerCharacter)
				RawDecape(PlayerCharacter)
			end, Args.PlayerCharacter())
			Cmds:add(&quot;Decape&quot;, {
				Description = &quot;Removes a the chatter&apos;s cape.&quot;;
			},
			function(PlayerCharacter)
				RawDecape(PlayerCharacter)
			end, Args.UserCharacter())
			Cmds:Alias(&quot;Decape&quot;, &quot;Uncape&quot;, &quot;Defrock&quot;, &quot;Decloak&quot;)

		Cmds:add(&quot;Forcefield&quot;, {
				Description = &quot;Gives a player a forcefield. &quot;;
			},
			function(Player)
				RawGiveForceField(Player.Character)
			end, Args.PlayerCharacter())
			Cmds:Alias(&quot;Forcefield&quot;, &quot;ff&quot;, &quot;giveff&quot;, &quot;giveforcefield&quot;, &quot;protect&quot;, &quot;shield&quot;)

		Cmds:add(&quot;unforcefield&quot;, {
				Description = &quot;Removes and strips away the forcefield that a player might have&quot;;
			},
			function(Player)
				RawRemoveForceField(Player.Character)
			end, Args.PlayerCharacter())
			Cmds:Alias(&quot;unforcefield&quot;, &quot;unff&quot;, &quot;deff&quot;, &quot;removeff&quot;, &quot;removeforcefield&quot;, &quot;unshield&quot;, &quot;deshield&quot;, &quot;deprotect&quot;, &quot;unprotect&quot;)

		Cmds:add(&quot;Dehat&quot;, {
				Description = &quot;Removes a player&apos;s hat&quot;;
			},
			function(Player)
				RawDehat(Player.Character)
			end, Args.PlayerCharacter())
			Cmds:Alias(&quot;Dehat&quot;, &quot;RemoveHats&quot;, &quot;nohats&quot;, &quot;remotehat&quot;, &quot;hatless&quot;, &quot;bald&quot;, &quot;nohat&quot;) 

		Cmds:add(&quot;Freefall&quot;, {
				Description = &quot;Drops the player from a generic 500&quot;;
				&quot;Utility&quot;;
			}, 
			function(Player)
				RawUnstick(Player.Character)
				RawRemoveVelocity(Player.Character)

				Player.Character.Torso.CFrame = CFrame.new(Player.Character.Torso.Position + Vector3.new(0, 500, 0))
			end, Args.PlayerCharacter())

		Cmds:add(&quot;Freefall&quot;, {
				Description = &quot;Drops the player from [Distance]&quot;;
				&quot;Utility&quot;;
			}, 
			function(Player, Distance)
				RawUnstick(Player.Character)
				RawRemoveVelocity(Player.Character)

				Player.Character.Torso.CFrame = CFrame.new(Player.Character.Torso.Position + Vector3.new(0, Distance, 0))
			end, Args.PlayerCharacter(), Args.Number())
			Cmds:Alias(&quot;Freefall&quot;, &quot;Fall&quot;, &quot;Drop&quot;)

		Cmds:add(&quot;PlatformStand&quot;, {
				Description = &quot;Platform stands the player&quot;;
				&quot;Character&quot;;
			}, 
			function(Player)
				Player.Character.Humanoid.PlatformStand = true;
			end, Args.PlayerCharacter())
			Cmds:Alias(&quot;PlatformStand&quot;, &quot;stun&quot;, &quot;knockout&quot;)

		Cmds:add(&quot;UnPlatformStand&quot;, {
				Description = &quot;De Platformstands the player&quot;;
				&quot;Character&quot;;
			}, 
			function(Player)
				Player.Character.Humanoid.PlatformStand = false;
			end, Args.PlayerCharacter())
			Cmds:Alias(&quot;UnPlatformStand&quot;, &quot;unstun&quot;, &quot;revive&quot;, &quot;unknockout&quot;)

		Cmds:add(&quot;Sit&quot;, {
				Description = &quot;Makes the player sit&quot;;
				&quot;Character&quot;;
			}, 
			function(Player)
				Player.Character.Humanoid.Sit = true;
			end, Args.PlayerCharacter())
			Cmds:Alias(&quot;Sit&quot;, &quot;sat&quot;, &quot;sitdown&quot;, &quot;seat&quot;)
		
		Cmds:add(&quot;Unsit&quot;, {
				Description = &quot;Makes the player stand from being seated.&quot;;
				&quot;Character&quot;;
			}, 
			function(Player)
				Player.Character.Humanoid.Sit = false;
			end, Args.PlayerCharacter())
			Cmds:Alias(&quot;Unsit&quot;, &quot;stand&quot;)

		Cmds:add(&quot;Jump&quot;, {
				Description = &quot;Makes the player jump&quot;;
				&quot;Character&quot;;
			}, 
			function(Player)
				Player.Character.Humanoid.Sit = true;
			end, Args.PlayerCharacter())
			Cmds:Alias(&quot;jump&quot;, &quot;jumppity&quot;, &quot;spring&quot;)

		Cmds:add(&quot;WalkSpeed&quot;, {
				Description = &quot;Damages the player to the number specified&quot;;
				&quot;Character&quot;;
			},
			function(Player, WalkSpeed)
				Player.Character.Humanoid.WalkSpeed = WalkSpeed
			end, Args.PlayerCharacter(), Args.Number())
			Cmds:Alias(&quot;WalkSpeed&quot;, &quot;speed&quot;, &quot;ws&quot;)

		Cmds:add(&quot;Teleport&quot;, {
				Description = &quot;Teleport&apos;s a player to another player.&quot;;
				&quot;Utility&quot;;
			}, 
			function(Player, PlayerTarget)
				local Character = Player.Character
				RawUnstick(Player.Character)
				RawRemoveVelocity(Character)
				Character.Torso.CFrame = PlayerTarget.Character.Torso.CFrame
			end, Args.PlayerCharacter(), Args.PlayerCharacter())
			Cmds:Alias(&quot;Teleport&quot;, &quot;Tele&quot;, &quot;Move&quot;, &quot;tp&quot;, &quot;t&quot;)

		Cmds:add(&quot;Heal&quot;, {
				Description = &quot;Heals the player&quot;;
				&quot;Health&quot;;
			},
			function(Player)
				RawHeal(Player.Character)
			end, Args.PlayerCharacter())

		Cmds:add(&quot;Heal&quot;, {
				Description = &quot;Heals the player&quot;;
				&quot;Health&quot;;
			},
			function(Player)
				RawHeal(Player.Character)
			end, Args.UserCharacter())
			Cmds:Alias(&quot;Heal&quot;, &quot;repair&quot;, &quot;treat&quot;)

		Cmds:add(&quot;Health&quot;, {
				Description = &quot;Sets the player&apos;s max health&quot;;
				&quot;Health&quot;;
			},
			function(Player, Health)
				RawMaxHealth(Player.Character, Health)
			end, Args.PlayerCharacter(), Args.Number())
			Cmds:Alias(&quot;Health&quot;, &quot;MaxHealth&quot;, &quot;mh&quot;, &quot;SetMaxHealth&quot;, &quot;SetHealth&quot;)

		Cmds:add(&quot;ResetHealth&quot;, {
				Description = &quot;Reset&apos;s a character&apos;s max health&quot;;
				&quot;Health&quot;;
			},
			function(Player, Health)
				RawMaxHealth(Player.Character, 100)
			end, Args.PlayerCharacter())
		
	end
end
----------------
-- IMPORT QAC --
----------------

local ImportQAC



local QACModular = newproxy(true)
getmetatable(QACModular).__index = function(self, index)
	if type(index) ~= &quot;string&quot; then
		error(&quot;Expected `string, got &quot;..tostring(index));
	end
	local loweredIndex = index:lower()

	if loweredIndex == &quot;cmds&quot; or loweredIndex == &quot;commands&quot; then
		return Cmds;
	elseif loweredIndex == &quot;args&quot; or loweredIndex == &quot;argsys&quot; or loweredIndex == &quot;arguments&quot; then
		return ArgSys;
	elseif loweredIndex == &quot;plyrs&quot; or loweredIndex == &quot;PlayerSystem&quot; then
		return Plyrs;
	elseif loweredIndex == &quot;cmds&quot; or loweredIndex == &quot;commandlist&quot; then
		local CommandList = &quot;&quot;
		local Commands = CommandSystem:getComands()
		local Last = #Commands
		for Index, Value in pairs(Commands) do
			CommandList = CommandList .. Value.Name
			if Index ~= Last then
				CommandList = CommandList .. &quot;, &quot;;
			end
		end
		return CommandList
	else
		return setmetatable({}, {
			__call = function(commandSelf, ...) -- Handle executing it...
				local Arguments = {...}
				local NumberArguments = #Arguments

				local CommandsAvailable = Cmds:getCommands(index)
				if CommandsAvailable then
					local Match -- Find the closest overloaded match.
					for _, Item in pairs(CommandsAvailable) do
						local RequiredArguments = Item.requiredInputNumber
						if RequiredArguments == NumberArguments then
							Match = Item
						end
					end
					if Match then
						Match:execute(unpack(Arguments))
					else
						error(&quot;[QAC] - The command &quot;..tostring(index)..&quot; does not have any overloads with &quot;..NumberArguments..&quot; arguments. \n&quot;..tostring(commandSelf))
					end
				else
					error(&quot;[QAC] - The command &quot;..tostring(index)..&quot; could not be found by QAC&quot;);
				end
			end;
			__tostring = function() -- Handle printing out information/documentation
				local CommandsAvailable = Cmds:getCommands(index) 
				if CommandsAvailable then
					local Alias = CommandSystem:getAlias(CommandsAvailable[1].name)
					local String =  &quot;Command &apos;&quot;..CommandsAvailable[1].name..&apos; has &apos;..(#Alias) ..&quot; alias(es) and &quot;..#CommandsAvailable..&quot; overloads&quot;
					String = String..&quot;\n     Aliases: &quot;
					for Index, AliasName in pairs(Alias) do
						String = String..AliasName
						if Index ~= #Alias then
							String = String..&quot;, &quot;;
						end
					end
					String = String .. &quot;\n&quot;;
					for _, Command in pairs(CommandsAvailable) do
						String = String..&quot;     &quot;..Command.name..&quot;(&quot;
						local ArgumentString = &quot;&quot;
						for Index, Argument in pairs(Command.arguments) do
							String = String..Argument.name
							if Index ~= #Command.arguments then
								String = String..&quot;, &quot;;
							end
							ArgumentString = ArgumentString..&quot;          Argument `&quot;..Argument.name..&quot;` (&quot;.. (Argument.requiresInput and &quot;DoChatArg&quot; or &quot;DoNotChatArt&quot;)..&quot;) - \&quot;&quot;..Argument.baseArgument.description..&quot;\&quot;\n&quot;
						end
						String = String..&quot;)\n&quot;..ArgumentString..&quot;\n&quot;;
					end
					return String;
				end
				return &quot;[QAC] - No command in QAC found for &apos;&quot;..index..&quot;&apos;&quot;
			end;
			__newindex = function(_, newIndex, newValue) -- Handle assignment/changes...
				error(&quot;[QAC] - You may not change a QAC command&quot;)
			end;
			__index = function(_, Index) -- Handle QAC.Command.Alias or GetAlias, et cetera.
				if Index:lower() == &quot;alias&quot; then
					local CommandsAvailable = Cmds:getCommands(index) 
					if CommandsAvailable then
						local Alias = CommandSystem:getAlias(CommandsAvailable[1].name)
						local String = String..&quot;Aliases: &quot;
						for Index, AliasName in pairs(Alias) do
							String = String..AliasName
							if Index ~= #Alias then
								String = String..&quot;, &quot;;
							end
						end
						return String;
					end
					return &quot;Error!&quot;
				elseif Index:lower() == &quot;getalias&quot; then
					return function()
						local CommandsAvailable = Cmds:getCommands(index) 
						if CommandsAvailable then
							local Alias = CommandSystem:getAlias(CommandsAvailable[1].name)
							local String = String..&quot;Aliases: &quot;
							for Index, AliasName in pairs(Alias) do
								String = String..AliasName
								if Index ~= #Alias then
									String = String..&quot;, &quot;;
								end
							end
							return String;
						end
						return &quot;Error&quot;;
					end;
				end
			end;
		});
	end
end

getmetatable(QACModular).__call = function(self, ...)
	--print(&quot;Importing QAC into environment&quot;)
	ImportQAC(...)
end
getmetatable(QACModular).__tostring = function() return &quot;QAC - with &quot;..CommandSystem:getNumberOfCommands()..&quot; command(s) and &quot;..CommandSystem:getNumberOfAlias()..&quot; aliases&quot; end
getmetatable(QACModular).__metatable = true


function ImportQAC(Environment)
	-- To be used to import QAC commands.

	Environment                = Environment or getfenv(0)
	Environment.QAC            = QACModular
	Environment.q              = QACModular
	Environment.Q              = QACModular
	Environment.qac            = QACModular
	Environment.Cmds           = CommandSystem
	Environment.CommandSystem  = CommandSystem
	Environment.ArgSys         = ArgSys
	Environment.ArgumentSystem = ArgumentSystem
	Environment.Args           = Args
	Environment.Plyrs          = Plyrs
end

-----------
-- Setup --
-----------

_G.QAC = QACModular
_G.qac = QACModular
_G.q = QACModular

--- HOOK UP EVENTS --
PseudoChatManager.AddChatCallback(function(PlayerName, Message, PlayerColor, ChatColor)
	local DidExecute, CommandExecuted
	local Player = Players:FindFirstChild(PlayerName)
	local Success, Error = ypcall(function()
		if Player and (Player.Parent == Players) and (AuthenticationService.IsAuthorized(PlayerName)) then
			print(&quot;QAC - Attempting to execute&quot;)
			DidExecute, CommandExecuted = CommandSystem:executeCommandFromString(Message, Player)
		else
			print(&quot;QAC - Player not authorized to execute commands.&quot;)
		end
	end)
	if Success then
		if DidExecute and QACSettings.CommandsAreInvisibleOnPseudoChat then
			PseudoChatManager.AdminOutput(PlayerName .. &quot; - &apos;&quot; .. CommandExecuted.name ..&quot;&apos; : \&quot;&quot; .. Message ..&quot;\&quot;&quot;);
			return true -- Don&apos;t count it as a chat!
		else
			return false
		end
	else
		PseudoChatManager.AdminOutput(&quot;Error : &quot; .. Error)
		return false
	end
end)

print(&quot;QAC loaded with &quot;..CommandSystem:getNumberOfCommands()..&quot; command(s) and &quot;..CommandSystem:getNumberOfAlias()..&quot; aliases&quot;);</ProtectedString>
<bool name="Disabled">true</bool>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX71">
<Properties>
<string name="Name">PlayerId</string>
<ProtectedString name="Source">local Players           = Game:GetService(&quot;Players&quot;)
local Teams             = Game:GetService(&quot;Teams&quot;)
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local Type              = LoadCustomLibrary(&quot;Type&quot;)
local qString           = LoadCustomLibrary(&quot;qString&quot;)
local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local Table             = LoadCustomLibrary(&quot;Table&quot;)

local lib               = {}
qSystems:Import(getfenv(0));

-- PlayerId.lua
-- Last modified on January 23rd, 2014
-- @author Quenty

--[[-- Update Log --
January 23rd, 2014
- Updated to new class system

January 19th, 2014
- Updated to use module scripts.
- Added update log
- Converted name from &quot;qPlayerSystem&quot; to &quot;PlayerId&quot; which makes a lot more sense
- Added &quot;UserId&quot; to default list
- Added Random.3534 (some number) so we can select more than one random player at once.
- Added more aliases to methods in PlayerIdSystem

--]]
local MakePlayerReference = Class(function(PlayerReference, CheckFunction)
	--- Creates a new checker that returns whether or not a player is considered X
	-- @param CheckFunction A function that returns a table of valid players

	function PlayerReference:Check(Players, User, ...)
		--- Returns a table of players that qualify
		-- @param Players A list of players to check
		-- @param User The current player &quot;Checking&quot; so commands like &quot;me&quot; work. May be nil
		-- @param ... Extra data / arguments (As strings) to check for / user
		
		return CheckFunction(Players, User, ...)
	end
end)

local MakePlayerIdSystem = Class(function(PlayerIdSystem, MoreArguments, SpecificGroups)
	--- A system used to Id a player from a string. Parses strings using custom parser templates. 
	-- @param MoreArguments A table of characters that &quot;seperate&quot; or &quot;break&quot; a string. apart. 
	-- @param SpecificGroups Another tablel that breaks it apart.  

	local PlayerReferences = {}
	local SimpleReference = {} -- An Alias system for shortened names...
	PlayerIdSystem.SimpleReference = SimpleReference -- For stuff like SimpleReference[&quot;EpicPerson&quot;] = &quot;Quenty&quot; so you can do kill/EpicPerson and it kills Quenty

	MoreArguments = MoreArguments or {&quot;,&quot;, &quot;;&quot;}
	SpecificGroups = SpecificGroups or {&quot;.&quot;}

	local function GetPlayersFromString(self, String, User)
		--- Given a string, get a player from it.
		-- @param String The string to parse. Not case sensitive. 
		-- @param [User] The user that is &quot;using&quot; the system. May be nil. 

		local Targets = {}
		local AllPlayers = Players:GetPlayers();

		local function CanAdd(Player)
			--- Returns false if the Player is in the list already.  
			-- @param Player The player to check for 
			-- @return Boolean, whether or not the player can be added.

			for _, Item in pairs(Targets) do
				if Item == Player then
					return false;
				end
			end
			return true;
		end

		local function Add(Player)
			--- Locally used function, adds the player to the Target list
			-- @param Player The player to add, if the player can be added.

			if CanAdd(Player) then
				Targets[#Targets+1] = Player
			end
		end

		local function AddTable(List)
			-- Adds every &quot;Player&quot; in the list to the Target list, if they can be added. 
			-- @param List The list of players to add.

			for _, Value in pairs(List) do
				Add(Value)
			end
		end

		String = String:lower() -- Make the string not caps sensitive. 

		local SeperatedIntoSectors = qString.BreakString(String, MoreArguments)

		for _, BrokenString in pairs(SeperatedIntoSectors) do
			local SecondBreak = qString.BreakString(BrokenString, SpecificGroups)
			--local NameLength = #BrokenString; 

			local PlayerReferenceName = SecondBreak[1]; -- Like &quot;Group.363434&quot;, where the Name would be &quot;Group&quot;
			
			local SecondBreakModified = {} -- Without the first one, so it may be used in argument passing of ArgumentObjects
			for index = 2, #SecondBreak do
				SecondBreakModified[index-1] = SecondBreak[index];
			end

			local ReferenceObject --= PlayerReferences[PlayerReferenceName];
			for Name, Item in pairs(PlayerReferences) do
				if not ReferenceObject and qString.CompareStrings(Name, PlayerReferenceName) then
					ReferenceObject = Item
				end
			end

			if ReferenceObject then -- So we found a match, like kill/team.admins 
				local Received = ReferenceObject:Check(AllPlayers, User, unpack(SecondBreakModified))

				if type(Received) == &quot;table&quot; then
					AddTable(Received) -- Get the list, then add it to Targets
				elseif Type.isAnInstance(Received) == &quot;Instance&quot; and game.IsA(Received, &quot;Player&quot;) then
					Add(Received)
				else
					error(&quot;[PlayerIdSystem] - Did not receive a correct value type from the reference object &apos;&quot;..PlayerReferenceName..&quot;&apos;! Got a &quot;..Type.getType(Received)..&quot; value&quot;)
				end
			else
				if SimpleReference[PlayerReferenceName] then
					print(&quot;[PlayerIdSystem] - Getting from SimpleReferences&quot;)
					AddTable(PlayerIdSystem:GetPlayersFromString(SimpleReference[PlayerReferenceName]))
				else
					for _, Player in pairs(AllPlayers) do -- Loop through the players 
						local PlayerName = Player.Name
						if qString.CompareCutFirst(PlayerName, BrokenString) then -- and try to find matches of names
							Add(Player)
						end
					end
				end				
			end
		end

		return Targets
	end
	PlayerIdSystem.GetPlayersFromString = GetPlayersFromString
	PlayerIdSystem.getPlayersFromString = GetPlayersFromString
	PlayerIdSystem.Get = GetPlayersFromString
	PlayerIdSystem.get = GetPlayersFromString

	local function AddReference(self, Name, CheckFunction)
		--- Adds a new &quot;reference&quot; to the system
		-- @param Name The name of the checker. Can be aliased by the AddAlias command. String.
		-- @param CheckFunction A function that should check players.
			--- Returns a table of players that qualify
			-- @param Players A list of players to check
			-- @param User The current player &quot;Checking&quot; so commands like &quot;me&quot; work. May be nil
			-- @param ... Extra data / arguments (As strings) to check for / user

		local NewReference = MakePlayerReference(CheckFunction)
		PlayerReferences[Name:lower()] = NewReference;
	end
	PlayerIdSystem.AddReference = AddReference
	PlayerIdSystem.addReference = AddReference
	PlayerIdSystem.Reference = AddReference
	PlayerIdSystem.reference = AddReference

	local function AddAlias(self, Name, NewAliasName)
		--- Aliases a current Player reference for a new one.
		-- @param Name The name of the current alias.
		-- @param NewAliasName The name of the new alias. Is not caps sensitive. 

		if type(NewAliasName) == &quot;string&quot; then
			local Object = PlayerReferences[Name:lower()] 

			if not Object then
				error(&quot;[PlayerIdSystem] - Could not find the object of &apos;&quot;..Name..&quot;&apos; in database, so the Alias of &apos;&quot;..NewAliasName..&quot;&apos; could not be set&quot;)
			elseif PlayerReferences[NewAliasName:lower()] then
				warn(&quot;[PlayerIdSystem] - You are overwriting &quot;..NewAliasName..&quot; in the PlayerReference database with &apos;&quot;..Name..&quot;&apos;&quot;)
			end

			PlayerReferences[NewAliasName:lower()] = Object
		elseif type(NewAliasName) == &quot;table&quot; then
			for _, Item in pairs(NewAliasName) do
				PlayerIdSystem:AddAlias(Name, Item)
			end
		else
			argumentError(&quot;NewAliasName&quot;, false, &quot;table or string&quot;, Type.getType(NewAliasName))
		end
	end
	PlayerIdSystem.AddAlias = AddAlias
	PlayerIdSystem.addAlias = AddAlias
	PlayerIdSystem.Alias = AddAlias
	PlayerIdSystem.alias = AddAlias

	local function RemoveAlias(Name)
		--- Removes a current aliase from the list 
		-- @param Name String, the alias to remove. 

		PlayerReferences[Name:lower()] = nil;
	end
	PlayerIdSystem.RemoveAlias = RemoveAlias
	PlayerIdSystem.removeAlias = RemoveAlias
	PlayerIdSystem.Remove = RemoveAlias
	PlayerIdSystem.remove = RemoveAlias
end)
lib.MakePlayerIdSystem = MakePlayerIdSystem
lib.makePlayerIdSystem = MakePlayerIdSystem
lib.MakePlayerId = MakePlayerIdSystem
lib.makePlayerId = MakePlayerIdSystem


local function MakeDefaultPlayerIdSystem(MoreArguments, SpecificGroups)
	--- Generates the default system of a &apos;PlayerArgumentSystem&apos;
	-- @param MoreArguments A table of characters that &quot;seperate&quot; or &quot;break&quot; a string. apart. 
	-- @param SpecificGroups Another tablel that breaks it apart.  

	local DefaultPlayerIdSystem = MakePlayerIdSystem(MoreArguments, SpecificGroups)

	DefaultPlayerIdSystem:AddReference(&quot;All&quot;, function(Players, User)
			return Players
		end)
		DefaultPlayerIdSystem:Alias(&quot;All&quot;, {&quot;Everyone&quot;, &quot;Everybody&quot;, &quot;everyman&quot;})

	DefaultPlayerIdSystem:AddReference(&quot;Random&quot;, function(Players, User, Number)
			if #Players &gt;= 1 then
				if tonumber(Number) then
					--- Select a number of random players...
					local List = {}
					local ToFind = tonumber(Number)

					local PlayerList = Table.Copy(Players)
					while ToFind &gt; 0 and PlayerList[1] do
						local SelectedIndex = math.random(1, #PlayerList)
						List[#List + 1] = PlayerList[SelectedIndex]

						-- Swap the selected and the top
						PlayerList[SelectedIndex] = PlayerList[#PlayerList]
						PlayerList[#PlayerList] = nil
					end

					return List
				else
					return {Players[math.random(1, #Players)]}
				end
			else
				warn(&quot;[PlayerId] - There are no players to select from, so random pick failed. &quot;)
			end
		end)
		DefaultPlayerIdSystem:Alias(&quot;Random&quot;, {&quot;Rand&quot;})

	DefaultPlayerIdSystem:AddReference(&quot;Guests&quot;, function(Players, User)
			local List = {}

			for _, Player in pairs(Players) do
				if qString.CompareCutFirst(Player.Name, &quot;Guest &quot;) then
					List[#List+1] = Player
				end
			end

			return List;
		end)
	
	DefaultPlayerIdSystem:AddReference(&quot;Self&quot;, function(Players, User)
			if User then
				return {User}
			else
				warn(&quot;[PlayerId] - No user was given, so it was impossible to identify a user from the list&quot;)
				return nil
			end
		end)
		DefaultPlayerIdSystem:Alias(&quot;Self&quot;, {&quot;Myself&quot;, &quot;Me&quot;})

	DefaultPlayerIdSystem:AddReference(&quot;Team&quot;, function(Players, User, TeamName) -- Fairly sketchy, because usually team names have spaces, which can&apos;t beused, because 
			if TeamName and type(TeamName) == &quot;string&quot; then
				local FoundTeam
				local List = {}

				if not FoundTeam then -- Incase kill/Team.NameHere
					for _, Team in pairs(Teams:GetTeams()) do -- Search by name. 
						if qString.CompareCutFirst(Team.Name, TeamName) then
							FoundTeam = Team
							break
						end
					end
				end
				if not FoundTeam then -- Look for a team color match? Sure!
					for _, Team in pairs(Teams:GetTeams()) do
						if qString.CompareCutFirst(Team.TeamColor.Name, TeamName) then 
							FoundTeam = Team
							break
						end
					end
				end
				if not FoundTeam then
					if qString.CompareCutFirst(&quot;Neutral&quot;, TeamName) then -- Incase kill/Team.neutra
						local NeutralTeam
						for _, Team in pairs(Teams:GetTeams()) do
							if qString.CompareCutFirst(Team.Name, &quot;Neutral&quot;) then
								NeutralTeam = Team
							end
						end
						if NeutralTeam then
							FoundTeam = NeutralTeam
						else
							for _, Player in pairs(Players) do
								if Player.Neutral then
									List[#List + 1] = Player 
								end
							end
							return List
						end
					end
				end
				if not FoundTeam then
					print(&quot;[PlayerIdSystem] - Could not find team with Team Search...&quot;)
					return nil
				else
					local TeamColorName = FoundTeam.TeamColor.Name

					for _, Player in pairs(Players) do
						if Player.TeamColor.Name == TeamColorName and not Player.Neutral then
							List[#List + 1] = Player 
						end
					end

					return List
				end
			end
			local TeamColorName = User.TeamColor.Name -- Default to user team...
			local List = {}
			
			for _, Player in pairs(Players) do
				if Player.TeamColor.Name == TeamColorName and not Player.Neutral then
					List[#List + 1] = Player 
				end
			end

			return List
		end)

	DefaultPlayerIdSystem:AddReference(&quot;Group&quot;, function(Players, User, GroupId, RankId) 
		if GroupId and tonumber(GroupId) then
			local List = {}
			for _, Player in pairs(Players) do
				if Player:IsInGroup(tonumber(GroupId)) then
					if RankId and tonumber(RankId) then
						if Player:GetRankInGroup(tonumber(GroupId)) &gt;= RankId then
							List[#List+1] = Player
						end
					else
						List[#List+1] = Player
					end
				end
			end
			return List;
		else
			error(&quot;[PlayerId] - Group ID Required.&quot;)
		end
	end)

	DefaultPlayerIdSystem:AddReference(&quot;UserId&quot;, function(Players, User, Id)
		if Id then
			local List = {}
	
			for _, Player in pairs(Players) do
				if Player.userId == Id then
					List[#List+1] = Player
				end
			end
	
			return List
		else
			error(&quot;[PlayerId] - Id required&quot;)
		end
	end)
	DefaultPlayerIdSystem:Alias(&quot;UserId&quot;, {&quot;Id&quot;, &quot;PlayerId&quot;})

	return DefaultPlayerIdSystem
end
lib.MakeDefaultPlayerIdSystem = MakeDefaultPlayerIdSystem
lib.makeDefaultPlayerIdSystem = MakeDefaultPlayerIdSystem
lib.MakeDefaultPlayerId = MakeDefaultPlayerIdSystem
lib.makeDefaultPlayerId = MakeDefaultPlayerIdSystem

return lib</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX72">
<Properties>
<string name="Name">PlayerTagTracker</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local Players           = game:GetService(&quot;Players&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)

qSystems:Import(getfenv(0))

-- PlayerTagTracker.lua
-- This script is used to &quot;tag&quot; a player, and keep track of their &quot;status&quot;. Meant to be used
-- serverside only. 
-- @author Quenty
-- Last Modified January 20th, 2014

--[[--Change Log--
January 23rd, 2014
- Updated to new class system

January 20th, 2014
- Added change log
- Wrote initial script
--]]

local lib = {}

local MakePlayerTagTracker = Class(function(PlayerTagTracker, DoNotGCTags)
	--- Tracks players / tags players.
	-- @param [DoNotGCTags] Boolean, whether or not the system should remove player&apos;s tags when they leave. 

	DoNotGCTags = DoNotGCTags or false

	local TagCache = {}

	local function GetPlayerTagCache(Player)
		--- Return&apos;s a player&apos;s tag cache. Used internally
		-- @param Player The player to get the cache of
		-- @return Table, the Cache

		local Cache = TagCache[Player.userId]
		if not Cache then
			Cache = {}
			TagCache[Player.userId] = Cache
		end
		return Cache
	end

	local function IsTagged(Player, TagName, TagId)
		--- Returns whether or not a player is tagged. If the player is not in game, returns false. 
		-- @param Player The player to check
		-- @param TagName String, The name of the tag to check (Not caps sensitive)
		-- @param [TagId] If given, makes sure the TagId is matched. 
		-- @return Boolean, true if tagged, false otherwise.

		if Player and Player:IsA(&quot;Player&quot;) and Player.Parent == Players then
			local Cache = GetPlayerTagCache(Player)
			if TagId then
				if Cache[TagName:lower()] == TagId then
					return true
				else
					return false
				end
			else
				return Cache[TagName:lower()] ~= nil
			end
		else
			return false
		end
	end
	PlayerTagTracker.IsTagged = IsTagged
	PlayerTagTracker.isTagged = IsTagged
	PlayerTagTracker.GetTagStatus = IsTagged
	PlayerTagTracker.getTagStatus = IsTagged
	PlayerTagTracker.TagStatus = IsTagged
	PlayerTagTracker.tagStatus = IsTagged

	local function Tag(Player, TagName)
		--- Sets a tag to the player to true. 
		-- @param Player The player to tag
		-- @param TagName String, The name of the tag to tag. Not caps sensitive. 
		-- @return The TagId idnetified 

		local Cache = GetPlayerTagCache(Player)
		Cache[TagName:lower()] = math.floor(tick())

		return Cache[TagName:lower()]
	end
	PlayerTagTracker.Tag = Tag
	PlayerTagTracker.tag = Tag

	local function Untag(Player, TagName)
		--- Sets a tag to the player to false
		-- @param Player The player to untag
		-- @param TagName String, The name of the tag to tag. Not caps sensitive. 

		local Cache = GetPlayerTagCache(Player)
		Cache[TagName:lower()] = nil
	end
	PlayerTagTracker.Untag = Untag
	PlayerTagTracker.untag = Untag

	-- Setup GC 
	if not DoNotGCTags then
		Players.PlayerRemoving:connect(function(Player)
			TagCache[Player] = nil
		end)
	end
end)
lib.MakePlayerTagTracker = MakePlayerTagTracker
lib.makePlayerTagTracker = MakePlayerTagTracker
lib.New = MakePlayerTagTracker 
lib.new = MakePlayerTagTracker

return lib</ProtectedString>
</Properties>
</Item>
<Item class="Script" referent="RBX73">
<Properties>
<string name="Name">QACSettings</string>
<ProtectedString name="Source">-- QACSettings.lua
-- @author Quenty
-- Maintains QAC settings

return {
	CommandsAreInvisibleOnPseudoChat = true;
	CommandSeperators = {
		&quot;/&quot;; &quot; &quot;; &quot;!&quot;; &quot;&gt;&quot;; &quot;&lt;&quot;; &quot;;&quot;; &quot;:&quot;};
	MoreArguments = {&quot;;&quot;; &quot;;&quot;};
	SpecificGroups = {&quot;.&quot;};
	PrintHeader = &quot;[CommandSystem] - &quot;;
};</ProtectedString>
<bool name="Disabled">true</bool>
</Properties>
</Item>
</Item>
<Item class="Backpack" referent="RBX74">
<Properties>
<string name="Name">sProxy</string>
</Properties>
<Item class="ModuleScript" referent="RBX75">
<Properties>
<string name="Name">FilteredProxy</string>
<ProtectedString name="Source">-- A system by Seranok to sandbox methods in ROBLOX.
-- https://github.com/matthewdean/sandbox.lua/blob/master/proxy.lua

-- FilteredProxy.lua
-- Modified to allow a &quot;filter&quot; on items to sandbox stuff.


local convertValue do
	
	local pack = function(...)
		-- in Lua 5.2, table.pack
		return {n = select(&apos;#&apos;,...), ...}
	end
	
	local convertValues = function(Filter, mt, from, to, ...)
		local results = pack(...)
		for i = 1, results.n do
			results[i] = convertValue(Filter, mt,from,to,results[i])
		end
		return unpack(results,1,results.n)
	end

	convertValue = function(Filter, mt, from, to, value)
		-- if there is already a wrapper, return it
		-- no point in making a new one and it ensures consistency
		-- print(Game == Game) --&gt; true

		-- @param mt Metatable, every action should go through this metatable. 
		-- @param to/from Caches/Tables (weak)
		-- @param value The value to wrap into a proxy
		-- @param Filter A function, sends it the value being &quot;accessed&quot;, if it returns &quot;true&quot; then the value will act as &quot;nil&quot;
		-- @return The converted / wrapped value. 

		local result = to.lookup[value]
		if result then
			return result
		end
		
		local type = type(value)
		if Filter(value) then
			return nil
		else
			if type == &apos;table&apos; then
				result =  {}
				-- must be indexed before keys and values are converted
				-- otherwise stack overflow
				to.lookup[value] = result
				from.lookup[result] = value
				for key, value in pairs(value) do
					result[convertValue(Filter, mt,from,to,key)] = convertValue(Filter, mt,from,to,value)
				end
				if not from.trusted then
					-- any future changes by the user to the table
					-- will be picked up by the metatable and transferred to its partner
					setmetatable(value,mt)
				else
					setmetatable(result,mt)
				end
				return result
			elseif type == &apos;userdata&apos; then
				-- create a userdata to serve as proxy for this one
				result = newproxy(true)
				local metatable = getmetatable(result)
				for event, metamethod in pairs(mt) do
					metatable[event] = metamethod
				end
				to.lookup[value] = result
				from.lookup[result] = value
				return result
			elseif type == &apos;function&apos; then
				-- unwrap arguments, call function, wrap arguments
				result = function(...)
					local results = pack(ypcall(function(...) return value(...) end,convertValues(Filter, mt,to,from,...)))
					if results[1] then
						return convertValues(Filter, mt,from,to,unpack(results,2,results.n))
					else
						error(results[2],2)
					end
				end
				to.lookup[value] = result
				from.lookup[result] = value
				return result
			else
				-- numbers, strings, booleans, nil, and threads are left as-is
				-- because they are harmless
				return value
			end
		end
	end
end

local proxy = {}

local defaultMetamethods = {
	__len       = function(a) return #a end;
	__unm       = function(a) return -a end;
	__add       = function(a, b) return a + b end;
	__sub       = function(a, b) return a - b end;
	__mul       = function(a, b) return a * b end;
	__div       = function(a, b) return a / b end;
	__mod       = function(a, b) return a % b end;
	__pow       = function(a, b) return a ^ b end;
	__lt        = function(a, b) return a &lt; b end;
	__eq        = function(a, b) return a == b end;
	__le        = function(a, b) return a &lt;= b end;
	__concat    = function(a, b) return a .. b end;
	__call      = function(f, ...) return f(...) end;
	__tostring  = function(a) return tostring(a) end;
	__index     = function(t, k) return t[k] end;
	__newindex  = function(t, k, v) t[k] = v end;
	__metatable = function(t) return getmetatable(t) end;
}

proxy.new = function(options)
	options = options or {}
	local environment = options.environment or getfenv(2) -- defaults to calling function&apos;s environment
	local metatable = options.metatable or {}

	-- allow wrappers to be garbage-collected
	local trusted = {trusted = true,lookup = setmetatable({},{__mode=&apos;k&apos;})}
	local untrusted = {trusted = false,lookup = setmetatable({},{__mode=&apos;v&apos;})}

	local Filter = options.filter or error(&quot;[FilteredProxy] - No filter provided&quot;)

	for event, metamethod in pairs(defaultMetamethods) do
		-- the metamethod will be fired on the wrapper class
		-- so we need to unwrap the arguments and wrap the return values
		metatable[event] = convertValue(Filter, metatable, trusted, untrusted, metatable[event] or metamethod)
	end

	return convertValue(Filter, metatable, trusted, untrusted, environment)
end

return proxy</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX76">
<Properties>
<string name="Name">sProxy</string>
<ProtectedString name="Source">-- A system by Seranok to sandbox methods in ROBLOX.
-- https://github.com/matthewdean/sandbox.lua/blob/master/proxy.lua

local convertValue do
	
	local pack = function(...)
		-- in Lua 5.2, table.pack
		return {n = select(&apos;#&apos;,...), ...}
	end
	
	local convertValues = function(mt, from, to, ...)
		local results = pack(...)
		for i = 1, results.n do
			results[i] = convertValue(mt,from,to,results[i])
		end
		return unpack(results,1,results.n)
	end

	convertValue = function(mt, from, to, value)
		-- if there is already a wrapper, return it
		-- no point in making a new one and it ensures consistency
		-- print(Game == Game) --&gt; true
		local result = to.lookup[value]
		if result then
			return result
		end
		
		local type = type(value)
		if type == &apos;table&apos; then
			result =  {}
			-- must be indexed before keys and values are converted
			-- otherwise stack overflow
			to.lookup[value] = result
			from.lookup[result] = value
			for key, value in pairs(value) do
				result[convertValue(mt,from,to,key)] = convertValue(mt,from,to,value)
			end
			if not from.trusted then
				-- any future changes by the user to the table
				-- will be picked up by the metatable and transferred to its partner
				setmetatable(value,mt)
			else
				setmetatable(result,mt)
			end
			return result
		elseif type == &apos;userdata&apos; then
			-- create a userdata to serve as proxy for this one
			result = newproxy(true)
			local metatable = getmetatable(result)
			for event, metamethod in pairs(mt) do
				metatable[event] = metamethod
			end
			to.lookup[value] = result
			from.lookup[result] = value
			return result
		elseif type == &apos;function&apos; then
			-- unwrap arguments, call function, wrap arguments
			result = function(...)
				local results = pack(ypcall(function(...) return value(...) end,convertValues(mt,to,from,...)))
				if results[1] then
					return convertValues(mt,from,to,unpack(results,2,results.n))
				else
					error(results[2],2)
				end
			end
			to.lookup[value] = result
			from.lookup[result] = value
			return result
		else
			-- numbers, strings, booleans, nil, and threads are left as-is
			-- because they are harmless
			return value
		end
	end
end

local proxy = {}

local defaultMetamethods = {
        __len       = function(a) return #a end;
        __unm       = function(a) return -a end;
        __add       = function(a, b) return a + b end;
        __sub       = function(a, b) return a - b end;
        __mul       = function(a, b) return a * b end;
        __div       = function(a, b) return a / b end;
        __mod       = function(a, b) return a % b end;
        __pow       = function(a, b) return a ^ b end;
        __lt        = function(a, b) return a &lt; b end;
        __eq        = function(a, b) return a == b end;
        __le        = function(a, b) return a &lt;= b end;
        __concat    = function(a, b) return a .. b end;
        __call      = function(f, ...) return f(...) end;
        __tostring  = function(a) return tostring(a) end;
        __index     = function(t, k) return t[k] end;
        __newindex  = function(t, k, v) t[k] = v end;
        __metatable = function(t) return getmetatable(t) end;
}

proxy.new = function(options)
	options = options or {}
	local environment = options.environment or getfenv(2) -- defaults to calling function&apos;s environment
	local metatable = options.metatable or {}

	-- allow wrappers to be garbage-collected
	local trusted = {trusted = true,lookup = setmetatable({},{__mode=&apos;k&apos;})}
	local untrusted = {trusted = false,lookup = setmetatable({},{__mode=&apos;v&apos;})}

	for event, metamethod in pairs(defaultMetamethods) do
		-- the metamethod will be fired on the wrapper class
		-- so we need to unwrap the arguments and wrap the return values
		metatable[event] = convertValue(metatable, trusted, untrusted, metatable[event] or metamethod)
	end

	return convertValue(metatable, trusted, untrusted, environment)
end

return proxy</ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX77">
<Properties>
<string name="Name">sSandbox</string>
<ProtectedString name="Source">-- A system by Seranok to sandbox methods in ROBLOX.
-- https://github.com/matthewdean/sandbox.lua/blob/master/examples/sandbox.lua

-- @author Quenty
-- Last Modified February 10th, 2014

local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;) -- See import statement.
local FilteredProxy     = LoadCustomLibrary(&quot;FilteredProxy&quot;)

qSystems:Import(getfenv(0))
-- qSystems is only required for CreateSignal(), which may also be found in RbxUtility
-- qSystems CreateSignal() is better, but you may use RbxUtilities. 

-- The following line will remove qSystem dependency. 
-- local CreateSignal = LoadLibrary(&quot;RbxUtility&quot;).CreateSignal

local lib = {}

local function MakeExecutor(Source, Options)
	--- Executes code and creates an &quot;Executor&quot; object.
	-- @param Source A String, the source of the code to execute.  
	-- @param Options A table filled with Options, in this case, organized like this:
	--[[
	Options = {
		metatable = {
			-- Your common metatable, here. Must be lowercase named. 
			-- Added to each &quot;Child&quot; of each ROBLOX item. 
			__index = function(self, Index)
				-- @param self The real object
				-- @param Index The indexed item

				print(Index)
			end;
			__newindex = ...
		};
		environment = {
			-- Standard environment, if empty will set no initial environments
			-- environments must be lower case.
			-- &quot;print&quot; will be overriden. 
		};
		chunk = &quot;ChunkName&quot;;
		filter = function(Value)
			if Type.isAnInstance(Value) and Value.Name == &quot;Quenty&quot; then -- Filter out anything named &quot;Quenty&quot;
				return true
			end

			-- Another example would be: Filter = function(Value) if Value == game.SavePlace then return true end end
			-- to filter SavePlace
		end
	}
	--]]
	-- @return Executor Defines output and results of execution
	--[[

	Executor
		An executor is a pseudo object used to regulate the execution of Lua code. It will attempt to collect
		output, errors, and execution span, as well as regulate what ROBLOX API is accessed. 

		Note that the Filter function in Options must be very well designed otherwise methods such as :ClearAllChildren()
		and Workspace.Destroy(Workspace.Part.SomethingYouDoNotWantRemoved) can be abused to escape the sandbox.

		`Number` TimeStamp
			The timestamp when the executor was created and executed
		`Signal` Output
			ROBLOX Signal which fires with the following parameters
				@param Output String, The output generated by the script
		`Signal` Finished
			ROBLOX Signal which fires with the following information
				@param Success Boolean, Returns true if it executed without error, otherwise returns false
				@param Error If there was an error, this String will be the error generated
		`Fucntion` Execute
			This function should be called to &quot;execute&quot; the code whenever you want to execute it. 
	--]]

	local Executor = {}
	Executor.TimeStamp = tick() 

	--Note that LogService provides a more robust solution than this.
	Executor.Output = CreateSignal() -- Fires (Output)
		-- @param Output A string
	Executor.Finished = CreateSignal() -- Fires (Success, Error)
		-- @param Boolean, true if it executed without error.
		-- @param Error The error if it happened. 

	Options = Options or {}

	-- local result = {}
	-- result.output = {}
	local function Execute()
		Spawn(function()
			local oldPrint = print
			local function print(...)
				oldPrint(...)
				local t = {...}
				for i = 1, select(&apos;#&apos;, ...) do
					t[i] = tostring(t[i])
				end

				Executor.Output:fire(table.concat(t, &apos; &apos;))
			end
			
			local ExecuteFunction, err = loadstring(Source, Options.chunk or &quot;chunk&quot;)
			if ExecuteFunction == nil then
				Executor.Finished:fire(false, err)
			else
				Options.environment = Options.environment or getfenv(0);--{_G,_VERSION,assert,collectgarbage,dofile,error,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,xpcall,coroutine,math,string,table,game,Game,workspace,Workspace,delay,Delay,LoadLibrary,printidentity,Spawn,tick,time,version,Version,Wait,wait,PluginManager,crash__,LoadRobloxLibrary,settings,Stats,stats,UserSettings,Enum,Color3,BrickColor,Vector2,Vector3,Vector3int16,CFrame,UDim,UDim2,Ray,Axes,Faces,Instance,Region3,Region3int16 = _G,_VERSION,assert,collectgarbage,dofile,error,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,xpcall,coroutine,math,string,table,game,Game,workspace,Workspace,delay,Delay,LoadLibrary,printidentity,Spawn,tick,time,version,Version,Wait,wait,PluginManager,crash__,LoadRobloxLibrary,settings,Stats,stats,UserSettings,Enum,Color3,BrickColor,Vector2,Vector3,Vector3int16,CFrame,UDim,UDim2,Ray,Axes,Faces,Instance,Region3,Region3int16}
				Options.environment.print = print

				setfenv(ExecuteFunction, FilteredProxy.new(Options))
				
				local SuccessfulExecution, err = ypcall(ExecuteFunction)
				if not SuccessfulExecution then
					-- if err == &quot;Game script timout&quot; then
					-- 	wait() --FIXME hack
					-- end
					Executor.Finished:fire(false, err)
				else
					Executor.Finished:fire(true)
				end
			end
		end)
	end
	Executor.Execute = Execute
	Executor.execute = Execute

	return Executor
end
lib.MakeExecutor = MakeExecutor
lib.makeExecutor = MakeExecutor

return lib</ProtectedString>
</Properties>
</Item>
</Item>
<Item class="Backpack" referent="RBX78">
<Properties>
<string name="Name">World</string>
</Properties>
<Item class="ModuleScript" referent="RBX79">
<Properties>
<string name="Name">AreaLoader</string>
<ProtectedString name="Source">local ReplicatedStorage       = game:GetService(&quot;ReplicatedStorage&quot;)
local Players                 = game:GetService(&quot;Players&quot;)

local NevermoreEngine         = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary       = NevermoreEngine.LoadLibrary

local qSystems                = LoadCustomLibrary(&quot;qSystems&quot;)
local qInstance               = LoadCustomLibrary(&quot;qInstance&quot;)
local qString                 = LoadCustomLibrary(&quot;qString&quot;)
local qCFrame                 = LoadCustomLibrary(&quot;qCFrame&quot;)
local OverriddenConfiguration = LoadCustomLibrary(&quot;OverriddenConfiguration&quot;)
local EventGroup              = LoadCustomLibrary(&quot;EventGroup&quot;)

qSystems:Import(getfenv(0));

-- AreaLoader.lua
-- Handles building loading and management. Handles it server-side. 
-- @author Quenty

local lib = {}

local MakeGridManager = Class(function(GridManager, Center, StudsPerGridSquare, Rows, Columns)
	local Grid = {}

	-- Generate grid.
	for Row = 1, Rows do
		Grid[Row] = {}
	end

	local function GetOpenSlotPosition()
		--- Return&apos;s a Vector2 of the location that is open, if one is open
		--  Otherwise, return&apos;s nil

		for Row = 1, Rows do
			local RowData = Grid[Row]
			for Column = 1, Columns do
				if RowData[Column] == nil then
					return Vector2.new(Row, Column)
				end
			end
		end
		return nil
	end
	GridManager.GetOpenSlotPosition = GetOpenSlotPosition
	GridManager.getOpenSlotPosition = GetOpenSlotPosition

	local function GetListOfFilledSlots()
		--- Get&apos;s a list of all filled slots

		local List = {}

		for Row = 1, Rows do
			local RowData = Grid[Row]
			for Column = 1, Columns do
				if RowData[Column] ~= nil then
					List[#List+1] = RowData[Column]
				end
			end
		end

		return List
	end
	GridManager.GetListOfFilledSlots = GetListOfFilledSlots
	GridManager.getListOfFilledSlots = GetListOfFilledSlots

	local function GetListOfOpenSlots()
		-- Return&apos;s list of slots that are open

		local List = {}

		for Row = 1, Rows do
			local RowData = Grid[Row]
			for Column = 1, Columns do
				if RowData[Column] == nil then
					List[#List+1] = RowData[Column]
				end
			end
		end

		return List
	end
	GridManager.GetListOfOpenSlots = GetListOfOpenSlots
	GridManager.getListOfOpenSlots = GetListOfOpenSlots

	local function SlotInBounds(SlotLocation)
		local RowIndex = SlotLocation.X
		local ColumnIndex = SlotLocation.Y

		if RowIndex &gt;= 1 and RowIndex &lt;= Rows then
			if ColumnIndex &gt;= 1 and ColumnIndex &lt;= Columns then
				return true
			end
		end

		return false
	end
	GridManager.SlotInBounds = SlotInBounds
	GridManager.slotInBounds = SlotInBounds

	local function IsSlotOpen(SlotLocation)
		-- @param SlotLocation Vector2, the location of the slot.

		if SlotInBounds(SlotLocation) then
			return Grid[SlotLocation.X][SlotLocation.Y] == nil
		else
			return false
		end
	end
	GridManager.IsSlotOpen = IsSlotOpen
	GridManager.isSlotOpen = IsSlotOpen

	local function AddItemToSlot(SlotLocation, Item)
		--- Adds the item to the slot. 
		-- @param SlotLocation Vector2, the location of the slot.
		-- @param Item The item to add to it. Can be anything except nil.

		if IsSlotOpen(SlotLocation) then
			Grid[SlotLocation.X][SlotLocation.Y] = Item
			return true
		else
			error(&quot;[GridManager] - Slot is not open, cannot add to it&quot;)
			return false
		end
	end
	GridManager.AddItemToSlot = AddItemToSlot
	GridManager.addItemToSlot = AddItemToSlot

	local function RemoteItemFromSlot(SlotLocation)
		if SlotInBounds(SlotLocation) then
			if IsSlotOpen(SlotLocation) then
				local Removed = Grid[SlotLocation.X][SlotLocation.Y]
				if Removed then
					Grid[SlotLocation.X][SlotLocation.Y] = nil
					return Removed
				else
					error(&quot;[GridManager] - Slot did not have any content!&quot;)
				end
			end
		else
			error(&quot;[GridManager] - Slot is not in bounds. Obviously cannot remove from it.&quot;)
		end
	end
	GridManager.RemoteItemFromSlot = RemoteItemFromSlot
	GridManager.remoteItemFromSlot = RemoteItemFromSlot

	local function SlotLocationToWorldLocation(SlotLocation)
		local CenteredSlotLocation = (SlotLocation - (Vector2.new(Rows, Columns)/2))
		return (Center + Vector3.new(CenteredSlotLocation.X * StudsPerGridSquare, 0, CenteredSlotLocation.Y * StudsPerGridSquare))
	end
	GridManager.SlotLocationToWorldLocation = SlotLocationToWorldLocation
	GridManager.slotLocationToWorldLocation = SlotLocationToWorldLocation
end)

local MakeGateConnection = Class(function(GateConnection, BaseGate, DestinationID, DoorID)
	--- Represents the connection between a gate and a Area
	-- @param BaseGate The gateway in, BasePart
	-- @param DestinationGateRender The rendering function to use if GateOut fails. ()
	-- @param DoorID The doorId in the DestinationID

	GateConnection.BaseGate              = BaseGate
	GateConnection.DestinationID         = DestinationID
	GateConnection.DoorID                = DoorID
	GateConnection.DestinationGate       = nil
end)

local MakeAreaLoader = Class(function(AreaLoader, Container, Configuration)
	--- @param Container The container all the buildings go into.

	local Configuration    = OverriddenConfiguration.new(Configuration, {
		StudsPerGridSquare = 300;
		RenderHeight       = 10000;
		GridSize           = 8; -- 64 should be enough, no?
		Lifetime           = 30; -- Lifetime is areas after players leave, in seconds.
		UpdateCycle        = 60; -- Every X seconds run the GC.
	})

	-- MaximumLifetime for an area is UpdateCycle + Lifetime

	local Grid = MakeGridManager(Vector3.new(0, Configuration.RenderHeight, 0), Configuration.StudsPerGridSquare, Configuration.GridSize, Configuration.GridSize)
	local DestinationIDToRender = {}

	local function PositionCharacter(Door, Character)
		--- Positions the character relative to the front of the door. Better algorithm laster.

		local DoorBase = Door.CFrame - Vector3.new(0, Door.Size.Y/2, 0)
		local DistanceCheckingRay = Ray.new(Character.Torso.Position, Vector3.new(0,-999,0))

		local IgnoreList = {Character}

		local Hit, Position = Workspace:FindPartOnRayWithIgnoreList(DistanceCheckingRay, IgnoreList)
		local DistanceOffGround
		
		if Hit and Position then
			DistanceOffGround = math.max(3, (Character.Torso.Position - Position).magnitude)
			-- print(&quot;Player is &quot; .. DistanceOffGround .. &quot; studs off of the ground&quot;)
		else
			DistanceOffGround = 3
		end
		
		Character.Torso.CFrame = (DoorBase * CFrame.new(0, 0, -4)) + Vector3.new(0, DistanceOffGround, 0)
	end

	local EventTracker = EventGroup.MakeEventGroup()
	local Areas = {}

	local function LoadNewArea(Parent, AreaModel, MainPart, NewPlayer, NewCharacter)
		--- Loads the new area into a new location
		-- @param Parent The parent of the new area
		-- @param MainPart The mainpart of the whole model. 

		local NewLocation = Grid.GetOpenSlotPosition()
		if NewLocation then
			local NewSpawnLocation = Grid.SlotLocationToWorldLocation(NewLocation)

			local NewArea = {}
			NewArea.GridLocation         = NewLocation
			NewArea.WorldLocation        = NewSpawnLocation

			Grid.AddItemToSlot(NewLocation, NewArea)

			local GatewayConnections = {}

			local function AddGatewayConnection(GateConnection)
				print(&quot;[AreaLoader] - Added GateConnection&quot;)
				--- Adds the GateConnection to the system, and sets the DestinationGate
				-- @param GateConnection The connection to add.

				local DoorName = GateConnection.DoorID
				GateConnection.DestinationGate = AreaModel:FindFirstChild(DoorName) or error(&quot;New Area does not have a door named &apos;&quot; .. DoorName ..&quot;&apos;&quot;)
				GateConnection.DestinationArea = NewArea

				GateConnection.DestinationGate.Touched:connect(function(Part)
					local Character, Player = GetCharacter(Part)
					if Character and Player then
						if CheckCharacter(Player) and Character.Humanoid.Health &gt; 0 then
							PositionCharacter(GateConnection.BaseGate, Character)
							print(&quot;Player leave&quot;)
							NewArea.UntrackCharacter(Player)
						end
					end
				end)

				GatewayConnections[#GatewayConnections+1] = GateConnection
			end
			NewArea.AddGatewayConnection = AddGatewayConnection
			NewArea.addGatewayConnection = AddGatewayConnection

			local NewModel = Make &apos;Model&apos; {
				Parent     = Parent;
				Name       = AreaModel.Name .. &quot;Cloned&quot;;
				Archivable = false;
				AreaModel;
			}
			NewArea.Model = Model

			local Bricks = qInstance.GetBricks(AreaModel)
			qCFrame.TransformModel(Bricks, MainPart.CFrame, CFrame.new(NewSpawnLocation))

			-- START GC SECTION --

			local Characters = {}
			local LastUpdate = tick() -- Record the last time players occuped the area

			local function GCCheckCycle()
				--- Checks if the area can be GC, and if so, GC&apos;s it.
				-- Conditions are met when there are no active players, and lifetime is exceeded

				local CurrentTime = tick()
				local Count = 0
				for Player, Character in pairs(Characters) do
					if (Player and Player.Parent == Players and Character and Character.Parent) then
						Count = Count + 1
					else
						-- print(&quot;Player invalid&quot;)
						NewArea.UntrackCharacter(Player)
					end
				end
				if Count &lt;= 0 and LastUpdate + Configuration.Lifetime &lt; CurrentTime then
					NewArea.Destroy()
				else
					LastUpdate = CurrentTime
				end
			end
			NewArea.GCCheckCycle = GCCheckCycle

			local function TrackCharacter(Player, Character)
				--- Tracks a player. 
				-- @param Player The player to track
				-- @param Charater The character of the player
				-- @pre Charater is checked (Verify Humanoid)

				-- print(&quot;[AreaLoader] - Tracking player &quot; .. Player.Name)
				
				Characters[Player] = Character

				EventTracker[NewArea][Player.Name].Died = Character.Humanoid.Died:connect(function()
					-- print(&quot;Player died&quot;)
					NewArea.UntrackCharacter(Player)
				end)

				EventTracker[NewArea][Player.Name].Respawn = Player.CharacterAdded:connect(function()
					-- print(&quot;Player respawn&quot;)
					NewArea.UntrackCharacter(Player)
				end)

				LastUpdate = tick()
			end
			NewArea.TrackCharacter = TrackCharacter
			NewArea.trackCharacter = TrackCharacter

			local function UntrackCharacter(Player)
				--- Untracks a player, should be called when a player is not in the area anymore
				-- @param Player The player to untrack.

				-- print(&quot;[AreaLoader] - Untracked &quot; .. Player.Name)
				Characters[Player] = nil
				EventTracker[NewArea][Player.Name] = nil
				LastUpdate = tick()
				-- GCCheckCycle() 
			end
			NewArea.UntrackCharacter = UntrackCharacter
			NewArea.untrackCharacter = UntrackCharacter

			-- END GC SECTION --
			local function Destroy()
				Areas[NewArea] = nil
				-- print(&quot;[AreaLoader] - GC Area.&quot;)
				NewArea.Destroy        = nil
				NewArea.TrackCharacter = nil
				NewArea.trackCharacter = nil
				Characters = nil
				NewSpawnLocation = nil

				EventTracker[NewArea] = nil -- GC events is so awesome. &lt;3 Anaminus

				Grid.RemoteItemFromSlot(NewLocation)

				for _, Item in pairs(GatewayConnections) do
					Item.DestinationGate = nil
					Item.DestinationArea = nil
				end
				NewModel.Parent = nil
				NewModel:Destroy()
			end
			NewArea.Destroy = Destroy
			NewArea.destroy = Destroy

			Areas[NewArea] = true -- Track areas

			return NewArea
		else
			print(&quot;[AreaLoader] - Unable to find open slot. D:&quot;)
			return nil
		end
	end

	EventTracker.PlayerLeaving = Players.PlayerRemoving:connect(function(Player)
		for NewArea, _ in pairs(Areas) do
			-- print(&quot;Player leave game&quot;)
			NewArea.UntrackCharacter(Player)
		end
	end)

	Spawn(function()
		while true do
			local Count = 0
			for NewArea, _ in pairs(Areas) do
				Count = Count + 1
				NewArea.GCCheckCycle()
			end
			print(&quot;[AreaLoader] - ActiveArea count = &quot; .. Count)
			wait(Configuration.UpdateCycle)
		end
	end)

	local function AddDestination(DestinationID, DestinationRender, ...)
		--- Adds a destination to the render handler. 
		-- @param DestinationID String, the ID of the destination available.
		-- @param DestinationRender Function that returns the model to use as the destination.
		--        DestinationRender(GatewayConnection)
		--            @param GatewayConnection The connection being used to request the model.
		--            @return Model, MainPart

		DestinationID = DestinationID:lower()
		if not DestinationIDToRender[DestinationID] then
			DestinationIDToRender[DestinationID] = {
				Render    = DestinationRender;
				Arguments = {...};
			}
		else
			error(&quot;[AreaLoader] - DestinationID &apos;&quot; .. DestinationID .. &quot;&apos; is already registered.&quot;)
		end
	end
	AreaLoader.AddDestination = AddDestination
	AreaLoader.addDestination = AddDestination


	local function OnGatewayRequest(Player, Character, GatewayConnection, DestinationRender)
		--- When a player requests to go into a gateway, (triggered by touch), this will actaully handle the request.

		if GatewayConnection.DestinationGate then
			GatewayConnection.DestinationArea.TrackCharacter(Player, Character)

			PositionCharacter(GatewayConnection.DestinationGate, Character)
		else
			local Rendered, MainPart = DestinationRender.Render(GatewayConnection, unpack(DestinationRender.Arguments))
			local RenderArea = LoadNewArea(Container, Rendered, MainPart, Player, Character)
			RenderArea.AddGatewayConnection(GatewayConnection)
			PositionCharacter(GatewayConnection.DestinationGate, Character)
			RenderArea.TrackCharacter(Player, Character)
		end
	end

	function OnGatewayTouch(Part, GatewayConnection, DestinationRender)
		--- Handles gateway touchy thing, verifys that a connection request occured
		-- @param Part The part that touched
		-- @param  GatewayConnection The connection linked to the part.

		local Character, Player = GetCharacter(Part)
		if Character and Player then
			if CheckCharacter(Player) and Character.Humanoid.Health &gt; 0 then
				OnGatewayRequest(Player, Character, GatewayConnection, DestinationRender)

				return true
			end
		end
		return false
	end

	local function SetupGateway(GatewayIn, DestinationID, DoorID)
		--- Setups up the connection structure, and the event on-touch.
		-- @param GatewayIn The gateway model going in
		-- @param DestinationID The destination ID (already registered) to where this gateway goes. Will probably be generated based on parent-child structure.
		-- @param DoorID String, the DoorID of the gateway.

		DestinationID = DestinationID:lower()

		if DestinationIDToRender[DestinationID] then
			local DestinationRender = DestinationIDToRender[DestinationID]
			local GatewayConnection = MakeGateConnection(GatewayIn, DestinationID, DoorID)

			GatewayIn.Touched:connect(function(Part)
				OnGatewayTouch(Part, GatewayConnection, DestinationRender)
			end)
		else
			error(&quot;[AreaLoader] - Destination &apos;&quot; .. DestinationID .. &quot;&apos; is not registered.&quot;)
		end
	end
	AreaLoader.SetupGateway = SetupGateway
	AreaLoader.setupGateway = SetupGateway

	local function ParseGatewayName(GatewayName)
		--- Parses a gateway&apos;s name and return&apos;s the DoorID and DestinationID
		-- @param GatewayName The gateway name to parse.
		-- @return nil, if it failed, otherwise, the DestinationID, Followed by the GatewayIn

		-- Gateways are setup like this: &quot;Door:&lt;DestinationId&gt;:&lt;DoorId&gt;&quot;
		-- Model.Name = &quot;Door:DestinationA:DoorA&quot;

		local BrokenString = qString.BreakString(GatewayName, &quot;:&quot;)
		if BrokenString[1] and qString.CompareStrings(BrokenString[1], &quot;Door&quot;) then
			if #BrokenString == 3 then
				return BrokenString[2], BrokenString[3]
			else
				return nil
			end
		else
			return nil
		end
	end
	AreaLoader.ParseGatewayName = ParseGatewayName
	AreaLoader.ParseGatewayName = ParseGatewayName

	local function LookForGatewaysAndSetup(Model)
		--- Sweeps a model&apos;s children and searches for valid doors. Call after adding destinations.
		-- @param Model The model to sweep

		CallOnChildren(Model, function(Item)
			if Item:IsA(&quot;BasePart&quot;) and Item.Name:sub(1, 5) == &quot;Door:&quot; then
				local DestinationID, DoorID = ParseGatewayName(Item.Name)
				if DestinationID and DoorID then
					SetupGateway(Item, DestinationID, DoorID)
				else
					error(&quot;[AreaLoader] - Invalid door found at &apos;&quot; .. Item:GetFullname() .. &quot;&apos;&quot;)
				end
			end
		end)
	end
	AreaLoader.LookForGatewaysAndSetup = LookForGatewaysAndSetup
	AreaLoader.LookForGatewaysAndSetup = LookForGatewaysAndSetup
end)
lib.MakeAreaLoader = MakeAreaLoader
lib.makeAreaLoader = MakeAreaLoader

return lib</ProtectedString>
</Properties>
</Item>
</Item>
<Item class="Backpack" referent="RBX80">
<Properties>
<string name="Name">_untested</string>
</Properties>
<Item class="ModuleScript" referent="RBX81">
<Properties>
<string name="Name">AnimationSystems</string>
<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&apos;qSystems&apos;)
local qCFrame           = LoadCustomLibrary(&apos;qCFrame&apos;)
local qInstance         = LoadCustomLibrary(&apos;qInstance&apos;)
local qMath             = LoadCustomLibrary(&apos;qMath&apos;)
local Type              = LoadCustomLibrary(&apos;Type&apos;)

qSystems:Import(getfenv(0));

local lib = {}

local MakeDoor = Class &apos;Door&apos; (function(Door, Brick, BaseCFrame, EndCFrame)
	local CurrentPercentOpen = 0
	local Bricks
	local Offset = {}
	setmetatable(Offset, {__mode = &quot;k&quot;}) -- Memory Allocations. 

	if type(Brick) == &quot;table&quot; then
		Bricks = Brick
	else
		Bricks = qInstance.getBricks(Brick)
	end

	local function UpdateCFrameOffset()
		for _, BrickPart in pairs(Bricks) do
			Offset[BrickPart] = BaseCFrame:inverse() * BrickPart.CFrame
		end
	end

	function Door:SetPosition(PercentOpen)
		CurrentPercentOpen = PercentOpen
		PercentOpen = qMath.ClampNumber(PercentOpen, 0, 1)
		local Slerp = qCFrame.SlerpCFrame(BaseCFrame, EndCFrame, PercentOpen)

		for _, BrickPart in pairs(Bricks) do
			BrickPart.CFrame = Slerp * Offset[BrickPart]
		end

		--print(&quot;Setting position of door @ &quot;..PercentOpen)
		--Brick.CFrame = qCFrame.SlerpCFrame(BaseCFrame, EndCFrame, PercentOpen)
		--local Slerp = qCFrame.SlerpCFrame(BaseCFrame, EndCFrame, PercentOpen)
		--qCFrame.TransformModel(Bricks, OldSlerp, Slerp)
	end

	function Door:SetBaseCFrame(NewBaseCFrame)
		BaseCFrame = NewBaseCFrame
		Door:SetPosition(CurrentPercentOpen)
		UpdateCFrameOffset()
	end

	function Door:SetEndCFrame(NewEndCFrame)
		EndCFrame = NewEndCFrame
		Door:SetPosition(CurrentPercentOpen)
	end

	UpdateCFrameOffset()
end)

lib.makeDoor = MakeDoor;
lib.MakeDoor = MakeDoor;


local MakeMoveTowards = Class &apos;MoveTowards&apos; (function(MoveTowards, MaxIncreasePerSecond, CurrentValue, Target, SmoothnessFactor, Execution, UpdateTime)
	-- Always tries to equalize CurrentValue towards target. At CutoffNumber, it&apos;ll say &quot;Close enough&quot;, and set the currentValue to the
	-- target, instead of letting it flip flop back and forth. 
	local LastUpdateTime = time();
	UpdateTime = UpdateTime or 0.03
	local Updating = false;
	local Velocity = 0;
	SmoothnessFactor = SmoothnessFactor or 2;

	local function NeutralUpdate()
		--print(&quot;Update @ Neutral position, will not update anymore until next update.&quot;)
		CurrentValue = Target
		Velocity = 0;
		Execution(CurrentValue)
		return false;
	end

	local function SetMaxIncreasePerSecond(Value)
		MaxIncreasePerSecond = Value
	end
	MoveTowards.SetMaxIncreasePerSecond = SetMaxIncreasePerSecond

	local function SetSmoothnessFactor(Value)
		SmoothnessFactor = Value
	end
	MoveTowards.SetSmoothnessFactor = SetSmoothnessFactor

	local function Update() -- returns bool `ShouldUpdateAgain`
		local Delta = time() - LastUpdateTime;

		if not (CurrentValue == Target) then
			if CurrentValue &lt; Target then -- First, determine velocity...
				-- If we need to add to get to the target, we need to add to velocity...
				Velocity = Velocity + (MaxIncreasePerSecond * (Delta/SmoothnessFactor))
			else
				Velocity = Velocity - (MaxIncreasePerSecond * (Delta/SmoothnessFactor))
			end
		else
			Velocity = 0;
		end

		Velocity = qMath.ClampNumber(Velocity, -MaxIncreasePerSecond, MaxIncreasePerSecond)
		--print(&quot;Velocity: &quot;..Velocity..&quot; CurrentValue: &quot;..CurrentValue..&quot; Target: &quot;..Target)

		--local TargetedIncrease = MaxIncreasePerSecond * Delta -- This is the maxIncrease for the time period elapsed. 
		local Increase = Velocity-- * TargetedIncrease;

		if CurrentValue &lt; Target then
			CurrentValue = CurrentValue + Increase;
			if CurrentValue &gt;= Target then
				return NeutralUpdate()
			end
		else
			CurrentValue = CurrentValue + Increase;
			if CurrentValue &lt;= Target then
				return NeutralUpdate()
			end
		end
		
		Spawn(function()
			Execution(CurrentValue)
		end)

		LastUpdateTime = time()
		return true
	end

	local function StartUpdate()
		if Updating then
			--print(&quot;[AnimationSystems] - Already updating&quot;)
			return false
		end

		Updating = true;
		LastUpdateTime = time()
		Velocity = 0;
		Spawn(function()
			while Update() do
				wait(UpdateTime)
			end
			Updating = false;
		end)
	end

	function MoveTowards:SetTarget(Value)
		Target = Value;
		StartUpdate()
	end

	StartUpdate()
end)
lib.MakeMoveTowards = MakeMoveTowards
lib.makeMoveTowards = MakeMoveTowards

local MakeGate = Class &apos;Gate&apos; (function(Gate, SmoothnessFactor, ...)
	-- As smoothness Factor decreases, the speed of the animation increases. 
	local Doors = {...}
	local Status = Make &apos;BoolValue&apos; { -- Where is it suppose to be (Headed towards)? Open = true, Closed = false;
		Name = &quot;GateStatus&quot;;
		Value = false;
	}
	Gate.StatusValue = Status

	local GateMoveTowards = MakeMoveTowards(0.5, 0, 0, SmoothnessFactor, function(Position)
		for _, Item in pairs(Doors) do
			Item:SetPosition(Position)
		end
	end)


	function Gate:SetStatus(Status)
		-- Set&apos;s the status as either Open (True) or Closed(false)
		Status.Value = Status;
	end

	function Gate:AddNewDoor(Brick, BaseCFrame, EndCFrame)
		-- Adds a new door into the gate system. This means that technically, you can have 1 gate that dictates the open
		-- /closed feature of 10 doors.  Handy for a quick base lockdown. 

		local Door = MakeDoor(Brick, BaseCFrame, EndCFrame)
		Doors[#Doors+1] = Door
		return Door;
	end

	Status.Changed:connect(function()
		--print(&quot;Status update&quot;)
		if Status.Value then
			GateMoveTowards:SetTarget(1) -- Open!
		else
			GateMoveTowards:SetTarget(0) -- Closed!
		end
	end)
end)

lib.makeGate = MakeGate;
lib.MakeGate = MakeGate;

return lib</ProtectedString>
</Properties>
</Item>
<Item class="Script" referent="RBX82">
<Properties>
<string name="Name">NotificationSystem</string>
<ProtectedString name="Source">while not _G.NevermoreEngine do wait(0) end

local NevermoreEngine   = _G.NevermoreEngine
local LoadCustomLibrary = NevermoreEngine.LoadLibrary;

local qSystems          = LoadCustomLibrary(&apos;qSystems&apos;)
local qGUI              = LoadCustomLibrary(&apos;qGUI&apos;)
local PersistantLog     = LoadCustomLibrary(&apos;PersistantLog&apos;)

qSystems:import(getfenv(0));

local lib = {}

--local PlayerDataContainer     = PersistantLog.AddSubDataLayer(&quot;QuentyPlayerData&quot;, ServerContainer)

local function GetNotificationObject(Player, Name, TitleName)
	-- Grab&apos;s a string value that the PlayerManager uses. &apos;Name&apos; is the name of the StringValue
	-- Messy. 
	
	Name = Name or &quot;Notification&quot;
	TitleName = TitleName or NotificationTitle
	local PlayerData = PersistantLog.AddSubDataLayer(Player.Name..&quot;Data&quot;, PlayerDataBin)
	local Notification = PlayerData:FindFirstChild(Name) or Make &apos;StringValue&apos; { 
		Name       = Name;
		Value      = &quot;&quot;;
		Parent     = PlayerData;
		Archivable = false;
	}
	local NotificationTitle = PlayerData:FindFirstChild(&quot;NotificationTitle&quot;) or Make &apos;StringValue&apos; {
		Name       = TitleName;
		Value      = &quot;&quot;;
		Parent     = PlayerData;
		Archivable = false;
	}
	return Notification, NotificationTitle
end
lib.GetNotificationObject = GetNotificationObject
lib.getNotificationObject = GetNotificationObject

local MakeNotificationSystem = Class &apos;NotificationSystem&apos; (function(NotificationSystem, ScreenGui)
	local NotificationId          = 0;
	local Displaying              = false
	local NotificationStateChange = CreateSignal()
	local DefaultAnimateTime      = 0.25

	local function ClearNotifications()
		NotificationId = NotificationId + 1;
		NotificationStateChange:fire()
	end
	NotificationSystem.ClearNotifications = ClearNotifications

	local function ConnectStringValue(StringValue, Title, Icon, AnimationTime)
		-- When the StringValue changes, then it&apos;ll notify the player. Title may be a string value.
		return StringValue.Changed:connect(function()
			if StringValue.Value ~= &quot;&quot; then
				local TitleText = Title
				if Title and not type(Title) ~= &quot;string&quot; then
					TitleText = Title.Value
				end
				local Content = StringValue.Value
				StringValue.Value = &quot;&quot;
				NotificationSystem.Notify(Content, Icon, TitleText, true, AnimationTime)
			end
		end)
	end
	NotificationSystem.ConnectStringValue = ConnectStringValue
	NotificationSystem.connectStringValue = ConnectStringValue

	local function Notify(ContentText, IconImage, TitleText, Override, AnimateTime)
		AnimateTime = AnimateTime or DefaultAnimateTime
		IconImage = IconImage or &quot;http://www.roblox.com/asset/?id=116318363&quot;
		TitleText = TitleText or &quot;System Notification&quot;;

		if Displaying and Override then
			NotificationId = NotificationId + 1;
		elseif Displaying then
			print(&quot;[NotifacationSystem] - Did not display &apos;&quot; .. TitleText .. &quot;&apos;&quot;)
			return false;
		end

		print(&quot;[NotifacationSystem] - New Notification &apos;&quot; .. TitleText .. &quot;&apos;&quot;)
		NotificationId = NotificationId + 1;
		NotificationStateChange:fire()
		Displaying = true
		local LocalNotificationId = NotificationId


		local NotificationFrame = Make &apos;Frame&apos; {
			Archivable             = false;
			BackgroundColor3       = Color3.new(0, 0, 0);
			BackgroundTransparency = 1;
			BorderSizePixel        = 0;
			Name                   = &quot;qNotification&quot;;
			Parent                 = ScreenGui;
			Size                   = UDim2.new(0, 400, 0, 175);
			ZIndex                 = 9;
		}
		--NotificationFrame.Position = UDim2.new(0.5, -NotificationFrame.AbsoluteSize.X/2, 0, -NotificationFrame.AbsoluteSize.Y)--qGUI.GetCenteringPosition(NotificationFrame)
		NotificationFrame.Position = qGUI.GetCenteringPosition(NotificationFrame) + UDim2.new(0, 0, 0, -100);

		local Icon = Make &apos;Frame&apos; {
			Archivable             = false;
			BackgroundColor3       = Color3.new(0, 0, 0);
			BackgroundTransparency = 1;
			BorderSizePixel        = 0;
			Name                   = &quot;Icon&quot;;
			Parent                 = NotificationFrame;
			Position               = UDim2.new(0, 20,  0.5, -70);
			Size                   = UDim2.new(0, 100, 0, 100);
			ZIndex                 = 9;
		}
		qGUI.SetImageId(Icon, IconImage, 10)

		local Title = Make &apos;TextLabel&apos; {
			Archivable             = false;
			BackgroundColor3       = Color3.new(0, 0, 0);
			BackgroundTransparency = 1;
			BorderSizePixel        = 0;
			Font                   = &quot;ArialBold&quot;;
			FontSize               = &quot;Size24&quot;;
			Name                   = &quot;Title&quot;;
			Parent                 = NotificationFrame;
			Position               = UDim2.new(0, 120,  0, 10);
			Size                   = UDim2.new(1, -120, 0, 40);
			Text                   = &quot;[ Content Deleted ]&quot;; -- In case...
			TextColor3             = qGUI.NewColor3(220, 220, 220);
			TextWrapped            = false;
			TextXAlignment         = &quot;Left&quot;;
			TextYAlignment         = &quot;Center&quot;;
			ZIndex                 = 10;
			TextTransparency = 1;
		}
		Title.Text = TitleText;

		local Content = Make &apos;TextLabel&apos; {
			Archivable             = false;
			BackgroundColor3       = Color3.new(0, 0, 0);
			BackgroundTransparency = 1;
			BorderSizePixel        = 0;
			Font                   = &quot;Arial&quot;;
			FontSize               = &quot;Size14&quot;;
			Name                   = &quot;Content&quot;;
			Parent                 = NotificationFrame;
			Position               = UDim2.new(0, 120,  0, 50);
			Size                   = UDim2.new(1, -140, 1, -110);
			Text                   = &quot;[ Content Deleted ]&quot;;
			TextColor3             = qGUI.NewColor3(220, 220, 220);
			TextWrapped            = true;
			TextXAlignment         = &quot;Left&quot;;
			TextYAlignment         = &quot;Top&quot;;
			ZIndex                 = 10;
			TextTransparency = 1;
		}
		Content.Text = ContentText

		local ConfirmButton = Make &apos;TextButton&apos; {
			Archivable             = false;
			BackgroundColor3       = Color3.new(0, 0, 0);
			BackgroundTransparency = 1; -- Tweens to 0.5
			BorderSizePixel        = 0;
			Font                   = &quot;Arial&quot;;
			FontSize               = &quot;Size18&quot;;
			Name                   = &quot;ConfirmButton&quot;;
			Parent                 = NotificationFrame;
			Position               = UDim2.new(0.5, -100,  1, -45);
			Size                   = UDim2.new(0, 200, 0, 35);
			Text                   = &quot;CLOSE&quot;;
			TextColor3             = qGUI.NewColor3(220, 220, 220);	
			TextWrapped            = false;
			TextXAlignment         = &quot;Center&quot;;
			TextYAlignment         = &quot;Center&quot;;
			ZIndex                 = 10;
		}
		local DidFinish = false

		local Connection = ConfirmButton.MouseButton1Click:connect(function()
			if (not DidFinish) and LocalNotificationId == NotificationId then
				NotificationId = NotificationId + 1
				NotificationStateChange:fire() -- Let&apos;s change a few things...
			end
		end)

		local TopLeft, TopRight, BottomLeft, BottomRight, Middle, MiddleLeft, MiddleRight = qGUI.AddTexturedWindowTemplate(NotificationFrame, 14) -- Heh. It works.
		qGUI.SetImageId(TopLeft, &quot;http://www.roblox.com/asset/?id=116183684&quot;, 10)
		qGUI.SetImageId(TopRight, &quot;http://www.roblox.com/asset/?id=116183621&quot;, 10)
		qGUI.SetImageId(BottomLeft, &quot;http://www.roblox.com/asset/?id=116183704&quot;, 10)
		qGUI.SetImageId(BottomRight, &quot;http://www.roblox.com/asset/?id=116183661&quot;, 10)

		qGUI.TweenImages(TopLeft, AnimateTime, true, true)
		qGUI.TweenImages(TopRight, AnimateTime, true, true)
		qGUI.TweenImages(BottomLeft, AnimateTime, true, true)
		qGUI.TweenImages(BottomRight, AnimateTime, true, true)
		qGUI.TweenImages(Icon, AnimateTime, true, true)
		
		qGUI.TweenTransparency(Middle, {BackgroundTransparency = 0.6}, AnimateTime, true)
		qGUI.TweenTransparency(MiddleLeft , {BackgroundTransparency = 0.6}, AnimateTime, true)
		qGUI.TweenTransparency(MiddleRight, {BackgroundTransparency = 0.6}, AnimateTime, true)

		qGUI.TweenTransparency(Content, {TextTransparency = 0}, AnimateTime, true)
		qGUI.TweenTransparency(Title, {TextTransparency = 0}, AnimateTime, true)
		qGUI.TweenTransparency(ConfirmButton, {TextTransparency = 0, BackgroundTransparency = 0.5}, AnimateTime, true)
		NotificationFrame:TweenPosition(qGUI.GetCenteringPosition(NotificationFrame), &quot;Out&quot;, &quot;Sine&quot;, AnimateTime, true)

		while NotificationStateChange:wait(0) and LocalNotificationId == NotificationId do end-- Wait until it&apos;s time to close...
		print(&quot;[NotifacationSystem] - Hiding Notification&quot;)
		DidFinish = true
		Displaying = false;
		Connection:disconnect()

		qGUI.TweenImages(TopLeft, AnimateTime, false, true)
		qGUI.TweenImages(TopRight, AnimateTime, false, true)
		qGUI.TweenImages(BottomLeft, AnimateTime, false, true)
		qGUI.TweenImages(BottomRight, AnimateTime, false, true)
		qGUI.TweenImages(Icon, AnimateTime, false, true)

		qGUI.TweenTransparency(Middle, {BackgroundTransparency = 1}, AnimateTime, true)
		qGUI.TweenTransparency(MiddleLeft , {BackgroundTransparency = 1}, AnimateTime, true)
		qGUI.TweenTransparency(MiddleRight, {BackgroundTransparency = 1}, AnimateTime, true)

		qGUI.TweenTransparency(Content, {TextTransparency = 1}, AnimateTime, true)
		qGUI.TweenTransparency(Title, {TextTransparency = 1}, AnimateTime, true)
		qGUI.TweenTransparency(ConfirmButton, {TextTransparency = 1, BackgroundTransparency = 1}, AnimateTime, true)
		--NotificationFrame:TweenPosition(UDim2.new(0.5, -NotificationFrame.AbsoluteSize.X/2, 0, -NotificationFrame.AbsoluteSize.Y), &quot;In&quot;, &quot;Sine&quot;, AnimateTime, true)
		NotificationFrame:TweenPosition(qGUI.GetCenteringPosition(NotificationFrame) + UDim2.new(0, 0, 0, -100), &quot;In&quot;, &quot;Sine&quot;, AnimateTime, true);
		wait(1)
		NotificationFrame:Destroy()
	end
	NotificationSystem.Notify = Notify;
	NotificationSystem.notify = Notify;

end)
lib.MakeNotificationSystem = MakeNotificationSystem
lib.makeNotificationSystem = MakeNotificationSystem

NevermoreEngine.RegisterLibrary(&apos;NotificationSystem&apos;, lib)

</ProtectedString>
<bool name="Disabled">true</bool>
</Properties>
</Item>
<Item class="Script" referent="RBX83">
<Properties>
<string name="Name">ParagraphConstructor</string>
<ProtectedString name="Source">while not _G.NevermoreEngine do wait(0) end

local NevermoreEngine   = _G.NevermoreEngine
local LoadCustomLibrary = NevermoreEngine.LoadLibrary;

local qSystems          = LoadCustomLibrary(&apos;qSystems&apos;)
local qString           = LoadCustomLibrary(&apos;qString&apos;)
local MarkdownSystem    = LoadCustomLibrary(&apos;MarkdownSystem&apos;)
local qGUI              = LoadCustomLibrary(&apos;qGUI&apos;)

local lib    = {}
local Styles = {}

qSystems:Import(getfenv(0))

local NewColor3 = qGUI.NewColor3

local TemporaryLabel

local function ModifyWithClone(instance, values)
	-- Modifies an instance by using a table, but clones instances instead of parenting...

	for key, value in next, values do
		if type(key) == &quot;number&quot; then
			value:Clone().Parent = instance
		else 	
			instance[key] = value
		end
	end
	return instance
end

local function GetSentenceBreakdown(MaxX, CurrentX, Text, Style, ScreenGui)
	--- Breaks the given Text into fragments to be rendred as a paragraph.
	-- @param MaxX Number, in pixels, the width (X) of the frame it is being put into.
	-- @param CurrentX The distance in pixels (width, X), of that the marker has already gone. This parameter
	--                 may be used when a sentence has stying in the middle.
	-- @param Text The text to break into. A string.
	-- @param [Style] The style to use, a table. The style must be given so the label can know how far to go
	--                / render before stopping.
	-- @param ScreenGui A ScreenGui that is active, because TextBounds doesn&apos;t work. 
	-- @return Table &apos;Fragments&apos; A table of all the fragments generated,
	--         number The CurrentX it ended at

	-- Note that this system does sometimes generate excess labels. Still working on that. 


	--print(&quot;Breaking down \&quot;&quot; .. Text .. &quot;\&quot;&quot;)

	if (not TemporaryLabel) or (TemporaryLabel and not TemporaryLabel.Parent) then
		if TemporaryLabel then
			TemporaryLabel:Destroy()
		end
		TemporaryLabel = Make &apos;TextLabel&apos; {
			BackgroundTransparency = 1;
			Name                   = &quot;TemporaryLabel&quot;;
			Parent                 = assert(ScreenGui, &quot;ScreenGui is nil&quot;);
			Position               = UDim2.new(0, 0, 0, -105);
			Size                   = UDim2.new(0, 100, 0, 100);
			Visible                = true;
			Archivable = true;
		}
	end

	Style = Style or {}
	local Fragments = {}
	local Words = {}

	for Text, Whitespace in string.gmatch(Text, &quot;([%w%p]*)([%s]*)&quot;) do
		if Text ~= &quot;&quot; then 
			Words[#Words+1] = Text 
		end 
		if Whitespace ~= &quot;&quot; then 
			Words[#Words+1] = Whitespace 
		end 
	end

	local TemporaryLabel = ModifyWithClone(TemporaryLabel, Style)
	TemporaryLabel.Text = &quot;&quot;

	--[[
	OverflowWarFail:
		1234567890
		HelloBigWorld

	Overflow Correct: 
		1234567890
		HelloBigWoXXX
		rld

	--]]

	local FragmentCount = 1
	local CurrentLine

	local function CloneLabel(OldText)
		-- Adds OldText to the fragment list, presuming that OldText is all of that style&apos;s text for that line.

		--print(&quot;Adding clone label of \&quot;&quot; .. OldText .. &quot;\&quot;&quot;)
		TemporaryLabel.Text = OldText -- We can get text&apos;s like &quot;&quot;... For now, ignore.
		local Label = TemporaryLabel:Clone()
		Label.Text = TemporaryLabel.Text
		Label.Size = UDim2.new(0, TemporaryLabel.TextBounds.x, 0, TemporaryLabel.TextBounds.y)
		Fragments[FragmentCount] = Label
		CurrentLine = Label
		FragmentCount = FragmentCount + 1
		CurrentX = 0;
	end

	for _, Word in pairs(Words) do
		local OldText = TemporaryLabel.Text
		local NewText = TemporaryLabel.Text .. Word
		TemporaryLabel.Text = NewText

		if not qString.IsWhitespace(Word) then
			if (TemporaryLabel.TextBounds.X + CurrentX) &gt;= MaxX then -- If we can&apos;t add the next word, then...
				CloneLabel(OldText) -- And add the current line information that is there.
				-- Now we need to add the word to the next new line.

				TemporaryLabel.Text = Word -- Add... :D

				if TemporaryLabel.TextBounds.X &gt; MaxX then -- Next Word is too long to fit on a single line, Overflow correctly
					-- by basically fitting as many characters as we can per a line...

					TemporaryLabel.Size = UDim2.new(0, MaxX, 0, 100)
					local WorkingWord = Word
					while #WorkingWord ~= 0 do -- While letters are left in the word, do...
						TemporaryLabel.Text = TemporaryLabel.Text .. WorkingWord:sub(1, 1) -- Add the first letter to the word..
						if (TemporaryLabel.TextBounds.X + CurrentX) &gt;= MaxX then -- If it overflows...
							CloneLabel(TemporaryLabel.Text:sub(1, #TemporaryLabel.Text-1)) -- Add the whole part of the word to the label, 
							-- and then effectively add the next letter to the label...
							TemporaryLabel.Text = WorkingWord:sub(1, 1)
						end
						WorkingWord = WorkingWord:sub(2)
					end
				end -- Else, the new word fits fine, move on....
			end -- Otherwise the new word fits fine, keep on adding words...
		--[[else -- Handling Whitespace (Can overflow indefinitely)
			if (TemporaryLabel.TextBounds.X + CurrentX) &gt;= MaxX then -- We overflowed... Technically, nothing happens?
				-- CloneLabel(OldText)
				-- TemporaryLabel.Text = Word
			end--]]
		end
	end
	CloneLabel(TemporaryLabel.Text)

	return Fragments, (CurrentLine and TemporaryLabel.TextBounds.X or CurrentX)
end

local function ConstructParagraph(Container, Content, ParagrahFormat, ScreenGui)
	-- Given a Container sized at UDim2.new(0, ?, 0, ?), this will resize the Y part of the Container and fill it with &apos;Content&apos;.



	ParagrahFormat = ParagrahFormat or {}
	ParagrahFormat.LineSpacingAt = ParagrahFormat.LineSpacingAt or 1.2

	local CurrentX = 0;
	local MaxX = Container.AbsoluteSize.X
	local Lines = {}
	local LineNumber = 1;

	local function GetLine(LineNumber)
		local Line = Lines[LineNumber]
		if not Line then
			Line = {
				Fragments = {};
				HeightY = 0;
			}
			Lines[LineNumber] = Line;
		end
		return Line
	end

	for _, TextClass in pairs(Content) do -- We&apos;re breaking it into segments based upon style
		--print(&quot;Processing Content &quot; .. TextClass.Text .. &quot; &quot;)
		local Text = assert(TextClass.Text, &quot;Could not get Text&quot;);
		local Style = assert(TextClass.Style, &quot;Could not get Style&quot;);

		local Fragments

		Fragments, CurrentX = GetSentenceBreakdown(MaxX, CurrentX, Text, Style, ScreenGui)
		for _, Fragment in pairs(Fragments) do -- And then process it into lines, regardless of style.
			local Line = GetLine(LineNumber)
			--print(&quot;Added new fragment \&quot;&quot; .. Fragment.Text .. &quot;\&quot; to line &quot; .. LineNumber .. &quot; @ index &quot; .. (#Line.Fragments+1))
			Line.Fragments[#Line.Fragments+1] = Fragment
			local TextBoundY = Fragment.Size.Y.Offset
			if Line.HeightY &lt; TextBoundY then
				Line.HeightY = TextBoundY
			end
			LineNumber = LineNumber + 1
		end
		LineNumber = LineNumber - 1 -- Last line may still contain content, we we start at that, not one above.
	end

	local CurrentY = 0
	for LineNumber, Line in pairs(Lines) do
		--print(&quot;Processing Line &quot;..LineNumber..&quot; #Line.Fragments = &quot; .. (#Line.Fragments) .. &quot;; Line.HeightY = &quot; .. Line.HeightY)
		local LineSpacing = Line.HeightY * (ParagrahFormat.LineSpacingAt - 1)
		CurrentY = CurrentY + Line.HeightY + LineSpacing
		CurrentX = 0;
		for _, Fragment in pairs(Line.Fragments) do
			--print(&quot;Processing Fragment \&quot;&quot; .. Fragment.Text .. &quot;\&quot;&quot;)
			Fragment.Name = &quot;Fragment&quot; .. LineNumber
			Fragment.Parent = Container;
			Fragment.Position = UDim2.new(0, CurrentX, 0, CurrentY - Fragment.Size.Y.Offset - LineSpacing)
			CurrentX = CurrentX + Fragment.Size.X.Offset
		end
	end

	return Container, CurrentY, CurrentX
end
lib.ConstructParagraph = ConstructParagraph
lib.constructParagraph = ConstructParagraph


Styles.Headers = {}
	Styles.Headers[1] = {
		TextColor3 = NewColor3(255, 255, 255);
		BackgroundColor3 = NewColor3(255, 255, 255);
		BackgroundTransparency = 1;
		BorderSizePixel = 0;
		TextXAlignment = &quot;Left&quot;;
		TextYAlignment = &quot;Center&quot;;
		TextStrokeTransparency = 1;
		TextTransparency = 0;
		TextStrokeColor3 = NewColor3(0, 0, 0);
		FontSize = &quot;Size48&quot;;
		Font = &quot;ArialBold&quot;;
	}
	Styles.Headers[2] = {
		TextColor3 = NewColor3(255, 255, 255);
		BackgroundColor3 = NewColor3(255, 255, 255);
		BackgroundTransparency = 1;
		BorderSizePixel = 0;
		TextXAlignment = &quot;Left&quot;;
		TextYAlignment = &quot;Center&quot;;
		TextStrokeTransparency = 1;
		TextTransparency = 0;
		TextStrokeColor3 = NewColor3(0, 0, 0);
		FontSize = &quot;Size36&quot;;
		Font = &quot;ArialBold&quot;;
	}
	Styles.Headers[3] = {
		TextColor3 = NewColor3(255, 255, 255);
		BackgroundColor3 = NewColor3(255, 255, 255);
		BackgroundTransparency = 1;
		BorderSizePixel = 0;
		TextXAlignment = &quot;Left&quot;;
		TextYAlignment = &quot;Center&quot;;
		TextStrokeTransparency = 1;
		TextTransparency = 0;
		TextStrokeColor3 = NewColor3(0, 0, 0);
		FontSize = &quot;Size24&quot;;
		Font = &quot;ArialBold&quot;;
	}
	Styles.Headers[4] = {
		TextColor3 = NewColor3(255, 255, 255);
		BackgroundColor3 = NewColor3(255, 255, 255);
		BackgroundTransparency = 1;
		BorderSizePixel = 0;
		TextXAlignment = &quot;Left&quot;;
		TextYAlignment = &quot;Center&quot;;
		TextStrokeTransparency = 1;
		TextTransparency = 0;
		TextStrokeColor3 = NewColor3(0, 0, 0);
		FontSize = &quot;Size18&quot;;
		Font = &quot;ArialBold&quot;;
	}
	Styles.Headers[5] = {
		TextColor3 = NewColor3(255, 255, 255);
		BackgroundColor3 = NewColor3(255, 255, 255);
		BackgroundTransparency = 1;
		BorderSizePixel = 0;
		TextXAlignment = &quot;Left&quot;;
		TextYAlignment = &quot;Center&quot;;
		TextStrokeTransparency = 1;
		TextTransparency = 0;
		TextStrokeColor3 = NewColor3(0, 0, 0);
		FontSize = &quot;Size14&quot;;
		Font = &quot;ArialBold&quot;;
	}
Styles.Normal = {
	TextColor3 = NewColor3(215, 215, 215);
	BackgroundColor3 = NewColor3(255, 255, 255);
	BackgroundTransparency = 1;
	BorderSizePixel = 0;
	TextXAlignment = &quot;Left&quot;;
	TextYAlignment = &quot;Center&quot;;
	TextStrokeTransparency = 1;
	TextTransparency = 0;
	TextStrokeColor3 = NewColor3(0, 0, 0);
	FontSize = &quot;Size14&quot;;
	Font = &quot;Arial&quot;;
}
Styles.TransparentFrame = {
	BackgroundColor3       = Color3.new(0, 0, 0);
	BackgroundTransparency = 1;
	BorderSizePixel        = 0;
	-- Style                  = &quot;Custom&quot;;
}



local function ParseText(MarkdownText)
	-- Using the MarkdownSystem, convert ito beautiful beautiful tables using concepts I don&apos;t understand fully.
	
	local MarkdownedTable = MarkdownSystem.MarkdownToTable(MarkdownText)
	return MarkdownedTable
end

local Handlers = {
	normal = function(Data, NewContainer, ScreenGui)
		if Data.text ~= &quot;&quot; then
			local TextContent = {}

			TextContent[1] = { -- Will improve later for markdown emphasis, etc.
				Text = Data.text;
				Style = Styles.Normal;
			}

			local NewContainer, ContainerHeight = ConstructParagraph(NewContainer, TextContent, {
				LineSpacingAt = 1.15; -- Standard in MS Word (115%)
			}, ScreenGui)

			return NewContainer, ContainerHeight
		else
			--print(&quot;[ParagraphConstructor] - Could not Process: Data.text == \&quot;\&quot;&quot;);
			return false;
		end
	end;
	header = function(Data, NewContainer, ScreenGui)
		if Data.text ~= &quot;&quot; then
			local TextContent = {}

			TextContent[1] = { 
				Text = assert(Data.text, &quot;Data.text is nil&quot;);
				Style = Styles.Headers[Data.level or 1];
			}

			local NewContainer, ContainerHeight = ConstructParagraph(NewContainer, TextContent, {
				LineSpacingAt = 1;
			}, ScreenGui)


			return NewContainer, ContainerHeight
		else
			--print(&quot;[ParagraphConstructor] - Could not Process: Data.text == \&quot;\&quot;&quot;);
			return false;
		end
	end;
	list_item = function(Data, NewContainer, ScreenGui)
		if Data.text ~= &quot;&quot; then
			local TextContent = {}

			TextContent[1] = {
				Text = Data.text;
				Style = Styles.Normal;
			}

			local NewNewContainer = NewContainer:Clone()
			NewNewContainer.Size = UDim2.new(1, -20, 1, 0)
			NewNewContainer.Position = UDim2.new(0, 20, 0, 0)
			NewNewContainer.Parent = NewContainer

			local BulletPoint = Make &apos;Frame&apos; {
				Size = UDim2.new(0, 6, 0, 6);
				Position = UDim2.new(0, 4, 0.5, -3);
				BorderSizePixel = 0;
				BackgroundTransparency = 0;
				BackgroundColor3 = Color3.new(1, 1, 1);
				Name = &quot;BulletPoint&quot;;
				Parent = NewContainer;
				ZIndex = NewContainer.ZIndex;
			}

			local NewNewContainer, ContainerHeight = ConstructParagraph(NewNewContainer, TextContent, {
				LineSpacingAt = 1;
			}, ScreenGui)

			return NewContainer, ContainerHeight
		else
			--print(&quot;[ParagraphConstructor] - Could not Process: Data.text == \&quot;\&quot;&quot;);
			return false;
		end
	end;
}

local function GetHandler(HandlerName)
	-- Return&apos;s a markdown handler, will default to &apos;normal&apos; if all else fails.
	-- So yeah, this is a really weird system.

	if not Handlers[HandlerName] then
		print(&quot;Warning: Could not find &apos;&quot; .. HandlerName .. &quot;&apos; defaulting to &apos;normal&apos;&quot;)
	end

	return Handlers[HandlerName] or Handlers.normal
end

local function ConstructBlock(MarkdownText, Container, ScreenGui, Format)
	-- Format&apos;s a &quot;Block&quot; of MardownText, that is, basically a document.
	-- MarkdownText is a string, using markdown text
	-- Container is the container we dump it into
	-- ScreenGui is the screenGUI that will be utilized to create it (really required for some rendering / size getting issues)
	-- Format is a configuration table. 

	Format = Format or {}
	Format.MarginLeft    = Format.MarginLeft or 10
	Format.MarginRight   = Format.MarginRight or 10
	Format.SpacingAfter  = Format.SpacingAfter or 5
	Format.SpacingBefore = Format.SpacingBefore or 5

	local HeightY = 0

	local ParsedText = ParseText(MarkdownText)
	for Index, Item in pairs(ParsedText) do
		HeightY = HeightY + Format.SpacingBefore
		local NewContainer = Make &apos;Frame&apos; (Styles.TransparentFrame)
		NewContainer.Parent = Container
		NewContainer.Position = UDim2.new(0, Format.MarginLeft, 0, HeightY)
		NewContainer.Size = UDim2.new(1, -Format.MarginLeft - Format.MarginRight, 0, 0)
		NewContainer.Name = Index..&quot;Container&quot;

		local Success, NewHeightY = GetHandler(Item.type)(Item, NewContainer, ScreenGui)
		if Success then
			HeightY = HeightY + NewHeightY + Format.SpacingAfter
			NewContainer.Size = UDim2.new(NewContainer.Size.X.Scale, NewContainer.Size.X.Offset, 0, NewHeightY + Format.SpacingAfter)
		else
			HeightY = HeightY - Format.SpacingBefore -- Remove old spacing. :/
		end
	end

	return Container, HeightY
end
lib.ConstructBlock = ConstructBlock
lib.constructBlock = ConstructBlock

NevermoreEngine.RegisterLibrary(&quot;ParagraphConstructor&quot;, lib)</ProtectedString>
<bool name="Disabled">true</bool>
</Properties>
</Item>
<Item class="Script" referent="RBX84">
<Properties>
<string name="Name">SoundPlayer</string>
<ProtectedString name="Source">while not _G.NevermoreEngine do wait(0) end

local Players           = Game:GetService(&apos;Players&apos;)
local StarterPack       = Game:GetService(&apos;StarterPack&apos;)
local StarterGui        = Game:GetService(&apos;StarterGui&apos;)
local Lighting          = Game:GetService(&apos;Lighting&apos;)
local Debris            = Game:GetService(&apos;Debris&apos;)
local Teams             = Game:GetService(&apos;Teams&apos;)
local BadgeService      = Game:GetService(&apos;BadgeService&apos;)
local InsertService     = Game:GetService(&apos;InsertService&apos;)
local Terrain           = Workspace.Terrain

local NevermoreEngine   = _G.NevermoreEngine
local LoadCustomLibrary = NevermoreEngine.LoadLibrary;

local qSystems          = LoadCustomLibrary(&apos;qSystems&apos;)
local lib               = {}

qSystems:import(getfenv(0));

local Sounds              = {} -- We&apos;re doing safe indexing with a metatable. :)
local SoundList           = {} -- Lowercase. :)
local SoundListUnmodified = {
	[&quot;2Thumps&quot;]                   = &quot;http://www.roblox.com/asset/?id=12813086&quot;;
	[&quot;Bang/Thump3&quot;]               = &quot;http://www.roblox.com/asset/?id=10730819&quot;;
	[&quot;Banjo I Chord&quot;]             = &quot;http://www.roblox.com/asset/?id=12857629&quot;;
	[&quot;Banjo III Chord&quot;]           = &quot;http://www.roblox.com/asset/?id=12857664&quot;;
	[&quot;Banjo IV Chord&quot;]            = &quot;http://www.roblox.com/asset/?id=12857637&quot;;
	[&quot;Banjo IVII Chord&quot;]          = &quot;http://www.roblox.com/asset/?id=12857660&quot;;
	[&quot;Banjo V Chord&quot;]             = &quot;http://www.roblox.com/asset/?id=12857804&quot;;
	[&quot;Banjo VVII Chord&quot;]          = &quot;http://www.roblox.com/asset/?id=12857654&quot;;
	[&quot;Beewem&quot;]                    = &quot;http://www.roblox.com/asset/?id=11998770&quot;;
	[&quot;Bite Sandwich&quot;]             = &quot;http://www.roblox.com/asset/?id=12517136&quot;;
	[&quot;Blow Dryer&quot;]                = &quot;http://www.roblox.com/asset/?id=11717967&quot;;
	[&quot;Bloxpin 1&quot;]                 = &quot;http://www.roblox.com/asset/?id=12844799&quot;;
	[&quot;Bloxpin 2&quot;]                 = &quot;http://www.roblox.com/asset/?id=12844794&quot;;
	[&quot;Bloxpin 3&quot;]                 = &quot;http://www.roblox.com/asset/?id=12803520&quot;;
	[&quot;Bloxpin 4&quot;]                 = &quot;http://www.roblox.com/asset/?id=12803507&quot;;
	[&quot;Bloxpin 5&quot;]                 = &quot;http://www.roblox.com/asset/?id=12803498&quot;;
	[&quot;Boing&quot;]                     = &quot;rbxasset://sounds\\short spring sound.wav&quot;;
	[&quot;Bzzt 1&quot;]                    = &quot;http://www.roblox.com/asset/?id=11998777&quot;;
	[&quot;Bzzt 2&quot;]                    = &quot;http://www.roblox.com/asset/?id=11998796&quot;;
	[&quot;Calibrate&quot;]                 = &quot;http://www.roblox.com/asset/?id=11956590&quot;;
	[&quot;Carmel Dansen&quot;]             = &quot;http://www.roblox.com/asset/?id=2303479&quot;;
	[&quot;Charge&quot;]                    = &quot;http://www.roblox.com/asset/?id=2101137&quot;;
	[&quot;Clang&quot;]                     = &quot;http://www.roblox.com/asset/?id=11113679&quot;;
	[&quot;Creative Music 1&quot;]          = &quot;http://www.roblox.com/Asset/?id=11266868&quot;;
	[&quot;Creative Music 2&quot;]          = &quot;http://www.roblox.com/asset/?id=5985139&quot;;
	[&quot;Dar Creative Music&quot;]        = &quot;http://www.roblox.com/asset/?ID=10410939&quot;;
	[&quot;Dark Creative&quot;]             = &quot;http://www.roblox.com/asset/?id=4470389&quot;;
	[&quot;Default Explosion&quot;]         = &quot;rbxasset://sounds\collide.wav&quot;;
	[&quot;Drinking&quot;]                  = &quot;http://www.roblox.com/asset/?id=10722059&quot;;
	[&quot;Electric I Chord&quot;]          = &quot;http://www.roblox.com/asset/?id=1089403&quot;;
	[&quot;Electric III Chord&quot;]        = &quot;http://www.roblox.com/asset/?id=1089404&quot;;
	[&quot;Electric IV Chord&quot;]         = &quot;http://www.roblox.com/asset/?id=1089406&quot;;
	[&quot;Electric IVII Chord&quot;]       = &quot;http://www.roblox.com/asset/?id=1089405&quot;;
	[&quot;Electric V Chord&quot;]          = &quot;http://www.roblox.com/asset/?id=1089407&quot;;
	[&quot;Electric VVII Chord&quot;]       = &quot;http://www.roblox.com/asset/?id=1089410&quot;;
	[&quot;Empty Chamber&quot;]             = &quot;http://www.roblox.com/asset/?ID=10918913&quot;;
	[&quot;Escape Music&quot;]              = &quot;http://www.roblox.com/asset/?ID=11266612&quot;;
	[&quot;Explode/Gunshot&quot;]           = &quot;http://www.roblox.com/asset/?ID=10920368&quot;;
	[&quot;Fuse&quot;]                      = &quot;http://www.roblox.com/asset/?id=11565378&quot;;
	[&quot;Ghost&quot;]                     = &quot;rbxasset://sounds\HalloweenGhost.wav&quot;;
	[&quot;GlassBreak&quot;]                = &quot;rbxasset://sounds\\Glassbreak.wav&quot;;
	[&quot;Gunshot&quot;]                   = &quot;http://www.roblox.com/asset/?ID=10918856&quot;;
	[&quot;Gunshot2&quot;]                  = &quot;http://www.roblox.com/asset/?ID=10918856&quot;;
	[&quot;Gunshot3&quot;]                  = &quot;http://www.roblox.com/asset/?ID=10241826&quot;;
	[&quot;Heal&quot;]                      = &quot;http://www.roblox.com/asset/?id=2101144&quot;;
	[&quot;Helicopter&quot;]                = &quot;http://www.roblox.com/asset/?ID=10920268&quot;;
	[&quot;Japanase CHior&quot;]            = &quot;http://www.roblox.com/asset/?id=1372258&quot;;
	[&quot;Jet Takeoff&quot;]               = &quot;http://www.roblox.com/asset/?ID=10920312&quot;;
	[&quot;Jump Swoosh&quot;]               = &quot;rbxasset://sounds/swoosh.wav&quot;;
	[&quot;Jungle Chords&quot;]             = &quot;http://www.roblox.com/asset/?id=12892216&quot;;
	[&quot;Laser Bewm&quot;]                = &quot;http://www.roblox.com/asset/?id=13775494&quot;;
	[&quot;Laser Hit&quot;]                 = &quot;http://www.roblox.com/asset/?id=11945266&quot;;
	[&quot;Laser&quot;]                     = &quot;http://www.roblox.com/asset/?id=1616554&quot;;
	[&quot;Laser2&quot;]                    = &quot;http://www.roblox.com/asset/?id=1369158&quot;;
	[&quot;Machine Gun&quot;]               = &quot;http://www.roblox.com/asset/?id=1753007&quot;;
	[&quot;Mario Song&quot;]                = &quot;http://www.roblox.com/asset/?id=1280470&quot;;
	[&quot;New Explode1&quot;]              = &quot;http://www.roblox.com/asset/?id=2233908&quot;;
	[&quot;New Explode2&quot;]              = &quot;http://www.roblox.com/asset/?id=2248511&quot;;
	[&quot;New Explode3/Cannon Blast&quot;] = &quot;http://www.roblox.com/asset/?id=2101148&quot;;
	[&quot;New Explode4&quot;]              = &quot;http://www.roblox.com/asset/?id=2101157&quot;;
	[&quot;Nom Nom Nom&quot;]               = &quot;http://www.roblox.com/asset/?id=12544690&quot;;
	[&quot;Open Parchute&quot;]             = &quot;http://www.roblox.com/asset/?id=3931318&quot;;
	[&quot;Open Pop&quot;]                  = &quot;http://www.roblox.com/asset/?id=10721950&quot;;
	[&quot;Paintball Shot&quot;]            = &quot;rbxasset://sounds\\paintball.wav&quot;;
	[&quot;Player Death&quot;]              = &quot;rbxasset://sounds/uuhhh.wav&quot;;
	[&quot;Player Get Up&quot;]             = &quot;rbxasset://sounds/hit.wav&quot;;
	[&quot;Player Jump&quot;]               = &quot;rbxasset://sounds/button.wav&quot;;
	[&quot;Quaking Duck&quot;]              = &quot;http://www.roblox.com/asset/?id=2036448&quot;;
	[&quot;Quiete Boom&quot;]               = &quot;http://www.roblox.com/asset/?id=11984254&quot;;
	[&quot;Rain&quot;]                      = &quot;http://www.roblox.com/asset/?id=11387922&quot;;
	[&quot;Reload1 Alt&quot;]               = &quot;http://www.roblox.com/asset/?version=1&amp;id=2691591&quot;;
	[&quot;Reload1&quot;]                   = &quot;http://www.roblox.com/Item.aspx?ID=10920368&quot;;
	[&quot;Reload2&quot;]                   = &quot;http://www.roblox.com/asset/?id=2697432&quot;;
	[&quot;Reload3&quot;]                   = &quot;http://www.roblox.com/asset/?ID=10919283&quot;;
	[&quot;Ringing Phone&quot;]             = &quot;http://www.roblox.com/asset/?id=4762065&quot;;
	[&quot;Roblox Theme Music&quot;]        = &quot;http://www.roblox.com/asset/?id=4470503&quot;;
	[&quot;Rocket/Heavy Explosion&quot;]    = &quot;http://www.roblox.com/asset/?id=2101159&quot;;
	[&quot;RocketShot&quot;]                = &quot;rbxasset://sounds\\Rocket shot.wav&quot;;
	[&quot;Rokkit Launch&quot;]             = &quot;rbxasset://sounds/Launching rocket.wav&quot;;
	[&quot;Rokkit Launch2&quot;]            = &quot;rbxasset://sounds\Shoulder fired rocket.wav&quot;;
	[&quot;Self Esteem&quot;]               = &quot;http://www.roblox.com/asset/?ID=11267051&quot;;
	[&quot;Short Wail&quot;]                = &quot;http://www.roblox.com/asset/?ID=10920535&quot;;
	[&quot;Slateskin&quot;]                 = &quot;http://www.roblox.com/asset/?id=11450310&quot;;
	[&quot;Slingshot&quot;]                 = &quot;rbxasset://sounds\\Rubber band sling shot.wav&quot;;
	[&quot;Sparkler Light&quot;]            = &quot;http://www.roblox.com/asset/?id=12555589&quot;;
	[&quot;Sparkler Spark&quot;]            = &quot;http://www.roblox.com/asset/?id=12555594&quot;;
	[&quot;Splat&quot;]                     = &quot;rbxasset://sounds/splat.wav&quot;;
	[&quot;Spooky III Chord&quot;]          = &quot;http://www.roblox.com/asset/?id=13061810&quot;;
	[&quot;Spooky IV Chord&quot;]           = &quot;http://www.roblox.com/asset/?id=13061809&quot;;
	[&quot;Spooky IVII Chord&quot;]         = &quot;http://www.roblox.com/asset/?id=13061809&quot;;
	[&quot;Spooky V Chord&quot;]            = &quot;http://www.roblox.com/asset/?id=13061810&quot;;
	[&quot;Spooky VVII Chord&quot;]         = &quot;http://www.roblox.com/asset/?id=13061802&quot;;
	[&quot;Sppoky I Chord&quot;]            = &quot;http://www.roblox.com/asset/?id=13061802&quot;;
	[&quot;Squish&quot;]                    = &quot;http://www.roblox.com/asset/?id=1390349&quot;;
	[&quot;Subspace Explosion&quot;]        = &quot;http://www.roblox.com/asset/?id=11984351&quot;;
	[&quot;Swoosh&quot;]                    = &quot;rbxasset://sounds\Rocket whoosh 01.wav&quot;;
	[&quot;Sword Lunge&quot;]               = &quot;rbxasset://sounds\swordlunge.wav&quot;;
	[&quot;Sword Slash&quot;]               = &quot;rbxasset://sounds\swordslash.wav&quot;;
	[&quot;Ta-Dah!&quot;]                   = &quot;rbxasset://sounds\\Victory.wav&quot;;
	[&quot;Throw Knife&quot;]               = &quot;http://www.roblox.com/asset/?id=1369159&quot;;
	[&quot;Thump&quot;]                     = &quot;http://www.roblox.com/Asset/?ID=11949128&quot;;
	[&quot;Thump2&quot;]                    = &quot;http://www.roblox.com/asset/?id=10548108&quot;;
	[&quot;Thump4/Clunk&quot;]              = &quot;http://www.roblox.com/asset/?id=12814239&quot;;
	[&quot;Thunder Zap&quot;]               = &quot;http://www.roblox.com/asset/?id=2974000&quot;;
	[&quot;Thunder&quot;]                   = &quot;rbxasset://sounds\HalloweenThunder.wav&quot;;
	[&quot;Tick&quot;]                      = &quot;rbxasset://sounds\\clickfast.wav&quot;;
	[&quot;Trowel Build&quot;]              = &quot;rbxasset://sounds\\bass.wav&quot;;
	[&quot;Unsheath&quot;]                  = &quot;rbxasset://sounds\unsheath.wav&quot;;
	[&quot;Wail&quot;]                      = &quot;http://www.roblox.com/asset/?ID=10920578&quot;;
	[&quot;Walking&quot;]                   = &quot;rbxasset://sounds/bfsl-minifigfoots1.mp3&quot;;
	[&quot;Wood Clank&quot;]                = &quot;http://www.roblox.com/asset/?id=10548112&quot;;
	[&quot;Zap Boom&quot;]                  = &quot;http://www.roblox.com/asset/?id=1994345&quot;;
	[&quot;Zap1&quot;]                      = &quot;http://www.roblox.com/asset/?id=10756118&quot;;
	[&quot;Zap2&quot;]                      = &quot;http://www.roblox.com/asset/?id=10756104&quot;;
}

for Index, Value in pairs(SoundListUnmodified) do
	SoundList[Index:lower()] = Value;
end

setmetatable(Sounds, {
	__index = function(_, NewIndex)
		return SoundList[NewIndex:lower()];
	end;
})

function lib.PreloadSound(SoundId)
	-- Preloads a sound into ROBLOX.   It does it silently though. Yay. :)

	Spawn(function()
		local Sound = Instance.new(&quot;Sound&quot;, Players.LocalPlayer.PlayerGui)
		Sound.Name = &quot;PreloadSound&quot;;
		Sound.Archivable = false;
		Sound.Looped = false;
		Sound.Volume = 0;
		Sound.SoundId = SoundId
		Sound:Play()
		wait(0)
		Sound:Stop();
		Sound:Destroy();
	end)
end

function lib.PreoadAllSounds()
	-- Preloads all the sounds in the list. 

	repeat wait(0) until Players.LocalPlayer and Player.LocalPlayer:FindFirstChild(&quot;PlayerGui&quot;)
	for SoundName, SoundId in pairs(SoundListUnmodified) do
		lib.PreloadSound(SoundId)
	end
end

local function getSoundContainer()
	return Players.LocalPlayer.PlayerGui:FindFirstChild(&quot;qSoundPlayerContainer&quot;) or Make &apos;Configuration&apos; {
		Name = &quot;qSoundPlayerContainer&quot;;
		Parent = Players.LocalPlayer.PlayerGui;
		Archivable = false;
	}
end

function lib.PlaySound(SoundName, Volume, Properties)
	-- Play&apos;s a sound.  Needs work, but for now, it works. Properties is a table of properties to be added to the sound. 
	
	Volume = Volume or 1
	local SoundId = Sounds[SoundName]
	if not SoundId then -- If we can&apos;t find it in the list, then they&apos;ll providing a custom asset.
		SoundId = SoundName
	end

	local Sound = Make &apos;Sound&apos; {
		Archivable = false;
		Looped     = false;
		Name       = SoundName;
		Parent     = getSoundContainer();
		SoundId    = SoundId;
		Volume     = Volume;
	}

	Modify(Sound, Properties or {})

	Spawn(function()
		Sound:Play()
		Debris:AddItem(Sound, 120) -- Can&apos;t honestly play longer then 2 minutes, can it?
		--while Sound.Changed:wait() ~= &quot;IsPlaying&quot; do end
		wait(30);
		if Sound then
			Sound:Stop()
			Sound:Destroy()
		end
	end)

	return Sound;
end

lib.Play = lib.PlaySound
lib.SoundList = Sounds;

NevermoreEngine.RegisterLibrary(&apos;SoundPlayer&apos;, lib);

</ProtectedString>
<bool name="Disabled">true</bool>
</Properties>
</Item>
<Item class="Script" referent="RBX85">
<Properties>
<string name="Name">UserActionSystem</string>
<ProtectedString name="Source">while not _G.NevermoreEngine do wait(0) end

local Players            = Game:GetService(&apos;Players&apos;)
local StarterPack        = Game:GetService(&apos;StarterPack&apos;)
local StarterGui         = Game:GetService(&apos;StarterGui&apos;)
local Lighting           = Game:GetService(&apos;Lighting&apos;)
local Debris             = Game:GetService(&apos;Debris&apos;)
local Teams              = Game:GetService(&apos;Teams&apos;)
local BadgeService       = Game:GetService(&apos;BadgeService&apos;)
local InsertService      = Game:GetService(&apos;InsertService&apos;)
local MarketplaceService = game:GetService(&quot;MarketplaceService&quot;)
local Terrain            = Workspace.Terrain

local NevermoreEngine    = _G.NevermoreEngine
local LoadCustomLibrary  = NevermoreEngine.LoadLibrary;

local qSystems           = LoadCustomLibrary(&apos;qSystems&apos;)

qSystems:Import(getfenv(0));

local lib = {}

-- This service helpers manage the 

local MakeUserActionSystem = Class &apos;UserActionSystem&apos; (function(UserActionSystem)
	local Actions = {}
	local CurrentAction

	local function AddAction(Action, Name)
		Name = Name or &quot;Unnammed&quot;
		Action.Name = Name
		Action.Data = Action.Data or {}
		-- Adds a new action to the service. Actions have OnStart, OnStop, Condition, and Step

		-- May have: OnButton1Click
		Actions[#Actions+1] = Actions
	end

	function UserActionSystem.Update(Mouse)
		for _, Action in ipairs(Actions) do
			if Action.Condition(Mouse) then

			end
		end
	end
end)</ProtectedString>
<bool name="Disabled">true</bool>
</Properties>
</Item>
<Item class="Script" referent="RBX86">
<Properties>
<string name="Name">ViriumSystems</string>
<ProtectedString name="Source">while not _G.NevermoreEngine do wait(0) end

local Players            = Game:GetService(&apos;Players&apos;)
local StarterPack        = Game:GetService(&apos;StarterPack&apos;)
local StarterGui         = Game:GetService(&apos;StarterGui&apos;)
local Lighting           = Game:GetService(&apos;Lighting&apos;)
local Debris             = Game:GetService(&apos;Debris&apos;)
local Teams              = Game:GetService(&apos;Teams&apos;)
local BadgeService       = Game:GetService(&apos;BadgeService&apos;)
local InsertService      = Game:GetService(&apos;InsertService&apos;)
local MarketplaceService = game:GetService(&quot;MarketplaceService&quot;)
local Terrain            = Workspace.Terrain

local NevermoreEngine    = _G.NevermoreEngine
local LoadCustomLibrary  = NevermoreEngine.LoadLibrary;

local qSystems           = LoadCustomLibrary(&apos;qSystems&apos;)
local AnimationSystems   = LoadCustomLibrary(&apos;AnimationSystems&apos;)
local Table              = LoadCustomLibrary(&apos;Table&apos;)
local EasyConfiguration  = LoadCustomLibrary(&apos;EasyConfiguration&apos;)
local qCFrame            = LoadCustomLibrary(&apos;qCFrame&apos;)
local qMath              = LoadCustomLibrary(&apos;qMath&apos;)
local qString            = LoadCustomLibrary(&apos;qString&apos;)
local PlayerManager      = LoadCustomLibrary(&apos;PlayerManager&apos;)
local ChatManager        = PlayerManager.ChatManager

qSystems:Import(getfenv(0));

local lib = {}
local RandomRoundNames = {
	&quot;Night&quot;;
	&quot;Evening&quot;;
	&quot;Nightfall&quot;;
	&quot;Moon&quot;;
	&quot;Darkness&quot;;
	&quot;Dusk&quot;;
	&quot;Twilight&quot;;
	&quot;Sundown&quot;;
	&quot;Gloom&quot;;
	&quot;Gloaming&quot;;
	&quot;Eventide&quot;;
	&quot;Dimday&quot;;
	&quot;Dark&quot;;
	&quot;Nightly&quot;;
	&quot;Nocturnal&quot;;
	&quot;Darkness&quot;;
	&quot;Sunset&quot;;
}

local function OpenControlPanel(Part, Player, CanNotClose)
	-- Requests that the control panel be open...
	if Player and CheckCharacter(Player) and Player.Character.Humanoid.Health &gt; 0 then
		local UserSettings = Player:FindFirstChild(&quot;UserSettings&quot;)
		if UserSettings and UserSettings:FindFirstChild(&quot;RequestShowPanel&quot;) and UserSettings:FindFirstChild(&quot;ControlPanelShowPosition&quot;) and UserSettings.ControlPanelShowPosition:IsA(&quot;Vector3Value&quot;) and UserSettings.RequestShowPanel:IsA(&quot;BoolValue&quot;) then
			local SetTo = not UserSettings.RequestShowPanel.Value
			if SetTo or (SetTo == false and not CanNotClose) then
				UserSettings.RequestShowPanel.Value = SetTo
				if Part then
					wait(0)
					UserSettings.ControlPanelShowPosition.Value = Part.Position
				end
			end
		end
	end
end
lib.OpenControlPanel = OpenControlPanel
lib.openControlPanel = OpenControlPanel

local function FindFaceFromCoord(size, loc)
	local pa, pb = -size/2, size/2
	local dx = math.min(math.abs(loc.x-pa.x), math.abs(loc.x-pb.x))
	local dy = math.min(math.abs(loc.y-pa.y), math.abs(loc.y-pb.y))
	local dz = math.min(math.abs(loc.z-pa.z), math.abs(loc.z-pb.z))
	--
	if dx &lt; dy and dx &lt; dz then
		if math.abs(loc.x-pa.x) &lt; math.abs(loc.x-pb.x) then
			return Enum.NormalId.Left --&apos;Left&apos;
		else
			return Enum.NormalId.Right --&apos;Right&apos;
		end
	elseif dy &lt; dx and dy &lt; dz then
		if math.abs(loc.y-pa.y) &lt; math.abs(loc.y-pb.y) then
			return Enum.NormalId.Bottom --&apos;Bottom&apos;
		else
			return Enum.NormalId.Top --&apos;Top&apos;
		end
	elseif dz &lt; dx and dz &lt; dy then
		if math.abs(loc.z-pa.z) &lt; math.abs(loc.z-pb.z) then
			return Enum.NormalId.Front --&apos;Front&apos;
		else
			return Enum.NormalId.Back --&apos;Back&apos;
		end	
	end 
end


local function SetupOneWayGateModel(OneWayGatePart)
	local Configuration = {
		FlingBackVelocity = 200;
		DefaultReflectance = OneWayGatePart.Reflectance;
	}

	local SessionId = 0

	OneWayGatePart.Touched:connect(function(TouchedPart)
		local Character, Player = GetCharacter(TouchedPart)

		if Character and Player and CheckCharacter(Player) and not (not Player.Neutral and Player.TeamColor.Name == OneWayGatePart.BrickColor.Name) then
			local HitFace = FindFaceFromCoord(OneWayGatePart.Size, OneWayGatePart.CFrame:toObjectSpace(CFrame.new(Character.Torso.Position)))
			--print(&quot;[MenuSystemTester] - Player hit @ &quot; .. tostring(HitFace))
			if HitFace ~= Enum.NormalId.Back then
				local TargetPosition = (OneWayGatePart.CFrame * CFrame.new(0, 0, -5)).p
				Player.Character.Torso.CFrame = OneWayGatePart.CFrame * CFrame.new(0, 0, -5)
				if (TargetPosition - Player.Character.Torso.Position).magnitude &gt;= 1 then
					Player.Character.Humanoid.Health = 0
				end
				Player.Character.Torso.Velocity = OneWayGatePart.CFrame.lookVector * Configuration.FlingBackVelocity
				Spawn(function()
					PlayerManager.PlayerManager:Notify(Player, &quot;Trying to get into other people&apos;s spawns is rude and against the game&apos;s rules. Please stop.&quot;, &quot;Warning&quot;)
				end)
				SessionId = SessionId + 1
				local LocalSessionId = SessionId

				Spawn(function()
					OneWayGatePart.Reflectance = 1
					while OneWayGatePart.Reflectance &gt; Configuration.DefaultReflectance and SessionId == LocalSessionId do
						OneWayGatePart.Reflectance = OneWayGatePart.Reflectance - 0.05
						wait(0.03)
					end
					OneWayGatePart.Reflectance = Configuration.DefaultReflectance
				end)
			end
		end
	end)
end
lib.SetupOneWayGateModel = SetupOneWayGateModel
lib.setupOneWayGateModel = SetupOneWayGateModel



local function SetupStatusLights(DefaultValue)
	local StatusValue = Make &apos;BoolValue&apos; {
		Name = &quot;StatusLightValue&quot;;
		Value = DefaultValue ~= nil and DefaultValue or false;
	}

	local StatusLightSystem = {}
	local StatusLights = {}

	local function SwitchLight(Item, Value)
		local Light = Item:FindFirstChild(&quot;SwitchLight&quot;) or Make &apos;PointLight&apos; {
			Brightness = 10;
			Range = 2;
			Name = &quot;SwitchLight&quot;;
			Color = Item.BrickColor.Color;
			Archivable = false;
			Parent = Item;
		};
		Light.Enabled = Value;
	end

	local function AddStatusLight(GreenLight, RedLight)
		local Item = {
			GreenLight = GreenLight;
			RedLight = RedLight;
		}

		if not StatusValue.Value then
			Item.RedLight.BrickColor = BrickColor.new(&quot;Mid grey&quot;)
			Item.GreenLight.BrickColor = BrickColor.new(&quot;Bright green&quot;)
			SwitchLight(Item.RedLight, false)
			SwitchLight(Item.GreenLight, true)
		else
			Item.RedLight.BrickColor = BrickColor.new(&quot;Bright red&quot;)
			Item.GreenLight.BrickColor = BrickColor.new(&quot;Mid grey&quot;)
			SwitchLight(Item.RedLight, true)
			SwitchLight(Item.GreenLight, false)
		end
		StatusLights[#StatusLights+1] = Item
	end
	StatusLightSystem.AddStatusLight = AddStatusLight
	StatusLightSystem.addStatusLight = AddStatusLight

	local function UpdateStatusLights()
		if not StatusValue.Value then
			for _, Item in pairs(StatusLights) do
				Item.RedLight.BrickColor = BrickColor.new(&quot;Bright red&quot;)
				Item.GreenLight.BrickColor = BrickColor.new(&quot;Mid grey&quot;)
				SwitchLight(Item.RedLight, true)
				SwitchLight(Item.GreenLight, false)
			end
		else
			for _, Item in pairs(StatusLights) do
				Item.RedLight.BrickColor = BrickColor.new(&quot;Mid grey&quot;)
				Item.GreenLight.BrickColor = BrickColor.new(&quot;Bright green&quot;)
				SwitchLight(Item.RedLight, false)
				SwitchLight(Item.GreenLight, true)
			end
		end
	end

	StatusLightSystem.UpdateStatusLights = UpdateStatusLights
	StatusLightSystem.updateStatusLights = UpdateStatusLights

	local function SetStatus(NewValue)
		StatusValue.Value = NewValue
		UpdateStatusLights()
	end
	StatusLightSystem.SetStatus = SetStatus
	StatusLightSystem.setStatus = SetStatus


	return StatusLightSystem
end
lib.SetupStatusLights = SetupStatusLights
lib.setupStatusLights = SetupStatusLights


local function SetupSwitches(DefaultValue, AnimateTime)
	local SwitchSystem = {}
	local SwitchGate = AnimationSystems.MakeGate(AnimateTime or 2);
	local SwitchStatusValue = SwitchGate.StatusValue
	SwitchStatusValue.Value = DefaultValue or false;
	local PowerSwitches = {}

	local function AddSwitch(SwitchButton, SwitchCenter)
		-- SwitchButton is the part that moves, SwitchCenter is what it revovles around...
		local Origin = SwitchCenter.CFrame
		local OnPosition = Origin * CFrame.Angles(math.rad(60), 0, 0)
		local OffPosition = Origin * CFrame.Angles(math.rad(-60), 0, 0)
		qCFrame.TransformModel(SwitchButton:GetChildren(), Origin, OnPosition)
		local Door = SwitchGate:AddNewDoor(SwitchButton, OnPosition, OffPosition)

		--PowerSwitches[#PowerSwitches+1] = Door
	end
	SwitchSystem.AddSwitch = AddSwitch
	SwitchSystem.addSwitch = AddSwitch

	local function Reset()
		-- Reset&apos;s the system into it&apos;s actual position
		SwitchSystem.SetStatus(not SwitchStatusValue.Value)
		SwitchSystem.SetStatus(SwitchStatusValue.Value)
	end
	SwitchSystem.Reset = Reset
	SwitchSystem.reset = Reset

	local function SetStatus(NewValue)
		SwitchStatusValue.Value = NewValue
	end
	SwitchSystem.SetStatus = SetStatus
	SwitchSystem.SetStatus = SetStatus

	return SwitchSystem	
end
lib.SetupSwitches = SetupSwitches
lib.setupSwitches = SetupSwitches

local function SetupStandardGate(GateModel)
	local Gate = {}
	local NewGate = AnimationSystems.MakeGate(1);
	local StatusValue = NewGate.StatusValue
	local MainStatusValue = Make &apos;BoolValue&apos; {
		Name = &quot;GateStatus&quot;;
		Parent = GateModel;
		Value = false;
	}

	local StatusLightSystem = SetupStatusLights(MainStatusValue.Value)
	local SwitchSystem = SetupSwitches(MainStatusValue.Value)

	local function Update(NewValue)
		StatusValue.Value = NewValue
		MainStatusValue.Value = NewValue
		SwitchSystem.SetStatus(NewValue)
		StatusLightSystem.SetStatus(NewValue)
	end
	Gate.Update = Update
	Gate.update = Update

	local function SetStatus(NewValue)
		MainStatusValue.Value = NewValue
	end
	Gate.SetStatus = SetStatus
	Gate.setStatus = SetStatus

	MainStatusValue.Changed:connect(function(NewValue)
		Update(MainStatusValue.Value)
	end)

	for _, Item in pairs(GateModel:GetChildren()) do
		if Item:IsA(&quot;BasePart&quot;) then
			if Item.Name == &quot;Left&quot; then
				NewGate:AddNewDoor(Item, Item.CFrame, Item.CFrame * CFrame.new(-Item.Size.X+1, 0, 0))
			elseif Item.Name == &quot;Right&quot; then
				NewGate:AddNewDoor(Item, Item.CFrame, Item.CFrame * CFrame.new(-Item.Size.X+1, 0, 0))
			end
		elseif Item:IsA(&quot;Model&quot;) then
			local GreenLight = Item:FindFirstChild(&quot;GreenLight&quot;)
			local RedLight = Item:FindFirstChild(&quot;RedLight&quot;)
			local SwitchButton = Item:FindFirstChild(&quot;SwitchButton&quot;)

			if GreenLight and RedLight then
				StatusLightSystem.AddStatusLight(GreenLight, RedLight)
			elseif SwitchButton then
				local SwitchCenter = SwitchButton:FindFirstChild(&quot;SwitchCenter&quot;)
				if SwitchCenter and SwitchCenter:IsA(&quot;BasePart&quot;) then
					SwitchSystem.AddSwitch(SwitchButton, SwitchCenter)
				end
			end
		end

		if Item:FindFirstChild(&quot;ClickDetector&quot;) and Item:IsA(&quot;BasePart&quot;) and Item.ClickDetector:IsA(&quot;ClickDetector&quot;) then
			Item.ClickDetector.MouseClick:connect(function(Player)
				print(&quot;[ViriumSystems] - Click trigger gate... &quot;..GateModel.Name)
				Update(not MainStatusValue.Value)
			end)
		end
	end

	SwitchSystem.Reset()
	--print(&quot;[AnimationSystemTester] - Setup gate &quot;..GateModel.Name)
	return Gate
end
lib.SetupStandardGate = SetupStandardGate
lib.setupStandardGate = SetupStandardGate



local function SetupDoor(Item)
	local Door = {}
	local NewGate = AnimationSystems.MakeGate(0.5);
	NewGate.StatusValue.Parent = Item

	local DoorDegreesOpen = Make &apos;NumberValue&apos; {
		Name = &quot;DegreesOpen&quot;;
		Parent = Item;
		Value = 80;
	};
	
	local DoorModel = WaitForChild(Item, &quot;Door&quot;)
	local DoorMain = WaitForChild(DoorModel, &quot;Main&quot;)
	local Origin = DoorMain.CFrame * CFrame.new(-DoorMain.Size.X/2, 0, 0)
	local Door = NewGate:AddNewDoor(DoorModel, DoorMain.CFrame, Origin * CFrame.Angles(0, math.rad(-DoorDegreesOpen.Value), 0) * CFrame.new(DoorMain.Size.X/2, 0, 0))

	DoorDegreesOpen.Changed:connect(function()
		Door:SetEndCFrame(Origin * CFrame.Angles(0, math.rad(-DoorDegreesOpen.Value), 0) * CFrame.new(DoorMain.Size.X/2, 0, 0))
	end)

	local function SetStatus(Value)
		NewGate.StatusValue.Value = Value
	end
	Door.SetStatus = SetStatus
	Door.setStatus = SetStatus

	return Door
end
lib.SetupDoor = SetupDoor
lib.setupDoor = SetupDoor

local function SetupConsoleSystem(Model)
	--print(&quot;[AnimationSystemTester] - Setup Console  @ &quot; .. Model:GetFullName())
	CallOnChildren(Model, function(Part)
		--print(&quot;[AnimationSystemTester] - Setup Console Part @ &quot; .. Part:GetFullName())
		if Part and Part:IsA(&quot;BasePart&quot;)then
			Part.Touched:connect(function(Item)
				local Character, Player = getCharacter(Item)
				OpenControlPanel(Part, Player, true)
			end)
		elseif Part and Part:IsA(&quot;ClickDetector&quot;) and Part.Parent and Part.Parent:IsA(&quot;BasePart&quot;) then
			local BasePart = Part.Parent
			Part.MouseClick:connect(function(Player)
				OpenControlPanel(BasePart, Player)
			end)
		end	
	end)
end
lib.SetupConsoleSystem = SetupConsoleSystem
lib.setupConsoleSystem = SetupConsoleSystem

local function SetupPowerCore(PowerCoreModel, CanSwitchFilter)
	local Core = {}
	Core.Name = PowerCoreModel.Name

	local CoreConfiguration = EasyConfiguration.MakeEasyConfiguration(EasyConfiguration.AddSubDataLayer(&quot;qPowerCoreConfiguration&quot;, PowerCoreModel))
	CoreConfiguration.AddValue(&quot;IntValue&quot;, {
		Name = &quot;CoreStatus&quot;;
		Value = 1; -- 1 = on, 0 is off for now. 
	})
	CoreConfiguration.AddValue(&quot;IntValue&quot;, {
		Name = &quot;MaxPowerLevel&quot;;
		Value = 1200;
	})
	CoreConfiguration.AddValue(&quot;NumberValue&quot;, {
		Name = &quot;CorePowerLevel&quot;;
		Value = CoreConfiguration.MaxPowerLevel; 
	})
	CoreConfiguration.AddValue(&quot;NumberValue&quot;, {
		Name = &quot;MaxIncreasePerSecond&quot;;
		Value = 1; 
	})
	CoreConfiguration.AddValue(&quot;BoolValue&quot;, {
		Name = &quot;HasPower&quot;;
		Value = CoreConfiguration.CorePowerLevel == 0;
	})
	CoreConfiguration.CoreStatus = 1
	CoreConfiguration.CorePowerLevel = CoreConfiguration.MaxPowerLevel
	CoreConfiguration.HasPower = CoreConfiguration.CorePowerLevel &gt;= 0;

	local CoreStatus = CoreConfiguration.GetValue(&quot;CoreStatus&quot;)
	local StatusLightSystem = SetupStatusLights(CoreStatus == 1)
	local SwitchSystem = SetupSwitches(CoreStatus == 1)

	Core.CoreConfiguration = CoreConfiguration
	local function Step()
		local Increase
		if CoreConfiguration.CoreStatus == 1 then
			Increase = math.abs(CoreConfiguration.MaxIncreasePerSecond)
		else
			Increase = -math.abs(CoreConfiguration.MaxIncreasePerSecond)
		end

		local Value, DidClamp = qMath.ClampNumber(CoreConfiguration.CorePowerLevel + Increase, 0, CoreConfiguration.MaxPowerLevel)
		CoreConfiguration.CorePowerLevel = Value
		if Value &lt;= 0 then
			--print(&quot;[AnimationSystemTester] - Clamp false&quot;)
			CoreConfiguration.HasPower = false
		else
			CoreConfiguration.HasPower = true
		end
		return not DidClamp
	end
	Core.Step = Step
	Core.step = Step

	local Updating = false

	local function StartUpdate()
		if not Updating then	
			Updating = true
			local Valid = Step()
			while Valid do
				wait(1)
				Valid = Step()
			end
			print(&quot;[AnimationSystemTester] - Update finish&quot;)
			Updating = false
		else
			print(&quot;[AnimationSystemTester] - Already updating power core entity&quot;)
		end
	end
	Core.StartUpdate = StartUpdate
	Core.startUpdate = StartUpdate

	local function Reset()
		CoreConfiguration.CoreStatus = 1
		CoreConfiguration.CorePowerLevel = CoreConfiguration.MaxPowerLevel
		Step()
	end
	Core.Reset = Reset
	Core.reset = Reset
	
	CoreStatus.Changed:connect(function()
		if CoreConfiguration.CoreStatus == 1 then
			SwitchSystem.SetStatus(true)
			StatusLightSystem.SetStatus(true)
			StartUpdate()
			--PowerGoal:SetTarget(CoreConfiguration.MaxPowerLevel)
		else
			SwitchSystem.SetStatus(false)
			StatusLightSystem.SetStatus(false)
			StartUpdate()
			--PowerGoal:SetTarget(0)
		end
	end)

	for _, Item in pairs(PowerCoreModel:GetChildren()) do
		if Item:IsA(&quot;Model&quot;) then
			local GreenLight = Item:FindFirstChild(&quot;GreenLight&quot;)
			local RedLight = Item:FindFirstChild(&quot;RedLight&quot;)
			local SwitchButton = Item:FindFirstChild(&quot;SwitchButton&quot;)

			if GreenLight and RedLight then
				StatusLightSystem.AddStatusLight(GreenLight, RedLight)
			elseif SwitchButton then
				local SwitchCenter = SwitchButton:FindFirstChild(&quot;SwitchCenter&quot;)
				if SwitchCenter and SwitchCenter:IsA(&quot;BasePart&quot;) then
					SwitchSystem.AddSwitch(SwitchButton, SwitchCenter)
				end
			end
		elseif Item:FindFirstChild(&quot;ClickDetector&quot;) and Item:IsA(&quot;BasePart&quot;) and Item.ClickDetector:IsA(&quot;ClickDetector&quot;) then
			Item.ClickDetector.MouseClick:connect(function(Player)
				local Authorized = CanSwitchFilter == nil
				local NotAuthoredMessage = &quot;You are not authorized to change this core&quot;;
				local NotAuthorizedTitle = &quot;Warning&quot;
				if CanSwitchFilter then
					local IsAuthorized, Message, Title = CanSwitchFilter(Player, Core)
					Authorized = not IsAuthorized
					if Message then
						NotAuthoredMessage = Message
					end
					if Title then
						NotAuthorizedTitle = Title
					end
				end
				if (Authorized) then
					--print(&quot;[AnimationSystemTester] - Click trigger power core... &quot;..PowerCoreModel.Name)
					if CoreConfiguration.CoreStatus == 1 then
						CoreConfiguration.CoreStatus = 0
						StatusLightSystem.SetStatus(false)
					else
						CoreConfiguration.CoreStatus = 1
						StatusLightSystem.SetStatus(true)
					end
				else
					PlayerManager.PlayerManager:Notify(Player, NotAuthoredMessage, NotAuthorizedTitle)
					--print(&quot;[AnimationSystemTester] - Can not switch switch, filter returned true &apos;&quot; .. NotAuthoredMessage .. &quot;&apos;&quot;)
				end
			end)
		end
	end
	SwitchSystem.Reset()

	--print(&quot;[AnimationSystemTester] - Setup Power Core &quot;..PowerCoreModel.Name)
	return Core
end
lib.SetupPowerCore = SetupPowerCore
lib.setupPowerCore = SetupPowerCore

local function GenerateRandomRoundId()
	local Num = math.floor((tick() % 100000000))
	local NewId = &quot;&quot;;
	math.randomseed(tick());
	for i=1, 3 do
		NewId = NewId .. RandomRoundNames[math.random(1, #RandomRoundNames)] .. &quot;-&quot;
	end
	NewId = NewId..Num
	return NewId
end
lib.GenerateRandomRoundId = GenerateRandomRoundId
lib.generateRandomRoundId = GenerateRandomRoundId


local function CountTeamMembers(TeamColorName)
	local Count = 0
	for _, Player in pairs(Players:GetPlayers()) do
		if not Player.Neutral then
			if Player.TeamColor.Name == TeamColorName then
				Count = Count + 1
			end
		end
	end
	return Count
end
lib.CountTeamMembers = CountTeamMembers
lib.countTeamMembers = CountTeamMembers


local function SetupZoneSystem(ZoneData) 
	-- Setups up an authorization zone system to make official games...
	--[[
		ZoneData = {
			Name = &quot;&quot;
			ZonePart = ZonePart;
			ZoneFilter = function(Character, Player)

			end;
			RequiredUsers = 5;
		}
		
	--]]
	local ZoneSystem = {}
	ZoneSystem.ZoneData = ZoneData
	local OfficialStatusMet = CreateSignal();
	ZoneSystem.OfficialStatusMet = OfficialStatusMet

	local function CheckIfConditionsMet()
		local Authorized = true
		for _, Zone in pairs(ZoneData) do
			if not Zone.CheckZone() then
				Authorized = false
			end
		end
		if Authorized then
			ZoneSystem.OfficialStatusMet:fire()
			return true
		end
		return false;
	end
	ZoneSystem.CheckIfConditionsMet = CheckIfConditionsMet
	ZoneSystem.checkIfConditionsMet = CheckIfConditionsMet

	for _, Zone in pairs(ZoneData) do
		Zone.Name = Zone.Name or &quot;[ Unnamed ]&quot;;
		Zone.RequiredUsers = Zone.RequiredUsers or 5;
		--Zone.ActiveCharacters = {}
		Zone.MoreUsersRequired = Zone.RequiredUsers
		Zone.ZoneFilter = Zone.ZoneFilter or function() return false end;
		if not Zone.ZonePart then
			error(&quot;[ViriumSystems][ZoneSystem] - Zonepart is required for Zone &apos;&quot;..Zone.Name..&quot;&apos;&quot;)
		end

		local BillboardGui = Make &apos;BillboardGui&apos; {
			Active      = false;
			Adornee     = Zone.ZonePart;
			AlwaysOnTop = false;
			Enabled     = true;
			Name        = &apos;BillboardGui&apos;;
			StudsOffset = Vector3.new(0, 10, 0);
			Parent      = Zone.ZonePart;
			Size        = UDim2.new(10, 0, 10, 0);
		}

		local Counter = Make &apos;TextLabel&apos; {
			BackgroundTransparency = 1;
			Font                   = &quot;ArialBold&quot;;
			FontSize               = &quot;Size36&quot;;
			Name                   = &quot;Counter&quot;;
			Parent                 = BillboardGui;
			Size                   = UDim2.new(1, 0, 1, 0);
			Text                   = Zone.MoreUsersRequired..&quot;+&quot;;
			TextColor3             = Color3.new(1, 1, 1);
			TextScaled             = true;
			TextStrokeColor3       = Color3.new(0.5, 0.5, 0.5);
			TextStrokeTransparency = 0.8;
			TextTransparency       = 0;
			Visible                = true;
		}

		local PreviousCharacters = {}
		local function CheckZone()
			--print(&quot;Checking zone&quot;)
			local Count = 0
			--[[for Character, Info in pairs(Zone.ActiveCharacters) do
				if Character and Character.Parent and Info.Player and Info.Player.Character == Character and Character:FindFirstChild(&quot;Torso&quot;) and Character.Torso:IsA(&quot;BasePart&quot;) then 
					if qCFrame.PointInsidePart(Zone.ZonePart, Character.Torso.Position) then
						Count = Count + 1
						Info.LastTimeIn = tick()
					elseif Info.LastTimeIn + 1 &gt;= tick()  then -- They&apos;ve been out long enough, remove them from a check...
						Zone.ActiveCharacters[Character] = nil
					end
				else
					Zone.ActiveCharacters[Character] = nil
				end
			end
			
			--]]
			local ToNotify = {}
			local ToNotifyLeave = {}
			for _, Player in pairs(Players:GetPlayers()) do
				local Character = Player.Character
				if Character and Character.Parent and Character:FindFirstChild(&quot;Torso&quot;) and Character.Torso:IsA(&quot;BasePart&quot;) and not Zone.ZoneFilter(Character, Player) then 
					if qCFrame.PointInsidePart(Zone.ZonePart, Character.Torso.Position) then
						print(&quot;Player &quot;..Player.Name..&quot; is inside of the zone.&quot;)
						if not PreviousCharacters[Character] then
							print(&quot;Player &quot;..Player.Name..&quot; has entered the zone&quot;)
							ToNotify[#ToNotify+1] = Player
							PreviousCharacters[Character] = true
						end
						Count = Count + 1
					elseif PreviousCharacters[Character] then
						print(&quot;Player &quot;..Player.Name..&quot; has left the zone&quot;)
						ToNotifyLeave[#ToNotifyLeave+1] = Player
						PreviousCharacters[Character] = nil
					end
				end
			end

			Zone.MoreUsersRequired = math.max(0, Zone.RequiredUsers - Count)
			Counter.Text  = Zone.MoreUsersRequired..&quot;+&quot;;

			for _, Player in pairs(ToNotify) do
				PlayerManager.PlayerManager:Notify(Player, &quot;You&apos;ve entered a server activation system for &quot;..Zone.Name..&quot;, &quot;..(Zone.RequiredUsers - Count)..&quot; user&quot;..((Zone.RequiredUsers - Count) == 1 and &quot;&quot; or &quot;s&quot;)..&quot; are required in order to activate your team&apos;s side. &quot;, 
					&quot;Raid System&quot;)
			end
			for _, Player in pairs(ToNotifyLeave) do
				PlayerManager.PlayerManager:Notify(Player, &quot;You&apos;ve left a server activation system for &quot;..Zone.Name..&quot;, &quot;..(Zone.RequiredUsers - Count)..&quot; user&quot;..((Zone.RequiredUsers - Count) == 1 and &quot;&quot; or &quot;s&quot;)..&quot; are required in order to activate your team&apos;s side. &quot;, 
					&quot;Raid System&quot;)
			end
			if Zone.OnCheck then
				Zone.OnCheck(Count)
			end

			if Count &gt;= Zone.RequiredUsers then
				return true, Count
			else
				return false, Count
			end
		end
		Zone.CheckZone = CheckZone

		Zone.ZonePart.Touched:connect(function()
			--print(&quot;Touch start&quot;)
			--CheckZone()
			CheckIfConditionsMet()
		end)

		Zone.ZonePart.TouchEnded:connect(function()
			--print(&quot;Touch end&quot;)
			--CheckZone()
			CheckIfConditionsMet()
		end)
		--[[
		Zone.ZonePart.Touched:connect(function(Part)
			local Character, Player = GetCharacter(Part)
			if Character and Player and not Zone.ZoneFilter(Character, Player) and not Zone.ActiveCharacters[Character] then
				Zone.ActiveCharacters[Character] = {
					Player = Player;
					LastTimeIn = tick();
				}
				local ZoneValid, Count = CheckZone()
				PlayerManager.PlayerManager:Notify(Player, &quot;You&apos;ve entered a server activation system, &quot;..(Zone.RequiredUsers - Count)..&quot; user&quot;..((Zone.RequiredUsers - Count) == 1 and &quot;&quot; or &quot;s&quot;)..&quot; are required in order to activate your team&apos;s side. &quot;, 
					&quot;Raid System&quot;)
				CheckIfConditionsMet()
			end
		end)--]]
	end

	Spawn(function()
		while true do
			--[[for _, Zone in pairs(ZoneData) do
				Zone.CheckZone()
				wait(1)
			end--]]
			CheckIfConditionsMet()
			wait(5)
		end
	end)

	return ZoneSystem;
end
lib.SetupZoneSystem = SetupZoneSystem

local MakeViriumGameSystem = Class &apos;ViriumGameSystem&apos; (function(GameSystem, GameGates, GameDoors, OneWayGates, SetupCores, ZoneData)
	-- Runs the main game...

	local GameConfiguration = EasyConfiguration.MakeEasyConfiguration(EasyConfiguration.AddSubDataLayer(&quot;ViriumGameSettings&quot;, PlayerManager.ServerContainer))
	GameConfiguration.AddValue(&quot;IntValue&quot;, {
		Name = &quot;StandardRoundTime&quot;;
		Value = 7200;
	})
	GameConfiguration.AddValue(&quot;IntValue&quot;, {
		Name = &quot;RoundTimeLeft&quot;;
		Value = GameConfiguration.StandardRoundTime;
	})
	GameConfiguration.AddValue(&quot;BoolValue&quot;, {
		Name = &quot;RaidOfficial&quot;;
		Value = false;
	})
	GameConfiguration.AddValue(&quot;StringValue&quot;, {
		Name = &quot;RoundId&quot;;
		Value = &quot;[ERROR]&quot;;
	})
	GameConfiguration.AddValue(&quot;IntValue&quot;, {
		Name = &quot;RoundCount&quot;;
		Value = 1;
	})

	local ZoneSystem = SetupZoneSystem(ZoneData) 

	local Gates = {}
	local Doors = {}

	for _, GateModel in pairs(GameGates) do
		Gates[#Gates+1] = SetupStandardGate(GateModel)
	end

	for _, DoorModel in pairs(GameDoors) do
		Doors[#Doors+1] = SetupDoor(DoorModel)
	end

	for _, OneWayGate in pairs(OneWayGates) do
		SetupOneWayGateModel(OneWayGate)
	end

	local function ResetGame()
		print(&quot;Resetting game...&quot;)
		GameConfiguration.RoundCount = GameConfiguration.RoundCount + 1
		GameConfiguration.RoundTimeLeft = GameConfiguration.StandardRoundTime
		ChatManager:SystemNotification(&quot;Restarting game, please wait...&quot;)
		for _, Door in pairs(Gates) do
			Door.SetStatus(true)
		end
		for _, Gate in pairs(Gates) do
			Gate.SetStatus(true)
		end
		for _, Core in pairs(SetupCores) do
			Core.Reset()
		end
		for _, Player in pairs(Players:GetPlayers()) do
			Player:LoadCharacter()
		end
	end
	GameSystem.ResetGame = ResetGame
	GameSystem.resetGame = ResetGame

	local function CheckIfCoresStillHavePower()
		for _, Core in pairs(SetupCores) do
			if Core.CoreConfiguration.HasPower then
				return false
			end
		end
		return true
	end
	GameSystem.CheckIfCoresStillHavePower = CheckIfCoresStillHavePower
	GameSystem.checkIfCoresStillHavePower = CheckIfCoresStillHavePower

	local OfficialGameNext = false

	local function StartRound(IsOfficial)
		if IsOfficial then
			OfficialGameNext = false
		end
		GameConfiguration.RaidOfficial = IsOfficial
		local LocalRoundId = GenerateRandomRoundId()
		local LocalRoundCount = GameConfiguration.RoundCount
		GameConfiguration.RoundId = LocalRoundId
		local OfficialStatus = IsOfficial and &quot;Official&quot; or &quot;Unofficial&quot;

		ChatManager:SystemNotification(OfficialStatus..&quot; game round &quot; .. qString.GetRomanNumeral(LocalRoundCount) .. &quot; \&quot;&quot; .. LocalRoundId .. &quot;\&quot; has begun.&quot;)

		while GameConfiguration.RoundCount == LocalRoundCount do
			GameConfiguration.RoundTimeLeft = GameConfiguration.RoundTimeLeft - 1
			if CheckIfCoresStillHavePower() then
				ChatManager:SystemNotification(&quot;Raiders have won the &quot;..OfficialStatus:lower()..&quot; game (Good game :D)  ID: &quot;..LocalRoundCount..&quot;&quot;)
				ResetGame()
			elseif GameConfiguration.RoundTimeLeft &lt;= 0 then
				ChatManager:SystemNotification(&quot;The game time is up, the round &quot;..qString.GetRomanNumeral(LocalRoundCount)..&quot; game is over.&quot;)
				ResetGame()
			else
				wait(1)
			end
		end
	end

	ZoneSystem.OfficialStatusMet:connect(function()
		if not GameConfiguration.RaidOfficial then
			ResetGame()
			OfficialGameNext = true
			ChatManager:SystemNotification(&quot;Official game round will start soon...&quot;)
		end
	end)
	Spawn(function()
		while true do
			StartRound(OfficialGameNext)
		end
	end)
end)
lib.MakeViriumGameSystem = MakeViriumGameSystem
lib.makeViriumGameSystem = MakeViriumGameSystem



local function SetupProductNotificationSystem(ProductId, CheckTime, Title, GSubDescription)
	Title = Title or &quot;Game Notification&quot;
	CheckTime = CheckTime or 30

	Spawn(function()
		local ProductInformation = MarketplaceService:GetProductInfo(ProductId)
		local LastDescription = &quot;&quot;--ProductInformation.Description
		local ServerNotification = PlayerManager.GetServerContainer():WaitForChild(&quot;ServerNotification&quot;)

		while game do
			ProductInformation = MarketplaceService:GetProductInfo(ProductId)
			local Description = ProductInformation.Description
			if Description ~= LastDescription and Description ~= &quot;&quot; and not qString.CompareCutFirst(Description, &quot;nothing&quot;) then
				Description = GSubDescription(Description)
				ServerNotification.Value = Description
				ChatManager:SystemNotification(&quot;[NOTIFICATION] - &quot;..Description)
				for _, Player in pairs(Players:GetPlayers()) do
					Spawn(function()
						PlayerManager.PlayerManager:Notify(Player, Description, Title)
					end)
				end
				LastDescription = Description
			end
			wait(CheckTime)
		end
	end)
end
lib.SetupProductNotificationSystem = SetupProductNotificationSystem
lib.setupProductNotificationSystem = SetupProductNotificationSystem

NevermoreEngine.RegisterLibrary(&apos;ViriumSystems&apos;, lib)</ProtectedString>
<bool name="Disabled">true</bool>
</Properties>
</Item>
</Item>
</Item>
</Item>
</roblox>
