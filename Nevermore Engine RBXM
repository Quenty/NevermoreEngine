'''xml
<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Backpack" referent="RBX0">
		<Properties>
			<string name="Name">Nevermore</string>
		</Properties>
		<Item class="Backpack" referent="RBX1">
			<Properties>
				<string name="Name">Modules</string>
			</Properties>
			<Item class="Backpack" referent="RBX2">
				<Properties>
					<string name="Name">Character</string>
				</Properties>
				<Item class="ModuleScript" referent="RBX3">
					<Properties>
						<string name="Name">Character</string>
						<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local RawCharacter      = LoadCustomLibrary(&quot;RawCharacter&quot;)
local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)


qSystems:Import(getfenv(0));

local safeLib = {}

--- This library handles making sure it is safe to use RawCharacter functions. 
-- @author Quenty
-- Last modified January 14th, 2013

--[[-- Change Log --

January 19th, 2014
- Updated to include output parser

--]]

for functionName, libraryItem in pairs(RawCharacter) do
&#9;if type(functionName) ~= &quot;string&quot; then
&#9;&#9;error(&quot;[Character] - functionName &apos;&quot;..tostring(functionName)..&quot;&apos; a &apos;&quot;..Type.GetType(functionName)..&quot;&apos; value should be a string&quot;)
&#9;end
&#9;if type(libraryItem) == &quot;function&quot; and functionName:lower() ~= &quot;import&quot; then
&#9;&#9;safeLib[functionName] = function(character, ...) 
&#9;&#9;&#9;if CheckCharacter(character) then
&#9;&#9;&#9;&#9;libraryItem(character, ...)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;[Character] - The character did not have a correct head, torso, or humanoid, so &apos;&quot;..functionName..&quot;&apos; could not execute&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

return safeLib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4">
					<Properties>
						<string name="Name">RawCharacter</string>
						<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local Type              = LoadCustomLibrary(&quot;Type&quot;)
local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)

qSystems:Import(getfenv(0))

-- RawCharacter.lua
-- This script handles character interaction, presuming that the character is &quot;validated&quot;
-- @author Quenty
-- Last modified January 20th, 2014

--[[--Change Log--

January 20th, 2014
- Added change log
- Added heal
- Added maxhealth
- Added remove hats method

--]]
local lib               = {}
--local safeLib           = {}
--local playerLib         = {}
local faceIndex         = {}
-- An index of faces...

faceIndex.worriedFace   = &quot;http://www.roblox.com/asset/?id=83906109&quot;;
faceIndex.scaredFace    = &quot;http://www.roblox.com/asset/?id=22823614&quot;;
faceIndex.mommyFace     = &quot;http://www.roblox.com/asset/?id=24669458&quot;;

local faceAnimations = {}
-- An array of tables of different animations for faces (sequences);

faceAnimations.mommy = {
&#9;faceIndex.worriedFace;
&#9;faceIndex.scaredFace;
&#9;faceIndex.mommyFace;
}

lib.faceIndex = faceIndex
lib.faceAnimation = faceAnimations

--[[
&#9;These presume the character is validated for the humanoid, torso, and head.
--]]

local function Kill(character)
&#9;-- Kills the character

&#9;character.Humanoid.Health = 0;
end
lib.kill = Kill;
lib.Kill = Kill;

local function Heal(character)
&#9;-- Heals the character

&#9;character.Humanoid.Health = character.Humanoid.MaxHealth;
end
lib.Heal = Heal
lib.heal = heal

local function MaxHealth(character, MaxHealth)
&#9;-- Sets the character&apos;s MaxHealth

&#9;character.Humanoid.MaxHealth = MaxHealth
&#9;character.Humanoid.Health = character.Humanoid.MaxHealth;
end
lib.MaxHealth = MaxHealth
lib.maxHealth = MaxHealth

local function Explode(character)
&#9;-- Explodes the character, and guarantees a kill

&#9;Instance.new(&quot;Explosion&quot;, character.Torso).Position = character.Torso.Position
&#9;Kill(character)
end
lib.explode = Explode;
lib.Explode = Explode;


local function GetFace(character)
&#9;-- Returns the character&apos;s face, if it exists. 

&#9;if (Character.Head:FindFirstChild(&quot;face&quot;) and Character.Head.face:IsA(&quot;decal&quot;)) then
&#9;&#9;return Character.Head.face;
&#9;end
&#9;return nil
end
lib.GetFace = GetFace;
lib.getFace = GetFace;
lib.get_face = GetFace;

local function GetOrCreateFace(character)
&#9;-- Returns the character&apos;s face, or craetes a new one

&#9;local face = getFace(character) or create &apos;decal&apos; {
&#9;&#9;Name = &quot;face&quot;;
&#9;&#9;Parent = character.Head;
&#9;&#9;Texture = &quot;http://www.roblox.com/asset/?id=20418518&quot;;
&#9;}
&#9;return face;
end
lib.getOrCreateFace = GetOrCreateFace;
lib.GetOrCreateFace = GetOrCreateFace;
lib.get_or_create_face = GetOrCreateFace;

local function SetFace(character, texture)
&#9;-- Set&apos;s the character&apos;s face to the texture specified

&#9;GetOrCreateFace(character).Texture = texture;
end
lib.setFace = SetFace
lib.SetFace = SetFace
lib.set_face = SetFace

local function PlayFaceAnimation(character, animation, timeToPlay)
&#9;-- Play&apos;s an &quot;animation&quot; of changing faces over the specified time.  Animation should be an array of textures (strings)

&#9;local Face = GetOrCreateFace(character)
&#9;local animationFrames = #animation + 1

&#9;for index, textureId in pairs(animation) do
&#9;&#9;delay(((index/animationFrames) * timeToPlay), function()
&#9;&#9;&#9;if Face then
&#9;&#9;&#9;&#9;Face.Texture = textureId
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end

end

local function Jump(character)
&#9;-- Forces the player to jump

&#9;character.Humanoid.Jump = true;
&#9;character.Humanoid.Jump = false;
end
lib.jump = Jump;
lib.Jump = Jump;

local function RemoveVelocity(character)
&#9;CallOnChildren(character, function(Object)
&#9;&#9;if Object:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;Object.Velocity = Vector3.new(0, 0, 0);
&#9;&#9;&#9;Object.RotVelocity = Vector3.new(0, 0, 0);
&#9;&#9;end
&#9;end)
end
lib.RemoveVelocity = RemoveVelocity
lib.removeVelocity = RemoveVelocity
lib.remove_velocity = RemoveVelocity

local function Unstick(character)
&#9;if character.Humanoid.Sit then
&#9;&#9;character.Humanoid.Sit = false
&#9;end
end
lib.Unstick = Unstick
lib.unstick = unstick;

local function Dehat(character)
&#9;--- Remove&apos;s a character&apos;s hats

&#9;CallOnChildren(character, function(Item)
&#9;&#9;if Item:IsA(&quot;Hat&quot;) then
&#9;&#9;&#9;Item:Destroy()
&#9;&#9;end
&#9;end)
end
lib.Dehat = Dehat
lib.dehat = Dehat

local function Damage(character, value)
&#9;-- Damages the player&apos;s character absolutely.  Won&apos;t go below 0. 

&#9;character.Humanoid.Health = math.max(0, character.Humanoid.Health - value)
end
lib.damage = Damage;
lib.Damage = Damage;


local function SetFace(character, faceId)
&#9;-- Set&apos;s the character&apos;s face to a new faceID

&#9;GetOrCreateFace(character).Texture = faceId;
end
lib.setFace = SetFace;
lib.SetFace = SetFace;
lib.set_face = SetFace;

local function GetFaceTexture(character)
&#9;-- Returns the current faces texture

&#9;return GetOrCreateFace(character).Texture
end
lib.getFaceTexture = GetFaceTexture;
lib.GetFaceTexture = GetFaceTexture;
lib.get_face_texture = GetFaceTexture;


local function GiveForceField(character)
&#9;-- Give&apos;s a character a force field

&#9;Instance.new(&quot;ForceField&quot;, character)
end
lib.GiveForceField = GiveForceField;
lib.giveForceField = GiveForceField;
lib.give_force_field = GiveForceField;

local function RemoveForceField(character)
&#9;-- Remove&apos;s a character&apos;s forcefield 

&#9;for _, Item in pairs(character:GetChildren()) do
&#9;&#9;if Item:IsA(&quot;ForceField&quot;) then
&#9;&#9;&#9;Item:Destroy()
&#9;&#9;end&#9;
&#9;end
end
lib.RemoveForceField = RemoveForceField
lib.removeForceField = RemoveForceField
lib.remove_force_field = RemoveForceField

local function Cape(Player, Color)
&#9;-- VerifyArg(Color, &quot;BrickColor&quot;, &quot;Color&quot;, true)

&#9;local function CreateCapeModel()
&#9;&#9;local Character = Player.Character;

&#9;&#9;Color = Color or Character.Torso.BrickColor

&#9;&#9;local CapeModel = Instance.new(&quot;Model&quot;, Character);
&#9;&#9;CapeModel.Name = &quot;QuentyCapeModel&quot;

&#9;&#9;local NeckPiece = Make(&quot;Part&quot;, {
&#9;&#9;&#9;Parent = CapeModel;
&#9;&#9;&#9;FormFactor = &quot;Custom&quot;;
&#9;&#9;&#9;Name = &quot;NeckPiece&quot;;
&#9;&#9;&#9;BrickColor = Color;
&#9;&#9;&#9;CanCollide = false;
&#9;&#9;&#9;TopSurface = &quot;Smooth&quot;;
&#9;&#9;&#9;BottomSurface = &quot;Smooth&quot;;
&#9;&#9;})
&#9;&#9;NeckPiece.Size = Vector3.new(2, 0.2, 1);

&#9;&#9;local NeckWeld = Make(&quot;Weld&quot;, {
&#9;&#9;&#9;Parent = NeckPiece;
&#9;&#9;&#9;Part0 = Character.Head;
&#9;&#9;&#9;Part1 = NeckPiece;
&#9;&#9;&#9;C0 = CFrame.new(0, -0.45, 0);
&#9;&#9;})

&#9;&#9;local Segment1 = Modify(NeckPiece:Clone(), {
&#9;&#9;&#9;Size = Vector3.new(3, 0.2, 1);
&#9;&#9;&#9;Parent = CapeModel;
&#9;&#9;&#9;Name = &quot;Segment1&quot;;
&#9;&#9;})

&#9;&#9;local Segment1Weld = Make(&quot;Weld&quot;, {
&#9;&#9;&#9;Parent = Segment1;
&#9;&#9;&#9;Part0 = NeckPiece;
&#9;&#9;&#9;Part1 = Segment1;
&#9;&#9;&#9;C0 = CFrame.new(0, 0, 0.45);
&#9;&#9;&#9;C1 = CFrame.new(0, 0, -0.45) * CFrame.Angles(math.rad(-80),0,0);
&#9;&#9;})

&#9;&#9;local Segment2 = Modify(Segment1:Clone(), {
&#9;&#9;&#9;Parent = CapeModel;
&#9;&#9;&#9;Name = &quot;Segment2&quot;;
&#9;&#9;})

&#9;&#9;local Segment2Weld = Make(&quot;Weld&quot;, {
&#9;&#9;&#9;Parent = Segment2;
&#9;&#9;&#9;Part0 = Segment1;
&#9;&#9;&#9;Part1 = Segment2;
&#9;&#9;&#9;C0 = CFrame.new(0, 0, 0.45);
&#9;&#9;&#9;C1 = CFrame.new(0, 0, -0.45) * CFrame.Angles(math.rad(-5),0,0);
&#9;&#9;})

&#9;&#9;local Segment3 = Modify(Segment1:Clone(), {
&#9;&#9;&#9;Parent = CapeModel;
&#9;&#9;&#9;Name = &quot;Segment3&quot;;
&#9;&#9;})

&#9;&#9;local Segment3Weld = Make(&quot;Weld&quot;, {
&#9;&#9;&#9;Parent = Segment3;
&#9;&#9;&#9;Part0 = Segment2;
&#9;&#9;&#9;Part1 = Segment3;
&#9;&#9;&#9;C0 = CFrame.new(0, 0, 0.45);
&#9;&#9;&#9;C1 = CFrame.new(0, 0, -0.45) * CFrame.Angles(math.rad(-2),0,0);
&#9;&#9;})

&#9;&#9;local Segment4 = Modify(Segment1:Clone(), {
&#9;&#9;&#9;Parent = CapeModel;
&#9;&#9;&#9;Name = &quot;Segment4&quot;;
&#9;&#9;})

&#9;&#9;local Segment4Weld = Make(&quot;Weld&quot;, {
&#9;&#9;&#9;Parent = Segment4;
&#9;&#9;&#9;Part0 = Segment3;
&#9;&#9;&#9;Part1 = Segment4;
&#9;&#9;&#9;C0 = CFrame.new(0, 0, 0.45);
&#9;&#9;&#9;C1 = CFrame.new(0, 0, -0.45);
&#9;&#9;})

&#9;&#9;return CapeModel;
&#9;end

&#9;local function Flex(Cape, Values)
&#9;&#9;local Continue = true
&#9;&#9;local CapeChildren = Cape:GetChildren();
&#9;&#9;for Index, Value in pairs(Values) do
&#9;&#9;&#9;if Index ~= 1 and CapeChildren[Index] and CapeChildren[Index]:FindFirstChild(&quot;Weld&quot;) and CapeChildren[Index].Weld:IsA(&quot;Weld&quot;) then
&#9;&#9;&#9;&#9;CapeChildren[Index].Weld.C1 = CFrame.new(0, 0, -0.45) * CFrame.Angles(math.rad(Values[Index-1]),0,0);
&#9;&#9;&#9;elseif Index ~= 1 then
&#9;&#9;&#9;&#9;print(&quot;CapeChildren[&quot;..Index..&quot;] did not qualify in cape...&quot;)
&#9;&#9;&#9;&#9;Continue = false
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return Continue
&#9;end

&#9;--local Character    = Player.Character
&#9;local Cape         = CreateCapeModel()
&#9;Cape.Parent        = Player.Character
&#9;local LastFirstRad = -60;
&#9;local Ta
&#9;local Ta1          = 5
&#9;local PlayerName   = Player.Name

&#9;local function StartUpdate()
&#9;&#9;local Index = 0
&#9;&#9;local Continue = true
&#9;&#9;while Continue do
&#9;&#9;&#9;if not CheckCharacter(Player) or not (Player.Character and Player.Character.Parent and Cape and Cape.Parent)  then
&#9;&#9;&#9;&#9;print(&quot;[RawCharacter] - Cape update break for &apos;&quot;..PlayerName..&quot;&apos;&quot;);
&#9;&#9;&#9;&#9;Continue = false;
&#9;&#9;&#9;end
&#9;&#9;&#9;local FirstRad = -60;
&#9;&#9;&#9;Ta = Ta1 * Player.Character.Torso.Velocity.magnitude/16 + 1 * (math.random() + 0.5);
&#9;&#9;&#9;if Ta &gt; 10 then
&#9;&#9;&#9;&#9;Ta = math.random(90, 100) / 10;
&#9;&#9;&#9;end
&#9;&#9;&#9;FirstRad = FirstRad + (Player.Character.Torso.Velocity.magnitude) + math.sin(Index)*3*Ta;
&#9;&#9;&#9;if FirstRad &gt; 65 then
&#9;&#9;&#9;&#9;FirstRad = 65;
&#9;&#9;&#9;elseif (Player.Character.Torso.Velocity.magnitude &lt; 5) then
&#9;&#9;&#9;&#9;FirstRad = -80;
&#9;&#9;&#9;end

&#9;&#9;&#9;--[[
&#9;&#9;&#9;if Player.Character.Humanoid:HasCustomStatus(&quot;Flying&quot;) then
&#9;&#9;&#9;&#9;FirstRad = -80;
&#9;&#9;&#9;&#9;ta = 15;
&#9;&#9;&#9;end--]]

&#9;&#9;&#9;FirstRad = (FirstRad + LastFirstRad)/2;
&#9;&#9;&#9;LastFirstRad = FirstRad;
&#9;&#9;&#9;Continue = Flex(Cape, {FirstRad, math.sin(Index+20)*-1*Ta,math.sin(Index+20)*2*Ta,math.sin(Index+20)*Ta,math.sin(Index+20)*-1*Ta})
&#9;&#9;&#9;wait(0.05);
&#9;&#9;&#9;Index = Index+1
&#9;&#9;end
&#9;end
&#9;Spawn(function()
&#9;&#9;StartUpdate();
&#9;end)
end

lib.cape = Cape;
lib.Cape = Cape;

local function Decape(Player)
&#9;for _, Item in pairs(Player.Character:GetChildren()) do
&#9;&#9;if Item.Name == &quot;QuentyCapeModel&quot; and Item:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;Item:Destroy()
&#9;&#9;end
&#9;end
end
lib.Decape = Decape
lib.decape = Decape

local function TagHumanoid(Humanoid, Killer)
&#9;--- Tags the humanoid, and removes all other tags.
&#9;-- @param Humanoid The humanoid to tag
&#9;-- @param Killer The killer of the humanoid.

&#9;for _, Item in pairs(Humanoid:GetChildren()) do
&#9;&#9;if Item.Name == &quot;creator&quot; then
&#9;&#9;&#9;Item:Destroy()
&#9;&#9;end
&#9;end

&#9;return Make(&quot;ObjectValue&quot;, {
&#9;&#9;Name = &quot;creator&quot;;
&#9;&#9;Value = Killer;
&#9;&#9;Parent = Humanoid;
&#9;});
end
lib.TagHumanoid = TagHumanoid
lib.tagHumanoid = TagHumanoid

local function GetKiller(Character)
&#9;local Humanoid = Character:FindFirstChild(&quot;Humanoid&quot;)
&#9;
&#9;if Humanoid then
&#9;&#9;local Creator = Humanoid:FindFirstChild(&quot;creator&quot;)
&#9;&#9;if Creator and Creator:IsA(&quot;ObjectValue&quot;) and Creator.Value and Creator.Value:IsA(&quot;Player&quot;) and Creator.Value.Parent then
&#9;&#9;&#9;return Creator.Value
&#9;&#9;end
&#9;end
end
lib.GetKiller = GetKiller
lib.getKiller = GetKiller

return lib</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="Backpack" referent="RBX5">
				<Properties>
					<string name="Name">Events</string>
				</Properties>
				<Item class="ModuleScript" referent="RBX6">
					<Properties>
						<string name="Name">Maid</string>
						<ProtectedString name="Source">--[[Maid
Manages the cleaning of events and other things.

Modified by Quenty
 
API:
&#9;HireMaid()                        Returns a new Maid object.
 
&#9;Maid[key] = (function)            Adds a task to perform when cleaning up.
&#9;Maid[key] = (event connection)    Manages an event connection. Anything that isn&apos;t a function is assumed to be this.
&#9;Maid[key] = nil                   Removes a named task. If the task is an event, it is disconnected.
 
&#9;Maid:GiveTask(task)               Same as above, but uses an incremented number as a key.
&#9;Maid:DoCleaning()                 Disconnects all managed events and performs all clean-up tasks.
]]

local lib = {}
 
local index = {
&#9;GiveTask = function(self,task)
&#9;&#9;local n = #self.Tasks+1
&#9;&#9;self.Tasks[n] = task
&#9;&#9;return n
&#9;end;
&#9;DoCleaning = function(self)
&#9;&#9;local tasks = self.Tasks
&#9;&#9;for name,task in pairs(tasks) do
&#9;&#9;&#9;if type(task) == &apos;function&apos; then
&#9;&#9;&#9;&#9;task()
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;task:disconnect()
&#9;&#9;&#9;end
&#9;&#9;&#9;tasks[name] = nil
&#9;&#9;end
&#9;&#9;-- self.Tasks = {}
&#9;end;
};
local mt = {
&#9;__index = function(self,k)
&#9;&#9;if index[k] then
&#9;&#9;&#9;return index[k]
&#9;&#9;else
&#9;&#9;&#9;return self.Tasks[k]
&#9;&#9;end
&#9;end;
&#9;__newindex = function(self,k,v)
&#9;&#9;local tasks = self.Tasks
&#9;&#9;if v == nil then
&#9;&#9;&#9;-- disconnect if the task is an event
&#9;&#9;&#9;if type(tasks[k]) ~= &apos;function&apos; then
&#9;&#9;&#9;&#9;tasks[k]:disconnect()
&#9;&#9;&#9;end
&#9;&#9;elseif tasks[k] then
&#9;&#9;&#9;-- clear previous task
&#9;&#9;&#9;self[k] = nil
&#9;&#9;end
&#9;&#9;tasks[k] = v
&#9;end;
}

local function MakeMaid()
&#9;return setmetatable({Tasks={},Instances={}},mt)
end
lib.MakeMaid = MakeMaid
lib.makeMaid = MakeMaid
lib.new = MakeMaid
lib.New = makeMaid

return lib</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="Backpack" referent="RBX7">
				<Properties>
					<string name="Name">Penlight</string>
				</Properties>
				<Item class="ModuleScript" referent="RBX8">
					<Properties>
						<string name="Name">PenlightUtils</string>
						<ProtectedString name="Source">--- Generally useful routines.
-- See  @{01-introduction.md.Generally_useful_functions|the Guide}.
-- @module pl.utils
local format,gsub,byte = string.format,string.gsub,string.byte
local clock = os.clock
local stdout = io.stdout
local append = table.insert

local collisions = {}

local utils = {}

-- Derived from Penlight, modified to work in qSystems
-- https://github.com/stevedonovan/Penlight/blob/master/lua/pl/utils.lua

--[[
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the &quot;Software&quot;), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF
    ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
    TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
    PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT
    SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
    ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
    OR OTHER DEALINGS IN THE SOFTWARE.
--]]

utils._VERSION = &quot;1.1.0&quot;

local lua51 = rawget(_G,&apos;setfenv&apos;)

utils.lua51 = lua51
if not lua51 then -- Lua 5.2 compatibility
    unpack = table.unpack
    loadstring = load
end

utils.dir_separator = _G.package.config:sub(1,1)

--- end this program gracefully.
-- @param code The exit code or a message to be printed
-- @param ... extra arguments for message&apos;s format&apos;
-- @see utils.fprintf
function utils.quit(code,...)
    if type(code) == &apos;string&apos; then
        utils.fprintf(io.stderr,code,...)
        code = -1
    else
        utils.fprintf(io.stderr,...)
    end
    io.stderr:write(&apos;\n&apos;)
    os.exit(code)
end

--- print an arbitrary number of arguments using a format.
-- @param fmt The format (see string.format)
-- @param ... Extra arguments for format
function utils.printf(fmt,...)
    utils.assert_string(1,fmt)
    utils.fprintf(stdout,fmt,...)
end

--- write an arbitrary number of arguments to a file using a format.
-- @param f File handle to write to.
-- @param fmt The format (see string.format).
-- @param ... Extra arguments for format
--[[
function utils.fprintf(f,fmt,...)
    utils.assert_string(2,fmt)
    f:write(format(fmt,...))
end
--]]
local function import_symbol(T,k,v,libname)
    local key = rawget(T,k)
    -- warn about collisions!
    if key and k ~= &apos;_M&apos; and k ~= &apos;_NAME&apos; and k ~= &apos;_PACKAGE&apos; and k ~= &apos;_VERSION&apos; then
        utils.printf(&quot;warning: &apos;%s.%s&apos; overrides existing symbol\n&quot;,libname,k)
    end
    rawset(T,k,v)
end

local function lookup_lib(T,t)
    for k,v in pairs(T) do
        if v == t then return k end
    end
    return &apos;?&apos;
end

local already_imported = {}

--- take a table and &apos;inject&apos; it into the local namespace.
-- @param t The Table
-- @param T An optional destination table (defaults to callers environment)
function utils.import(t,T)
    T = T or _G
    t = t or utils
    if type(t) == &apos;string&apos; then
        t = require (t)
    end
    local libname = lookup_lib(T,t)
    if already_imported[t] then return end
    already_imported[t] = libname
    for k,v in pairs(t) do
        import_symbol(T,k,v,libname)
    end
end

utils.patterns = {
    FLOAT = &apos;[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*&apos;,
    INTEGER = &apos;[+%-%d]%d*&apos;,
    IDEN = &apos;[%a_][%w_]*&apos;,
    FILE = &apos;[%a%.\\][:%][%w%._%-\\]*&apos;
}

--- escape any &apos;magic&apos; characters in a string
-- @param s The input string
function utils.escape(s)
    utils.assert_string(1,s)
    return (s:gsub(&apos;[%-%.%+%[%]%(%)%$%^%%%?%*]&apos;,&apos;%%%1&apos;))
end

--- return either of two values, depending on a condition.
-- @param cond A condition
-- @param value1 Value returned if cond is true
-- @param value2 Value returned if cond is false (can be optional)
function utils.choose(cond,value1,value2)
    if cond then return value1
    else return value2
    end
end

local raise

--- return the contents of a file as a string
-- @param filename The file path
-- @param is_bin open in binary mode
-- @return file contents
function utils.readfile(filename,is_bin)
    local mode = is_bin and &apos;b&apos; or &apos;&apos;
    utils.assert_string(1,filename)
    local f,err = io.open(filename,&apos;r&apos;..mode)
    if not f then return utils.raise (err) end
    local res,err = f:read(&apos;*a&apos;)
    f:close()
    if not res then return raise (err) end
    return res
end

--- write a string to a file
-- @param filename The file path
-- @param str The string
-- @return true or nil
-- @return error message
-- @raise error if filename or str aren&apos;t strings
function utils.writefile(filename,str)
    utils.assert_string(1,filename)
    utils.assert_string(2,str)
    local f,err = io.open(filename,&apos;w&apos;)
    if not f then return raise(err) end
    f:write(str)
    f:close()
    return true
end

--- return the contents of a file as a list of lines
-- @param filename The file path
-- @return file contents as a table
-- @raise errror if filename is not a string
function utils.readlines(filename)
    utils.assert_string(1,filename)
    local f,err = io.open(filename,&apos;r&apos;)
    if not f then return raise(err) end
    local res = {}
    for line in f:lines() do
        append(res,line)
    end
    f:close()
    return res
end

--- split a string into a list of strings separated by a delimiter.
-- @param s The input string
-- @param re A Lua string pattern; defaults to &apos;%s+&apos;
-- @param plain don&apos;t use Lua patterns
-- @param n optional maximum number of splits
-- @return a list-like table
-- @raise error if s is not a string
function utils.split(s,re,plain,n)
    utils.assert_string(1,s)
    local find,sub,append = string.find, string.sub, table.insert
    local i1,ls = 1,{}
    if not re then re = &apos;%s+&apos; end
    if re == &apos;&apos; then return {s} end
    while true do
        local i2,i3 = find(s,re,i1,plain)
        if not i2 then
            local last = sub(s,i1)
            if last ~= &apos;&apos; then append(ls,last) end
            if #ls == 1 and ls[1] == &apos;&apos; then
                return {}
            else
                return ls
            end
        end
        append(ls,sub(s,i1,i2-1))
        if n and #ls == n then
            ls[#ls] = sub(s,i1)
            return ls
        end
        i1 = i3+1
    end
end

--- split a string into a number of values.
-- @param s the string
-- @param re the delimiter, default space
-- @return n values
-- @usage first,next = splitv(&apos;jane:doe&apos;,&apos;:&apos;)
-- @see split
function utils.splitv (s,re)
    return unpack(utils.split(s,re))
end

--- convert an array of values to strings.
-- @param t a list-like table
-- @param temp buffer to use, otherwise allocate
-- @param tostr custom tostring function, called with (value,index).
-- Otherwise use `tostring`
-- @return the converted buffer
function utils.array_tostring (t,temp,tostr)
    temp, tostr = temp or {}, tostr or tostring
    for i = 1,#t do
        temp[i] = tostr(t[i],i)
    end
    return temp
end

local lua51_load = load

if utils.lua51 then -- define Lua 5.2 style load()
    function utils.load(str,src,mode,env)
        local chunk,err
        if type(str) == &apos;string&apos; then
            chunk,err = loadstring(str,src)
        else
            chunk,err = lua51_load(str,src)
        end
        if chunk and env then setfenv(chunk,env) end
        return chunk,err
    end
else
    utils.load = load
    -- setfenv/getfenv replacements for Lua 5.2
    -- by Sergey Rozhenko
    -- http://lua-users.org/lists/lua-l/2010-06/msg00313.html
    -- Roberto Ierusalimschy notes that it is possible for getfenv to return nil
    -- in the case of a function with no globals:
    -- http://lua-users.org/lists/lua-l/2010-06/msg00315.html
    function setfenv(f, t)
        f = (type(f) == &apos;function&apos; and f or debug.getinfo(f + 1, &apos;f&apos;).func)
        local name
        local up = 0
        repeat
            up = up + 1
            name = debug.getupvalue(f, up)
        until name == &apos;_ENV&apos; or name == nil
        if name then
            debug.upvaluejoin(f, up, function() return name end, 1) -- use unique upvalue
            debug.setupvalue(f, up, t)
        end
        if f ~= 0 then return f end
    end

    function getfenv(f)
        local f = f or 0
        f = (type(f) == &apos;function&apos; and f or debug.getinfo(f + 1, &apos;f&apos;).func)
        local name, val
        local up = 0
        repeat
            up = up + 1
            name, val = debug.getupvalue(f, up)
        until name == &apos;_ENV&apos; or name == nil
        return val
    end
end


--- execute a shell command.
-- This is a compatibility function that returns the same for Lua 5.1 and Lua 5.2
-- @param cmd a shell command
-- @return true if successful
-- @return actual return code
function utils.execute (cmd)
    local res1,res2,res2 = os.execute(cmd)
    if lua51 then
        return res1==0,res1
    else
        return res1,res2
    end
end

if lua51 then
    function table.pack (...)
        local n = select(&apos;#&apos;,...)
        return {n=n; ...}
    end
    local sep = package.config:sub(1,1)
    function package.searchpath (mod,path)
        mod = mod:gsub(&apos;%.&apos;,sep)
        for m in path:gmatch(&apos;[^;]+&apos;) do
            local nm = m:gsub(&apos;?&apos;,mod)
            local f = io.open(nm,&apos;r&apos;)
            if f then f:close(); return nm end
        end
    end
end

if not table.pack then table.pack = _G.pack end
if not rawget(_G,&quot;pack&quot;) then _G.pack = table.pack end

--- take an arbitrary set of arguments and make into a table.
-- This returns the table and the size; works fine for nil arguments
-- @param ... arguments
-- @return table
-- @return table size
-- @usage local t,n = utils.args(...)

--- &apos;memoize&apos; a function (cache returned value for next call).
-- This is useful if you have a function which is relatively expensive,
-- but you don&apos;t know in advance what values will be required, so
-- building a table upfront is wasteful/impossible.
-- @param func a function of at least one argument
-- @return a function with at least one argument, which is used as the key.
function utils.memoize(func)
    return setmetatable({}, {
        __index = function(self, k, ...)
            local v = func(k,...)
            self[k] = v
            return v
        end,
        __call = function(self, k) return self[k] end
    })
end

--- is the object either a function or a callable object?.
-- @param obj Object to check.
function utils.is_callable (obj)
    return type(obj) == &apos;function&apos; or getmetatable(obj) and getmetatable(obj).__call
end

--- is the object of the specified type?.
-- If the type is a string, then use type, otherwise compare with metatable
-- @param obj An object to check
-- @param tp String of what type it should be
function utils.is_type (obj,tp)
    if type(tp) == &apos;string&apos; then return type(obj) == tp end
    local mt = getmetatable(obj)
    return tp == mt
end

local fileMT = getmetatable(io.stdout)

--- a string representation of a type.
-- For tables with metatables, we assume that the metatable has a `_name`
-- field. Knows about Lua file objects.
-- @param obj an object
-- @return a string like &apos;number&apos;, &apos;table&apos; or &apos;List&apos;
function utils.type (obj)
    local t = type(obj)
    if t == &apos;table&apos; or t == &apos;userdata&apos; then
        local mt = getmetatable(obj)
        if mt == fileMT then
            return &apos;file&apos;
        else
            return mt._name or &quot;unknown &quot;..t
        end
    else
        return t
    end
end

--- is this number an integer?
-- @param x a number
-- @raise error if x is not a number
function utils.is_integer (x)
    return math.ceil(x)==x
end

utils.stdmt = {
    List = {_name=&apos;List&apos;}, Map = {_name=&apos;Map&apos;},
    Set = {_name=&apos;Set&apos;}, MultiMap = {_name=&apos;MultiMap&apos;}
}

local _function_factories = {}

--- associate a function factory with a type.
-- A function factory takes an object of the given type and
-- returns a function for evaluating it
-- @param mt metatable
-- @param fun a callable that returns a function
function utils.add_function_factory (mt,fun)
    _function_factories[mt] = fun
end

local function _string_lambda(f)
    local raise = utils.raise
    if f:find &apos;^|&apos; or f:find &apos;_&apos; then
        local args,body = f:match &apos;|([^|]*)|(.+)&apos;
        if f:find &apos;_&apos; then
            args = &apos;_&apos;
            body = f
        else
            if not args then return raise &apos;bad string lambda&apos; end
        end
        local fstr = &apos;return function(&apos;..args..&apos;) return &apos;..body..&apos; end&apos;
        local fn,err = loadstring(fstr)
        if not fn then return raise(err) end
        fn = fn()
        return fn
    else return raise &apos;not a string lambda&apos;
    end
end

--- an anonymous function as a string. This string is either of the form
-- &apos;|args| expression&apos; or is a function of one argument, &apos;_&apos;
-- @param lf function as a string
-- @return a function
-- @usage string_lambda &apos;|x|x+1&apos; (2) == 3
-- @usage string_lambda &apos;_+1 (2) == 3
-- @function utils.string_lambda
utils.string_lambda = utils.memoize(_string_lambda)

local ops

--- process a function argument.
-- This is used throughout Penlight and defines what is meant by a function:
-- Something that is callable, or an operator string as defined by &lt;code&gt;pl.operator&lt;/code&gt;,
-- such as &apos;&gt;&apos; or &apos;#&apos;. If a function factory has been registered for the type, it will
-- be called to get the function.
-- @param idx argument index
-- @param f a function, operator string, or callable object
-- @param msg optional error message
-- @return a callable
-- @raise if idx is not a number or if f is not callable
-- @see utils.is_callable
function utils.function_arg (idx,f,msg)
    utils.assert_arg(1,idx,&apos;number&apos;)
    local tp = type(f)
    if tp == &apos;function&apos; then return f end  -- no worries!
    -- ok, a string can correspond to an operator (like &apos;==&apos;)
    if tp == &apos;string&apos; then
        if not ops then ops = require &apos;pl.operator&apos;.optable end
        local fn = ops[f]
        if fn then return fn end
        local fn, err = utils.string_lambda(f)
        if not fn then error(err..&apos;: &apos;..f) end
        return fn
    elseif tp == &apos;table&apos; or tp == &apos;userdata&apos; then
        local mt = getmetatable(f)
        if not mt then error(&apos;not a callable object&apos;,2) end
        local ff = _function_factories[mt]
        if not ff then
            if not mt.__call then error(&apos;not a callable object&apos;,2) end
            return f
        else
            return ff(f) -- we have a function factory for this type!
        end
    end
    if not msg then msg = &quot; must be callable&quot; end
    if idx &gt; 0 then
        error(&quot;argument &quot;..idx..&quot;: &quot;..msg,2)
    else
        error(msg,2)
    end
end

--- bind the first argument of the function to a value.
-- @param fn a function of at least two values (may be an operator string)
-- @param p a value
-- @return a function such that f(x) is fn(p,x)
-- @raise same as @{function_arg}
-- @see pl.func.curry
function utils.bind1 (fn,p)
    fn = utils.function_arg(1,fn)
    return function(...) return fn(p,...) end
end

--- bind the second argument of the function to a value.
-- @param fn a function of at least two values (may be an operator string)
-- @param p a value
-- @return a function such that f(x) is fn(x,p)
-- @raise same as @{function_arg}
function utils.bind2 (fn,p)
    fn = utils.function_arg(1,fn)
    return function(x,...) return fn(x,p,...) end
end


--- assert that the given argument is in fact of the correct type.
-- @param n argument index
-- @param val the value
-- @param tp the type
-- @param verify an optional verfication function
-- @param msg an optional custom message
-- @param lev optional stack position for trace, default 2
-- @raise if the argument n is not the correct type
-- @usage assert_arg(1,t,&apos;table&apos;)
-- @usage assert_arg(n,val,&apos;string&apos;,path.isdir,&apos;not a directory&apos;)
function utils.assert_arg (n,val,tp,verify,msg,lev)
    if type(val) ~= tp then
        error((&quot;argument %d expected a &apos;%s&apos;, got a &apos;%s&apos;&quot;):format(n,tp,type(val)),lev or 2)
    end
    if verify and not verify(val) then
        error((&quot;argument %d: &apos;%s&apos; %s&quot;):format(n,val,msg),lev or 2)
    end
end

--- assert the common case that the argument is a string.
-- @param n argument index
-- @param val a value that must be a string
-- @raise val must be a string
function utils.assert_string (n,val)
    utils.assert_arg(n,val,&apos;string&apos;,nil,nil,3)
end

local err_mode = &apos;default&apos;

--- control the error strategy used by Penlight.
-- Controls how &lt;code&gt;utils.raise&lt;/code&gt; works; the default is for it
-- to return nil and the error string, but if the mode is &apos;error&apos; then
-- it will throw an error. If mode is &apos;quit&apos; it will immediately terminate
-- the program.
-- @param mode - either &apos;default&apos;, &apos;quit&apos;  or &apos;error&apos;
-- @see utils.raise
function utils.on_error (mode)
    if ({[&apos;default&apos;] = 1, [&apos;quit&apos;] = 2, [&apos;error&apos;] = 3})[mode] then
      err_mode = mode
    else
      -- fail loudly
      if err_mode == &apos;default&apos; then err_mode = &apos;error&apos; end
      utils.raise(&quot;Bad argument expected string; &apos;default&apos;, &apos;quit&apos;, or &apos;error&apos;. Got &apos;&quot;..tostring(mode)..&quot;&apos;&quot;)
    end
end

--- used by Penlight functions to return errors.  Its global behaviour is controlled
-- by &lt;code&gt;utils.on_error&lt;/code&gt;
-- @param err the error string.
-- @see utils.on_error
function utils.raise (err)
    if err_mode == &apos;default&apos; then return nil,err
    elseif err_mode == &apos;quit&apos; then utils.quit(err)
    else error(err,2)
    end
end

raise = utils.raise

--- load a code string or bytecode chunk.
-- @param code Lua code as a string or bytecode
-- @param name for source errors
-- @param mode kind of chunk, &apos;t&apos; for text, &apos;b&apos; for bytecode, &apos;bt&apos; for all (default)
-- @param env  the environment for the new chunk (default nil)
-- @return compiled chunk
-- @return error message (chunk is nil)
-- @function utils.load


--- Lua 5.2 Compatible Functions
-- @section lua52

--- pack an argument list into a table.
-- @param ... any arguments
-- @return a table with field n set to the length
-- @return the length
-- @function table.pack

------
-- return the full path where a Lua module name would be matched.
-- @param mod module name, possibly dotted
-- @param path a path in the same form as package.path or package.cpath
-- @see path.package_path
-- @function package.searchpath

return utils

</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9">
					<Properties>
						<string name="Name">PenlightPretty</string>
						<ProtectedString name="Source">-- PenlightPretty.lua
-- Last Modified February 3rd, 2014
-- @author Steve Donovan
-- @author Quenty (Modified)

local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

-- Derived from Penlight, modified to work in qSystems
-- https://github.com/stevedonovan/Penlight/blob/master/lua/pl/pretty.lua

--[[
&#9;Permission is hereby granted, free of charge, to any person obtaining a copy
&#9;of this software and associated documentation files (the &quot;Software&quot;), to deal
&#9;in the Software without restriction, including without limitation the rights
&#9;to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&#9;copies of the Software, and to permit persons to whom the Software is
&#9;furnished to do so, subject to the following conditions:

&#9;The above copyright notice and this permission notice shall be included in
&#9;all copies or substantial portions of the Software.

&#9;THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF
&#9;ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
&#9;TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
&#9;PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT
&#9;SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
&#9;ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
&#9;ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&#9;OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
&#9;OR OTHER DEALINGS IN THE SOFTWARE.
--]]

--[[
&#9;Pretty-printing Lua tables.
&#9;Also provides a sandboxed Lua table reader and
&#9;a function to present large numbers in human-friendly format.

&#9;Dependencies: `pl.utils`, `pl.lexer`
&#9;@module pl.pretty
--]]
local append = table.insert
local concat = table.concat
local lexer = LoadCustomLibrary(&quot;PenlightLexer&quot;)


---- Derived from pl.utils
--- assert that the given argument is in fact of the correct type.
-- @param n argument index
-- @param val the value
-- @param tp the type
-- @param verify an optional verfication function
-- @param msg an optional custom message
-- @param lev optional stack position for trace, default 2
-- @raise if the argument n is not the correct type
-- @usage assert_arg(1,t,&apos;table&apos;)
-- @usage assert_arg(n,val,&apos;string&apos;,path.isdir,&apos;not a directory&apos;)
local function assert_arg (n,val,tp,verify,msg,lev)
&#9;if type(val) ~= tp then
&#9;&#9;error((&quot;argument %d expected a &apos;%s&apos;, got a &apos;%s&apos;&quot;):format(n,tp,type(val)),lev or 2)
&#9;end
&#9;if verify and not verify(val) then
&#9;&#9;error((&quot;argument %d: &apos;%s&apos; %s&quot;):format(n,val,msg),lev or 2)
&#9;end
end

---- Derived from pl.utils
--- convert an array of values to strings.
-- @param t a list-like table
-- @param temp buffer to use, otherwise allocate
-- @param tostr custom tostring function, called with (value,index).
-- Otherwise use `tostring`
-- @return the converted buffer
local function load(str,src,mode,env)
&#9;local chunk,err
&#9;if type(str) == &apos;string&apos; then
&#9;&#9;chunk,err = loadstring(str,src)
&#9;else
&#9;&#9;chunk,err = lua51_load(str,src)
&#9;end
&#9;if chunk and env then setfenv(chunk,env) end
&#9;return chunk, err
end


local pretty = {}

local function save_string_index ()
&#9;local SMT = getmetatable &apos;&apos;
&#9;if SMT then
&#9;&#9;SMT.old__index = SMT.__index
&#9;&#9;SMT.__index = nil
&#9;end
&#9;return SMT
end

local function restore_string_index (SMT)
&#9;if SMT then
&#9;&#9;SMT.__index = SMT.old__index
&#9;end
end

--- read a string representation of a Lua table.
-- Uses load(), but tries to be cautious about loading arbitrary code!
-- It is expecting a string of the form &apos;{...}&apos;, with perhaps some whitespace
-- before or after the curly braces. A comment may occur beforehand.
-- An empty environment is used, and
-- any occurance of the keyword &apos;function&apos; will be considered a problem.
-- in the given environment - the return value may be `nil`.
-- @param s {string} string of the form &apos;{...}&apos;, with perhaps some whitespace
-- before or after the curly braces.
-- @return a table
function pretty.read(s)
&#9;assert_arg(1,s,&apos;string&apos;)
&#9;if s:find &apos;^%s*%-%-&apos; then -- may start with a comment..
&#9;&#9;s = s:gsub(&apos;%-%-.-\n&apos;,&apos;&apos;)
&#9;end
&#9;if not s:find &apos;^%s*%b{}%s*$&apos; then return nil,&quot;not a Lua table&quot; end
&#9;if s:find &apos;[^\&apos;&quot;%w_]function[^\&apos;&quot;%w_]&apos; then
&#9;&#9;local tok = lexer.lua(s)
&#9;&#9;for t,v in tok do
&#9;&#9;&#9;if t == &apos;keyword&apos; then
&#9;&#9;&#9;&#9;return nil,&quot;cannot have functions in table definition&quot;
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;s = &apos;return &apos;..s
&#9;local chunk,err = load(s,&apos;tbl&apos;,&apos;t&apos;,{})
&#9;if not chunk then return nil,err end
&#9;local SMT = save_string_index()
&#9;local ok,ret = pcall(chunk)
&#9;restore_string_index(SMT)
&#9;if ok then return ret
&#9;else
&#9;&#9;return nil,ret
&#9;end
end

--- read a Lua chunk.
-- @param s Lua code
-- @param env optional environment
-- @param paranoid prevent any looping constructs and disable string methods
-- @return the environment
function pretty.load (s, env, paranoid)
&#9;env = env or {}
&#9;if paranoid then
&#9;&#9;local tok = lexer.lua(s)
&#9;&#9;for t,v in tok do
&#9;&#9;&#9;if t == &apos;keyword&apos;
&#9;&#9;&#9;&#9;and (v == &apos;for&apos; or v == &apos;repeat&apos; or v == &apos;function&apos; or v == &apos;goto&apos;)
&#9;&#9;&#9;then
&#9;&#9;&#9;&#9;return nil, &quot;looping not allowed&quot;
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local chunk,err = load(s,&apos;tbl&apos;,&apos;t&apos;,env)
&#9;if not chunk then return nil,err end
&#9;local SMT = paranoid and save_string_index()
&#9;local ok,err = pcall(chunk)
&#9;restore_string_index(SMT)
&#9;if not ok then return nil,err end
&#9;return env
end

local function quote_if_necessary(v)
&#9;if not v then return &apos;&apos;
&#9;else
&#9;&#9;if v:find &apos; &apos; then v = &apos;&quot;&apos;..v..&apos;&quot;&apos; end
&#9;end
&#9;return v
end

local keywords

local function is_identifier(s)
&#9;return type(s) == &apos;string&apos; and s:find(&apos;^[%a_][%w_]*$&apos;) and not keywords[s]
end

local function quote(s)
&#9;if type(s) == &apos;table&apos; then
&#9;&#9;return pretty.write(s,&apos;&apos;)
&#9;else
&#9;&#9;return (&apos;%q&apos;):format(tostring(s))
&#9;end
end

local function index (numkey,key)
&#9;if not numkey then key = quote(key) end
&#9;return &apos;[&apos;..key..&apos;]&apos;
end


--- Create a string representation of a Lua table.
--  This function never fails, but may complain by returning an
--  extra value. Normally puts out one item per line, using
--  the provided indent; set the second parameter to &apos;&apos; if
--  you want output on one line.
--  @param tbl {table} Table to serialize to a string.
--  @param space {string} (optional) The indent to use.
--  Defaults to two spaces; make it the empty string for no indentation
--  @param not_clever {bool} (optional) Use for plain output, e.g {[&apos;key&apos;]=1}.
--  Defaults to false.
--  @return a string
--  @return a possible error message
local function write(tbl,space,not_clever)
&#9;if type(tbl) ~= &apos;table&apos; then
&#9;&#9;local res = tostring(tbl)
&#9;&#9;if type(tbl) == &apos;string&apos; then return quote(tbl) end
&#9;&#9;return res, &apos;not a table&apos;
&#9;end
&#9;if not keywords then
&#9;&#9;keywords = lexer.get_keywords()
&#9;end
&#9;local set = &apos; = &apos;
&#9;if space == &apos;&apos; then set = &apos;=&apos; end
&#9;space = space or &apos;  &apos;
&#9;local lines = {}
&#9;local line = &apos;&apos;
&#9;local tables = {}


&#9;local function put(s)
&#9;&#9;if #s &gt; 0 then
&#9;&#9;&#9;line = line..s
&#9;&#9;end
&#9;end

&#9;local function putln (s)
&#9;&#9;if #line &gt; 0 then
&#9;&#9;&#9;line = line..s
&#9;&#9;&#9;append(lines,line)
&#9;&#9;&#9;line = &apos;&apos;
&#9;&#9;else
&#9;&#9;&#9;append(lines,s)
&#9;&#9;end
&#9;end

&#9;local function eat_last_comma()
&#9;&#9;local n,lastch = #lines
&#9;&#9;local lastch = lines[n]:sub(-1,-1)
&#9;&#9;if lastch == &apos;,&apos; then
&#9;&#9;&#9;lines[n] = lines[n]:sub(1,-2)
&#9;&#9;end
&#9;end


&#9;local writeit
&#9;writeit = function (t,oldindent,indent)
&#9;&#9;local tp = type(t)
&#9;&#9;if tp ~= &apos;string&apos; and  tp ~= &apos;table&apos; then
&#9;&#9;&#9;putln(quote_if_necessary(tostring(t))..&apos;,&apos;)
&#9;&#9;elseif tp == &apos;string&apos; then
&#9;&#9;&#9;if t:find(&apos;\n&apos;) then
&#9;&#9;&#9;&#9;putln(&apos;[[\n&apos;..t..&apos;]],&apos;)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;putln(quote(t)..&apos;,&apos;)
&#9;&#9;&#9;end
&#9;&#9;elseif tp == &apos;table&apos; then
&#9;&#9;&#9;if tables[t] then
&#9;&#9;&#9;&#9;putln(&apos;&lt;cycle&gt;,&apos;)
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;&#9;tables[t] = true
&#9;&#9;&#9;local newindent = indent..space
&#9;&#9;&#9;putln(&apos;{&apos;)
&#9;&#9;&#9;local used = {}
&#9;&#9;&#9;if not not_clever then
&#9;&#9;&#9;&#9;for i,val in ipairs(t) do
&#9;&#9;&#9;&#9;&#9;put(indent)
&#9;&#9;&#9;&#9;&#9;writeit(val,indent,newindent)
&#9;&#9;&#9;&#9;&#9;used[i] = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;for key,val in pairs(t) do
&#9;&#9;&#9;&#9;local numkey = type(key) == &apos;number&apos;
&#9;&#9;&#9;&#9;if not_clever then
&#9;&#9;&#9;&#9;&#9;key = tostring(key)
&#9;&#9;&#9;&#9;&#9;put(indent..index(numkey,key)..set)
&#9;&#9;&#9;&#9;&#9;writeit(val,indent,newindent)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;if not numkey or not used[key] then -- non-array indices
&#9;&#9;&#9;&#9;&#9;&#9;if numkey or not is_identifier(key) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;key = index(numkey,key)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;put(indent..key..set)
&#9;&#9;&#9;&#9;&#9;&#9;writeit(val,indent,newindent)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;tables[t] = nil
&#9;&#9;&#9;eat_last_comma()
&#9;&#9;&#9;putln(oldindent..&apos;},&apos;)
&#9;&#9;else
&#9;&#9;&#9;putln(tostring(t)..&apos;,&apos;)
&#9;&#9;end
&#9;end
&#9;writeit(tbl,&apos;&apos;,space)
&#9;eat_last_comma()
&#9;return concat(lines,#space &gt; 0 and &apos;\n&apos; or &apos;&apos;)
end
pretty.write = write
pretty.Write = write

pretty.tableToString = write -- My type of syntax. 
pretty.TableToString = write

--- Dump a Lua table out to a file or stdout.
--  @param t {table} The table to write to a file or stdout.
--  @param ... {string} (optional) File name to write too. Defaults to writing
--  to stdout.
--[[
function pretty.dump (t,...)
&#9;if select(&apos;#&apos;,...)==0 then
&#9;&#9;print(pretty.write(t))
&#9;&#9;return true
&#9;else
&#9;&#9;return utils.writefile(...,pretty.write(t))
&#9;end
end
--]]

local memp,nump = {&apos;B&apos;,&apos;KiB&apos;,&apos;MiB&apos;,&apos;GiB&apos;},{&apos;&apos;,&apos;K&apos;,&apos;M&apos;,&apos;B&apos;}

local comma
function comma (val)
&#9;local thou = math.floor(val/1000)
&#9;if thou &gt; 0 then return comma(thou)..&apos;,&apos;..(val % 1000)
&#9;else return tostring(val) end
end

--- format large numbers nicely for human consumption.
-- @param num a number
-- @param kind one of &apos;M&apos; (memory in KiB etc), &apos;N&apos; (postfixes are &apos;K&apos;,&apos;M&apos; and &apos;B&apos;)
-- and &apos;T&apos; (use commas as thousands separator)
-- @param prec number of digits to use for &apos;M&apos; and &apos;N&apos; (default 1)
function pretty.number (num,kind,prec)
&#9;local fmt = &apos;%.&apos;..(prec or 1)..&apos;f%s&apos;
&#9;if kind == &apos;T&apos; then
&#9;&#9;return comma(num)
&#9;else
&#9;&#9;local postfixes, fact
&#9;&#9;if kind == &apos;M&apos; then
&#9;&#9;&#9;fact = 1024
&#9;&#9;&#9;postfixes = memp
&#9;&#9;else
&#9;&#9;&#9;fact = 1000
&#9;&#9;&#9;postfixes = nump
&#9;&#9;end
&#9;&#9;local div = fact
&#9;&#9;local k = 1
&#9;&#9;while num &gt;= div and k &lt;= #postfixes do
&#9;&#9;&#9;div = div * fact
&#9;&#9;&#9;k = k + 1
&#9;&#9;end
&#9;&#9;div = div / fact
&#9;&#9;if k &gt; #postfixes then k = k - 1; div = div/fact end
&#9;&#9;if k &gt; 1 then
&#9;&#9;&#9;return fmt:format(num/div,postfixes[k] or &apos;duh&apos;)
&#9;&#9;else
&#9;&#9;&#9;return num..postfixes[1]
&#9;&#9;end
&#9;end
end

return pretty</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX10">
					<Properties>
						<string name="Name">PenlightLexer</string>
						<ProtectedString name="Source">-- PenlightLexar.lua
-- Last Modified February 3rd, 2014
-- @author Steve Donovan
-- @author Quenty (Modified)

-- Derived from Penlight, modified to work in qSystems
-- https://github.com/stevedonovan/Penlight/blob/master/lua/pl/lexer.lua

--[[
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the &quot;Software&quot;), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF
    ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
    TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
    PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT
    SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
    ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
    OR OTHER DEALINGS IN THE SOFTWARE.
--]]


--[[
    Lexical scanner for creating a sequence of tokens from text.
    `lexer.scan(s)` returns an iterator over all tokens found in the
    string `s`. This iterator returns two values, a token type string
    (such as &apos;string&apos; for quoted string, &apos;iden&apos; for identifier) and the value of the
    token.

    Versions specialized for Lua and C are available; these also handle block comments
    and classify keywords as &apos;keyword&apos; tokens. For example:

       &gt; s = &apos;for i=1,n do&apos;
       &gt; for t,v in lexer.lua(s)  do print(t,v) end
       keyword for
       iden    i
       =       =
       number  1
       ,       ,
       iden    n
       keyword do

    See the Guide for further @{06-data.md.Lexical_Scanning|discussion}
    @module pl.lexer
--]]

local yield,wrap = coroutine.yield,coroutine.wrap
local strfind = string.find
local strsub = string.sub
local append = table.insert

local function assert_arg(idx,val,tp)
    if type(val) ~= tp then
        error(&quot;argument &quot;..idx..&quot; must be &quot;..tp, 2)
    end
end

local lexer = {}

local NUMBER1 = &apos;^[%+%-]?%d+%.?%d*[eE][%+%-]?%d+&apos;
local NUMBER2 = &apos;^[%+%-]?%d+%.?%d*&apos;
local NUMBER3 = &apos;^0x[%da-fA-F]+&apos;
local NUMBER4 = &apos;^%d+%.?%d*[eE][%+%-]?%d+&apos;
local NUMBER5 = &apos;^%d+%.?%d*&apos;
local IDEN = &apos;^[%a_][%w_]*&apos;
local WSPACE = &apos;^%s+&apos;
local STRING0 = [[^([&apos;\&quot;]).-\\%1]]
local STRING1 = [[^([&apos;\&quot;]).-[^\]%1]]
local STRING3 = &quot;^(([&apos;\&quot;])%2)&quot; -- empty string
local PREPRO = &apos;^#.-[^\\]\n&apos;

local plain_matches,lua_matches,cpp_matches,lua_keyword,cpp_keyword

local function tdump(tok)
    return yield(tok,tok)
end

local function ndump(tok,options)
    if options and options.number then
        tok = tonumber(tok)
    end
    return yield(&quot;number&quot;,tok)
end

-- regular strings, single or double quotes; usually we want them
-- without the quotes
local function sdump(tok,options)
    if options and options.string then
        tok = tok:sub(2,-2)
    end
    return yield(&quot;string&quot;,tok)
end

-- long Lua strings need extra work to get rid of the quotes
local function sdump_l(tok,options)
    if options and options.string then
        tok = tok:sub(3,-3)
    end
    return yield(&quot;string&quot;,tok)
end

local function chdump(tok,options)
    if options and options.string then
        tok = tok:sub(2,-2)
    end
    return yield(&quot;char&quot;,tok)
end

local function cdump(tok)
    return yield(&apos;comment&apos;,tok)
end

local function wsdump (tok)
    return yield(&quot;space&quot;,tok)
end

local function pdump (tok)
    return yield(&apos;prepro&apos;,tok)
end

local function plain_vdump(tok)
    return yield(&quot;iden&quot;,tok)
end

local function lua_vdump(tok)
    if lua_keyword[tok] then
        return yield(&quot;keyword&quot;,tok)
    else
        return yield(&quot;iden&quot;,tok)
    end
end

local function cpp_vdump(tok)
    if cpp_keyword[tok] then
        return yield(&quot;keyword&quot;,tok)
    else
        return yield(&quot;iden&quot;,tok)
    end
end

--- create a plain token iterator from a string or file-like object.
-- @param s the string
-- @param matches an optional match table (set of pattern-action pairs)
-- @param filter a table of token types to exclude, by default {space=true}
-- @param options a table of options; by default, {number=true,string=true},
-- which means convert numbers and strip string quotes.
function lexer.scan (s,matches,filter,options)
    --assert_arg(1,s,&apos;string&apos;)
    local file = type(s) ~= &apos;string&apos; and s
    filter = filter or {space=true}
    options = options or {number=true,string=true}
    if filter then
        if filter.space then filter[wsdump] = true end
        if filter.comments then
            filter[cdump] = true
        end
    end
    if not matches then
        if not plain_matches then
            plain_matches = {
                {WSPACE,wsdump},
                {NUMBER3,ndump},
                {IDEN,plain_vdump},
                {NUMBER1,ndump},
                {NUMBER2,ndump},
                {STRING3,sdump},
                {STRING0,sdump},
                {STRING1,sdump},
                {&apos;^.&apos;,tdump}
            }
        end
        matches = plain_matches
    end
    local function lex ()
        local i1,i2,idx,res1,res2,tok,pat,fun,capt
        local line = 1
        if file then s = file:read()..&apos;\n&apos; end
        local sz = #s
        local idx = 1
        --print(&apos;sz&apos;,sz)
        while true do
            for _,m in ipairs(matches) do
                pat = m[1]
                fun = m[2]
                i1,i2 = strfind(s,pat,idx)
                if i1 then
                    tok = strsub(s,i1,i2)
                    idx = i2 + 1
                    if not (filter and filter[fun]) then
                        lexer.finished = idx &gt; sz
                        res1,res2 = fun(tok,options)
                    end
                    if res1 then
                        local tp = type(res1)
                        -- insert a token list
                        if tp==&apos;table&apos; then
                            yield(&apos;&apos;,&apos;&apos;)
                            for _,t in ipairs(res1) do
                                yield(t[1],t[2])
                            end
                        elseif tp == &apos;string&apos; then -- or search up to some special pattern
                            i1,i2 = strfind(s,res1,idx)
                            if i1 then
                                tok = strsub(s,i1,i2)
                                idx = i2 + 1
                                yield(&apos;&apos;,tok)
                            else
                                yield(&apos;&apos;,&apos;&apos;)
                                idx = sz + 1
                            end
                            --if idx &gt; sz then return end
                        else
                            yield(line,idx)
                        end
                    end
                    if idx &gt; sz then
                        if file then
                            --repeat -- next non-empty line
                                line = line + 1
                                s = file:read()
                                if not s then return end
                            --until not s:match &apos;^%s*$&apos;
                            s = s .. &apos;\n&apos;
                            idx ,sz = 1,#s
                            break
                        else
                            return
                        end
                    else break end
                end
            end
        end
    end
    return wrap(lex)
end

local function isstring (s)
    return type(s) == &apos;string&apos;
end

--- insert tokens into a stream.
-- @param tok a token stream
-- @param a1 a string is the type, a table is a token list and
-- a function is assumed to be a token-like iterator (returns type &amp; value)
-- @param a2 a string is the value
function lexer.insert (tok,a1,a2)
    if not a1 then return end
    local ts
    if isstring(a1) and isstring(a2) then
        ts = {{a1,a2}}
    elseif type(a1) == &apos;function&apos; then
        ts = {}
        for t,v in a1() do
            append(ts,{t,v})
        end
    else
        ts = a1
    end
    tok(ts)
end

--- get everything in a stream upto a newline.
-- @param tok a token stream
-- @return a string
function lexer.getline (tok)
    local t,v = tok(&apos;.-\n&apos;)
    return v
end

--- get current line number. &lt;br&gt;
-- Only available if the input source is a file-like object.
-- @param tok a token stream
-- @return the line number and current column
function lexer.lineno (tok)
    return tok(0)
end

--- get the rest of the stream.
-- @param tok a token stream
-- @return a string
function lexer.getrest (tok)
    local t,v = tok(&apos;.+&apos;)
    return v
end

--- get the Lua keywords as a set-like table.
-- So &lt;code&gt;res[&quot;and&quot;]&lt;/code&gt; etc would be &lt;code&gt;true&lt;/code&gt;.
-- @return a table
function lexer.get_keywords ()
    if not lua_keyword then
        lua_keyword = {
            [&quot;and&quot;] = true, [&quot;break&quot;] = true,  [&quot;do&quot;] = true,
            [&quot;else&quot;] = true, [&quot;elseif&quot;] = true, [&quot;end&quot;] = true,
            [&quot;false&quot;] = true, [&quot;for&quot;] = true, [&quot;function&quot;] = true,
            [&quot;if&quot;] = true, [&quot;in&quot;] = true,  [&quot;local&quot;] = true, [&quot;nil&quot;] = true,
            [&quot;not&quot;] = true, [&quot;or&quot;] = true, [&quot;repeat&quot;] = true,
            [&quot;return&quot;] = true, [&quot;then&quot;] = true, [&quot;true&quot;] = true,
            [&quot;until&quot;] = true,  [&quot;while&quot;] = true
        }
    end
    return lua_keyword
end


--- create a Lua token iterator from a string or file-like object.
-- Will return the token type and value.
-- @param s the string
-- @param filter a table of token types to exclude, by default {space=true,comments=true}
-- @param options a table of options; by default, {number=true,string=true},
-- which means convert numbers and strip string quotes.
function lexer.lua(s,filter,options)
    filter = filter or {space=true,comments=true}
    lexer.get_keywords()
    if not lua_matches then
        lua_matches = {
            {WSPACE,wsdump},
            {NUMBER3,ndump},
            {IDEN,lua_vdump},
            {NUMBER4,ndump},
            {NUMBER5,ndump},
            {STRING3,sdump},
            {STRING0,sdump},
            {STRING1,sdump},
            {&apos;^%-%-%[%[.-%]%]&apos;,cdump},
            {&apos;^%-%-.-\n&apos;,cdump},
            {&apos;^%[%[.-%]%]&apos;,sdump_l},
            {&apos;^==&apos;,tdump},
            {&apos;^~=&apos;,tdump},
            {&apos;^&lt;=&apos;,tdump},
            {&apos;^&gt;=&apos;,tdump},
            {&apos;^%.%.%.&apos;,tdump},
            {&apos;^%.%.&apos;,tdump},
            {&apos;^.&apos;,tdump}
        }
    end
    return lexer.scan(s,lua_matches,filter,options)
end

--- create a C/C++ token iterator from a string or file-like object.
-- Will return the token type type and value.
-- @param s the string
-- @param filter a table of token types to exclude, by default {space=true,comments=true}
-- @param options a table of options; by default, {number=true,string=true},
-- which means convert numbers and strip string quotes.
function lexer.cpp(s,filter,options)
    filter = filter or {comments=true}
    if not cpp_keyword then
        cpp_keyword = {
            [&quot;class&quot;] = true, [&quot;break&quot;] = true,  [&quot;do&quot;] = true, [&quot;sizeof&quot;] = true,
            [&quot;else&quot;] = true, [&quot;continue&quot;] = true, [&quot;struct&quot;] = true,
            [&quot;false&quot;] = true, [&quot;for&quot;] = true, [&quot;public&quot;] = true, [&quot;void&quot;] = true,
            [&quot;private&quot;] = true, [&quot;protected&quot;] = true, [&quot;goto&quot;] = true,
            [&quot;if&quot;] = true, [&quot;static&quot;] = true,  [&quot;const&quot;] = true, [&quot;typedef&quot;] = true,
            [&quot;enum&quot;] = true, [&quot;char&quot;] = true, [&quot;int&quot;] = true, [&quot;bool&quot;] = true,
            [&quot;long&quot;] = true, [&quot;float&quot;] = true, [&quot;true&quot;] = true, [&quot;delete&quot;] = true,
            [&quot;double&quot;] = true,  [&quot;while&quot;] = true, [&quot;new&quot;] = true,
            [&quot;namespace&quot;] = true, [&quot;try&quot;] = true, [&quot;catch&quot;] = true,
            [&quot;switch&quot;] = true, [&quot;case&quot;] = true, [&quot;extern&quot;] = true,
            [&quot;return&quot;] = true,[&quot;default&quot;] = true,[&apos;unsigned&apos;]  = true,[&apos;signed&apos;] = true,
            [&quot;union&quot;] =  true, [&quot;volatile&quot;] = true, [&quot;register&quot;] = true,[&quot;short&quot;] = true,
        }
    end
    if not cpp_matches then
        cpp_matches = {
            {WSPACE,wsdump},
            {PREPRO,pdump},
            {NUMBER3,ndump},
            {IDEN,cpp_vdump},
            {NUMBER4,ndump},
            {NUMBER5,ndump},
            {STRING3,sdump},
            {STRING1,chdump},
            {&apos;^//.-\n&apos;,cdump},
            {&apos;^/%*.-%*/&apos;,cdump},
            {&apos;^==&apos;,tdump},
            {&apos;^!=&apos;,tdump},
            {&apos;^&lt;=&apos;,tdump},
            {&apos;^&gt;=&apos;,tdump},
            {&apos;^-&gt;&apos;,tdump},
            {&apos;^&amp;&amp;&apos;,tdump},
            {&apos;^||&apos;,tdump},
            {&apos;^%+%+&apos;,tdump},
            {&apos;^%-%-&apos;,tdump},
            {&apos;^%+=&apos;,tdump},
            {&apos;^%-=&apos;,tdump},
            {&apos;^%*=&apos;,tdump},
            {&apos;^/=&apos;,tdump},
            {&apos;^|=&apos;,tdump},
            {&apos;^%^=&apos;,tdump},
            {&apos;^::&apos;,tdump},
            {&apos;^.&apos;,tdump}
        }
    end
    return lexer.scan(s,cpp_matches,filter,options)
end

--- get a list of parameters separated by a delimiter from a stream.
-- @param tok the token stream
-- @param endtoken end of list (default &apos;)&apos;). Can be &apos;\n&apos;
-- @param delim separator (default &apos;,&apos;)
-- @return a list of token lists.
function lexer.get_separated_list(tok,endtoken,delim)
    endtoken = endtoken or &apos;)&apos;
    delim = delim or &apos;,&apos;
    local parm_values = {}
    local level = 1 -- used to count ( and )
    local tl = {}
    local function tappend (tl,t,val)
        val = val or t
        append(tl,{t,val})
    end
    local is_end
    if endtoken == &apos;\n&apos; then
        is_end = function(t,val)
            return t == &apos;space&apos; and val:find &apos;\n&apos;
        end
    else
        is_end = function (t)
            return t == endtoken
        end
    end
    local token,value
    while true do
        token,value=tok()
        if not token then return nil,&apos;EOS&apos; end -- end of stream is an error!
        if is_end(token,value) and level == 1 then
            append(parm_values,tl)
            break
        elseif token == &apos;(&apos; then
            level = level + 1
            tappend(tl,&apos;(&apos;)
        elseif token == &apos;)&apos; then
            level = level - 1
            if level == 0 then -- finished with parm list
                append(parm_values,tl)
                break
            else
                tappend(tl,&apos;)&apos;)
            end
        elseif token == delim and level == 1 then
            append(parm_values,tl) -- a new parm
            tl = {}
        else
            tappend(tl,token,value)
        end
    end
    return parm_values,{token,value}
end

--- get the next non-space token from the stream.
-- @param tok the token stream.
function lexer.skipws (tok)
    local t,v = tok()
    while t == &apos;space&apos; do
        t,v = tok()
    end
    return t,v
end

local skipws = lexer.skipws

--- get the next token, which must be of the expected type.
-- Throws an error if this type does not match!
-- @param tok the token stream
-- @param expected_type the token type
-- @param no_skip_ws whether we should skip whitespace
function lexer.expecting (tok,expected_type,no_skip_ws)
    assert_arg(1,tok,&apos;function&apos;)
    assert_arg(2,expected_type,&apos;string&apos;)
    local t,v
    if no_skip_ws then
        t,v = tok()
    else
        t,v = skipws(tok)
    end
    if t ~= expected_type then error (&quot;expecting &quot;..expected_type,2) end
    return v
end

return lexer</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="Backpack" referent="RBX11">
				<Properties>
					<string name="Name">OutputStream</string>
				</Properties>
				<Item class="ModuleScript" referent="RBX12">
					<Properties>
						<string name="Name">OutputStreamInterface</string>
						<ProtectedString name="Source">local ReplicatedStorage       = game:GetService(&quot;ReplicatedStorage&quot;)
local Players                 = game:GetService(&quot;Players&quot;)

local NevermoreEngine         = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary       = NevermoreEngine.LoadLibrary

local qSystems                = LoadCustomLibrary(&quot;qSystems&quot;)
local ScrollBar               = LoadCustomLibrary(&apos;ScrollBar&apos;)
local qGUI                    = LoadCustomLibrary(&apos;qGUI&apos;)
local CircularBuffer          = LoadCustomLibrary(&quot;CircularBuffer&quot;)
local PseudoChatSettings      = LoadCustomLibrary(&quot;PseudoChatSettings&quot;)
local OverriddenConfiguration = LoadCustomLibrary(&quot;OverriddenConfiguration&quot;)
local qTime = LoadCustomLibrary(&quot;qTime&quot;)

qSystems:Import(getfenv(0));

local lib = {}

--- OutputStreamInterface.lua
--- This library handles displaying render streams, from multiple channels.
-- @author Quenty
-- Last modified Janurary 26th, 2014

--[[--Change Log

-- January 26th, 2014
- Add Change log
- Update to use PseudoChatSettings

-- January 5th, 2014
- Wrote initial script

--]]
local DefaultConfiguration = {
&#9;TitleWidth            = 30;
&#9;ContentHeight         = 108; -- Height of the inteface. 
&#9;ScrollbarWidth        = 7;
&#9;ZIndex                = 8;
&#9;FrameRenderBufferSize = PseudoChatSettings.BufferSize;
&#9;
&#9;TitleLabelOffset = 10;
&#9;MenuZIndex       = 9; -- ZIndex of the menu overlay. We&apos;ll try to maintain a [8,9] ZIndex range. 
&#9;MenuAnimateTime  = 0.1;
&#9;MenuDefaultColor = Color3.new(0.5, 0.5, 0.5);
&#9;MenuNameWhenOpen = &quot;Switch Channels?&quot;;
}

local MakeOutputStreamMenu = Class(function(RenderStreamMenu, Parent, ScreenGui, Configuration)
&#9;--- Creates a list of open &quot;Channels&quot; which can be dynamically changed and modified. 
&#9;-- @param OutputStreamInterface The interface that this stream menu is associated with. 
&#9;-- Used internally, Configuration is expected to be sent by the script, all contents intact.

&#9;local MainFrame = Make(&quot;Frame&quot;, {
&#9;&#9;Active                 = false;
&#9;&#9;Archivable             = false;
&#9;&#9;BackgroundColor3       = Color3.new(0.25, 0.25, 0.25);
&#9;&#9;BackgroundTransparency = 0;
&#9;&#9;BorderSizePixel        = 1;
&#9;&#9;Name                   = &quot;MenuFrame&quot;;
&#9;&#9;Position               = UDim2.new(0.5, 0, 0, 0);
&#9;&#9;Size                   = UDim2.new(0.5, 0, 1, 0);
&#9;&#9;ZIndex                 = Configuration.MenuZIndex;
&#9;&#9;Parent                 = Parent;
&#9;})
&#9;RenderStreamMenu.Gui = MainFrame

&#9;local TitleButton = Make(&quot;ImageButton&quot;, {
&#9;&#9;Archivable       = false;
&#9;&#9;BackgroundColor3 = Color3.new(0.25, 0.25, 0.25);
&#9;&#9;BorderSizePixel  = 0;
&#9;&#9;Name             = &quot;TitleButton&quot;;
&#9;&#9;Parent           = MainFrame;
&#9;&#9;Position         = UDim2.new(0, -Configuration.TitleWidth, 0, 0);
&#9;&#9;Size             = UDim2.new(0, Configuration.TitleWidth + 1, 1, 0);
&#9;&#9;ZIndex           = Configuration.MenuZIndex;
&#9;})

&#9;local TitleLabel = Make(&quot;TextLabel&quot;, {
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Name                   = &quot;TitleLabel&quot;;
&#9;&#9;Parent                 = TitleButton;
&#9;&#9;Rotation               = 90;
&#9;&#9;Size                   = UDim2.new(0, TitleButton.AbsoluteSize.Y - Configuration.TitleLabelOffset, 0, Configuration.TitleWidth);
&#9;&#9;Text                   = &quot;Main Menu&quot;;
&#9;&#9;TextColor3             = Color3.new(1, 1, 1);
&#9;&#9;TextXAlignment         = &quot;Right&quot;;
&#9;&#9;ZIndex                 = Configuration.MenuZIndex;
&#9;})
&#9;TitleLabel.Position = UDim2.new(0.5, -(TitleButton.AbsoluteSize.Y) / 2, 0.5, -(Configuration.TitleWidth) / 2);

&#9;local ContentContainer = Make(&quot;Frame&quot;, {
&#9;&#9;Active                 = false;
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;ClipsDescendants       = true;
&#9;&#9;Name                   = &quot;ContentContainer&quot;;
&#9;&#9;Parent                 = MainFrame;
&#9;&#9;Position               = UDim2.new(0, 0, 0, 0);
&#9;&#9;Size                   = UDim2.new(1, -Configuration.ScrollbarWidth, 1, 0);
&#9;&#9;ZIndex                 = Configuration.MenuZIndex;
&#9;&#9;Archivable             = false;
&#9;})

&#9;local ContentFrame = Make(&quot;ImageButton&quot;, {
&#9;&#9;Image                  = &quot;&quot;; 
&#9;&#9;Active                 = false;
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;ClipsDescendants       = true;
&#9;&#9;Name                   = &quot;ContentFrame&quot;;
&#9;&#9;Parent                 = ContentContainer;
&#9;&#9;Position               = UDim2.new(0, 0, 0, 0);
&#9;&#9;Size                   = UDim2.new(1, 0, 1, 0);
&#9;&#9;ZIndex                 = Configuration.MenuZIndex;
&#9;&#9;Archivable             = false;
&#9;})

&#9;local ScrollBarFrame = Make(&quot;Frame&quot;, {
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;BorderSizePixel        = 0; 
&#9;&#9;Name                   = &quot;ScrollBarFrame&quot;;
&#9;&#9;Parent                 = MainFrame;
&#9;&#9;Position               = UDim2.new(1, -Configuration.ScrollbarWidth, 0, 0);
&#9;&#9;Size                   = UDim2.new(0, Configuration.ScrollbarWidth, 1, 0);
&#9;&#9;Visible                = true;
&#9;&#9;ZIndex                 = Configuration.MenuZIndex;
&#9;&#9;Archivable             = false;
&#9;})

&#9;local Scroller = ScrollBar.MakeScroller(ContentContainer, ContentFrame, ScreenGui, &apos;Y&apos;)
&#9;local ScrollBar = Scroller:AddScrollBar(ScrollBarFrame)
&#9;local IsShown = false
&#9;local CurrentColor = Color3.new(0.25, 0.25, 0.25);
&#9;local CurrentTitle = &quot;[ Nothing Active ]&quot;
&#9;local ActiveChoices = {}

&#9;RenderStreamMenu.MenuCollapseChanged = CreateSignal() -- Sends Signal(IsCollapsed)

&#9;local function UpdateChoices()
&#9;&#9;--- Repositions and updates the choices to new locations. 

&#9;&#9;local YPosition = PseudoChatSettings.RenderStreamMenu.ChoiceYPadding;
&#9;&#9;local ChoiceCount = 0
&#9;&#9;for _, Choice in pairs(ActiveChoices) do
&#9;&#9;&#9;ChoiceCount = ChoiceCount + 1
&#9;&#9;&#9;Choice.Gui.Position = UDim2.new(0, PseudoChatSettings.RenderStreamMenu.ChoiceSizeXPadding/2,
&#9;&#9;&#9;&#9;0, YPosition);
&#9;&#9;&#9;YPosition = YPosition + PseudoChatSettings.RenderStreamMenu.ChoiceYPadding + Choice.YHeight
&#9;&#9;end
&#9;&#9;ContentFrame.Size = UDim2.new(1, 0, 0, math.max(YPosition, ContentContainer.AbsoluteSize.Y))

&#9;&#9;if YPosition &gt; ContentContainer.AbsoluteSize.Y then
&#9;&#9;&#9;ScrollBarFrame.Visible = true
&#9;&#9;else
&#9;&#9;&#9;ScrollBarFrame.Visible = false
&#9;&#9;end

&#9;&#9;if ChoiceCount &gt; 1 then
&#9;&#9;&#9;MainFrame.Visible = true
&#9;&#9;else
&#9;&#9;&#9;MainFrame.Visible = false
&#9;&#9;end
&#9;end

&#9;local function UpdateTitleBar(BackgroundColor3, Text, DoNotAnimate)
&#9;&#9;--- Sets the TitleBar, helper function
&#9;&#9;-- @param BackgroundColor3 The new backgroundColor3 to set
&#9;&#9;-- @param Text The text to set
&#9;&#9;-- @param DoNotAnimate Shoudl it animate or not?

&#9;&#9;TitleLabel.Text = Text;

&#9;&#9;if DoNotAnimate then
&#9;&#9;&#9;TitleButton.BackgroundColor3 = BackgroundColor3
&#9;&#9;else
&#9;&#9;&#9;qGUI.TweenColor3(TitleButton, {BackgroundColor3 = BackgroundColor3}, Configuration.MenuAnimateTime, true)
&#9;&#9;end
&#9;end

&#9;local MouseEvent
&#9;local Mouse = Players.LocalPlayer:GetMouse()


&#9;local function Uncollapse(DoNotAnimate)
&#9;&#9;--- Show&apos;s the menu
&#9;&#9;-- @param [DoNotAnimate] If indicated, will not animate the menu when showing or hiding. 

&#9;&#9;-- If they don&apos;t click on the menu, hide it.
&#9;&#9;if not MouseEvent then
&#9;&#9;&#9;MouseEvent = Mouse.Button1Down:connect(function()
&#9;&#9;&#9;&#9;if not qGUI.MouseOver(Mouse, MainFrame) and not qGUI.MouseOver(Mouse, MainFrame) then
&#9;&#9;&#9;&#9;&#9;RenderStreamMenu.Collapse()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end

&#9;&#9;IsShown = true
&#9;&#9;local Position = UDim2.new(0.5, 0, 0, 0)
&#9;&#9;UpdateTitleBar(Configuration.MenuDefaultColor, Configuration.MenuNameWhenOpen, DoNotAnimate)

&#9;&#9;if DoNotAnimate then
&#9;&#9;&#9;MainFrame.Position = Position
&#9;&#9;else
&#9;&#9;&#9;MainFrame:TweenPosition(Position, &quot;Out&quot;, &quot;Sine&quot;, Configuration.MenuAnimateTime, true)
&#9;&#9;end

&#9;&#9;RenderStreamMenu.MenuCollapseChanged:fire(false)
&#9;end
&#9;RenderStreamMenu.Uncollapse = Uncollapse
&#9;RenderStreamMenu.uncollapse = Uncollapse

&#9;local function Collapse(DoNotAnimate)
&#9;&#9;--- Hide&apos;s the menu
&#9;&#9;-- @param [DoNotAnimate] If indicated, will not animate the menu when showing or hiding. 

&#9;&#9;if MouseEvent then
&#9;&#9;&#9;MouseEvent:disconnect()
&#9;&#9;&#9;MouseEvent = nil
&#9;&#9;end

&#9;&#9;IsShown = false
&#9;&#9;local Position = UDim2.new(1, 0, 0, 0)
&#9;&#9;UpdateTitleBar(CurrentColor, CurrentTitle, DoNotAnimate)

&#9;&#9;if DoNotAnimate then
&#9;&#9;&#9;MainFrame.Position = Position
&#9;&#9;else
&#9;&#9;&#9;MainFrame:TweenPosition(Position, &quot;Out&quot;, &quot;Sine&quot;, Configuration.MenuAnimateTime, true)
&#9;&#9;end

&#9;&#9;RenderStreamMenu.MenuCollapseChanged:fire(true)
&#9;end
&#9;RenderStreamMenu.Collapse = Collapse
&#9;RenderStreamMenu.Collapse = Collapse

&#9;local CurrentTransparency

&#9;local function SetTransparency(NewTransparency, AnimateTime)
&#9;&#9;--- Sets the transparency of the Interface to NewTransparency
&#9;&#9;-- @param NewTransparency The transparency to set it to
&#9;&#9;-- @param AnimateTime The time to animate. If not provided, will do it instantly. 

&#9;&#9;assert(NewTransparency ~= nil, &quot;NewTransparency is nil.&quot;)

&#9;&#9;if CurrentTransparency ~= NewTransparency then -- Make sure we don&apos;t waste processing power. 
&#9;&#9;&#9;CurrentTransparency = NewTransparency
&#9;&#9;&#9;if AnimateTime then
&#9;&#9;&#9;&#9;qGUI.TweenTransparency(MainFrame, {BackgroundTransparency = NewTransparency}, AnimateTime, true)
&#9;&#9;&#9;&#9;qGUI.TweenTransparency(TitleButton, {BackgroundTransparency = NewTransparency}, AnimateTime, true)
&#9;&#9;&#9;&#9;qGUI.TweenTransparency(TitleLabel, {TextTransparency = NewTransparency}, AnimateTime, true)
&#9;&#9;&#9;&#9;for _, Item in pairs(ActiveChoices) do
&#9;&#9;&#9;&#9;&#9;qGUI.TweenTransparency(Item.Gui, {BackgroundTransparency = NewTransparency}, AnimateTime, true)
&#9;&#9;&#9;&#9;&#9;qGUI.TweenTransparency(Item.Gui.ChoiceLabel, {TextTransparency = NewTransparency}, AnimateTime, true)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;qGUI.StopTransparencyTween(MainFrame)
&#9;&#9;&#9;&#9;qGUI.StopTransparencyTween(TitleButton)
&#9;&#9;&#9;&#9;qGUI.StopTransparencyTween(TitleLabel)
&#9;&#9;&#9;&#9;MainFrame.BackgroundTransparency = NewTransparency
&#9;&#9;&#9;&#9;TitleButton.BackgroundTransparency = NewTransparency
&#9;&#9;&#9;&#9;TitleLabel.TextTransparency = NewTransparency
&#9;&#9;&#9;&#9;for _, Item in pairs(ActiveChoices) do
&#9;&#9;&#9;&#9;&#9;qGUI.StopTransparencyTween(Item.Gui) 
&#9;&#9;&#9;&#9;&#9;qGUI.StopTransparencyTween(Item.Gui.ChoiceLabel)

&#9;&#9;&#9;&#9;&#9;Item.Gui.BackgroundTransparency = NewTransparency
&#9;&#9;&#9;&#9;&#9;Item.Gui.ChoiceLabel.BackgroundTransparency = NewTransparency
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;RenderStreamMenu.SetTransparency = SetTransparency
&#9;RenderStreamMenu.setTransparency = SetTransparency

&#9;local function SetColorAndTitle(Color, Title)
&#9;&#9;-- Sets the color and title of the Menu that it will display while &quot;Hidden.&quot; &quot;
&#9;&#9;-- @param Color A Color3, the color of the menu to set.
&#9;&#9;-- @param Title The title to show.

&#9;&#9;CurrentColor = Color
&#9;&#9;CurrentTitle = Title
&#9;&#9;if not IsShown then
&#9;&#9;&#9;UpdateTitleBar(Color, Title)
&#9;&#9;end
&#9;end
&#9;RenderStreamMenu.SetColorAndTitle = SetColorAndTitle
&#9;RenderStreamMenu.setColorAndTitle = SetColorAndTitle


&#9;local function Toggle(DoNotAnimate)
&#9;&#9;--- Toggle&apos;s the menu&apos;s visibility. 
&#9;&#9;-- @param [DoNotAnimate] If indicated, will not animate the menu when showing or hiding. 

&#9;&#9;if IsShown then
&#9;&#9;&#9;Collapse(DoNotAnimate)
&#9;&#9;else
&#9;&#9;&#9;Uncollapse(DoNotAnimate)
&#9;&#9;end
&#9;end
&#9;RenderStreamMenu.Toggle = Toggle
&#9;RenderStreamMenu.toggle = Toggle

&#9;local function MakeChoice(Text, BackgroundColor3)
&#9;&#9;--- Creates a new &quot;Choice&quot; GUI, for further manipulation.
&#9;&#9;-- @param [BackgroundColor3] The color3 value of the background
&#9;&#9;-- @param Text The text to display on the button.
&#9;&#9;-- @return The new choice

&#9;&#9;BackgroundColor3 = BackgroundColor3 or Color3.new(0, 0, 0)

&#9;&#9;local NewChoice = {}

&#9;&#9;NewChoice.BackgroundColor3 = BackgroundColor3
&#9;&#9;NewChoice.Text = Text
&#9;&#9;
&#9;&#9;NewChoice.Gui = Make(&quot;TextButton&quot;, {
&#9;&#9;&#9;Archivable             = false;
&#9;&#9;&#9;BackgroundColor3       = BackgroundColor3;
&#9;&#9;&#9;BackgroundTransparency = 0.3;
&#9;&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;&#9;FontSize               = PseudoChatSettings.ChatFontSize;
&#9;&#9;&#9;Name                   = &quot;ChoiceButton&quot;;
&#9;&#9;&#9;Parent                 = ContentFrame;
&#9;&#9;&#9;Size                   = UDim2.new(1, -PseudoChatSettings.RenderStreamMenu.ChoiceSizeXPadding, 0, PseudoChatSettings.RenderStreamMenu.ChoiceSizeY);
&#9;&#9;&#9;Text                   = &quot;&quot;;
&#9;&#9;&#9;Visible                = true;
&#9;&#9;&#9;ZIndex                 = Configuration.MenuZIndex;
&#9;&#9;&#9;Make(&quot;TextLabel&quot;, {
&#9;&#9;&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;&#9;&#9;Name                   = &quot;ChoiceLabel&quot;;
&#9;&#9;&#9;&#9;Position               = UDim2.new(0, 10, 0, 0);
&#9;&#9;&#9;&#9;Size                   = UDim2.new(1, -10, 1, 0);
&#9;&#9;&#9;&#9;Text                   = Text;
&#9;&#9;&#9;&#9;TextColor3             = Color3.new(1, 1, 1);
&#9;&#9;&#9;&#9;TextXAlignment         = &quot;Left&quot;;
&#9;&#9;&#9;&#9;ZIndex                 = Configuration.MenuZIndex
&#9;&#9;&#9;});
&#9;&#9;});
&#9;&#9;NewChoice.YHeight = PseudoChatSettings.RenderStreamMenu.ChoiceSizeY

&#9;&#9;ActiveChoices[#ActiveChoices + 1] = NewChoice

&#9;&#9;function NewChoice:Destroy()
&#9;&#9;&#9;-- For the GC of the choice.

&#9;&#9;&#9;local Index = GetIndexByValue(ActiveChoices, NewChoice)

&#9;&#9;&#9;NewChoice.Gui:Destroy()
&#9;&#9;&#9;NewChoice.Destroy = nil
&#9;&#9;&#9;NewChoice         = nil

&#9;&#9;&#9;table.remove(ActiveChoices, Index)
&#9;&#9;&#9;UpdateChoices()
&#9;&#9;end

&#9;&#9;UpdateChoices()
&#9;&#9;return NewChoice
&#9;end
&#9;RenderStreamMenu.MakeChoice = MakeChoice
&#9;RenderStreamMenu.makeChoice = MakeChoice

&#9;local function GetIsShown()
&#9;&#9;return IsShown
&#9;end
&#9;RenderStreamMenu.GetIsShown = GetIsShown
&#9;RenderStreamMenu.getIsShown = GetIsShown

&#9;-- Setup events
&#9;TitleButton.MouseButton1Click:connect(function()
&#9;&#9;Toggle()
&#9;end)

&#9;Collapse(true)
&#9;UpdateChoices()
end)

local MakeNotifier = Class(function(Notifier, ContentContainer, IsTop)
&#9;-- Used by the OutputStreamRender, creates a notification bar.
&#9;-- @param ContentContainer The parent of the NotificationBar
&#9;-- @param IsTop Boolean, if true, then it goes at the top, otherwise it goes to the top.

&#9;local Configuration = {
&#9;&#9;Height = 25;
&#9;&#9;ZIndex = DefaultConfiguration.ZIndex + 1;
&#9;}

&#9;local NotificationBar = Make(&quot;ImageButton&quot;, {
&#9;&#9;Visible                = true;
&#9;&#9;BackgroundTransparency = 0;
&#9;&#9;Parent                 = ContentContainer;
&#9;&#9;Name                   = &quot;Notification&quot;;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;BackgroundColor3       = Color3.new(51/255, 102/255, 204/255);
&#9;&#9;Size                   = UDim2.new(1, 0, 0, Configuration.Height);
&#9;&#9;Position               = UDim2.new(0, 0, 1, 0);
&#9;&#9;Archivable             = false;
&#9;&#9;ZIndex                 = Configuration.ZIndex;
&#9;})
&#9;Notifier.Gui = NotificationBar

&#9;local TextLabel = Make(&quot;TextLabel&quot;, {
&#9;&#9;Parent                 = NotificationBar;
&#9;&#9;TextColor3             = Color3.new(1, 1, 1);
&#9;&#9;Size                   = UDim2.new(1, -10, 1, 0);
&#9;&#9;Position               = UDim2.new(0, 10, 0, 0);
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Visible                = true;
&#9;&#9;Archivable             = false;
&#9;&#9;ZIndex                 = NotificationBar.ZIndex;
&#9;&#9;Text                   = &quot;&quot;;
&#9;&#9;TextXAlignment         = &quot;Left&quot;;
&#9;})

&#9;local IsVisible
&#9;local ShowPosition
&#9;local HidePosition

&#9;if IsTop then
&#9;&#9;ShowPosition = UDim2.new(0, 0, 0, 0)
&#9;&#9;HidePosition = UDim2.new(0, 0, 0, -Configuration.Height);
&#9;else
&#9;&#9;ShowPosition = UDim2.new(0, 0, 1, -Configuration.Height)
&#9;&#9;HidePosition = UDim2.new(0, 0, 1, 0);
&#9;end

&#9;local function Show(DoNotAnimate)
&#9;&#9;--- Show&apos;s the Notification bar. Updates the IsVisible variable to true
&#9;&#9;-- @param DoNotAnimate Boolean, if true, then it will not animate when showing, otherwise it will tween

&#9;&#9;IsVisible = true

&#9;&#9;if DoNotAnimate then
&#9;&#9;&#9;NotificationBar.Position = ShowPosition
&#9;&#9;else&#9;
&#9;&#9;&#9;NotificationBar:TweenPosition(ShowPosition, &quot;Out&quot;, &quot;Sine&quot;, 0.2, true)
&#9;&#9;end
&#9;end
&#9;Notifier.Show = Show

&#9;local function Hide(DoNotAnimate)
&#9;&#9;--- Hide&apos;s the Notification bar. Updates the IsVisible variable to false
&#9;&#9;-- @param DoNotAnimate Boolean, if true, then it will not animate when hiding, otherwise it will tween

&#9;&#9;IsVisible = false

&#9;&#9;if DoNotAnimate then
&#9;&#9;&#9;NotificationBar.Position = HidePosition
&#9;&#9;else
&#9;&#9;&#9;NotificationBar:TweenPosition(HidePosition, &quot;In&quot;, &quot;Sine&quot;, 0.2, true)
&#9;&#9;end
&#9;end
&#9;Notifier.Hide = Hide

&#9;local function SetText(NewText)
&#9;&#9;if not IsVisible then
&#9;&#9;&#9;Show()
&#9;&#9;end

&#9;&#9;TextLabel.Text = NewText;
&#9;end
&#9;Notifier.SetText = SetText

&#9;Hide(true)
end)

local MakeOutputStreamRender = Class(function(OutputStreamRender, Configuration, ScreenGui)
&#9;--- Render&apos;s a single stream, actual &quot;view&quot; model versus DataStreamRender conceptual model. 
&#9;-- @param FrameRenderBufferSize Number The amount of frames to render.
&#9;--                              This get&apos;s kind of messy when it comes down to it, because a render can be used by multiple
&#9;--                              classes. A standardized number should be used. 

&#9;local Configuration = OverriddenConfiguration.New(Configuration, DefaultConfiguration)
&#9;local Buffer   = CircularBuffer.New(Configuration.FrameRenderBufferSize)
&#9;OutputStreamRender.Buffer = Buffer
&#9;-- Make the new frame containing the whole thing. Will also hold the scroll bar. 
&#9;local MainFrame = Make(&quot;Frame&quot;, {
&#9;&#9;Active                 = false;
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Name                   = &quot;OutputStreamRender&quot;;
&#9;&#9;Size                   = UDim2.new(1, 0, 1, 0);
&#9;&#9;ZIndex                 = Configuration.ZIndex;
&#9;&#9;Archivable             = false;
&#9;})
&#9;OutputStreamRender.Gui = MainFrame

&#9;local ContentContainer = Make(&quot;Frame&quot;, {
&#9;&#9;Active                 = false;
&#9;&#9;BackgroundTransparency  = 1;
&#9;&#9;ClipsDescendants       = true;
&#9;&#9;Name                   = &quot;ContentContainer&quot;;
&#9;&#9;Parent                 = MainFrame;
&#9;&#9;Position               = UDim2.new(0, 0, 0, 0);
&#9;&#9;Size                   = UDim2.new(1, -Configuration.ScrollbarWidth, 1, 0);
&#9;&#9;ZIndex                 = Configuration.ZIndex;
&#9;})

&#9;local ContentFrameClass = &quot;ImageButton&quot;;
&#9;if qGUI.IsPhone(ScreenGui) then
&#9;&#9;ContentFrameClass = &quot;Frame&quot;;
&#9;end


&#9;local ContentFrame = Make(ContentFrameClass, {
&#9;&#9;Active                 = false;
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;ClipsDescendants       = true;
&#9;&#9;Name                   = &quot;ContentFrame&quot;;
&#9;&#9;Parent                 = ContentContainer;
&#9;&#9;Position               = UDim2.new(0, 0, 0, 0);
&#9;&#9;Size                   = UDim2.new(1, 0, 1, 0);
&#9;&#9;ZIndex                 = Configuration.ZIndex;
&#9;})
&#9;OutputStreamRender.ContentFrame = ContentFrame

&#9;if ContentFrameClass == &quot;ImageButton&quot; then
&#9;&#9;ContentFrame.Image = &quot;&quot;; 
&#9;end

&#9;local ScrollBarFrame = Make(&quot;Frame&quot;, {
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;BorderSizePixel        = 0; 
&#9;&#9;Name                   = &quot;ScrollBarFrame&quot;;
&#9;&#9;Parent                 = MainFrame;
&#9;&#9;Position               = UDim2.new(1, -Configuration.ScrollbarWidth, 0, 0);
&#9;&#9;Size                   = UDim2.new(0, Configuration.ScrollbarWidth, 1, 0);
&#9;&#9;Visible                = true;
&#9;&#9;ZIndex                 = Configuration.ZIndex;
&#9;&#9;Archivable             = false;
&#9;})

&#9;local NotifierTop           = MakeNotifier(ContentContainer, true)
&#9;local NotifierBottom        = MakeNotifier(ContentContainer, false)
&#9;
&#9;local Scroller              = ScrollBar.MakeScroller(ContentContainer, ContentFrame, ScreenGui, &apos;Y&apos;)
&#9;OutputStreamRender.Scroller = Scroller
&#9;local ScrollBar             = Scroller:AddScrollBar(ScrollBarFrame)
&#9;local ScrollBarAtBottom     = true
&#9;local IsScrolling           = false
&#9;local IsAutoScrolling       = false -- Is the porgram scrolling by itself? 

&#9;--[[local function IsItemGuiVisible(Gui)
&#9;&#9;--- Calculates whether or not the player can see the label.
&#9;&#9;-- Used internally.

&#9;&#9;if MainFrame.Visible then
&#9;&#9;&#9;local PositionY = Gui.AbsolutePosition.Y
&#9;&#9;&#9;if ContentContainer.AbsolutePosition.Y &gt;= PositionY and (ContentContainer.AbsolutePosition.Y + ContentContainer.Size.Y.Offset) &lt;= PositionY then
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;PositionY = PositionY + Gui.Size.Y.Offset
&#9;&#9;&#9;&#9;return ContentContainer.AbsolutePosition.Y &gt;= PositionY and (ContentContainer.AbsolutePosition.Y + ContentContainer.Size.Y.Offset) &lt;= PositionY 
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;end--]]

&#9;local function DoShowInterface()
&#9;&#9;--- Returns whether or not the interface shoudl be shown.
&#9;&#9;-- Not efficient, but readable, which is more important.
&#9;&#9;-- @return boolean Should be shown, if true, otherwise, false

&#9;&#9;-- print(IsScrolling, IsAutoScrolling, ScrollBarAtBottom)

&#9;&#9;if IsScrolling or IsAutoScrolling then
&#9;&#9;&#9;return true
&#9;&#9;elseif not ScrollBarAtBottom then
&#9;&#9;&#9;return true
&#9;&#9;end

&#9;&#9;return false
&#9;end
&#9;OutputStreamRender.DoShowInterface = DoShowInterface
&#9;OutputStreamRender.doShowInterface = DoShowInterface

&#9;local function RemoveOldItem(OldItem)
&#9;&#9;--- GC&apos;s an old item, removing from the qeueue. 
&#9;&#9;-- @param OldItem An old item in the equeue, created by RenderNew in the DataStreamRender class.
&#9;&#9;
&#9;&#9;OldItem.Gui:Destroy()
&#9;end

&#9;local function HideScrollBar(AnimateTime)
&#9;&#9;--- Makes the scroll bar invisible

&#9;&#9;-- print(&quot;Hideing scroll bar&quot;)
&#9;&#9;-- ScrollBarFrame.Visible = false
&#9;&#9;if AnimateTime &lt;= 0 then
&#9;&#9;&#9;ScrollBarFrame.ScrollBar.Backing.BackgroundTransparency = 1
&#9;&#9;else
&#9;&#9;&#9;qGUI.TweenTransparency(ScrollBarFrame.ScrollBar.Backing, {BackgroundTransparency = 1}, AnimateTime, true)
&#9;&#9;end
&#9;&#9;
&#9;end
&#9;OutputStreamRender.HideScrollBar = HideScrollBar
&#9;OutputStreamRender.hideScrollBar = HideScrollBar

&#9;local function ShowScrollBar(AnimateTime)
&#9;&#9;--- Makes the scroll bar visible.

&#9;&#9;-- print(&quot;Showing scroll bar&quot;)
&#9;&#9;-- ScrollBarFrame.Visible = true
&#9;&#9;if AnimateTime &lt;= 0 then
&#9;&#9;&#9;ScrollBarFrame.ScrollBar.Backing.BackgroundTransparency = 0.5
&#9;&#9;else
&#9;&#9;&#9;qGUI.TweenTransparency(ScrollBarFrame.ScrollBar.Backing, {BackgroundTransparency = 0.5}, AnimateTime, true)
&#9;&#9;end
&#9;end
&#9;OutputStreamRender.ShowScrollBar = ShowScrollBar
&#9;OutputStreamRender.showScrollBar = ShowScrollBar

&#9;local function GetScrollBarAtBottom()
&#9;&#9;--- Check&apos;s to see if the scroll bar is at the bottom or not
&#9;&#9;-- @return Boolean, true if the scroll bar is at the bottom. 
&#9;&#9;-- Used internally.

&#9;&#9;return Scroller.KineticModel.Position &lt;= Scroller.KineticModel.Minimum + 2
&#9;end

&#9;local function ScrollToBottom(DoNotAnimate)
&#9;&#9;--- Scrolls the scrol bar to the bottom. 
&#9;&#9;-- print(DoNotAnimate)
&#9;&#9;Scroller:AdjustRange() -- Unfortunately, the event fires slow otherwise. 
&#9;&#9;Scroller.ScrollTo(ContentContainer.AbsoluteSize.Y - ContentFrame.AbsoluteSize.Y, DoNotAnimate)
&#9;end
&#9;OutputStreamRender.ScrollToBottom = ScrollToBottom
&#9;OutputStreamRender.ScrollToBottom = ScrollToBottom

&#9;local function UpdateInterface(IsActive)
&#9;&#9;if IsActive then
&#9;&#9;&#9;ShowScrollBar()
&#9;&#9;else
&#9;&#9;&#9;HideScrollBar()
&#9;&#9;end
&#9;end
&#9;OutputStreamRender.UpdateInterface = UpdateInterface
&#9;OutputStreamRender.updateInterface = UpdateInterface

&#9;local LastFrameHeight = ContentFrame.Size.Y.Offset

&#9;local function TimeStampToText(TimeStamp)
&#9;&#9;-- Converts the time stamp into something more relative...
&#9;&#9;-- @param TimeStamp A time stamp

&#9;&#9;local RenderTimePass = &quot;[ Error ]&quot;
&#9;&#9;if TimeStamp &lt; 20 then
&#9;&#9;&#9;RenderTimePass = &quot;a few seconds&quot;;
&#9;&#9;elseif TimeStamp &lt; 60 then
&#9;&#9;&#9;RenderTimePass = &quot;less than a minute&quot;;
&#9;&#9;elseif TimeStamp &lt; 120 then
&#9;&#9;&#9;RenderTimePass = &quot;1 minute&quot;
&#9;&#9;elseif TimeStamp &lt; 3600 then
&#9;&#9;&#9;RenderTimePass = qTime.GetMinute(TimeStamp) .. &quot; minutes&quot;
&#9;&#9;elseif TimeStamp &lt; 216000 then
&#9;&#9;&#9;RenderTimePass = &quot;about 1 hour&quot;
&#9;&#9;elseif TimeStamp &lt; 219600 then
&#9;&#9;&#9;RenderTimePass = &quot;about &quot; .. qTime.GetHour(TimeStamp) .. &quot; hours&quot;
&#9;&#9;else
&#9;&#9;&#9;RenderTimePass = qTime.GetDayOfTheWeek(SmallestTimeStamp) -- If this ever ever happens in a ROBLOX server, I may die. 
&#9;&#9;end

&#9;&#9;return RenderTimePass
&#9;end

&#9;local function UpdateSeenCount(TopOfWindow, BottomOfWindow)
&#9;&#9;---[[
&#9;&#9;local ItemsNotSeenBelow = 0;
&#9;&#9;local ItemsNotSeenAbove = 0;
&#9;&#9;local SmallestTimeStampBelow = tick()
&#9;&#9;local SmallestTimeStampAbove = tick()

&#9;&#9;local DataBuffer = Buffer:GetData()

&#9;&#9;for Index = #DataBuffer, 1, -1 do
&#9;&#9;&#9;local Item = DataBuffer[Index]
&#9;&#9;&#9;
&#9;&#9;&#9;if not Item.Seen then
&#9;&#9;&#9;&#9;local YPosition = Item.Gui.AbsolutePosition.Y

&#9;&#9;&#9;&#9;--NEW MENTAL THOUGHTS: Get distance from visible space.


&#9;&#9;&#9;&#9;local DistanceFromTop = TopOfWindow - (YPosition + Item.Gui.AbsoluteSize.Y)
&#9;&#9;&#9;&#9;local DistanceFromBottom = YPosition - BottomOfWindow

&#9;&#9;&#9;&#9;if DistanceFromTop &gt;= 0 then -- We are above the frame.
&#9;&#9;&#9;&#9;&#9;ItemsNotSeenAbove = ItemsNotSeenAbove + 1
&#9;&#9;&#9;&#9;elseif DistanceFromBottom &gt;= 0 then
&#9;&#9;&#9;&#9;&#9;ItemsNotSeenBelow = ItemsNotSeenBelow + 1
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;Item.Seen = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;if ItemsNotSeenBelow &gt; 0 then
&#9;&#9;&#9;NotifierBottom.SetText(ItemsNotSeenBelow .. &quot; unread message&quot; .. ((ItemsNotSeenBelow == 1) and &quot;&quot; or &quot;s&quot;) .. &quot; (&quot; .. TimeStampToText(tick() - SmallestTimeStampBelow) .. &quot;)&quot;)
&#9;&#9;else
&#9;&#9;&#9;NotifierBottom.Hide()
&#9;&#9;end

&#9;&#9;if ItemsNotSeenAbove &gt; 0 then
&#9;&#9;&#9;NotifierTop.SetText(ItemsNotSeenAbove .. &quot; unread message&quot; .. ((ItemsNotSeenAbove == 1) and &quot;&quot; or &quot;s&quot;) .. &quot; (&quot; .. TimeStampToText(tick() - SmallestTimeStampAbove) .. &quot;)&quot;)
&#9;&#9;else
&#9;&#9;&#9;NotifierTop.Hide()
&#9;&#9;end
&#9;end


&#9;local function Update(DoNotAnimate, OldItemChange)
&#9;&#9;--- Updates positions and rendering.
&#9;&#9;-- @param DoNotAnimate Set to true if you do not want to animate

&#9;&#9;local WasAtBottom = ScrollBarAtBottom
&#9;&#9;local CurrentHeight = 0

&#9;&#9;local DataBuffer = Buffer:GetData()

&#9;&#9;for Index = #DataBuffer, 1, -1 do
&#9;&#9;&#9;local Item = DataBuffer[Index]
&#9;&#9;&#9;Item.Gui.Position = UDim2.new(0, 0, 0, CurrentHeight)
&#9;&#9;&#9;CurrentHeight = CurrentHeight + Item.Gui.Size.Y.Offset
&#9;&#9;end

&#9;&#9;-- for _, Element in ipairs(Buffer:GetData()) do
&#9;&#9;&#9;-- CurrentHeight = CurrentHeight + Element.Gui.Size.Y.Offset
&#9;&#9;&#9;-- Element.Gui.Position = UDim2.new(0, 0, 1, -CurrentHeight)
&#9;&#9;-- end

&#9;&#9;ContentFrame.Size = UDim2.new(1, 0, 0, math.max(CurrentHeight, ContentContainer.AbsoluteSize.Y))
&#9;&#9;local ChangeInSize = (LastFrameHeight - ContentFrame.Size.Y.Offset)
&#9;&#9;LastFrameHeight = ContentFrame.Size.Y.Offset

&#9;&#9;-- Only auto scroll if we are already auto scrolling and the user is not scrolling.
&#9;&#9;if not IsScrolling or IsAutoScrolling then
&#9;&#9;&#9;if WasAtBottom then
&#9;&#9;&#9;&#9;-- Autoscroll down if we&apos;re already at the bottom. 
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- IsAutoScrolling = true
&#9;&#9;&#9;&#9;ScrollToBottom(true)
&#9;&#9;&#9;elseif OldItemChange ~= 0 then
&#9;&#9;&#9;&#9;if Scroller.KineticModel.Position &lt; -OldItemChange then
&#9;&#9;&#9;&#9;&#9;-- Stay even, unless we&apos;re at the very end. 
&#9;&#9;&#9;&#9;&#9;-- print(&quot;Item was not at bottom; ChangeInIndex = &quot; .. ChangeInIndex .. &quot; Scroller.KineticModel.Position = &quot; .. Scroller.KineticModel.Position)
&#9;&#9;&#9;&#9;&#9;print(&quot;Current Position @ &quot; .. Scroller.KineticModel.Position .. &quot;! OldItemChange is &quot; .. OldItemChange)
&#9;&#9;&#9;&#9;&#9;-- Scroller.ScrollTo(Scroller.KineticModel.Position + ChangeInIndex, true)
&#9;&#9;&#9;&#9;&#9;IsAutoScrolling = true
&#9;&#9;&#9;&#9;&#9;Scroller.ScrollTo(Scroller.KineticModel.Position + OldItemChange, true)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;IsAutoScrolling = true
&#9;&#9;&#9;&#9;&#9;Scroller.ScrollTo(0, true)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;UpdateSeenCount(ContentContainer.AbsolutePosition.Y, ContentContainer.AbsolutePosition.Y + ContentContainer.AbsoluteSize.Y)
&#9;&#9;LastHeight = CurrentHeight
&#9;end

&#9;local function Insert(Index, NewElement, DoNotAnimate)
&#9;&#9;local OldItem = Buffer:Insert(Index, NewElement)
&#9;&#9;local Change = 0

&#9;&#9;-- Garbage collect
&#9;&#9;if OldItem then
&#9;&#9;&#9;Change = OldItem.Gui.Size.Y.Offset
&#9;&#9;&#9;RemoveOldItem(OldItem)
&#9;&#9;end

&#9;&#9;NewElement.Seen = false&#9;-- NewElement.Seen = IsItemGuiVisible(NewElement.Gui);

&#9;&#9;Update(DoNotAnimate, Change)
&#9;end
&#9;OutputStreamRender.Insert = Insert
&#9;OutputStreamRender.insert = Insert

&#9;--------------------
&#9;-- CONNECT EVENTS --
&#9;--------------------

&#9;-- Scroll events. 
&#9;local StartScrollPosition = 0
&#9;local TopOfWindow = 0
&#9;local BottomOfWindow = 0

&#9;--[[
&#9;0     StartPosition


&#9;-5000 EndPosition
&#9;-----------
&#9;0 EndPosition

&#9;-5000 StartPosition
&#9;---]]
&#9;Scroller.ScrollStarted:connect(function(Position)
&#9;&#9;StartScrollPosition = ContentFrame.AbsolutePosition.Y -- Let&apos;s say this is -200 out of -400 max range.
&#9;&#9;TopOfWindow, BottomOfWindow = ContentContainer.AbsolutePosition.Y, ContentContainer.AbsolutePosition.Y + ContentContainer.AbsoluteSize.Y

&#9;&#9;IsScrolling = true -- We scroll to -300 (So we&apos;ve scrolled up) We need to catch 
&#9;end)

&#9;Scroller.ScrollFinished:connect(function(KineticEndPosition)
&#9;&#9;if IsAutoScrolling then -- Make sure it isn&apos;t the program that is scrolling. 
&#9;&#9;&#9;IsAutoScrolling = false
&#9;&#9;else
&#9;&#9;&#9;local ChangeInPosition = ContentFrame.AbsolutePosition.Y - StartScrollPosition
&#9;&#9;&#9;if ChangeInPosition ~= 0 then
&#9;&#9;&#9;&#9;-- local EndPosition
&#9;&#9;&#9;&#9;-- local StartPosition

&#9;&#9;&#9;&#9;if ChangeInPosition &gt; 0 then
&#9;&#9;&#9;&#9;&#9;-- Moved up


&#9;&#9;&#9;&#9;&#9;UpdateSeenCount(ContentContainer.AbsolutePosition.Y, BottomOfWindow)

&#9;&#9;&#9;&#9;&#9;-- EndPosition = ContentContainer.AbsolutePosition.Y
&#9;&#9;&#9;&#9;&#9;-- StartPosition = ContentContainer.AbsolutePosition.Y + ContentContainer.AbsoluteSize.Y + ChangeInPosition
&#9;&#9;&#9;&#9;&#9;-- print(&quot;Scroll Up: StartPosition = &quot; .. StartPosition .. &quot; :: EndPosition = &quot; .. EndPosition)
&#9;&#9;&#9;&#9;elseif ChangeInPosition &lt; 0 then
&#9;&#9;&#9;&#9;&#9;-- Moved down 

&#9;&#9;&#9;&#9;&#9;UpdateSeenCount(TopOfWindow, ContentContainer.AbsolutePosition.Y + ContentContainer.AbsoluteSize.Y)

&#9;&#9;&#9;&#9;&#9;-- EndPosition = ContentContainer.AbsolutePosition.Y + ContentContainer.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;-- StartPosition = ContentContainer.AbsolutePosition.Y + ChangeInPosition
&#9;&#9;&#9;&#9;&#9;-- print(&quot;Scroll Down: StartPosition = &quot; .. StartPosition .. &quot; :: EndPosition = &quot; .. EndPosition)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;IsScrolling = false
&#9;&#9;ScrollBarAtBottom = GetScrollBarAtBottom()
&#9;end)
end)

local MakeOutputStreamInterface = Class(function(OutputStreamInterface, Configuration, ScreenGui)
&#9;-- Creates an interactive interface that allows for multiple incoming channels, et cetera. 

&#9;local Configuration = OverriddenConfiguration.New(Configuration, DefaultConfiguration)
&#9;local Subscribed = {} -- Maintain list of subscribed units. 


&#9;local MainFrame = Make(&quot;ImageButton&quot;, {
&#9;&#9;Active                 = false;
&#9;&#9;BackgroundColor3       = Color3.new(0, 0, 0);
&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;Name                   = &quot;OutputStreamInterface&quot;;
&#9;&#9;Parent                 = ScreenGui;
&#9;&#9;Size                   = qGUI.IsPhone(ScreenGui) and -- Some really horrible calculatinzsdf
&#9;&#9;                         UDim2.new(0, 280 + Configuration.TitleWidth + Configuration.ScrollbarWidth, 0, Configuration.ContentHeight + PseudoChatSettings.LineHeight) 
&#9;&#9;                         or UDim2.new(0, 500 + Configuration.TitleWidth + Configuration.ScrollbarWidth, 0, Configuration.ContentHeight + PseudoChatSettings.LineHeight);
&#9;&#9;ZIndex                 = Configuration.MenuZIndex - 1;
&#9;&#9;ClipsDescendants       = true;
&#9;&#9;Position = UDim2.new(0, 0, 0, 6);
&#9;})
&#9;OutputStreamInterface.Gui = MainFrame

&#9;local ContentContainer = Make(&quot;Frame&quot;, {
&#9;&#9;Active                 = false;
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;ClipsDescendants       = true;
&#9;&#9;Name                   = &quot;ContentContainer&quot;;
&#9;&#9;Parent                 = MainFrame;
&#9;&#9;Position               = UDim2.new(0, 0, 0, 0);
&#9;&#9;Size                   = UDim2.new(1, -Configuration.TitleWidth, 1, 0);
&#9;&#9;ZIndex                 = Configuration.ZIndex;
&#9;})

&#9;local Menu      = MakeOutputStreamMenu(MainFrame, ScreenGui, Configuration)
&#9;local ActiveSubscriber
&#9;local Mouse     = Players.LocalPlayer:GetMouse()
&#9;local MouseOver = qGUI.MouseOver(Mouse, MainFrame)

&#9;local function DoShowInterface()
&#9;&#9;if MouseOver then --qGUI.MouseOver(Mouse, MainFrame) then
&#9;&#9;&#9;return true
&#9;&#9;elseif Menu.GetIsShown() then
&#9;&#9;&#9;return true
&#9;&#9;elseif ActiveSubscriber then
&#9;&#9;&#9;return ActiveSubscriber.RenderFrame.DoShowInterface()
&#9;&#9;else
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;end

&#9;local function UpdateVisibility(DoNotAnimate)
&#9;&#9;if DoShowInterface() then
&#9;&#9;&#9;Menu.SetTransparency(0, DoNotAnimate and nil or Configuration.MenuAnimateTime)
&#9;&#9;&#9;for _, Item in pairs(Subscribed) do
&#9;&#9;&#9;&#9;Item.RenderFrame.ShowScrollBar(Configuration.MenuAnimateTime)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;Menu.SetTransparency(1, DoNotAnimate and nil or Configuration.MenuAnimateTime)
&#9;&#9;&#9;for _, Item in pairs(Subscribed) do
&#9;&#9;&#9;&#9;Item.RenderFrame.HideScrollBar(Configuration.MenuAnimateTime)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;OutputStreamInterface.UpdateVisibility = UpdateVisibility

&#9;local ScrollerEvent

&#9;local function SetActiveStream(Subscriber, DoNotAnimate)
&#9;&#9;if ActiveSubscriber then
&#9;&#9;&#9;ActiveSubscriber.Hide()
&#9;&#9;end
&#9;&#9;ActiveSubscriber = Subscriber
&#9;&#9;Subscriber.Show()
&#9;&#9;UpdateVisibility(DoNotAnimate)


&#9;&#9;if ScrollerEvent then
&#9;&#9;&#9;ScrollerEvent:disconnect()
&#9;&#9;&#9;ScrollerEvent = nil
&#9;&#9;end

&#9;&#9;ScrollerEvent = Subscriber.RenderFrame.Scroller.ScrollFinished:connect(function()
&#9;&#9;&#9;wait(0)
&#9;&#9;&#9;UpdateVisibility()
&#9;&#9;end)
&#9;end

&#9;local function Subscribe(OutputStreamSyndicator, RenderName, RenderColor)
&#9;&#9;-- @param RenderName &quot;String&quot; The name to show on the menu option, if the default StreamName does not look pretty.
&#9;&#9;-- @param RenderColor The color3 value to use on the menu choice.

&#9;&#9;if Subscribed[OutputStreamSyndicator] then
&#9;&#9;&#9;error(&quot;[OutputStreamInterface] - Already subscribed to &apos;&quot; .. OutputStreamSyndicator.Name .. &quot;&apos;&quot;)
&#9;&#9;else
&#9;&#9;&#9;RenderColor = RenderColor or Color3.new(0, 0, 0)
&#9;&#9;&#9;RenderName = RenderName or OutputStreamSyndicator.Name or tostring(OutputStreamSyndicator)

&#9;&#9;&#9;local Subscriber = {}
&#9;&#9;&#9;local RenderFrame = MakeOutputStreamRender(Configuration, ScreenGui)
&#9;&#9;&#9;local MenuOption = Menu.MakeChoice(RenderName, RenderColor)
&#9;&#9;&#9;Subscriber.RenderFrame = RenderFrame

&#9;&#9;&#9;local function HandleNewItem(OutputClass, Data, DoNotAnimate)
&#9;&#9;&#9;&#9;local BufferData = RenderFrame.Buffer:GetData()
&#9;&#9;&#9;&#9;local Index = 1
&#9;&#9;&#9;&#9;local TimeStamp = Data.TimeStamp
&#9;&#9;&#9;&#9;assert(TimeStamp ~= nil, &quot;[OutputStreamInterface] - TimeStamp is &quot; .. tostring(TimeStamp))
&#9;&#9;&#9;&#9;-- TimeStamp organization / mental thoughts
&#9;&#9;&#9;&#9;--[[ Inserting: 3000

&#9;&#9;&#9;&#9;&#9;1 : Most Recent : 2000
&#9;&#9;&#9;&#9;&#9;2 : Second Reef : 1995
&#9;&#9;&#9;&#9;&#9;3 : ........... : 0343

&#9;&#9;&#9;&#9;&#9;if [1] and 2000 &gt; 3000 then
&#9;&#9;&#9;&#9;&#9;&#9;Index = 2
&#9;&#9;&#9;&#9;&#9;....
&#9;&#9;&#9;&#9;&#9;if [2] and 1995 &gt; 3000 
&#9;&#9;&#9;&#9;--]]

&#9;&#9;&#9;&#9;while BufferData[Index] and BufferData[Index].Data.TimeStamp &gt; TimeStamp do
&#9;&#9;&#9;&#9;&#9;print(Index .. &quot; : &quot; .. BufferData[Index].Data.TimeStamp .. &quot; &gt; &quot; .. TimeStamp)
&#9;&#9;&#9;&#9;&#9;Index = Index + 1
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;if Index &lt; RenderFrame.Buffer.BufferSize then
&#9;&#9;&#9;&#9;&#9;local NewItem = {}

&#9;&#9;&#9;&#9;&#9;local Gui    = OutputClass.Render(ActiveSubscriber.RenderFrame.ContentFrame, Data, DoNotAnimate or (Index == RenderFrame.Buffer.BufferSize))
&#9;&#9;&#9;&#9;&#9;Gui.Parent   = RenderFrame.ContentFrame
&#9;&#9;&#9;&#9;&#9;NewItem.Gui  = Gui
&#9;&#9;&#9;&#9;&#9;NewItem.Data = Data

&#9;&#9;&#9;&#9;&#9;-- print(&quot;DoNotAnimate: &quot; .. DoNotAnimate)
&#9;&#9;&#9;&#9;&#9;RenderFrame.Insert(Index, NewItem, DoNotAnimate)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;print(&quot;[OutputStreamInterface] - Will not insert new item old time stamp @ &quot; .. tostring(TimeStamp))
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;function Subscriber.Show()
&#9;&#9;&#9;&#9;RenderFrame.Gui.Visible = true
&#9;&#9;&#9;&#9;Menu.SetColorAndTitle(RenderColor, RenderName)
&#9;&#9;&#9;end

&#9;&#9;&#9;function Subscriber.Hide()
&#9;&#9;&#9;&#9;RenderFrame.Gui.Visible = false
&#9;&#9;&#9;end

&#9;&#9;&#9;-- Connect Events --

&#9;&#9;&#9;OutputStreamSyndicator.NewItem:connect(function(OutputStreamClient, OutputClass, Data)
&#9;&#9;&#9;&#9;assert(Data ~= nil, &quot;Data is nil&quot;)
&#9;&#9;&#9;&#9;HandleNewItem(OutputClass, Data, ActiveSubscriber ~= Subscriber)
&#9;&#9;&#9;end)

&#9;&#9;&#9;MenuOption.Gui.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;SetActiveStream(Subscriber)
&#9;&#9;&#9;&#9;Menu.Collapse()
&#9;&#9;&#9;end)

&#9;&#9;&#9;-- Setup Subscription, GUI stuff --

&#9;&#9;&#9;RenderFrame.Gui.Parent = ContentContainer

&#9;&#9;&#9;Subscribed[OutputStreamSyndicator] = Subscriber
&#9;&#9;&#9;if not ActiveSubscriber then
&#9;&#9;&#9;&#9;SetActiveStream(Subscriber)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Subscriber.Hide()
&#9;&#9;&#9;end

&#9;&#9;&#9;-- Handle Logs -- 
&#9;&#9;&#9;local Logs = OutputStreamSyndicator.GetSyndicatedLogs()
&#9;&#9;&#9;for _, Item in pairs(Logs) do
&#9;&#9;&#9;&#9;HandleNewItem(Item.OutputClass, Item.Data, true)
&#9;&#9;&#9;end
&#9;&#9;&#9;Logs = nil -- GC

&#9;&#9;&#9;return Subscriber
&#9;&#9;end
&#9;end
&#9;OutputStreamInterface.Subscribe = Subscribe
&#9;OutputStreamInterface.subscribe = Subscribe

&#9;-- SETUP EVENTS --
&#9;MainFrame.MouseEnter:connect(function()
&#9;&#9;MouseOver = true
&#9;&#9;UpdateVisibility()
&#9;end)

&#9;MainFrame.MouseLeave:connect(function()
&#9;&#9;MouseOver = false
&#9;&#9;UpdateVisibility()
&#9;end)

&#9;Menu.MenuCollapseChanged:connect(function(State)
&#9;&#9;UpdateVisibility()
&#9;end)

&#9;UpdateVisibility(true)
end)
lib.MakeOutputStreamInterface = MakeOutputStreamInterface
lib.makeOutputStreamInterface = MakeOutputStreamInterface

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX13">
					<Properties>
						<string name="Name">OutputStream</string>
						<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local Players           = game:GetService(&quot;Players&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems       = LoadCustomLibrary(&quot;qSystems&quot;)
local Table          = LoadCustomLibrary(&quot;Table&quot;)
local RbxUtility     = LoadLibrary(&quot;RbxUtility&quot;)
local CircularBuffer = LoadCustomLibrary(&quot;CircularBuffer&quot;)

qSystems:Import(getfenv(0));

local lib = {}

--[[-- Change Log

January 27th, 2014
- Fixed logging
- Added change log

January 26th, 2014
- Initial rewrite


--]]

--[[
This is an improved version of RenderStream, and focuses upon improving the
reliability of the program, as well as the flexibility. 

Logging and Filtering
- Subscription services?


HOW IT WORKS
------------

Stuff is classified by how it&apos;s suppose to display. That is, each &quot;display item&quot; has three different things
- Parser
- Render

Each Stream has it&apos;s own log, which also filters out players. 

Now, streams can (and will be) syndicated by the OutputStreamSyndicator (on the client).
Streams can thus filter out data, but also maintain a coherent &quot;overview&quot; on the client.

Streams can even be reused in different syndications (OutputStreamSyndicator) so admin logs, say
can go into a global server output log, and also into an admin log thing.

The thing is, the logger or whatever is on the server is still MAINTAINED per a stream per a class.

It&apos;s all very haxy and inefficient, maybe, but the only way I could figure out how to do it while
maintaining every single condition. 
--]]

local ParserUIDCounter = 0;

local function GetUID()
&#9;--- Return&apos;s a UID (Unique ID) for the chat parser to use.
&#9;ParserUIDCounter = ParserUIDCounter + 1
&#9;return ParserUIDCounter
end

local MakeOutputParser = Class(function(OutputParser, Parse, Unparse)
&#9;--- Parses and deparses data between transit. 
&#9;-- @param Parse Lua function 
&#9;&#9;-- Parse( Table `Data`)
&#9;&#9;&#9;--- Returns a Table of the data to be sent over.
&#9;&#9;-- Unparse( Table `Data`)
&#9;&#9;&#9;--- Return&apos;s a Table of the deparsed data


&#9;function OutputParser.Parse(OutputClassName, Data)
&#9;&#9;--- Parses the Data into a packet, adds 3 elements.
&#9;&#9;-- @return Data
&#9;&#9;&#9;-- Data will have these items in it
&#9;&#9;&#9;-- ClassName (String)
&#9;&#9;&#9;-- UID (Number)
&#9;&#9;&#9;-- TimeStamp (Number)
&#9;&#9;&#9;-- Parsed (Table, parsed Data)

&#9;&#9;Data.ClassName = OutputClassName
&#9;&#9;Data.UID = GetUID()
&#9;&#9;Data.TimeStamp = tick()

&#9;&#9;local Parsed = Parse(Data)

&#9;&#9;Parsed.ClassName = OutputClassName
&#9;&#9;Parsed.UID = Data.UID
&#9;&#9;Parsed.TimeStamp = Data.TimeStamp

&#9;&#9;Data.Parsed = Parsed

&#9;&#9;return Data
&#9;end

&#9;OutputParser.Unparse = Unparse
&#9;-- Will simply mutate Data
end)
lib.MakeOutputParser = MakeOutputParser
lib.makeOutputParser = MakeOutputParser

local MakeOutputClass = Class(function(OutputClass, Name, Parser, Render)
&#9;--- Represents a type of output to render. 
&#9;
&#9;OutputClass.Name = Name
&#9;OutputClass.Parser = Parser
&#9;OutputClass.Render = Render
end)
lib.MakeOutputClass = MakeOutputClass
lib.makeOutputClass = MakeOutputClass

local MakeOutputStreamServer = Class(function(OutputStreamServer, Logger, StreamName)
&#9;--- Handles connections send and receive, and brings all the classes together.
&#9;-- @param Logger A logger, should have the following properties.
&#9;&#9;-- :GetLogs(Client)
&#9;&#9;-- :LogData(Data)
&#9;&#9;-- [:Sendable](Client, Data)
&#9;-- OutputClassStreamLoggers.lua as some examples. 

&#9;-- Client subscribes to any OutputStreamServer
&#9;--  --&gt; Updates get pushed to client. 

&#9;OutputStreamServer.Name = StreamName

&#9;local DataStream = NevermoreEngine.GetDataStream(StreamName)
&#9;local EventStream = NevermoreEngine.GetEventStream(StreamName)

&#9;local OutputClasses = {}

&#9;local function GetOutputClass(OutputClassName)
&#9;&#9;return OutputClasses[OutputClassName:lower()]
&#9;end

&#9;local function AddOutputClass(OutputClass)
&#9;&#9;--- Adds the OutputClass to the system so it can be used. Could be called &quot;Create&quot; but it doesn&apos;t really create it.
&#9;&#9;-- @param OutputClass The class itself. 

&#9;&#9;local OutputClassName = OutputClass.Name

&#9;&#9;if not GetOutputClass(OutputClassName) then
&#9;&#9;&#9;OutputClasses[OutputClassName:lower()] = OutputClass
&#9;&#9;else
&#9;&#9;&#9;error(&quot;[OutputStreamServer] - StreamName &quot; .. OutputClassName .. &quot; is already registered. &quot;)
&#9;&#9;end
&#9;end
&#9;OutputStreamServer.AddOutputClass = AddOutputClass
&#9;OutputStreamServer.addOutputClass = AddOutputClass

&#9;local function Send(OutputClassName, Data)
&#9;&#9;--- Constructs a new OutputStream item and then sends it to the appropriate places.

&#9;&#9;local OutputClass = GetOutputClass(OutputClassName)
&#9;&#9;if OutputClass then
&#9;&#9;&#9;-- print(&quot;Filter list [0.5] @ Send &quot; .. tostring(Data.FilterList) .. &quot;, Data = &quot; .. tostring(Data))
&#9;&#9;&#9;OutputClass.Parser.Parse(OutputClassName, Data)
&#9;&#9;&#9;assert(Data.Parsed ~= nil, &quot;Data.Parsed is nil&quot;)
&#9;&#9;&#9;-- print(&quot;Filter list [1] @ Send &quot; .. tostring(Data.FilterList) .. &quot;, Data = &quot; .. tostring(Data))
&#9;&#9;&#9;if Logger.Sendable then
&#9;&#9;&#9;&#9;for _, Player in pairs(Players:GetPlayers()) do

&#9;&#9;&#9;&#9;&#9;-- print(&quot;Filter list [2] @ Send &quot; .. tostring(Data.FilterList) .. &quot;, Data = &quot; .. tostring(Data))
&#9;&#9;&#9;&#9;&#9;if Logger:Sendable(Player, Data) then
&#9;&#9;&#9;&#9;&#9;&#9;EventStream.Fire(Player, &quot;Push&quot;, OutputClassName, Data.Parsed)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;EventStream.FireAllClients(&quot;Push&quot;, OutputClassName, Data.Parsed)
&#9;&#9;&#9;end

&#9;&#9;&#9;Logger:LogData(Data)
&#9;&#9;else
&#9;&#9;&#9;error(&quot;[OutputStreamServer] - OutputClass &apos;&quot; .. OutputClassName .. &quot;&apos; is not registered.&quot;)
&#9;&#9;end
&#9;&#9;-- print(&quot;Done sending data.&quot;)
&#9;end
&#9;OutputStreamServer.Send = Send
&#9;OutputStreamServer.send = Send

&#9;DataStream.RegisterRequestTag(&quot;Pull&quot;, function(Client)
&#9;&#9;-- print(&quot;[OutputStreamServer] - Returning log pull from Client &quot; .. tostring(Client))
&#9;&#9;return Logger:GetLogs(Client)
&#9;end)
end)
lib.MakeOutputStreamServer = MakeOutputStreamServer
lib.makeOutputStreamServer = MakeOutputStreamServer

local MakeOutputStreamClient = Class(function(OutputStreamClient, StreamName)
&#9;--- Manages connections, on the client, and subscriptions. Should be reconstructed after every reset. 
&#9;-- @param StreamName The name of the Stream, string. Should be unique, as it will construct a new DataStream and EventStream from it.
&#9;
&#9;assert(type(StreamName) == &quot;string&quot;, &quot;[OutputStreamClient] - StreamName is a &apos;&quot; .. type(StreamName) .. &quot;&apos; tostring() == &quot; .. tostring(StreamName))

&#9;local DataStream = NevermoreEngine.GetDataStream(StreamName)
&#9;local EventStream = NevermoreEngine.GetEventStream(StreamName)

&#9;OutputStreamClient.Name = StreamName

&#9;local OutputClasses = {}
&#9;local OutputClassesSignals = {}

&#9;OutputStreamClient.NewItem = CreateSignalInternal()

&#9;local function GetOutputClass(OutputClassName)
&#9;&#9;return OutputClasses[OutputClassName:lower()]
&#9;end

&#9;local function AddOutputClass(OutputClass)
&#9;&#9;--- Adds the OutputClass to the system so it can be used. 
&#9;&#9;-- @param OutputClass The class itself. 

&#9;&#9;local OutputClassName = OutputClass.Name
&#9;&#9;
&#9;&#9;if not GetOutputClass(OutputClassName) then
&#9;&#9;&#9;OutputClasses[OutputClassName:lower()] = OutputClass
&#9;&#9;else
&#9;&#9;&#9;error(&quot;[OutputStreamClient] - StreamName &quot; .. OutputClassName .. &quot; is already registered. &quot;)
&#9;&#9;end
&#9;end
&#9;OutputStreamClient.AddOutputClass = AddOutputClass
&#9;OutputStreamClient.addOutputClass = AddOutputClass

&#9;EventStream.RegisterRequestTag(&quot;Push&quot;, function(OutputClassName, Data)

&#9;&#9;assert(Data.TimeStamp ~= nil, &quot;TimeStamp is nil&quot;)

&#9;&#9;local OutputClass = GetOutputClass(OutputClassName)
&#9;&#9;if OutputClass then
&#9;&#9;&#9;OutputClass.Parser.Unparse(Data)
&#9;&#9;&#9;OutputStreamClient.NewItem:fire(OutputClass, Data)
&#9;&#9;else
&#9;&#9;&#9;Warn(&quot;[OutputStreamClient] - No OutputStream class for &apos;&quot; .. tostring(OutputClassName) .. &quot;&apos;&quot;)
&#9;&#9;end
&#9;end)


&#9;local function GetLogs()
&#9;&#9;--- Takes all the logs from all the classes

&#9;&#9;local Logs = DataStream.Call(&quot;Pull&quot;)
&#9;&#9;if Logs then
&#9;&#9;&#9;local UnparsedLogs = {}
&#9;&#9;&#9;for Index, Item in pairs(Logs) do
&#9;&#9;&#9;&#9;local Class = GetOutputClass(Item.ClassName)
&#9;&#9;&#9;&#9;if Class then
&#9;&#9;&#9;&#9;&#9;Class.Parser.Unparse(Item)
&#9;&#9;&#9;&#9;&#9;UnparsedLogs[#UnparsedLogs+1] = {
&#9;&#9;&#9;&#9;&#9;&#9;Data = Item;
&#9;&#9;&#9;&#9;&#9;&#9;OutputClass = Class;
&#9;&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;Warn(&quot;[OutputStreamClient] - Class &apos;&quot; .. Item.ClassName .. &quot;&apos; is not registered!&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return UnparsedLogs, true
&#9;&#9;else
&#9;&#9;&#9;Warn(&quot;[OutputStreamClient] - Could not retrieve logs! Logs were nil!&quot;)
&#9;&#9;&#9;return {}, false
&#9;&#9;end
&#9;end
&#9;OutputStreamClient.GetLogs = GetLogs
&#9;OutputStreamClient.getLogs = GetLogs

&#9;local function GetSortedLogs()
&#9;&#9;--- Sorts by TimeStamp
&#9;&#9;local UnparsedLogs, Success = GetLogs()
&#9;&#9;table.sort(UnparsedLogs, function(A, B)
&#9;&#9;&#9;return A.Data.TimeStamp &lt; B.Data.TimeStamp
&#9;&#9;end)
&#9;&#9;return UnparsedLogs
&#9;end
&#9;OutputStreamClient.GetSortedLogs = GetSortedLogs
&#9;OutputStreamClient.getSortedLogs = GetSortedLogs
end)
lib.MakeOutputStreamClient = MakeOutputStreamClient
lib.makeOutputStreamClient = MakeOutputStreamClient

_G.OutputSyndicatedLogs = {}
local LoggerDatabase = _G.OutputSyndicatedLogs

local MakeOutputStreamSyndicator = Class(function(OutputStreamSyndicator, Name, BufferSize)
&#9;--- Managers multiple streams being synced into one. Caches data so chat loads fast on respawn. Used on the client only.
&#9;-- @param Name The name of the Syndictator, purely for technical reasons. If no name is given, one will be generated.
&#9;-- @param [BufferSize] Size of the Cached Buffer to use. 

&#9;BufferSize = BufferSize or 100

&#9;OutputStreamSyndicator.Name = Name or tostring(&quot;[ &quot; .. OutputStreamSyndicator ..&quot; ]&quot;)
&#9;local OutputStreams = {}
&#9;OutputStreamSyndicator.NewItem = CreateSignalInternal()

&#9;local function GetOutputStream(StreamName)
&#9;&#9;return OutputStreams[StreamName:lower()]
&#9;end

&#9;local function AddOutputStream(OutputStreamClient)

&#9;&#9;local OutputStreamClientName = OutputStreamClient.Name
&#9;&#9;if not GetOutputStream(OutputStreamClientName) then
&#9;&#9;&#9;OutputStreams[OutputStreamClientName] = OutputStreamClient

&#9;&#9;&#9;OutputStreamClient.NewItem:connect(function(OutputClass, Data)
&#9;&#9;&#9;&#9;OutputStreamSyndicator.NewItem:fire(OutputStreamClient, OutputClass, Data)
&#9;&#9;&#9;&#9;-- CircularBuffer:Add(
&#9;&#9;&#9;&#9;-- {
&#9;&#9;&#9;&#9;&#9;-- Data        = Data;
&#9;&#9;&#9;&#9;&#9;-- OutputClass = OutputClass;
&#9;&#9;&#9;&#9;-- })
&#9;&#9;&#9;end)
&#9;&#9;else
&#9;&#9;&#9;error(&quot;[OutputStreamSyndicator] - Cannot add OutputStreamClient &apos;&quot; .. OutputStreamClientName .. &quot;&apos; as is already is added. &quot;)
&#9;&#9;end
&#9;end
&#9;OutputStreamSyndicator.AddOutputStream = AddOutputStream
&#9;OutputStreamSyndicator.addOutputStream = AddOutputStream

&#9;local function GetSyndicatedLogs(NoCache)
&#9;&#9;--- NOTE: CACHING NOT APPLIED

&#9;&#9;--- Syndicates all the logs together and sorts by time stamp.
&#9;&#9;-- @param NoCache Boolean, if true, does not use cached data. 
&#9;&#9;-- @return CircularBuffer with the logs in it. 

&#9;&#9;-- if NoCache or not LoggerDatabase[Name] then
&#9;&#9;&#9;local LogList = {}
&#9;&#9;&#9;for _, Item in pairs(OutputStreams) do
&#9;&#9;&#9;&#9;local Logs = Item:GetLogs()
&#9;&#9;&#9;&#9;for _, Item in pairs(Logs) do
&#9;&#9;&#9;&#9;&#9;LogList[#LogList+1] = Item
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;--- We have to sort if we get more results back than we need?
&#9;&#9;&#9;table.sort(LogList, function(A, B)
&#9;&#9;&#9;&#9;return A.Data.TimeStamp &lt; B.Data.TimeStamp
&#9;&#9;&#9;end)

&#9;&#9;&#9;if #LogList &gt; BufferSize then
&#9;&#9;&#9;&#9;-- Cull list size.
&#9;&#9;&#9;&#9;local NewList = {}

&#9;&#9;&#9;&#9;for Index = #LogList, #LogList - 100, -1 do
&#9;&#9;&#9;&#9;&#9;NewList[#NewList+1] = LogList[Index]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;LogList = NewList

&#9;&#9;&#9;&#9;return NewList
&#9;&#9;&#9;end

&#9;&#9;&#9;return LogList
&#9;&#9;&#9;-- LoggerDatabase[Name] = CircularBuffer.new(BufferSize, LogList)
&#9;&#9;-- end

&#9;&#9;-- return LoggerDatabase[Name]
&#9;end
&#9;OutputStreamSyndicator.GetSyndicatedLogs = GetSyndicatedLogs
&#9;OutputStreamSyndicator.getSyndicatedLogs = GetSyndicatedLogs
end)
lib.MakeOutputStreamSyndicator = MakeOutputStreamSyndicator
lib.makeOutputStreamSyndicator = MakeOutputStreamSyndicator

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX14">
					<Properties>
						<string name="Name">OutputClassStreamLoggers</string>
						<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local Players           = game:GetService(&quot;Players&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local CircularBuffer    = LoadCustomLibrary(&quot;CircularBuffer&quot;)
local Table             = LoadCustomLibrary(&quot;Table&quot;)

qSystems:Import(getfenv(0));

local lib = {}

-- @author Quenty
-- OutputClassStreamLoggers.lua
-- This script handles some logging stuff for OutputStreams. 
-- Last modified January 26th, 2014

local MakeGlobalOutputStreamLog = Class(function(GlobalOutputStreamLog, BufferSize)
&#9;--- Represents a &quot;stream&quot; that can be subscribbed too. Each stream has it&apos;s own way of
&#9;-- logging data, and filtering it out towards clients. This stream is one that has no
&#9;-- permissions system at all. 
&#9;-- @param [BufferSize] Int, the size of the buffer. Defaults at 100

&#9;-- Output streams can then be syndicated into one window. Windows will subscribe to output
&#9;-- streams. 

&#9;&#9;--[[
&#9;&#9;Data Specification

&#9;&#9;Data&#9;&#9;
&#9;&#9;&#9;string `Parsed`
&#9;&#9;&#9;&#9;Parsed JSON, saved to the data. 
&#9;--]]


&#9;local Logs = CircularBuffer.New(BufferSize or 100)

&#9;function GlobalOutputStreamLog:GetLogs(Client)
&#9;&#9;--- Return&apos;s all the logs based upon the client.
&#9;&#9;-- @param Client The client retrieving the logs for, can be used to filter out specific players, say
&#9;&#9;--               on an admin log.
&#9;&#9;-- @pre The data must have a variable called &quot;Parsed&quot; in it, before being logged.
&#9;&#9;-- @return A table of parsed JSON logs. 

&#9;&#9;local NewData = {}
&#9;&#9;for _, Item in pairs(Logs:GetData()) do
&#9;&#9;&#9;NewData[#NewData + 1] = Item.Parsed
&#9;&#9;end
&#9;&#9;return NewData
&#9;end

&#9;--[[function GlobalOutputStreamLog:Sendable(Client, Data)
&#9;&#9;--- Figures out whether or not the data should be sent to the client. 
&#9;&#9;-- @param Client The client to check
&#9;&#9;-- @param Data The data to check
&#9;&#9;-- @return Boolean true if it should be sent, false otherwise. 

&#9;&#9;return true
&#9;end--]]

&#9;function GlobalOutputStreamLog:LogData(Data)
&#9;&#9;--- Logs the Data into the Logs. 
&#9;&#9;-- @param Data The data to log
&#9;&#9;-- Data must contain &quot;Parsed&quot; data type.

&#9;&#9;Logs:Add(Data)
&#9;end
end)
lib.MakeGlobalOutputStreamLog = MakeGlobalOutputStreamLog
lib.makeGlobalOutputStreamLog = MakeGlobalOutputStreamLog

local MakePlayerNotificationStreamLog = Class(function(PlayerNotificationStreamLog, BufferSize)
&#9;--- Like a GlobalOutputStreamLog, but it specifically filters it to certain players. It sends temporary
&#9;-- notifications, and should be used to yell at players, but not log anything valuable. 
&#9;-- @param [BufferSize] Int, the size of the buffer. Defaults at 100

&#9;-- Technical issues can occur when the buffer get&apos;s killed, but it shouldn&apos;t matter at all, as
&#9;-- logging here is trivial. 

&#9;--[[
&#9;&#9;Data Specification

&#9;&#9;Data
&#9;&#9;&#9;table `FilterList`
&#9;&#9;&#9;&#9;number `userId` -- userId is preferred by 99999999%
&#9;&#9;&#9;&#9;number `userId`
&#9;&#9;&#9;&#9;...
&#9;&#9;&#9;&#9;String `PlayerName`
&#9;&#9;&#9;&#9;String `PlayerName`
&#9;&#9;&#9;&#9;String `PlayerName`
&#9;&#9;&#9;&#9;...

&#9;&#9;&#9;boolean `Inclusive`
&#9;&#9;&#9;&#9;If this boolean is true, then it will only send to players whose userId or name (Caps sensitive) is in the FilterList
&#9;&#9;&#9;&#9;Otherwise, if it is false, it will send it to any player who is NOT in the filter list. 
&#9;&#9;&#9;
&#9;&#9;&#9;string `Parsed`
&#9;&#9;&#9;&#9;Parsed JSON, saved to the data. 
&#9;--]]

&#9;local Logs = CircularBuffer.New(BufferSize or 100)

&#9;function PlayerNotificationStreamLog:GetLogs(Client)
&#9;&#9;--- Return&apos;s all the logs based upon the client.
&#9;&#9;-- @param Client The client retrieving the logs for, can be used to filter out specific players, say
&#9;&#9;--               on an admin log.
&#9;&#9;-- @pre The data must have a variable called &quot;Parsed&quot; in it, before being logged.
&#9;&#9;-- @return A table of parsed JSON logs. 

&#9;&#9;local NewData = {}
&#9;&#9;for _, Item in pairs(Logs:GetData()) do
&#9;&#9;&#9;if PlayerNotificationStreamLog:Sendable(Client, Item) then
&#9;&#9;&#9;&#9;NewData[#NewData+1] = Item.Parsed
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return NewData
&#9;end

&#9;function PlayerNotificationStreamLog:Sendable(Client, Data)
&#9;&#9;--- Figures out whether or not the data should be sent to the client. 
&#9;&#9;-- @param Client The client to check
&#9;&#9;-- @param Data The data to check
&#9;&#9;-- @return Boolean true if it should be sent, false otherwise. 

&#9;&#9;if Data.FilterList then
&#9;&#9;&#9;for _, Item in pairs(Data.FilterList) do
&#9;&#9;&#9;&#9;if Item == Client or Item == Client.userId or Item == Client.Name then
&#9;&#9;&#9;&#9;&#9;return Data.Inclusive
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return not Data.Inclusive
&#9;&#9;else
&#9;&#9;&#9;-- print(&quot;No filter list. &quot; .. tostring(Data.FilterList) .. &quot;, Data = &quot; .. tostring(Data))
&#9;&#9;&#9;error(&quot;[PlayerNotificationStreamLog] - Data does not have filter list&quot;)
&#9;&#9;end
&#9;end

&#9;function PlayerNotificationStreamLog:LogData(Data)
&#9;&#9;--- Logs the Data into the Logs. 
&#9;&#9;-- @param Data The data to log
&#9;&#9;-- Data must contain &quot;Parsed&quot; data type.

&#9;&#9;-- print(&quot;Logging data, Data.FilterList = &quot; .. tostring(Data.FilterList))
&#9;&#9;Logs:Add(Data)
&#9;end
end)
lib.MakePlayerNotificationStreamLog = MakePlayerNotificationStreamLog
lib.makePlayerNotificationStreamLog = MakePlayerNotificationStreamLog

local MakeFilteredLogStreamLog = Class(function(FilteredLogStreamLog, BufferSize)
&#9;--- This class filters on a single unit basis. It&apos;s for admin logs and error logs that the general
&#9;-- player should not see. 

&#9;-- @param [BufferSize] Int, the size of the buffer. Defaults at 100

&#9;-- Leaves the caching up the the Filter function. 

&#9;local Logs = CircularBuffer.New(BufferSize or 100)

&#9;function FilteredLogStreamLog:GetLogs(Client)
&#9;&#9;--- Return&apos;s all the logs based upon the client.
&#9;&#9;-- @param Client The client retrieving the logs for, can be used to filter out specific players, say
&#9;&#9;--               on an admin log.
&#9;&#9;-- @pre The data must have a variable called &quot;Parsed&quot; in it, before being logged.
&#9;&#9;-- @return A table of parsed JSON logs. 

&#9;&#9;local NewData = {}
&#9;&#9;for _, Item in pairs(Logs:GetData()) do
&#9;&#9;&#9;if FilteredLogStreamLog:Sendable(Client, Item) then
&#9;&#9;&#9;&#9;NewData[#NewData+1] = Item.Parsed
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return NewData
&#9;end

&#9;function FilteredLogStreamLog:LogData(Data)
&#9;&#9;--- Logs the Data into the Logs. 
&#9;&#9;-- @param Data The data to log
&#9;&#9;-- Data must contain &quot;Parsed&quot; data type.

&#9;&#9;Logs:Add(Data)
&#9;end

&#9;function FilteredLogStreamLog:Sendable(Client, Data)
&#9;&#9;--- Figures out whether or not the data should be sent to the client. 
&#9;&#9;-- @param Client The client to check
&#9;&#9;-- @param Data The data to check
&#9;&#9;-- @return Boolean true if it should be sent, false otherwise. 

&#9;&#9;return Data.Filter(Client)
&#9;end
end)
lib.MakeFilteredLogStreamLog = MakeFilteredLogStreamLog
lib.makeFilteredLogStreamLog = MakeFilteredLogStreamLog

local MakeGlobalFilteredLogStreamLog = Class(function(FilteredLogStreamLog, Filter, BufferSize)
&#9;--- This class filters on a &quot;global&quot; basis. It&apos;s for admin logs and error logs that the general
&#9;-- player should not see. 
&#9;-- @param Filter Function, indicates whether or not a player should be sent the data
&#9;&#9;-- function `Filter` ( Player `Client` )
&#9;&#9;-- @return boolean `ShouldSend` A boolean, if true, it should send the player the data. 

&#9;-- @param [BufferSize] Int, the size of the buffer. Defaults at 100

&#9;-- Leaves the caching up the the Filter function. 

&#9;local Logs = CircularBuffer.New(BufferSize or 100)

&#9;function FilteredLogStreamLog:GetLogs(Client)
&#9;&#9;--- Return&apos;s all the logs based upon the client.
&#9;&#9;-- @param Client The client retrieving the logs for, can be used to filter out specific players, say
&#9;&#9;--               on an admin log.
&#9;&#9;-- @pre The data must have a variable called &quot;Parsed&quot; in it, before being logged.
&#9;&#9;-- @return A table of parsed JSON logs. 

&#9;&#9;local NewData = {}
&#9;&#9;for _, Item in pairs(Logs:GetData()) do
&#9;&#9;&#9;if FilteredLogStreamLog:Sendable(Client, Item) then
&#9;&#9;&#9;&#9;NewData[#NewData+1] = Item.Parsed
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return NewData
&#9;end

&#9;function FilteredLogStreamLog:LogData(Data)
&#9;&#9;--- Logs the Data into the Logs. 
&#9;&#9;-- @param Data The data to log
&#9;&#9;-- Data must contain &quot;Parsed&quot; data type.

&#9;&#9;Logs:Add(Data)
&#9;end

&#9;function FilteredLogStreamLog:Sendable(Client, Data)
&#9;&#9;--- Figures out whether or not the data should be sent to the client. 
&#9;&#9;-- @param Client The client to check
&#9;&#9;-- @param Data The data to check
&#9;&#9;-- @return Boolean true if it should be sent, false otherwise. 

&#9;&#9;return Filter(Client)
&#9;end
end)
lib.MakeGlobalFilteredLogStreamLog = MakeGlobalFilteredLogStreamLog
lib.makeGlobalFilteredLogStreamLog = MakeGlobalFilteredLogStreamLog

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="Backpack" referent="RBX15">
					<Properties>
						<string name="Name">PseudoChat</string>
					</Properties>
					<Item class="ModuleScript" referent="RBX16">
						<Properties>
							<string name="Name">PseudoChatSettings</string>
							<ProtectedString name="Source">-- PseudoChatSettings.lua
-- @author Quenty
-- Last modified Januarty 26th, 2014
-- Maintains PseudoChat settings.

local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qColor3            = LoadCustomLibrary(&quot;qColor3&quot;)

return {
&#9;-- COLORS --
&#9;SpecialChatColors = {
&#9;&#9;-- [&quot;Quenty&quot;]          = qColor3.LerpColor3(BrickColor.new(&quot;Br. yellowish green&quot;).Color, Color3.new(1, 1, 1), 0.95);
&#9;&#9;-- [&quot;Mauv&quot;]            = BrickColor.new(&quot;Br. yellowish green&quot;).Color; -- Color3.new(1, 215/255, 0); 
&#9;&#9;-- [&quot;Player1&quot;]         = BrickColor.new(&quot;Br. yellowish green&quot;).Color; -- Color3.new(1, 215/255, 0);
&#9;&#9;-- [&quot;PumpedRobloxian&quot;] = Color3.new(0, 202/255, 220/255);
&#9;&#9;-- [&quot;xXxMoNkEyMaNxXx&quot;] = BrickColor.new(&quot;Lavender&quot;).Color;
&#9;&#9;-- [&quot;ColorfulBody&quot;]    = BrickColor.new(&quot;Br. yellowish green&quot;).Color;
&#9;&#9;-- [&quot;ColorfulBody&quot;] = Color3.new(252/255, 0, 154/255); -- Magenta #fc009a 
&#9;&#9;-- [&quot;RenderSettings&quot;]  = Color3.new(252/255, 0, 154/255); -- Magenta #fc009a 
&#9;&#9;-- [&quot;treyreynolds&quot;]    = BrickColor.new(&quot;Pastel light blue&quot;).Color; Color3.new(0, 56/256, 204/256)
&#9;};
&#9;SpecialNameColors = {
&#9;&#9;-- [&quot;ColorfulBody&quot;]    = Color3.new(254/255, 191/255, 229/255); -- Magenta #febfe5 
&#9;&#9;[&quot;ColorfulBody&quot;] = Color3.new(222/255, 244/255, 135/255);
&#9;};
&#9;RobloxAdminChatColor = Color3.new(218/255, 165/255, 32/255); -- BrickColor.new(&quot;Hot pink&quot;).Color;
&#9;DefaultChatColor     = Color3.new(1, 1, 1);
&#9;
&#9;-- RENDERING --
&#9;LineHeight         = 18; -- Recommended Height per chat line.
&#9;LinesShown         = 6;  -- Chat lines to show
&#9;LabelOffsetX       = 6; -- Offset from the left side of the frame.
&#9;LabelOffsetXOutput = 40; -- Output get&apos;s indented more.
&#9;ChatFontSize       = &quot;Size12&quot;; -- Fontsize of chat.

&#9;-- RENDERSTREAM CHOICE MENU --
&#9;RenderStreamMenu = {
&#9;&#9;ChoiceSizeY        = 30; 
&#9;&#9;ChoiceSizeXPadding = 10; -- Padding total on the X axis. 
&#9;&#9;ChoiceYPadding     = 5; -- Padding between each choice. 
&#9;};

&#9;DefaultNotificationColor = Color3.new(1, 1, 1);
&#9;ContentFailed = &quot;[ Content Deleted ]&quot;; -- When it fails to display content. 
&#9;MutedMessage = &quot;You are muted, and cannot chat.&quot;; -- Message to send to players when they are muted. 
&#9;MutedMessageColor = Color3.new(255/255, 233/255, 181/255);
&#9;
&#9;ScriptBuilder = {
&#9;&#9;-- Blue color, specifying when stuff is running, et cetera. 
&#9;&#9;InternalOutputColor = Color3.new(0, 209/255, 255/255);
&#9;&#9;ErrorOutputColor = Color3.new(1, 0, 0);
&#9;};
&#9;
&#9;OutputFontSize = &quot;Size10&quot;;

&#9;BufferSize = 25;
&#9;
&#9;ROBLOXAdminList = {
&#9;&#9;&quot;Rbadam&quot;;
&#9;&#9;&quot;Adamintygum&quot;;
&#9;&#9;&quot;androidtest&quot;;
&#9;&#9;&quot;RobloxFrenchie&quot;;
&#9;&#9;&quot;JacksSmirkingRevenge&quot;;
&#9;&#9;&quot;LindaPepita&quot;;
&#9;&#9;&quot;vaiobot&quot;;
&#9;&#9;&quot;Goddessnoob&quot;;
&#9;&#9;&quot;effward&quot;;
&#9;&#9;&quot;Blockhaak&quot;;
&#9;&#9;&quot;Drewbda&quot;;
&#9;&#9;&quot;659223&quot;;
&#9;&#9;&quot;Tone&quot;;
&#9;&#9;&quot;fasterbuilder19&quot;;
&#9;&#9;&quot;Zeuxcg&quot;;
&#9;&#9;&quot;concol2&quot;;
&#9;&#9;&quot;ReeseMcBlox&quot;;
&#9;&#9;&quot;Jeditkacheff&quot;;
&#9;&#9;&quot;whkm1980&quot;;
&#9;&#9;&quot;ChiefJustus&quot;;
&#9;&#9;&quot;Ellissar&quot;;
&#9;&#9;&quot;Arbolito&quot;;
&#9;&#9;&quot;Noob007&quot;;
&#9;&#9;&quot;Limon&quot;;
&#9;&#9;&quot;cmed&quot;;
&#9;&#9;&quot;hawkington&quot;;
&#9;&#9;&quot;Tabemono&quot;;
&#9;&#9;&quot;autoconfig&quot;;
&#9;&#9;&quot;BrightEyes&quot;;
&#9;&#9;&quot;Monsterinc3D&quot;;
&#9;&#9;&quot;MrDoomBringer&quot;;
&#9;&#9;&quot;IsolatedEvent&quot;;
&#9;&#9;&quot;CountOnConnor&quot;;
&#9;&#9;&quot;Scubasomething&quot;;
&#9;&#9;&quot;OnlyTwentyCharacters&quot;;
&#9;&#9;&quot;LordRugdumph&quot;;
&#9;&#9;&quot;bellavour&quot;;
&#9;&#9;&quot;david.baszucki&quot;;
&#9;&#9;&quot;ibanez2189&quot;;
&#9;&#9;&quot;Sorcus&quot;;
&#9;&#9;&quot;DeeAna00&quot;;
&#9;&#9;&quot;TheLorekt&quot;;
&#9;&#9;&quot;NiqueMonster&quot;;
&#9;&#9;&quot;Thorasaur&quot;;
&#9;&#9;&quot;MSE6&quot;;
&#9;&#9;&quot;CorgiParade&quot;;
&#9;&#9;&quot;Varia&quot;;
&#9;&#9;&quot;4runningwolves&quot;;
&#9;&#9;&quot;pulmoesflor&quot;;
&#9;&#9;&quot;Olive71&quot;;
&#9;&#9;&quot;groundcontroll2&quot;;
&#9;&#9;&quot;GuruKrish&quot;;
&#9;&#9;&quot;Countvelcro&quot;;
&#9;&#9;&quot;IltaLumi&quot;;
&#9;&#9;&quot;juanjuan23&quot;;
&#9;&#9;&quot;OstrichSized&quot;;
&#9;&#9;&quot;jackintheblox&quot;;
&#9;&#9;&quot;SlingshotJunkie&quot;;
&#9;&#9;&quot;gordonrox24&quot;;
&#9;&#9;&quot;sharpnine&quot;;
&#9;&#9;&quot;Motornerve&quot;;
&#9;&#9;&quot;Motornerve&quot;;
&#9;&#9;&quot;watchmedogood&quot;;
&#9;&#9;&quot;jmargh&quot;;
&#9;&#9;&quot;JayKorean&quot;;
&#9;&#9;&quot;Foyle&quot;;
&#9;&#9;&quot;MajorTom4321&quot;;
&#9;&#9;&quot;Shedletsky&quot;;
&#9;&#9;&quot;supernovacaine&quot;;
&#9;&#9;&quot;FFJosh&quot;;
&#9;&#9;&quot;Sickenedmonkey&quot;;
&#9;&#9;&quot;Doughtless&quot;;
&#9;&#9;&quot;KBUX&quot;;
&#9;&#9;&quot;totallynothere&quot;;
&#9;&#9;&quot;ErzaStar&quot;;
&#9;&#9;&quot;Keith&quot;;
&#9;&#9;&quot;Chro&quot;;
&#9;&#9;&quot;SolarCrane&quot;;
&#9;&#9;&quot;GloriousSalt&quot;;
&#9;&#9;&quot;UristMcSparks&quot;;
&#9;&#9;&quot;ITOlaurEN&quot;;
&#9;&#9;&quot;Malcomso&quot;;
&#9;&#9;&quot;Stickmasterluke&quot;;
&#9;&#9;&quot;windlight13&quot;;
&#9;&#9;&quot;yumyumcheerios&quot;;
&#9;&#9;&quot;Stravant&quot;;
&#9;&#9;&quot;ByteMe&quot;;
&#9;&#9;&quot;imaginationsensation&quot;;
&#9;&#9;&quot;Matt.Dusek&quot;;
&#9;&#9;&quot;Mcrtest&quot;;
&#9;&#9;&quot;Seranok&quot;;
&#9;&#9;&quot;maxvee&quot;;
&#9;&#9;&quot;Coatp0cketninja&quot;;
&#9;&#9;&quot;Screenme&quot;;
&#9;&#9;&quot;b1tsh1ft&quot;;
&#9;&#9;&quot;Totbl&quot;;
&#9;&#9;&quot;Aquabot8&quot;;
&#9;&#9;&quot;grossinger&quot;;
&#9;&#9;&quot;Merely&quot;;
&#9;&#9;&quot;CDakkar&quot;;
&#9;&#9;&quot;Siekiera&quot;;
&#9;&#9;&quot;Robloxkidsaccount&quot;;
&#9;&#9;&quot;flotsamthespork&quot;;
&#9;&#9;&quot;Soggoth&quot;;
&#9;&#9;&quot;Phil&quot;;
&#9;&#9;&quot;OrcaSparkles&quot;;
&#9;&#9;&quot;skullgoblin&quot;;
&#9;&#9;&quot;RickROSStheB0SS&quot;;
&#9;&#9;&quot;ArgonPirate&quot;;
&#9;&#9;&quot;NobleDragon&quot;;
&#9;&#9;&quot;Squidcod&quot;;
&#9;&#9;&quot;Raeglyn&quot;;
&#9;&#9;&quot;RobloxSai&quot;;
&#9;&#9;&quot;Briarroze&quot;;
&#9;&#9;&quot;hawkeyebandit&quot;;
&#9;&#9;&quot;DapperBuffalo&quot;;
&#9;&#9;&quot;Vukota&quot;;
&#9;&#9;&quot;swiftstone&quot;;
&#9;&#9;&quot;Gemlocker&quot;;
&#9;&#9;&quot;Loopylens&quot;;
&#9;&#9;&quot;Tarabyte&quot;;
&#9;&#9;&quot;Timobius&quot;;
&#9;&#9;&quot;Tobotrobot&quot;;
&#9;&#9;&quot;Foster008&quot;;
&#9;&#9;&quot;Twberg&quot;;
&#9;&#9;&quot;DarthVaden&quot;;
&#9;&#9;&quot;Khanovich&quot;;
&#9;&#9;&quot;CodeWriter&quot;;
&#9;&#9;&quot;VladTheFirst&quot;;
&#9;&#9;&quot;Phaedre&quot;;
&#9;&#9;&quot;gorroth&quot;;
&#9;&#9;&quot;SphinxShen&quot;;
&#9;&#9;&quot;jynj1984&quot;;
&#9;&#9;&quot;RoboYZ&quot;;
&#9;&#9;&quot;ZodiacZak&quot;
&#9;};
};
</ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX17">
						<Properties>
							<string name="Name">PseudoChatParser</string>
							<ProtectedString name="Source">local ReplicatedStorage  = game:GetService(&quot;ReplicatedStorage&quot;)
local Players            = game:GetService(&quot;Players&quot;)

local NevermoreEngine    = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary  = NevermoreEngine.LoadLibrary

local qSystems           = LoadCustomLibrary(&quot;qSystems&quot;)
local qString            = LoadCustomLibrary(&quot;qString&quot;)
local PseudoChatSettings = LoadCustomLibrary(&quot;PseudoChatSettings&quot;)
local qColor3            = LoadCustomLibrary(&quot;qColor3&quot;)
local qMath              = LoadCustomLibrary(&quot;qMath&quot;)
local qGUI               = LoadCustomLibrary(&quot;qGUI&quot;)
local OutputStream       = LoadCustomLibrary(&quot;OutputStream&quot;)

local RbxUtility         = LoadLibrary(&quot;RbxUtility&quot;)

qSystems:Import(getfenv(0));

local lib = {}

-- @author Quenty
-- This script handles parsing and rendering of specific pseudo chat stuff,
-- to be used with OutputStream
-- Last Modified January 26th, 2014

local GetPlayerNameColorRaw do 
&#9;local PlayerColours = {
&#9;&#9;BrickColor.new(&quot;Bright red&quot;),
&#9;&#9;BrickColor.new(&quot;Bright blue&quot;),
&#9;&#9;BrickColor.new(&quot;Earth green&quot;),
&#9;&#9;BrickColor.new(&quot;Bright violet&quot;),
&#9;&#9;BrickColor.new(&quot;Bright orange&quot;),
&#9;&#9;BrickColor.new(&quot;Bright yellow&quot;),
&#9;&#9;BrickColor.new(&quot;Light reddish violet&quot;),
&#9;&#9;BrickColor.new(&quot;Brick yellow&quot;),
&#9;}

&#9;local function GetNameValue(Name)
&#9;&#9;-- Returns the Player&apos;s color that their name is suppose to be.  
&#9;&#9;-- Credit to noliCAIKS for finding this solution. He&apos;s epicale. 

&#9;&#9;local Length = #Name
&#9;&#9;local Value = 0
&#9;&#9;for Index = 1, Length do
&#9;&#9;&#9;local CharacterValue = string.byte(string.sub(Name, Index, Index))
&#9;&#9;&#9;local ReverseIndex = Length - Index + 1
&#9;&#9;&#9;if Length % 2 == 1 then
&#9;&#9;&#9;&#9;ReverseIndex = ReverseIndex - 1
&#9;&#9;&#9;end
&#9;&#9;&#9;if ReverseIndex % 4 &gt;= 2 then
&#9;&#9;&#9;&#9;CharacterValue = -CharacterValue
&#9;&#9;&#9;end
&#9;&#9;&#9;Value = Value + CharacterValue
&#9;&#9;end
&#9;&#9;return Value % 8
&#9;end

&#9;function GetPlayerNameColorRaw(Name)
&#9;&#9;return PlayerColours[GetNameValue(Name) + 1]
&#9;end
end
lib.GetPlayerNameColorRaw = GetPlayerNameColorRaw
lib.getPlayerNameColorRaw = GetPlayerNameColorRaw

local function IsRobloxAdmin(Name)
&#9;--- Finds out if a player is a ROBLOX admin
&#9;-- @param Name The name of the player to check for
&#9;-- @return Boolean if the player is a ROBLOX admin or not.

&#9;Name = Name:lower()
&#9;for _, Admin in pairs(PseudoChatSettings.ROBLOXAdminList) do
&#9;&#9;if Admin:lower() == Name then
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;end
&#9;return false
end
lib.IsRobloxAdmin = IsRobloxAdmin
lib.isRobloxAdmin = IsRobloxAdmin

local function GetPlayerFromName(PlayerName)
&#9;--- Get&apos;s a player from their username.
&#9;-- @param PlayerName THe name of the player
&#9;-- @return The player, if they are in-game.

&#9;local Player = Players:FindFirstChild(PlayerName)
&#9;if Player and Player:IsA(&quot;Player&quot;) then
&#9;&#9;return Player
&#9;else
&#9;&#9;return nil
&#9;end
end
lib.GetPlayerFromName = GetPlayerFromName
lib.getPlayerFromName = GetPlayerFromName

local function GetPlayerChatColor(Name)
&#9;--- Return&apos;s a player&apos;s chat color
&#9;-- @param Name THe name of the player

&#9;if PseudoChatSettings.SpecialChatColors[Name] then
&#9;&#9;return PseudoChatSettings.SpecialChatColors[Name]
&#9;elseif IsRobloxAdmin(Name) then
&#9;&#9;return PseudoChatSettings.RobloxAdminChatColor
&#9;else
&#9;&#9;return PseudoChatSettings.DefaultChatColor
&#9;end
end
lib.GetPlayerChatColor = GetPlayerChatColor
lib.getPlayerChatColor = GetPlayerChatColor

local function GetPlayerNameColor(Name)
&#9;--- Return&apos;s a player&apos;s name color.
&#9;-- Priorities predefined, and then their TeamColor, and then finally the hashed name.
&#9;-- @param Name THe name of the player
&#9;-- @return Color3 value of what to color their name.

&#9;local Player = GetPlayerFromName(Name)

&#9;if PseudoChatSettings.SpecialNameColors[Name] then
&#9;&#9;return PseudoChatSettings.SpecialNameColors[Name]
&#9;else
&#9;&#9;if not Player or Player.Neutral then
&#9;&#9;&#9;return GetPlayerNameColorRaw(Name)
&#9;&#9;else
&#9;&#9;&#9;return Player.TeamColor.Color
&#9;&#9;end
&#9;end
end
lib.GetPlayerNameColor = GetPlayerNameColor
lib.getPlayerNameColor = GetPlayerNameColor

local CachedSpaceStringList = {}

local function ComputeSpaceString(Label, PlayerLabel)
&#9;--- Given a name, return the spaces required to push a text wrapped thing out of the way. Tricky Sorcus. Tricky. 
&#9;-- @param Label The label to test upon, probably the message label.
&#9;-- @param PlayerLabel The label representing the Player&apos;s name.

&#9;local newString = &quot; &quot;
&#9;
&#9;Label.Text = newString

&#9;while Label.TextBounds.X &lt; PlayerLabel.TextBounds.X do
&#9;&#9;-- print(Label.TextBounds.X .. &quot; &lt; &quot; .. PlayerLabel.TextBounds.X)
&#9;&#9;newString = newString .. &quot; &quot;
&#9;&#9;Label.Text = newString;
&#9;end
&#9;newString = newString .. &quot; &quot;
&#9;CachedSpaceStringList[PlayerLabel.Text] = newString
&#9;Label.Text = &quot;&quot;

&#9;return newString
end
lib.ComputeSpaceString = ComputeSpaceString
lib.computeSpaceString = ComputeSpaceString

local function GetSpaceString(Label, PlayerLabel)
&#9;--- Get&apos;s the cached version of the space string, or return&apos;s a new one. Since we&apos;re caching, the size of the text can&apos;t change halfway
&#9;--  through.
&#9;-- @param Label The label to test upon, probably the message label.
&#9;-- @param PlayerLabel The label representing the Player&apos;s name.

&#9;return CachedSpaceStringList[PlayerLabel.Text] or ComputeSpaceString(Label, PlayerLabel)
end
lib.GetSpaceString = GetSpaceString
lib.getSpaceString = GetSpaceString

local function GenericTextFadeIn(Gui, Time)
&#9;--- Transitions text labels to fade in. Recurses on children. 

&#9;CallOnChildren(Gui, function(Child)
&#9;&#9;if Child:IsA(&quot;TextLabel&quot;) or Child:IsA(&quot;TextButton&quot;) or Child:IsA(&quot;TextBox&quot;) then
&#9;&#9;&#9;local CurrentTextTransparency = Child.TextTransparency
&#9;&#9;&#9;local CurrentStrokeTransparency = Child.TextStrokeTransparency
&#9;&#9;&#9;Child.TextTransparency        = 1;
&#9;&#9;&#9;Child.TextStrokeTransparency  = 1;

&#9;&#9;&#9;qGUI.TweenTransparency(Child, {
&#9;&#9;&#9;&#9;TextTransparency       = CurrentTextTransparency;
&#9;&#9;&#9;&#9;TextStrokeTransparency = CurrentStrokeTransparency;
&#9;&#9;&#9;}, Time, true)
&#9;&#9;end
&#9;end)
end

local function GenericTextFadeOut(Gui, Time)
&#9;--- Trasitions text labels to fade out. Recurses on children. 

&#9;CallOnChildren(Gui, function(Child)
&#9;&#9;if Child:IsA(&quot;TextLabel&quot;) or Child:IsA(&quot;TextButton&quot;) or Child:IsA(&quot;TextBox&quot;) then
&#9;&#9;&#9;qGUI.TweenTransparency(Child, {
&#9;&#9;&#9;&#9;TextTransparency       = 1;
&#9;&#9;&#9;&#9;TextStrokeTransparency = 1;
&#9;&#9;&#9;}, Time, true)
&#9;&#9;end
&#9;end)
end
local ChatParser, ChatRender, ChatOutputClass do -- Chat parsing
&#9;function ChatRender(Parent, Data, DoNotAnimate)
&#9;&#9;--- Renders a frame, and returns it
&#9;&#9;-- @param Data The data is sent from the below parser, to the client
&#9;&#9;--[[ The following expected
&#9;&#9;&#9;Message &apos;String&apos; The message to be displayed.
&#9;&#9;&#9;PlayerColor &apos;Color3&apos; The Color3 value, in JSON, of the Player&apos;s name.
&#9;&#9;&#9;ClassName &apos;String&apos; The class of the chat. Automatically added.
&#9;&#9;&#9;ChatColor &apos;Color3&apos; The Color3 value
&#9;&#9;--]]
&#9;&#9;-- @return Gui Frame, resized correctly for the parent. 

&#9;&#9;local PlayerChatFrame = Make(&quot;Frame&quot;, {
&#9;&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;&#9;Parent                 = Parent;
&#9;&#9;&#9;Size                   = UDim2.new(1, 0, 1, 0);
&#9;&#9;&#9;Visible                = true;
&#9;&#9;&#9;Name                   = Data.ClassName;
&#9;&#9;})

&#9;&#9;local PlayerLabel = Make(&quot;TextLabel&quot;, {
&#9;&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;&#9;FontSize               = PseudoChatSettings.ChatFontSize;
&#9;&#9;&#9;Name                   = &quot;ChatNameLabel&quot;;
&#9;&#9;&#9;Parent                 = PlayerChatFrame; -- For text bounds, reassigned later. 
&#9;&#9;&#9;Position               = UDim2.new(0, PseudoChatSettings.LabelOffsetX, 0, 0);
&#9;&#9;&#9;Size                   = UDim2.new(1, -PseudoChatSettings.LabelOffsetX, 1, 0);
&#9;&#9;&#9;Text                   = Data.PlayerName..&quot;:&quot;;
&#9;&#9;&#9;TextColor3             = Data.PlayerColor;
&#9;&#9;&#9;TextStrokeColor3       = Color3.new(0.5, 0.5, 0.5);
&#9;&#9;&#9;TextStrokeTransparency = 1;
&#9;&#9;&#9;TextTransparency       = 0;
&#9;&#9;&#9;TextWrapped            = false;
&#9;&#9;&#9;TextXAlignment         = &quot;Left&quot;;
&#9;&#9;&#9;TextYAlignment         = &quot;Top&quot;;
&#9;&#9;&#9;ZIndex                 = Parent.ZIndex;&#9;
&#9;&#9;})

&#9;&#9;local MessageLabel = Make(&quot;TextLabel&quot;, {
&#9;&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;&#9;BorderSizePixel        = 0.0;
&#9;&#9;&#9;FontSize               = PseudoChatSettings.ChatFontSize;
&#9;&#9;&#9;Name                   = &quot;Message&quot;;
&#9;&#9;&#9;Parent                 = PlayerChatFrame;
&#9;&#9;&#9;Position               = UDim2.new(0, PseudoChatSettings.LabelOffsetX, 0, 0);
&#9;&#9;&#9;Size                   = UDim2.new(1, -PseudoChatSettings.LabelOffsetX, 1, 0);
&#9;&#9;&#9;TextColor3             = Data.ChatColor;
&#9;&#9;&#9;TextStrokeColor3       = Color3.new(0, 0, 0);
&#9;&#9;&#9;TextWrapped            = true;
&#9;&#9;&#9;TextStrokeTransparency = Data.MessageLabelTextStrokeTransparency;
&#9;&#9;&#9;TextXAlignment         = &quot;Left&quot;;
&#9;&#9;&#9;TextYAlignment         = &quot;Top&quot;;
&#9;&#9;&#9;ZIndex                 = Parent.ZIndex;
&#9;&#9;})

&#9;&#9;-- Set Message&apos;s Text --
&#9;&#9;local MessageSpacer = GetSpaceString(MessageLabel, PlayerLabel)
&#9;&#9;MessageLabel.Text   = MessageSpacer .. PseudoChatSettings.ContentFailed
&#9;&#9;MessageLabel.Text   = MessageSpacer .. Data.Message

&#9;&#9;local Height = qMath.RoundUp(MessageLabel.TextBounds.Y, PseudoChatSettings.LineHeight)
&#9;&#9;PlayerChatFrame.Size = UDim2.new(1, 0, 0, Height)

&#9;&#9;if DoNotAnimate then
&#9;&#9;&#9;
&#9;&#9;else
&#9;&#9;&#9;GenericTextFadeIn(PlayerChatFrame, 0.2)
&#9;&#9;end
&#9;&#9;return PlayerChatFrame
&#9;end

&#9;ChatParser = OutputStream.MakeOutputParser(function(Data)
&#9;&#9;--- Constructs a new &quot;data&quot; field to be sent, as well as fills in Data.

&#9;&#9;local Parsed = {}

&#9;&#9;Data.Message     = qString.TrimString(Data.Message and tostring(Data.Message) or &quot;[ No Message Provided ]&quot;)
&#9;&#9;Data.PlayerName  = Data.PlayerName or &quot;NoPlayerName&quot;;
&#9;&#9;Data.PlayerColor = Data.PlayerColor or GetPlayerNameColor(Data.PlayerName)
&#9;&#9;Data.ChatColor   = Data.ChatColor or GetPlayerChatColor(Data.PlayerName)
&#9;&#9;Data.MessageLabelTextStrokeTransparency = Data.MessageLabelTextStrokeTransparency or 0.8

&#9;&#9;Parsed.Message     = Data.Message
&#9;&#9;Parsed.PlayerName  = Data.PlayerName
&#9;&#9;Parsed.PlayerColor = qColor3.Encode(Data.PlayerColor)
&#9;&#9;Parsed.ChatColor   = qColor3.Encode(Data.ChatColor)&#9;&#9;
&#9;&#9;Parsed.MessageLabelTextStrokeTransparency = Data.MessageLabelTextStrokeTransparency

&#9;&#9;-- print(Parsed.PlayerColor)
&#9;&#9;-- print(Parsed.ChatColor)

&#9;&#9;return Parsed
&#9;end, function(Data)
&#9;&#9;--- Decodes JSON (unparses) it.
&#9;&#9;-- @return Table, if unparsed successfully, otherwise, nil

&#9;&#9;-- print(Data.PlayerColor)
&#9;&#9;-- print(Data.ChatColor)

&#9;&#9;local DecodedChatColor = qColor3.Decode(Data.ChatColor)
&#9;&#9;if DecodedChatColor then
&#9;&#9;&#9;Data.ChatColor = DecodedChatColor
&#9;&#9;else
&#9;&#9;&#9;Warn(&quot;[OutputParser] - Unable to parse Notifications&apos;s ChatColor in data&quot;)
&#9;&#9;end

&#9;&#9;local DecodedPlayerColor = qColor3.Decode(Data.PlayerColor)
&#9;&#9;if DecodedPlayerColor then
&#9;&#9;&#9;Data.PlayerColor = DecodedPlayerColor
&#9;&#9;else
&#9;&#9;&#9;Warn(&quot;[OutputParser] - Unable to parse Notifications&apos;s PlayerColor in data&quot;)
&#9;&#9;end

&#9;&#9;return Data
&#9;end)

&#9;ChatOutputClass = OutputStream.MakeOutputClass(&quot;ChatOutputClass&quot;, 
&#9;&#9;ChatParser, 
&#9;&#9;ChatRender
&#9;);
end
lib.ChatOutputClass = ChatOutputClass

local OutputParser, OutputRender, OutputOutputClass do -- Output parsing
&#9;function OutputRender(Parent, Data, DoNotAnimate)
&#9;&#9;--- Renders a new &quot;Output&quot; from the Data given.
&#9;&#9;-- @param Data The data given. 

&#9;&#9;local NotificationChatFrame = Make(&quot;Frame&quot;, {
&#9;&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;&#9;Parent                 = Parent;
&#9;&#9;&#9;Size                   = UDim2.new(1, 0, 1, 0);
&#9;&#9;&#9;Visible                = true;
&#9;&#9;&#9;Name                   = Data.ClassName;
&#9;&#9;})

&#9;&#9;local MessageLabel = Make(&quot;TextLabel&quot;, {
&#9;&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;&#9;BorderSizePixel        = 0.0;
&#9;&#9;&#9;FontSize               = PseudoChatSettings.ChatFontSize;
&#9;&#9;&#9;Name                   = &quot;Message&quot;;
&#9;&#9;&#9;Parent                 = NotificationChatFrame;
&#9;&#9;&#9;Position               = UDim2.new(0, PseudoChatSettings.LabelOffsetXOutput, 0, 0);
&#9;&#9;&#9;Size                   = UDim2.new(1, -PseudoChatSettings.LabelOffsetXOutput, 1, 0);
&#9;&#9;&#9;TextColor3             = Data.ChatColor;
&#9;&#9;&#9;Text                   = PseudoChatSettings.ContentFailed;
&#9;&#9;&#9;TextStrokeColor3       = Color3.new(0, 0, 0);
&#9;&#9;&#9;TextWrapped            = true;
&#9;&#9;&#9;TextStrokeTransparency = Data.MessageLabelTextStrokeTransparency;
&#9;&#9;&#9;TextXAlignment         = &quot;Left&quot;;
&#9;&#9;&#9;TextYAlignment         = &quot;Top&quot;;
&#9;&#9;&#9;ZIndex                 = Parent.ZIndex;
&#9;&#9;})
&#9;&#9;MessageLabel.Text = tostring(Data.Message)

&#9;&#9;-- print(NotificationChatFrame.AbsoluteSize.Y)
&#9;&#9;-- print(NotificationChatFrame:GetFullName())
&#9;&#9;-- print(MessageLabel.TextBounds.Y)

&#9;&#9;local Height = qMath.RoundUp(MessageLabel.TextBounds.Y, PseudoChatSettings.LineHeight)
&#9;&#9;NotificationChatFrame.Size = UDim2.new(1, 0, 0, Height)

&#9;&#9;return NotificationChatFrame
&#9;end

&#9;OutputParser = OutputStream.MakeOutputParser(function(Data)
&#9;&#9;--- Constructs a new &quot;data&quot; field to be sent.
&#9;&#9;-- @param Message The chat the player said
&#9;&#9;-- @param ChatColor The ChatColor to render at

&#9;&#9;local Parsed = {}

&#9;&#9;Data.Message     = qString.TrimString(Data.Message and tostring(Data.Message) or &quot;[ No Message Provided ]&quot;)
&#9;&#9;Data.ChatColor   = Data.ChatColor or PseudoChatSettings.DefaultNotificationColor;
&#9;&#9;Data.MessageLabelTextStrokeTransparency = Data.MessageLabelTextStrokeTransparency or 0.8

&#9;&#9;Parsed.Message     = Data.Message
&#9;&#9;Parsed.ChatColor   = qColor3.Encode(Data.ChatColor)&#9;&#9;
&#9;&#9;Parsed.MessageLabelTextStrokeTransparency = Data.MessageLabelTextStrokeTransparency
&#9;&#9;

&#9;&#9;return Parsed
&#9;end, function(Data)
&#9;&#9;--- Decodes JSON (unparses) it.
&#9;&#9;-- @param JSONData String JSON data, to be deparsed

&#9;&#9;local DecodedChatColor = qColor3.Decode(Data.ChatColor)
&#9;&#9;if DecodedChatColor then
&#9;&#9;&#9;Data.ChatColor = DecodedChatColor
&#9;&#9;else
&#9;&#9;&#9;Warn(&quot;[OutputParser] - Unable to parse Notifications&apos;s ChatColor in data&quot;)
&#9;&#9;end

&#9;&#9;return Data
&#9;end)

&#9;OutputOutputClass = OutputStream.MakeOutputClass(&quot;OutputOutputClass&quot;, 
&#9;&#9;OutputParser, 
&#9;&#9;OutputRender
&#9;);
end
lib.OutputOutputClass = OutputOutputClass

return lib</ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX18">
						<Properties>
							<string name="Name">PseudoChatManagerServer</string>
							<ProtectedString name="Source">local ReplicatedStorage        = game:GetService(&quot;ReplicatedStorage&quot;)
local Players                  = game:GetService(&quot;Players&quot;)
local LogService               = game:GetService(&quot;LogService&quot;)
local ScriptContext            = game:GetService(&quot;ScriptContext&quot;)

local NevermoreEngine          = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary        = NevermoreEngine.LoadLibrary

local qSystems                 = LoadCustomLibrary(&quot;qSystems&quot;)
local PseudoChatSettings       = LoadCustomLibrary(&quot;PseudoChatSettings&quot;)
local PseudoChatParser         = LoadCustomLibrary(&quot;PseudoChatParser&quot;)
local OutputClassStreamLoggers = LoadCustomLibrary(&quot;OutputClassStreamLoggers&quot;)
local OutputStream             = LoadCustomLibrary(&quot;OutputStream&quot;)
local qString                  = LoadCustomLibrary(&quot;qString&quot;)
local AuthenticationServiceServer    = LoadCustomLibrary(&quot;AuthenticationServiceServer&quot;)

-- local ShipKillFeedParser       = LoadCustomLibrary(&quot;ShipKillFeedParser&quot;)

qSystems:Import(getfenv(0))

-- PseudoChatManagerServer.lua
-- Manages chat connections, sends and making chats, filtering, et cetera.
-- Intendend for Serverside use only. 
-- @author Quenty
-- Last modified Janurary 19th, 2014

--[[-- Change Log --
Febraury 6th, 2015
- Updated to use AuthenticationServiceServer
- Modified AdminOutput to not use filter
- Modified to accept error output from client

February 3rd, 2014
- Fixed issue with /e emoticons and filtering.

January 26th, 2014
- Switched to OutputStream system. 

January 19th, 2014
- Added callback system to PseudoChatManager
- Added QuentyAdminCommandsOutput parser to system
- Added ScriptbuilderParser to the system
- Added Changelog

-- January 5th, 2014 --
- Wrote initial script

--]]

local PseudoChatManager = {} do
&#9;local ClientToServerOutputStream = NevermoreEngine.GetEventStream(&quot;ClientToServerOutputStream&quot;)

&#9;local ChatChannel = OutputStream.MakeOutputStreamServer(
&#9;&#9;OutputClassStreamLoggers.MakeGlobalOutputStreamLog(PseudoChatSettings.BufferSize),
&#9;&#9;&quot;ChatChannel&quot;
&#9;);
&#9;ChatChannel.AddOutputClass(PseudoChatParser.OutputOutputClass)
&#9;ChatChannel.AddOutputClass(PseudoChatParser.ChatOutputClass)

&#9;-- Notification stream
&#9;local NotificationChannel = OutputStream.MakeOutputStreamServer(
&#9;&#9;OutputClassStreamLoggers.MakePlayerNotificationStreamLog(PseudoChatSettings.BufferSize), 
&#9;&#9;&quot;NotificationChannel&quot;
&#9;);
&#9;NotificationChannel.AddOutputClass(PseudoChatParser.OutputOutputClass)


&#9;-- Admin stream
&#9;local AdminLogChannel = OutputStream.MakeOutputStreamServer(
&#9;&#9;OutputClassStreamLoggers.MakeGlobalFilteredLogStreamLog(AuthenticationServiceServer.IsAuthorized, PseudoChatSettings.BufferSize), 
&#9;&#9;&quot;AdminChannel&quot;
&#9;);
&#9;AdminLogChannel.AddOutputClass(PseudoChatParser.OutputOutputClass)

&#9;-- Output Stream
&#9;-- local AdminOutputClass = OutputStream.MakeOutputStreamServer(
&#9;-- &#9;OutputClassStreamLoggers.MakeGlobalFilteredLogStreamLog(AuthenticationServiceServer.IsAuthorized, PseudoChatSettings.BufferSize), 
&#9;-- &#9;&quot;Admin-Output&quot;
&#9;-- );
&#9;-- AdminOutputClass.AddOutputClass(PseudoChatParser.OutputOutputClass)

&#9;local Muted = {} -- List of muted players
&#9;local ChatCallbacks = {}

&#9;local function ExecuteChatCallbacks(Player, Message, PlayerColor, ChatColor)
&#9;&#9;--- Goes through each ChatCallbacks and executes it.
&#9;&#9;-- Used internally, called before a player is allowed to chat. 
&#9;&#9;-- Called even if mute is enabled. Calls every one. Order is undefined. 
&#9;&#9;-- @return Boolean True if it should not render.

&#9;&#9;local DoExecute = false

&#9;&#9;for _, Item in pairs(ChatCallbacks) do
&#9;&#9;&#9;local Result = Item(Player, Message, PlayerColor, ChatColor)
&#9;&#9;&#9;if Result then
&#9;&#9;&#9;&#9;-- print(&quot;[PseudoChatManager] - Callback result was &quot; .. tostring(Result))
&#9;&#9;&#9;&#9;DoExecute = true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return DoExecute
&#9;end

&#9;local function AddChatCallback(Callback)
&#9;&#9;--- Adds a callback to the chat callback system.
&#9;&#9;-- @param CallbackName The name of the callback.
&#9;&#9;&#9;--- Should do stuff with the information, and / or execute code.
&#9;&#9;&#9;-- @param PlayerName The name of the player chatting
&#9;&#9;&#9;-- @param Message The message
&#9;&#9;&#9;-- @param PlayerColor Color3, The color of the player label 
&#9;&#9;&#9;-- @param ChatColor&#9;Color3 The color of the chat
&#9;&#9;&#9;-- @return Boolean, true if it should not render. 
&#9;&#9;-- Callbacks will be executed in any arbitary order. 

&#9;&#9;ChatCallbacks[#ChatCallbacks + 1] = Callback
&#9;end
&#9;PseudoChatManager.AddChatCallback = AddChatCallback
&#9;PseudoChatManager.addChatCallback = AddChatCallback
&#9;PseudoChatManager.add_chat_callback = AddChatCallback

&#9;local function Mute(PlayerName)
&#9;&#9;--- Mute&apos;s any player&apos;s with the name &quot;PlayerName&quot;;
&#9;&#9;-- @param PlayerName String, The name of the player to mute

&#9;&#9;Muted[PlayerName:lower()] = true
&#9;end
&#9;PseudoChatManager.Mute = Mute
&#9;PseudoChatManager.mute = Mute

&#9;local function Unmute(PlayerName)
&#9;&#9;--- Remove&apos;s the mute from the player
&#9;&#9;-- @param PlayerName String, The name of the player to unmute

&#9;&#9;Muted[PlayerName:lower()] = nil
&#9;end
&#9;PseudoChatManager.Unmute = Unmute
&#9;PseudoChatManager.unmute = Unmute

&#9;local function IsMuted(PlayerName)
&#9;&#9;--- Get if a player is muted or not
&#9;&#9;-- @param PlayerName String, The name of the player to check
&#9;&#9;-- @return Boolean, is the player muted or not.

&#9;&#9;return Muted[PlayerName:lower()] or false
&#9;end
&#9;PseudoChatManager.IsMuted = IsMuted
&#9;PseudoChatManager.isMuted = IsMuted

&#9;local function FilteredNotify(PlayerList, Message, ChatColor)
&#9;&#9;--- Notifies a player
&#9;&#9;-- @param PlayerList A list of players to send it too
&#9;&#9;-- @param ChatColor The color of the chat. 
&#9;&#9;-- @param Message The message to send

&#9;&#9;-- This is basically a shortcode for RenderDataStream.Send

&#9;&#9;assert(PlayerList ~= nil, &quot;[PseudoChatManager] - PlayerList is nil.&quot;)

&#9;&#9;NotificationChannel.Send(&quot;OutputOutputClass&quot;, {
&#9;&#9;&#9;Message = tostring(Message);
&#9;&#9;&#9;ChatColor = ChatColor;

&#9;&#9;&#9;Inclusive = true;
&#9;&#9;&#9;FilterList = PlayerList;
&#9;&#9;})
&#9;end
&#9;PseudoChatManager.FilteredNotify = FilteredNotify
&#9;PseudoChatManager.filteredNotify = FilteredNotify

&#9;local function Notify(Message, ChatColor)
&#9;&#9;print(&quot;Notify&quot;)
&#9;&#9;NotificationChannel.Send(&quot;OutputOutputClass&quot;, {
&#9;&#9;&#9;Message = tostring(Message);
&#9;&#9;&#9;ChatColor = ChatColor;

&#9;&#9;&#9;Inclusive = false;
&#9;&#9;&#9;FilterList = {};
&#9;&#9;})
&#9;end
&#9;PseudoChatManager.Notify = Notify
&#9;PseudoChatManager.Notify = Notify

&#9;-- local function Output(Output, ChatColor)
&#9;-- &#9;--- Output&apos;s script builder output to a player
&#9;-- &#9;-- @param Output The output to output
&#9;-- &#9;-- @param ChatColor The chat color to output.

&#9;-- &#9;-- print(&quot;*** OUTPUT \&quot;&quot; .. Output .. &quot;\&quot;&quot;)

&#9;-- &#9;local Data = {
&#9;-- &#9;&#9;Message = Output;
&#9;-- &#9;&#9;ChatColor = ChatColor;
&#9;-- &#9;}
&#9;-- &#9;-- print(&quot;Filter list [0] @ Send&quot; .. tostring(Data.FilterList) .. &quot;, Data = &quot; .. tostring(Data))

&#9;-- &#9;AdminOutputClass.Send(&quot;OutputOutputClass&quot;, Data)
&#9;-- end
&#9;-- PseudoChatManager.Output = Output
&#9;-- PseudoChatManager.output = Output

&#9;local function AdminOutput(Output, ChatColor)
&#9;&#9;--- Output&apos;s admin commands log
&#9;&#9;-- @param Output The output to Output
&#9;&#9;-- @param ChatColor The chat color to output.


&#9;&#9;AdminLogChannel.Send(&quot;OutputOutputClass&quot;, {
&#9;&#9;&#9;Message   = Output;
&#9;&#9;&#9;ChatColor = ChatColor;
&#9;&#9;})
&#9;end
&#9;PseudoChatManager.AdminOutput = AdminOutput
&#9;PseudoChatManager.adminOutput = AdminOutput

&#9;local function Chat(PlayerName, Message, PlayerColor, ChatColor)
&#9;&#9;--- Makes the player with the name &quot;PlayerName&quot; chat &quot;Message&quot; No callbacks or filtered anything
&#9;&#9;-- @param PlayerName The name of the player saying the message
&#9;&#9;-- @param Message The message to say
&#9;&#9;-- @param [PlayerColor] The color of the player&apos;s name. Optional. 
&#9;&#9;-- @param [ChatColor] The color of the chat. Optional. 

&#9;&#9;ChatChannel.Send(&quot;ChatOutputClass&quot;, {
&#9;&#9;&#9;PlayerName  = tostring(PlayerName);
&#9;&#9;&#9;Message     = tostring(Message);
&#9;&#9;&#9;PlayerColor = PlayerColor;
&#9;&#9;&#9;ChatColor   = ChatColor;
&#9;&#9;})
&#9;end
&#9;PseudoChatManager.RawChat  = Chat
&#9;PseudoChatManager.rawChat  = Chat
&#9;PseudoChatManager.raw_chat = Chat

&#9;local function SendCustomNotification(OutputClass, Data)
&#9;&#9;--- Used to send killfeed and stuff...

&#9;&#9;NotificationChannel.Send(OutputClass, Data)
&#9;end
&#9;PseudoChatManager.SendCustomNotification = SendCustomNotification
&#9;PseudoChatManager.sendCustomNotification = SendCustomNotification

&#9;local function AddOutputClassToMainChannelNotify(Class)
&#9;&#9;--- Used to output custom classes, like kill feed.
&#9;&#9;NotificationChannel.AddOutputClass(Class)
&#9;end
&#9;PseudoChatManager.AddOutputClassToMainChannelNotify = AddOutputClassToMainChannelNotify
&#9;PseudoChatManager.addOutputClassToMainChannelNotify = AddOutputClassToMainChannelNotify

&#9;local function HandleChat(PlayerName, Message, PlayerColor, ChatColor)
&#9;&#9;--- Handle&apos;s chat replciation whenver a player chats.
&#9;&#9;-- @param PlayerName The PlayerName chatting
&#9;&#9;-- @param Message The message of the player

&#9;&#9;local DoNotDisplay = ExecuteChatCallbacks(PlayerName, Message, PlayerColor, ChatColor)

&#9;&#9;if DoNotDisplay then
&#9;&#9;&#9;print(&quot;[PseudoChatManager] - Player &quot; .. PlayerName .. &quot;&apos;s chat &apos;&quot; .. Message .. &quot;&apos; was stopped by a callback. &quot;)
&#9;&#9;else
&#9;&#9;&#9;if not IsMuted(PlayerName) then
&#9;&#9;&#9;&#9;Chat(PlayerName, Message, PlayerColor, ChatColor)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(&quot;[PseudoChatManager] - Player &apos;&quot; .. PlayerName .. &quot;&apos; is muted. &quot;)
&#9;&#9;&#9;&#9;-- Notify the player that they can&apos;t speak, they are muted!
&#9;&#9;&#9;&#9;local Player = Players:FindFirstChild(PlayerName)
&#9;&#9;&#9;&#9;if Player and Player:IsA(&quot;Player&quot;) then
&#9;&#9;&#9;&#9;&#9;FilteredNotify({Player.userId}, PseudoChatSettings.MutedMessage, PseudoChatSettings.MutedMessageColor)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;print(&quot;No player identified to notify the cannot chat&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;PseudoChatManager.Chat = HandleChat
&#9;PseudoChatManager.chat = HandleChat

&#9;--[[local function HandlePlayer(Player)
&#9;&#9;--- Handle&apos;s the player by connecting events, et cetera.

&#9;&#9;Player.Chatted:connect(function(Message)
&#9;&#9;&#9;HandleChat(Player.Name, Message)
&#9;&#9;end)
&#9;end--]]
&#9;
&#9;--[==[
&#9;local function Initiate()
&#9;&#9;-- Sets up PseudoChat. 

&#9;&#9;-- Connect events
&#9;&#9;--[[for _, Player in pairs(Players:GetPlayers()) do
&#9;&#9;&#9;HandlePlayer(Player)
&#9;&#9;end

&#9;&#9;Players.PlayerAdded:connect(function(Player)
&#9;&#9;&#9;HandlePlayer(Player)
&#9;&#9;end)--]]

&#9;&#9;ScriptContext.Error:connect(function(Message, StackTrace, Script)
&#9;&#9;&#9;Script = tostring(Script)
&#9;&#9;&#9;
&#9;&#9;&#9;Output((Script .. &quot; &quot; .. Message), Color3.new(1, 0, 0))
&#9;&#9;&#9;Output(StackTrace, Color3.new(0, 209/255, 255/255))
&#9;&#9;end)

&#9;&#9;LogService.MessageOut:connect(function(Message, MessageType)
&#9;&#9;&#9;local MessageColor
&#9;&#9;&#9;if MessageType.Name == &quot;MessageWarning&quot; then
&#9;&#9;&#9;&#9;MessageColor = Color3.new(255/255, 233/255, 181/255)
&#9;&#9;&#9;elseif MessageType.Name == &quot;MessageError&quot; then
&#9;&#9;&#9;&#9;MessageColor = Color3.new(1, 0, 0)
&#9;&#9;&#9;elseif MessageType.Name == MessageInfo then
&#9;&#9;&#9;&#9;MessageColor = Color3.new(0, 209/255, 255/255)
&#9;&#9;&#9;end
&#9;&#9;&#9;Output(Message, MessageColor)
&#9;&#9;end)
&#9;end
&#9;PseudoChatManager.Initiate = Initiate
&#9;PseudoChatManager.Initiate = Initiate--]==]

&#9;-- ClientToServerOutputStream.RegisterRequestTag(&quot;Error&quot;, function(Client, NewOutput)
&#9;-- &#9;Output(&quot;[&quot; .. tostring(Client) .. &quot;] - &quot; .. NewOutput.Script .. NewOutput.Message, Color3.new(1, 0, 0))
&#9;-- &#9;Output(NewOutput.StackTrace, Color3.new(0, 209/255, 255/255))
&#9;-- end)

&#9;ClientToServerOutputStream.RegisterRequestTag(&quot;Message&quot;, function(Client, Message)
&#9;&#9;if Message then
&#9;&#9;&#9;HandleChat(Client.Name, Message)
&#9;&#9;else
&#9;&#9;&#9;warn(&quot;[ClientToServerOutputStream] - No message sent. :/&quot;)
&#9;&#9;end
&#9;end)
end

PseudoChatManager.AddChatCallback(function(Player, Message, PlayerColor, ChatColor)
&#9;if qString.CompareCutFirst(Message, &quot;/e&quot;) then
&#9;&#9;return true
&#9;end
&#9;return false
end)

do
&#9;local SpamMuted = {}
&#9;local MuteDurationOnViolation = 10
&#9;local TimeWindow = 15;
&#9;local MaxChatRatioPerASecond = 1.5--2; -- 2 chats, every 1 seconds.

&#9;local function MutePlayer(PlayerName)
&#9;&#9;SpamMuted[PlayerName:lower()] = tick() + MuteDurationOnViolation
&#9;end

&#9;local PlayerDataBin = {}

&#9;PseudoChatManager.AddChatCallback(function(PlayerName, Message, PlayerColor, ChatColor)
&#9;&#9;local CurrentTime = tick()

&#9;&#9;local MutedState = SpamMuted[PlayerName:lower()]
&#9;&#9;if MutedState then
&#9;&#9;&#9;local TimeLeft = MutedState - CurrentTime

&#9;&#9;&#9;if TimeLeft &gt; 0 then
&#9;&#9;&#9;&#9;local Player = Players:FindFirstChild(PlayerName)
&#9;&#9;&#9;&#9;if Player and Player:IsA(&quot;Player&quot;) then
&#9;&#9;&#9;&#9;&#9;PseudoChatManager.FilteredNotify({Player.userId}, &quot;Stop spamming please. You&apos;ve been muted for &quot; .. math.floor(TimeLeft+1) .. &quot; more seconds.&quot;, PseudoChatSettings.MutedMessageColor)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;warn(&quot;[ChatSpamManager] - Could not find player with name &apos;&quot; .. PlayerName .. &quot;&apos; in game.&quot;)
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;SpamMuted[PlayerName:lower()] = nil
&#9;&#9;&#9;&#9;return false
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local DataBin = PlayerDataBin[PlayerName:lower()]
&#9;&#9;&#9;if DataBin then
&#9;&#9;&#9;&#9;-- http://www.perl.com/pub/2004/11/11/floodcontrol.html

&#9;&#9;&#9;&#9;local Index = 1
&#9;&#9;&#9;&#9;local OldestEventAge
&#9;&#9;&#9;&#9;local EventCount = 0

&#9;&#9;&#9;&#9;while Index &lt; #DataBin do
&#9;&#9;&#9;&#9;&#9;local TimeStamp = DataBin[Index]

&#9;&#9;&#9;&#9;&#9;local TimeAgo = CurrentTime - TimeStamp
&#9;&#9;&#9;&#9;&#9;if TimeAgo &gt; TimeWindow then
&#9;&#9;&#9;&#9;&#9;&#9;table.remove(DataBin, Index)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;OldestEventAge = OldestEventAge or TimeAgo
&#9;&#9;&#9;&#9;&#9;&#9;EventCount = EventCount + 1
&#9;&#9;&#9;&#9;&#9;&#9;Index = Index + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;if OldestEventAge then
&#9;&#9;&#9;&#9;&#9;local Ratio = EventCount/OldestEventAge
&#9;&#9;&#9;&#9;&#9;if Ratio &gt;= MaxChatRatioPerASecond then
&#9;&#9;&#9;&#9;&#9;&#9;MutePlayer(PlayerName)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;DataBin[#DataBin+1] = tick() -- Add a new timestamp in.
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;warn(&quot;[ChatSpamManager] - Warning, no data for player &apos;&quot; .. PlayerName .. &quot;&apos;&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;return false
&#9;&#9;end
&#9;end)

&#9;local function HandlePlayerAdd(Player)
&#9;&#9;PlayerDataBin[Player.Name:lower()] = {}
&#9;end

&#9;local function HandlePlayerLeave(Player)
&#9;&#9;PlayerDataBin[Player.Name:lower()] = nil
&#9;end

&#9;Players.PlayerAdded:connect(HandlePlayerAdd)
&#9;for _, Player in pairs(Players:GetPlayers()) do
&#9;&#9;HandlePlayerAdd(Player)
&#9;end

&#9;Players.PlayerRemoving:connect(HandlePlayerLeave)
end

return PseudoChatManager
</ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX19">
						<Properties>
							<string name="Name">PseudoChat</string>
							<ProtectedString name="Source">local ReplicatedStorage           = game:GetService(&quot;ReplicatedStorage&quot;)
local Players                     = game:GetService(&quot;Players&quot;)
local LogService                  = game:GetService(&quot;LogService&quot;)
local ScriptContext               = game:GetService(&quot;ScriptContext&quot;)
local StarterGui                  = game:GetService(&quot;StarterGui&quot;)

local NevermoreEngine             = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary           = NevermoreEngine.LoadLibrary

local qSystems                    = LoadCustomLibrary(&quot;qSystems&quot;)
local OutputStreamInterface       = LoadCustomLibrary(&quot;OutputStreamInterface&quot;)
local PseudoChatParser            = LoadCustomLibrary(&quot;PseudoChatParser&quot;)
local OutputClassStreamLoggers    = LoadCustomLibrary(&quot;OutputClassStreamLoggers&quot;)
local OutputStream                = LoadCustomLibrary(&quot;OutputStream&quot;)
local PseudoChatBar               = LoadCustomLibrary(&quot;PseudoChatBar&quot;)
local ClientAuthenticationService = LoadCustomLibrary(&quot;ClientAuthenticationService&quot;)

-- local ShipKillFeedParser          = LoadCustomLibrary(&quot;ShipKillFeedParser&quot;)

-- Setups up the PseudoChat on the client. It&apos;s the equivalent of the PseudoChatManager for the
-- server

-- PseudoChat.lua
-- Intended for the client only. Sets up pseudo chat on the client. 
-- @author Quenty
-- Last modified Janurary 19th, 2014

--[[-- Update Log --
July 25th, 2014
- Made ChatBar API avialable. 

February 6th, 2014
- Added local-side output support for errors.
- Output does not go to global chat log now
- Fixed glitch with script concatination

January 26th, 2014
- Updated to OutputStream

January 19th, 2014
- Added change log
- Added ScriptbuilderParser
- Added QuentyAdminCommandsOutput

January 5th, 2014
- Wrote intitial script

--]]


qSystems:Import(getfenv(0))

local lib = {}

local function MakePseudoChat(ScreenGui)
&#9;--- This will render a pseudo chat output stream thingy. Of course, you don&apos;t have to use this module, but it simplifies everything.
&#9;-- @param ScreenGui The ScreenGui the chat goes into. 
&#9;local Chat = {}
&#9;local LocalPlayer = game.Players.LocalPlayer

&#9;local ClientToServerOutputStream = NevermoreEngine.GetEventStream(&quot;ClientToServerOutputStream&quot;)

&#9;local Interface = OutputStreamInterface.MakeOutputStreamInterface(nil, ScreenGui)
&#9;Chat.Interface  = Interface
&#9;Chat.Gui        = Interface.Gui

&#9;local ChatBar = PseudoChatBar.MakePseudoChatBar(ScreenGui)
&#9;Chat.ChatBar = ChatBar

&#9;local function SendMessage(Message)
&#9;&#9;ClientToServerOutputStream.Fire(&quot;Message&quot;, Message); --[[{
&#9;&#9;&#9;Message = Message;
&#9;&#9;&#9;-- Player  = LocalPlayer;
&#9;&#9;})--]]
&#9;end

&#9;LocalPlayer.Chatted:connect(function(Message)
&#9;&#9;SendMessage(Message)
&#9;end)

&#9;ChatBar.NewChat:connect(function(Message)
&#9;&#9;SendMessage(Message)
&#9;end)


&#9;local ChatChannel = OutputStream.MakeOutputStreamClient(
&#9;&#9;&quot;ChatChannel&quot;
&#9;);
&#9;ChatChannel.AddOutputClass(PseudoChatParser.OutputOutputClass)
&#9;ChatChannel.AddOutputClass(PseudoChatParser.ChatOutputClass)
&#9;-- ChatChannel.AddOutputClass(ShipKillFeedParser.ShipKillFeedClass)

&#9;-- Notification stream
&#9;local NotificationChannel = OutputStream.MakeOutputStreamClient(
&#9;&#9;&quot;NotificationChannel&quot;
&#9;);
&#9;NotificationChannel.AddOutputClass(PseudoChatParser.OutputOutputClass)
&#9;-- NotificationChannel.AddOutputClass(ShipKillFeedParser.ShipKillFeedClass)

&#9;-- Admin stream
&#9;local AdminLogChannel = OutputStream.MakeOutputStreamClient(
&#9;&#9;&quot;AdminChannel&quot;
&#9;);
&#9;AdminLogChannel.AddOutputClass(PseudoChatParser.OutputOutputClass)

&#9;-- Output Stream
&#9;-- local AdminOutput = OutputStream.MakeOutputStreamClient(
&#9;-- &#9;&quot;Admin-Output&quot;
&#9;-- );
&#9;-- AdminOutput.AddOutputClass(PseudoChatParser.OutputOutputClass)

&#9;-- We will syndicate resources. 
&#9;-- Global one has all of &apos;em. 
&#9;local GlobalSyndictator = OutputStream.MakeOutputStreamSyndicator(&quot;Chat&quot;)
&#9;&#9;GlobalSyndictator.AddOutputStream(ChatChannel)
&#9;&#9;GlobalSyndictator.AddOutputStream(NotificationChannel)
&#9;&#9;GlobalSyndictator.AddOutputStream(AdminLogChannel)
&#9;&#9;-- GlobalSyndictator.AddOutputStream(AdminOutput)

&#9;Interface.Subscribe(GlobalSyndictator,         nil, Color3.new( 85/255,  98/255, 112/255), true)

&#9;if ClientAuthenticationService.IsAuthorized() then
&#9;&#9;-- Chat Syndictator has only chat.
&#9;&#9;-- local ChatOnly = OutputStream.MakeOutputStreamSyndicator(&quot;Main chat&quot;)
&#9;&#9;-- &#9;ChatOnly.AddOutputStream(ChatChannel)
&#9;&#9;-- &#9;ChatOnly.AddOutputStream(NotificationChannel)

&#9;&#9;-- local NotificationSyndictator = OutputStream.MakeOutputStreamSyndicator(&quot;Notifications&quot;)
&#9;&#9;-- &#9;NotificationSyndictator.AddOutputStream(NotificationChannel)

&#9;&#9;-- And admin only admin stuff. 
&#9;&#9;local AdminSyndictator  = OutputStream.MakeOutputStreamSyndicator(&quot;Admin Logs&quot;)
&#9;&#9;&#9;AdminSyndictator.AddOutputStream(AdminLogChannel)


&#9;&#9;-- Interface.Subscribe(ChatOnly,           nil, Color3.new( 78/255, 205/255, 196/255), true)
&#9;&#9;-- Interface.Subscribe(NotificationSyndictator,   nil, Color3.new(199/255, 244/255, 100/255), true)
&#9;&#9;Interface.Subscribe(AdminSyndictator,          nil, Color3.new(255/255, 107/255, 107/255), true)
&#9;end


&#9;--[[if not NevermoreEngine.SoloTestMode then
&#9;&#9;-- In SoloTest mode we log Errors already. 
&#9;&#9;
&#9;&#9;ScriptContext.Error:connect(function(Message, StackTrace, Script)
&#9;&#9;&#9;Script = tostring(Script)

&#9;&#9;&#9;ClientToServerOutputStream.Fire(&quot;Error&quot;, {
&#9;&#9;&#9;&#9;Message    = Message;
&#9;&#9;&#9;&#9;StackTrace = StackTrace;
&#9;&#9;&#9;&#9;Script     = Script;
&#9;&#9;&#9;})
&#9;&#9;end)
&#9;end--]]

&#9;StarterGui:SetCoreGuiEnabled(&quot;Chat&quot;, false)

&#9;return Chat
end
lib.MakePseudoChat = MakePseudoChat
lib.makePseudoChat = MakePseudoChat

return lib</ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX20">
						<Properties>
							<string name="Name">PseudoChatBar</string>
							<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local UserInputService  = game:GetService(&quot;UserInputService&quot;)
local Players           = game:GetService(&quot;Players&quot;)

local NevermoreEngine          = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary        = NevermoreEngine.LoadLibrary

local qSystems = LoadCustomLibrary(&quot;qSystems&quot;)
local Maid     = LoadCustomLibrary(&quot;Maid&quot;)
local qString  = LoadCustomLibrary(&quot;qString&quot;)
local qGUI     = LoadCustomLibrary(&quot;qGUI&quot;)

qSystems:Import(getfenv(0))

-- PseudoChatBar.lua
-- @author Quenty

local lib = {}

local MakePseudoChatBar = Class(function(PseudoChatBar, ScreenGui)
&#9;--- Creates a new pseudo chat bar for chatting

&#9;local Configuration = {
&#9;&#9;DefaultText = UserInputService.MouseEnabled and &quot;Push \&quot;/\&quot; to chat&quot; or &quot;Tap here to chat&quot;;
&#9;&#9;XOffset     = 65;
&#9;&#9;ZIndex      = 10;
&#9;&#9;DefaultTransparency = 1;
&#9;&#9;SelectedTransparency = 0.3;
&#9;&#9;AnimationTime = 0.05;
&#9;&#9;AnimationTimeHide = 0.1;
&#9;&#9;DefaultHeight = 30;
&#9;}

&#9;local NewChat         = CreateSignal()
&#9;PseudoChatBar.NewChat = NewChat

&#9;-- GENERATE GUIS 

&#9;local ChatBarBacking = Make(&quot;Frame&quot;, {
&#9;&#9;BackgroundColor3       = Color3.new(0, 0, 0);
&#9;&#9;BackgroundTransparency = Configuration.DefaultTransparency;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Name                   = &quot;ChatBar&quot;;
&#9;&#9;Position               = UDim2.new(0, 0, 1, -Configuration.DefaultHeight);
&#9;&#9;Size                   = UDim2.new(1, 0, 0, Configuration.DefaultHeight);
&#9;&#9;ZIndex                 = Configuration.ZIndex-1;
&#9;})
&#9;PseudoChatBar.Gui = ChatBarBacking

&#9;local InputButton = Make(&quot;ImageButton&quot;, {
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;Parent                 = ChatBarBacking;
&#9;&#9;ZIndex                 = Configuration.ZIndex;
&#9;&#9;Size                   = UDim2.new(1, 0, 1, 0);
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Name                   = &quot;CatchClick&quot;;
&#9;})

&#9;local InputGui = Make(&quot;TextBox&quot;, {
&#9;&#9;BackgroundColor3       = Color3.new(0, 0, 0);
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Font                   = &quot;Arial&quot;;
&#9;&#9;FontSize               = &quot;Size14&quot;;
&#9;&#9;Name                   = &quot;ChatBar&quot;;
&#9;&#9;Parent                 = ChatBarBacking;
&#9;&#9;Position               = UDim2.new(0, Configuration.XOffset, 0, 0);
&#9;&#9;Size                   = UDim2.new(1, -Configuration.XOffset, 1, 0);
&#9;&#9;Text                   = Configuration.DefaultText;
&#9;&#9;TextColor3             = Color3.new(1, 1, 1);
&#9;&#9;TextStrokeTransparency = 0.9;
&#9;&#9;TextTransparency       = 0;
&#9;&#9;TextXAlignment         = &quot;Left&quot;;
&#9;&#9;ZIndex                 = Configuration.ZIndex-1;
&#9;&#9;MultiLine = false;
&#9;})

&#9;local LastChat = &quot;&quot;
&#9;local LastInput = &quot;&quot; --- Utilized for autocomplete things.
&#9;PseudoChatBar.Focused = false
&#9;local InputCleaner

&#9;local function StartFocus()
&#9;&#9;if not PseudoChatBar.Focused then
&#9;&#9;&#9;PseudoChatBar.Focused = true

&#9;&#9;&#9;InputGui.Text = &quot;&quot;
&#9;&#9;&#9;game:GetService(&quot;RunService&quot;).RenderStepped:wait(0)
&#9;&#9;&#9;-- wait()
&#9;&#9;&#9;InputGui:CaptureFocus()
&#9;&#9;&#9;InputGui.Text = &quot;&quot;

&#9;&#9;&#9;InputCleaner = Maid.new()
&#9;&#9;&#9;qGUI.TweenTransparency(ChatBarBacking, {BackgroundTransparency = Configuration.SelectedTransparency}, Configuration.AnimationTime, true)
&#9;&#9;end
&#9;end

&#9;local function GetAutoCompleteOption(Message)

&#9;&#9;local Start, End = Message:find(&quot;%w*$&quot;)
&#9;&#9;local LastWord = Message:sub(Start, End)
&#9;&#9;if LastWord and #LastWord &gt;= 2 then
&#9;&#9;&#9;--local Possibles = {}
&#9;&#9;&#9;-- print(LastWord)

&#9;&#9;&#9;for _, Player in pairs(Players:GetPlayers()) do
&#9;&#9;&#9;&#9;if qString.CompareCutFirst(Player.Name, LastWord) then
&#9;&#9;&#9;&#9;&#9;--Possibles[#Possibles+1] = Player.Name
&#9;&#9;&#9;&#9;&#9;return Message:sub(1, Start-1) .. Player.Name .. &quot; &quot;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;--return Possibles
&#9;&#9;else
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end

&#9;local function StopFocus(EnterPressed)
&#9;&#9;if PseudoChatBar.Focused then
&#9;&#9;&#9;qGUI.TweenTransparency(ChatBarBacking, {BackgroundTransparency = Configuration.DefaultTransparency}, Configuration.AnimationTimeHide, true)

&#9;&#9;&#9;LastInput = &quot;&quot;

&#9;&#9;&#9;PseudoChatBar.Focused = false;

&#9;&#9;&#9;InputCleaner:DoCleaning()
&#9;&#9;&#9;InputCleaner = nil

&#9;&#9;&#9;if EnterPressed then
&#9;&#9;&#9;&#9;if InputGui.Text ~= &quot;&quot; and InputGui.Text ~= Configuration.DefaultText then
&#9;&#9;&#9;&#9;&#9;LastChat = InputGui.Text
&#9;&#9;&#9;&#9;&#9;NewChat:fire(LastChat)
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;-- InputGui.Text = Configuration.DefaultText
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;LastChat = InputGui.Text
&#9;&#9;&#9;end

&#9;&#9;&#9;InputGui.Text = Configuration.DefaultText

&#9;&#9;end
&#9;end

&#9;UserInputService.InputBegan:connect(function(Input)
&#9;&#9;Spawn(function()
&#9;&#9;&#9;if not PseudoChatBar.Focused then
&#9;&#9;&#9;&#9;-- print(Input)
&#9;&#9;&#9;&#9;-- print(tostring(Input.KeyCode))
&#9;&#9;&#9;&#9;-- print(Input.KeyCode.Name)
&#9;&#9;&#9;&#9;if Input.KeyCode.Name == &quot;Slash&quot; then
&#9;&#9;&#9;&#9;&#9;StartFocus()
&#9;&#9;&#9;&#9;-- elseif Input.KeyCode.Name == &quot;Tab&quot; then
&#9;&#9;&#9;&#9;-- &#9;print(&quot;Tab&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if Input.KeyCode.Name == &quot;Up&quot; then
&#9;&#9;&#9;&#9;&#9;InputGui.Text = LastChat
&#9;&#9;&#9;&#9;&#9;LastInput = InputGui.Text
&#9;&#9;&#9;&#9;elseif Input.KeyCode.Name == &quot;Tab&quot; then
&#9;&#9;&#9;&#9;&#9;local Option = GetAutoCompleteOption(InputGui.Text)
&#9;&#9;&#9;&#9;&#9;-- print(&quot;Option: &quot; .. tostring(Option))

&#9;&#9;&#9;&#9;&#9;if not Option then
&#9;&#9;&#9;&#9;&#9;&#9;Option = GetAutoCompleteOption(InputGui.Text:sub(1, #InputGui.Text-1))
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;if Option then
&#9;&#9;&#9;&#9;&#9;&#9;InputGui.Text = Option
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;LastInput = InputGui.Text
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end)

&#9;InputGui.FocusLost:connect(StopFocus)

&#9;InputButton.MouseButton1Click:connect(function()
&#9;&#9;StartFocus()
&#9;end)

&#9;ChatBarBacking.Parent = ScreenGui
end)
lib.MakePseudoChatBar = MakePseudoChatBar

return lib;</ProtectedString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Backpack" referent="RBX21">
				<Properties>
					<string name="Name">qGUI</string>
				</Properties>
				<Item class="ModuleScript" referent="RBX22">
					<Properties>
						<string name="Name">ScrollBar</string>
						<ProtectedString name="Source">local Players           = game:GetService(&quot;Players&quot;)
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local RunService        = game:GetService(&quot;RunService&quot;)
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&apos;qSystems&apos;)
local qGUI              = LoadCustomLibrary(&apos;qGUI&apos;)

qSystems:import(getfenv(0));

-- ScrollBar library
-- Change Log --
--[[
January 23rd, 2014
- Updated to new class system

Janurary 8th, 2014
- Fixed velocity when scrolling, as events didn&apos;t call unless a change occured. 
- Connected it to RunService.Stepped


--]]

local lib = {}

local function CreateFlatBacking(Frame, Spacing)
&#9;-- Applies a flat backing on the scroll bar. 
&#9;-- @param Frame The frame to put it on
&#9;-- @param Spacing The spacing on the left/right/top/bottom sides. The whitespace. Should be divisible by 2.

&#9;Spacing = Spacing or 2

&#9;local SmoothBacking = Make(&quot;Frame&quot;, {
&#9;&#9;BackgroundTransparency = 0;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Parent                 = Frame;
&#9;&#9;Name                   = &quot;Backing&quot;;
&#9;&#9;BackgroundColor3       = Color3.new(148/255, 161/255, 174/255);
&#9;&#9;Size                   = UDim2.new(1, -Spacing*2, 1, -Spacing*2);
&#9;&#9;Position               = UDim2.new(0, Spacing, 0, Spacing);
&#9;})

&#9;return SmoothBacking
end

local MakeKineticModel = Class(function(KineticModel, ContainerFrame, ContentFrame, ScreenGui)
&#9;-- Theoretical model

&#9;KineticModel.Duration = 0.6
&#9;KineticModel.BounceBackDuration = 0.3;
&#9;KineticModel.Position = 0
&#9;KineticModel.UpdateInterval = 1/30

&#9;KineticModel.Velocity = 0
&#9;KineticModel.Minimum = 0;
&#9;KineticModel.Maximum = 1000

&#9;KineticModel.MaxBounce = 50;

&#9;KineticModel.DisplayPosition = KineticModel.Position -- The position it displays at.
&#9;KineticModel.OnPositionChange = function() end -- Callbacks. 
&#9;KineticModel.OnScrollStart = function() end
&#9;KineticModel.OnScrollStop = function() end

&#9;KineticModel.LastPosition = 0
&#9;KineticModel.TimeStamp = tick()

&#9;KineticModel.UpdatingId = 0

&#9;function KineticModel:Clamp(Position, IncludeBounce)
&#9;&#9;-- Clamp&apos;s the model&apos;s position into the range.
&#9;&#9;if not IncludeBounce then
&#9;&#9;&#9;if Position &gt; self.Maximum then
&#9;&#9;&#9;&#9;return self.Maximum
&#9;&#9;&#9;elseif Position &lt; self.Minimum then
&#9;&#9;&#9;&#9;return self.Minimum
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;return Position
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;if Position &gt; self.Maximum + self.MaxBounce then
&#9;&#9;&#9;&#9;return self.Maximum + self.MaxBounce
&#9;&#9;&#9;elseif Position &lt; self.Minimum  - self.MaxBounce  then
&#9;&#9;&#9;&#9;return self.Minimum - self.MaxBounce
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;return Position
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;function KineticModel:SetRange(Start, End)
&#9;&#9;-- Set&apos;s the range that the model can scroll at...

&#9;&#9;self.Minimum = Start
&#9;&#9;self.Maximum = End
&#9;end

&#9;function KineticModel:GetRange(Start, End)
&#9;&#9;-- Return&apos;s the range...

&#9;&#9;return self.Minimum, self.Maximum
&#9;end

&#9;function KineticModel:SetPosition(NewPosition, DivideNewVelocityBy)
&#9;&#9;-- Set&apos;s the position of the kinetic model. Using this, it&apos;ll calculate velocity.

&#9;&#9;DivideNewVelocityBy = DivideNewVelocityBy or 1 -- Used by Scrollbar. 

&#9;&#9;local CurrentTime = tick()
&#9;&#9;local ElapsedTime = CurrentTime - self.TimeStamp

&#9;&#9;if NewPosition &gt; self.Maximum then
&#9;&#9;&#9;-- print(&quot;[KineticModel] - Past Max Manual @ &quot;..NewPosition)
&#9;&#9;&#9;-- Dampen position so it can&apos;t go over. In this case, summation with Maximum/2 as the first term, 0.5 as the rate.

&#9;&#9;&#9;local Displacement = math.abs(NewPosition - self.Maximum)
&#9;&#9;&#9;local TimesOver = Displacement / self.MaxBounce
&#9;&#9;&#9;local DisplayPosition = (((self.MaxBounce/2) * (1 - 0.5 ^ TimesOver)) / 0.5)
&#9;&#9;&#9;self.Position = NewPosition

&#9;&#9;&#9;self.DisplayPosition = DisplayPosition
&#9;&#9;&#9;self.OnPositionChange(DisplayPosition)
&#9;&#9;elseif NewPosition &lt; self.Minimum then
&#9;&#9;&#9;-- print(&quot;[KineticModel] - Past Min Manual @ &quot;..NewPosition)

&#9;&#9;&#9;local Displacement = math.abs(NewPosition - self.Minimum)
&#9;&#9;&#9;local TimesOver = Displacement / self.MaxBounce
&#9;&#9;&#9;local DisplayPosition = self.Minimum - (((self.MaxBounce/2) * (1 - 0.5 ^ TimesOver)) / 0.5)
&#9;&#9;&#9;self.Position = NewPosition

&#9;&#9;&#9;self.DisplayPosition = DisplayPosition
&#9;&#9;&#9;self.OnPositionChange(DisplayPosition)
&#9;&#9;else
&#9;&#9;&#9;self.Position = NewPosition

&#9;&#9;&#9;self.DisplayPosition = self.Position
&#9;&#9;&#9;self.OnPositionChange(self.Position)
&#9;&#9;end

&#9;&#9;local LocalVelocity = (((self.Position - self.LastPosition)) / ElapsedTime) / DivideNewVelocityBy
&#9;&#9;self.TimeStamp = CurrentTime
&#9;&#9;self:SetVelocity((0.2 * self.Velocity) + (0.8 * LocalVelocity)) -- 20% previous velocity maintained, 80% of new velocity used.


&#9;&#9;self.LastPosition = self.Position
&#9;&#9;-- print(&quot;[KineticModel] - Set Velocity @ &quot;..self.Velocity..&quot;; Local Velocity @ &quot;..LocalVelocity..&quot;; ElapsedTime: &quot;..ElapsedTime)
&#9;end

&#9;function KineticModel:SetVelocity(Velocity)
&#9;&#9;-- Set&apos;s the velocity

&#9;&#9;-- local TargetPosition = self.Position + Velocity
&#9;&#9;--print(&quot;[KineticModel] - Set Velocity @ &quot;..Velocity)
&#9;&#9;self.Velocity = Velocity

&#9;end

&#9;function KineticModel:AddVelocity(AddVelocity)
&#9;&#9;-- Set&apos;s the velocity

&#9;&#9;self.Velocity = self.Velocity + AddVelocity
&#9;end

&#9;function KineticModel:ResetSpeed()
&#9;&#9;-- Reset&apos;s the speed to 0, stops update loops. 

&#9;&#9;--print(&quot;[KineticModel] - Reset Speed&quot;)
&#9;&#9;self.Velocity = 0
&#9;&#9;self.LastPosition = self.Position
&#9;&#9;self.UpdatingId = self.UpdatingId + 1
&#9;&#9;self.TimeStamp = tick()
&#9;end

&#9;function KineticModel:ScrollTo(NewPosition, DoNotAnimate)
&#9;&#9;if not DoNotAnimate then
&#9;&#9;&#9;self:ResetSpeed()
&#9;&#9;&#9;self:SetVelocity(NewPosition - self.Position) -- -160 - (-180) 20 Instead, -180 - -160
&#9;&#9;&#9;self:Release()
&#9;&#9;&#9;-- print(&quot;[KineticModel] - Scrolling velocity ScrollTo @ &quot;..(self.Position - NewPosition)..&quot;; target @ &quot;..NewPosition)
&#9;&#9;else
&#9;&#9;&#9;self:ResetSpeed()
&#9;&#9;&#9;if NewPosition &gt; self.Maximum then -- Check if we&apos;re overbounds, and scale accordingly. 
&#9;&#9;&#9;&#9;local Displacement = math.abs(NewPosition - self.Maximum)
&#9;&#9;&#9;&#9;local TimesOver = Displacement / self.MaxBounce
&#9;&#9;&#9;&#9;local DisplayPosition = (((self.MaxBounce/2) * (1 - 0.5 ^ TimesOver)) / 0.5)
&#9;&#9;&#9;&#9;self.Position = NewPosition

&#9;&#9;&#9;&#9;self.DisplayPosition = DisplayPosition
&#9;&#9;&#9;&#9;self.OnPositionChange(DisplayPosition)
&#9;&#9;&#9;&#9;self:Release()
&#9;&#9;&#9;elseif NewPosition &lt; self.Minimum then -- Check if we&apos;re overbounds, and scale accordingly. 
&#9;&#9;&#9;&#9;local Displacement = math.abs(NewPosition - self.Minimum)
&#9;&#9;&#9;&#9;local TimesOver = Displacement / self.MaxBounce
&#9;&#9;&#9;&#9;local DisplayPosition = self.Minimum - (((self.MaxBounce/2) * (1 - 0.5 ^ TimesOver)) / 0.5)
&#9;&#9;&#9;&#9;self.Position = NewPosition

&#9;&#9;&#9;&#9;self.DisplayPosition = DisplayPosition
&#9;&#9;&#9;&#9;self.OnPositionChange(DisplayPosition)
&#9;&#9;&#9;&#9;self:Release()
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;self.Position = NewPosition

&#9;&#9;&#9;&#9;self.DisplayPosition = NewPosition
&#9;&#9;&#9;&#9;self.OnPositionChange(self.Position)
&#9;&#9;&#9;end
&#9;&#9;&#9;-- print(&quot;Update position @ &quot;..self.Position .. &quot; NewPosition @ &quot; .. NewPosition)
&#9;&#9;end
&#9;end

&#9;function KineticModel:Release()
&#9;&#9;-- Start the update...

&#9;&#9;-- print(&quot;[KineticModel] - Release @ &quot;..self.Position..&quot;; Velocity @ &quot;..self.Velocity)
&#9;&#9;local Amplitude = self.Velocity
&#9;&#9;local Start = self.Position
&#9;&#9;--local TargetPosition = self.Position + Amplitude
&#9;&#9;--local TimeConstant = self.Duration--1 + self.Duration /  6;
&#9;&#9;self.TimeStamp = tick()

&#9;&#9;self.UpdatingId = self.UpdatingId + 1
&#9;&#9;local LocalUpdateId = self.UpdatingId
&#9;&#9;-- print(&quot;release start &quot; .. LocalUpdateId)
&#9;&#9;Spawn(function() -- Update loop start.
&#9;&#9;&#9;while (LocalUpdateId == self.UpdatingId) do
&#9;&#9;&#9;&#9;local ElapsedTime = tick() - self.TimeStamp
&#9;&#9;&#9;&#9;local NewPosition = Start + Amplitude * ((ElapsedTime/self.Duration)^(1/2))

&#9;&#9;&#9;&#9;-- print(&quot;[KineticModel] - Updating @ &quot;..self.Position..&quot;; Amplitude = &quot;..(Amplitude)..&quot;; ElapsedTime = &quot; .. ElapsedTime)

&#9;&#9;&#9;&#9;if (ElapsedTime &gt; self.Duration) or self.Position &gt; self.Maximum or self.Position &lt; self.Minimum then -- WE&apos;re over the timelimit,
&#9;&#9;&#9;&#9;&#9;local Velocity
&#9;&#9;&#9;&#9;&#9;if self.Position &gt; self.Maximum then -- Check if we&apos;re overbounds so we can bounce back. 
&#9;&#9;&#9;&#9;&#9;&#9;local Displacement = math.abs(self.Position - self.Minimum)
&#9;&#9;&#9;&#9;&#9;&#9;local TimesOver = Displacement / self.MaxBounce
&#9;&#9;&#9;&#9;&#9;&#9;local Difference = (((self.MaxBounce/2) * (1 - 0.5 ^ TimesOver)) / 0.5)
&#9;&#9;&#9;&#9;&#9;&#9;self.Position = Difference -- Set position to the display position...
&#9;&#9;&#9;&#9;&#9;&#9;Velocity = -Difference

&#9;&#9;&#9;&#9;&#9;elseif self.Position &lt; self.Minimum then
&#9;&#9;&#9;&#9;&#9;&#9;local Displacement = math.abs(self.Position - self.Minimum)
&#9;&#9;&#9;&#9;&#9;&#9;local TimesOver = Displacement / self.MaxBounce
&#9;&#9;&#9;&#9;&#9;&#9;local Difference = (((self.MaxBounce/2) * (1 - 0.5 ^ TimesOver)) / 0.5)
&#9;&#9;&#9;&#9;&#9;&#9;self.Position = self.Minimum - Difference
&#9;&#9;&#9;&#9;&#9;&#9;Velocity = Difference -- Calculate velocity via difference. :D
&#9;&#9;&#9;&#9;&#9;else -- Nope, not over bounds, we can stop. 
&#9;&#9;&#9;&#9;&#9;&#9;self:ResetSpeed()
&#9;&#9;&#9;&#9;&#9;&#9;self.OnScrollStop(self.Position)
&#9;&#9;&#9;&#9;&#9;&#9;-- print(&quot;[KineticModel] - Stopped @ &quot;..self.Position..&quot;; ElapsedTime @ &quot;..ElapsedTime)
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;if Velocity then -- Bounce back, we&apos;re over
&#9;&#9;&#9;&#9;&#9;&#9;-- print(Velocity)
&#9;&#9;&#9;&#9;&#9;&#9;self.Velocity = Velocity

&#9;&#9;&#9;&#9;&#9;&#9;self.TimeStamp = tick()
&#9;&#9;&#9;&#9;&#9;&#9;Start = self.Position
&#9;&#9;&#9;&#9;&#9;&#9;while LocalUpdateId == self.UpdatingId do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local ElapsedTime = tick() - self.TimeStamp
&#9;&#9;&#9;&#9;&#9;&#9;&#9;self.Position = Start + Velocity * ((ElapsedTime/self.BounceBackDuration)^(1/2))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;self.DisplayPosition = self.Position
&#9;&#9;&#9;&#9;&#9;&#9;&#9;self.OnPositionChange(self.Position)

&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (ElapsedTime &gt; self.BounceBackDuration) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;self:ResetSpeed()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;self.OnScrollStop(self.Position)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- print(&quot;[KineticModel] - Stopped (2) @ &quot;..self.Position..&quot;; ElapsedTime @ &quot;..ElapsedTime)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;RunService.Heartbeat:wait(self.UpdateInterval)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- wait(self.UpdateInterval)
&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;self.DisplayPosition = Start + Velocity
&#9;&#9;&#9;&#9;&#9;&#9;self.OnPositionChange(Start + Velocity)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;self.DisplayPosition = Start + Amplitude
&#9;&#9;&#9;&#9;&#9;&#9;self.OnPositionChange(Start + Amplitude)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;if NewPosition &gt; self.Maximum then -- Check if we&apos;re overbounds, and scale accordingly. 
&#9;&#9;&#9;&#9;&#9;&#9;local Displacement    = math.abs(NewPosition - self.Maximum)
&#9;&#9;&#9;&#9;&#9;&#9;local TimesOver       = Displacement / self.MaxBounce
&#9;&#9;&#9;&#9;&#9;&#9;local DisplayPosition = (((self.MaxBounce/2) * (1 - 0.5 ^ TimesOver)) / 0.5)
&#9;&#9;&#9;&#9;&#9;&#9;self.Position         = NewPosition
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;self.DisplayPosition  = DisplayPosition
&#9;&#9;&#9;&#9;&#9;&#9;self.OnPositionChange(DisplayPosition)
&#9;&#9;&#9;&#9;&#9;elseif NewPosition &lt; self.Minimum then -- Check if we&apos;re overbounds, and scale accordingly. 
&#9;&#9;&#9;&#9;&#9;&#9;local Displacement    = math.abs(NewPosition - self.Minimum)
&#9;&#9;&#9;&#9;&#9;&#9;local TimesOver       = Displacement / self.MaxBounce
&#9;&#9;&#9;&#9;&#9;&#9;local DisplayPosition = self.Minimum - (((self.MaxBounce/2) * (1 - 0.5 ^ TimesOver)) / 0.5)
&#9;&#9;&#9;&#9;&#9;&#9;self.Position         = NewPosition

&#9;&#9;&#9;&#9;&#9;&#9;self.DisplayPosition = DisplayPosition
&#9;&#9;&#9;&#9;&#9;&#9;self.OnPositionChange(DisplayPosition)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;self.Velocity = NewPosition - self.Position
&#9;&#9;&#9;&#9;&#9;&#9;self.Position = NewPosition

&#9;&#9;&#9;&#9;&#9;&#9;self.DisplayPosition = self.Position
&#9;&#9;&#9;&#9;&#9;&#9;self.OnPositionChange(self.Position)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;RunService.Heartbeat:wait(self.UpdateInterval)
&#9;&#9;&#9;&#9;-- wait(self.UpdateInterval)
&#9;&#9;&#9;end

&#9;&#9;&#9;-- print(&quot;release end&quot; .. LocalUpdateId)

&#9;&#9;end)--]]
&#9;end
end)
lib.MakeKineticModel = MakeKineticModel

local MakeScroller = Class(function(Scroller, Container, Content, ScreenGui, Axis)
&#9;--- Models an iOS style window / a scroll bar.
&#9;-- @param Container The content frame. This is the space that renders. Stuff from &apos;Content&apos; will
&#9;--        display inside of this. If it&apos;s a GuiButton, then it will also allow for ROBLOX user input,
&#9;--        like iOS scrolling. It is suggested you use a GuiButton. 
&#9;-- @param Content The frame inside of the container that contains the actual content.  Probably larger
&#9;--        then the Container, otherwise, there&apos;s nothing to scroll...
&#9;-- @param ScreenGui The screengui the Container and Content are in.
&#9;-- @param Axis a char of &apos;X&apos; or &apos;Y&apos; that defines what axis the scrollbar works upon.  Only Y works for scroll bars. 

&#9;-- Axis: Char &apos;X&apos; or Char &apos;Y&apos;
&#9;Axis = Axis or &apos;Y&apos;;

&#9;--[[
&#9;&#9;Positioning is based on some super hacky negative scale

&#9;&#9;0 VERY TOP


&#9;&#9;-500 VERY BOTTOM

&#9;&#9;The range is represented as thus.  That is, the &quot;smallest&quot; size is the Content&apos;s absoluteSize + The Container&apos;s absoluteSize
&#9;&#9;
&#9;&#9;So if you have a Container sized at 100, and the content of 500...
&#9;&#9;You have a range of 400. Your scroll bar is at 20% (100 / 500) of it&apos;s frame. 
&#9;&#9;Your maximum is always 0
&#9;&#9;Your minimum is negative 400. 

&#9;&#9;KineticModel takes in absolute values. Scroller will adjust these absolute positions (relative to the frame)
&#9;&#9;to be relative to the Content Frame. 
&#9;
&#9;&#9;The positioning mechanism is this:

&#9;&#9;Content.Position = UDim2.new(Content.Position.X.Scale, Content.Position.X.Offset, 0, NewPosition)

&#9;&#9;You can see it maintains X axis (this is for a Y axis scroller). NewPosition is set directly. 

&#9;&#9;Thus, at 0 it is actually at the very bottom, and at -400 it&apos;s at the very top. Heck. that&apos;s confusing.
&#9;--]]

&#9;local KineticModel       = MakeKineticModel()
&#9;local Pressed            = false
&#9;local ScrollbarPressed -- Hold&apos;s a &apos;Scrollbar&apos; object. 
&#9;-- local MouseScrollEnabled = false -- Can we use the mouse wheel to scroll around? Glitches in First Person. 
&#9;local ReferencePosition  = 0 -- Reference position to the last &apos;Drag&apos; position, and then calculate velocity from this. :D
&#9;local MouseDrag          = qGUI.GenerateMouseDrag() -- A big GUI to capture Mouse.Moved()
&#9;local Mouse              = Players.LocalPlayer:GetMouse()
&#9;local Scrollbars         = {}
&#9;local StepEvent
&#9;
&#9;Scroller.PixelsPerWheelTurn = 80; -- How many pixels it&apos;ll scroll during a wheel turn.
&#9;Scroller.KineticModel       = KineticModel
&#9;Scroller.Content            = Content
&#9;Scroller.Container          = Container
&#9;Scroller.Axis               = Axis
&#9;Scroller.MouseDrag          = MouseDrag
&#9;Scroller.CanDrag            = true
&#9;Scroller.ScrollFinished     = CreateSignal() -- Fires an event whenever a scroll finishes moving. 
&#9;Scroller.InputFinished      = CreateSignal() -- When mouse down, this fires when mouse up
&#9;Scroller.ScrollStarted      = CreateSignal()

&#9;-- For scrollbaroverlays
&#9;local ScrollbarDefaultColor3 = Color3.new(0, 0, 0)
&#9;local ScrollbarMouseOverColor3 = Color3.new(0.1, 0.1, 0.1)

&#9;local function StopStepEvent()
&#9;&#9;if StepEvent then
&#9;&#9;&#9;StepEvent:disconnect()
&#9;&#9;&#9;StepEvent = nil
&#9;&#9;end
&#9;end

&#9;function Scroller:AdjustRange()
&#9;&#9;-- Readjustes the range on the scroller.

&#9;&#9;local Maximum = 0
&#9;&#9;local Minimum = -Content.AbsoluteSize[Axis] + Container.AbsoluteSize[Axis]

&#9;&#9;for _, Scrollbar in pairs(Scrollbars) do -- Adjust all the scrollbar&apos;s ranges too. :D
&#9;&#9;&#9;Scrollbar.ResizeBar()
&#9;&#9;end

&#9;&#9;-- print(&quot;[Scroller] - Adjusting range to max @ &quot;..Maximum)
&#9;&#9;KineticModel:SetRange(Minimum, Maximum)
&#9;end

&#9;function Scroller.CanScroll()
&#9;&#9;return Content.AbsoluteSize[Axis] &gt;= Container.AbsoluteSize[Axis] and Scroller.CanDrag
&#9;end

&#9;function Scroller.StartDrag(PositionX, PositionY)
&#9;&#9;-- Position X/Y should be absolute coordinates 
&#9;&#9;if ScrollbarPressed then
&#9;&#9;&#9;print(&quot;[Scroller] - Scrollbar is already pressed&quot;)
&#9;&#9;&#9;return false
&#9;&#9;elseif not Scroller.CanScroll() then
&#9;&#9;&#9;return false
&#9;&#9;end

&#9;&#9;ReferencePosition = Vector2.new(PositionX, PositionY)[Axis]

&#9;&#9;Scroller.ScrollStarted:fire(KineticModel.DisplayPosition)

&#9;&#9;StopStepEvent()
&#9;&#9;StepEvent = RunService.Heartbeat:connect(function() Scroller.Drag(Mouse.X, Mouse.Y) end)

&#9;&#9;-- print(&quot;[Scroller] - Start drag, reference position @ &quot;..tostring(ReferencePosition))

&#9;&#9;Pressed = true
&#9;&#9;MouseDrag.Parent = ScreenGui
&#9;&#9;KineticModel:ResetSpeed()
&#9;end

&#9;function Scroller.Drag(PositionX, PositionY)
&#9;&#9;-- Position X/Y should be absolute coordinates 

&#9;&#9;-- print(&quot;[Scroller] - Dragging @ (&quot; .. PositionX .. &quot;, &quot; .. PositionY..&quot;)&quot;)
&#9;&#9;if not Scroller.CanScroll() then
&#9;&#9;&#9;print(&quot;[Scroller] - Cannot scroll&quot;)
&#9;&#9;&#9;return false
&#9;&#9;end

&#9;&#9;local MouseClickPosition = Vector2.new(PositionX, PositionY)

&#9;&#9;local Change = (MouseClickPosition[Axis]) - ReferencePosition
&#9;&#9;-- if math.abs(Change) &gt;= 1 then
&#9;&#9;&#9;if Pressed then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local NewPosition = KineticModel.Position + Change

&#9;&#9;&#9;&#9;--print(&quot;[Scroller] - Drag, NewPosition @ &quot;..NewPosition..&quot;; Change @ &quot;..Change)
&#9;&#9;&#9;&#9;KineticModel:SetPosition(NewPosition)
&#9;&#9;&#9;&#9;ReferencePosition = MouseClickPosition[Axis]
&#9;&#9;&#9;elseif ScrollbarPressed then

&#9;&#9;&#9;&#9;local MaxDisplayRange = ScrollbarPressed.ScrollBarContainer.AbsoluteSize[Axis] - ScrollbarPressed.Bar.AbsoluteSize[Axis] 
&#9;&#9;&#9;&#9;                        -- Range displayable by the scrollbar...


&#9;&#9;&#9;&#9;if MaxDisplayRange == 0 then -- can&apos;t divide by 0
&#9;&#9;&#9;&#9;&#9;KineticModel:SetPosition(0)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;local MinimumScrollerRange, MaximumScrollerRange = KineticModel:GetRange()
&#9;&#9;&#9;&#9;&#9;local TotalScrollerRange = MaximumScrollerRange - MinimumScrollerRange -- Total range of the scroller
&#9;&#9;&#9;&#9;&#9;--local PercentScrolled = (ScrollbarPressed.Bar.AbsolutePosition - ScrollbarPressed.ScrollBarContainer.AbsolutePosition)[Axis] / MaxDisplayRange
&#9;&#9;&#9;&#9;&#9;Change = (Change / MaxDisplayRange) * TotalScrollerRange
&#9;&#9;&#9;&#9;&#9;local NewPosition = KineticModel.Position - Change

&#9;&#9;&#9;&#9;&#9;--print(&quot;[Scroller] - Drag, Scrollbar, NewPosition @ &quot;..NewPosition..&quot;; Change @ &quot;..Change)
&#9;&#9;&#9;&#9;&#9;KineticModel:SetPosition(NewPosition, TotalScrollerRange / MaxDisplayRange)
&#9;&#9;&#9;&#9;&#9;ReferencePosition = MouseClickPosition[Axis]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--print(&quot;[Scroller] - Scroller not pressed&quot;)
&#9;&#9;&#9;&#9;KineticModel:SetPosition(KineticModel.Position)
&#9;&#9;&#9;end
&#9;&#9;-- else
&#9;&#9;&#9;-- print(&quot;[Scroller] - Change too small for drag to register.&quot;)
&#9;&#9;-- end
&#9;end

&#9;function Scroller.StopDrag()
&#9;&#9;--- Stop&apos;s it from dragging.

&#9;&#9;-- Position X/Y should be absolute coordinates 
&#9;&#9;Scroller.InputFinished:fire()
&#9;&#9;StopStepEvent()
&#9;&#9;Pressed          = false
&#9;&#9;ScrollbarPressed = nil 
&#9;&#9;KineticModel:Release()
&#9;&#9;MouseDrag.Parent = nil
&#9;end

&#9;function Scroller.ScrollDown()
&#9;&#9;if Scroller.CanScroll() then
&#9;&#9;&#9;--print(&quot;[Scroller] - Scroll down&quot;)
&#9;&#9;&#9;--local OldVelocity = KineticModel.Velocity

&#9;&#9;&#9;StopStepEvent()
&#9;&#9;&#9;
&#9;&#9;&#9;-- KineticModel:ResetSpeed()
&#9;&#9;&#9;-- KineticModel:SetVelocity(-Scroller.PixelsPerWheelTurn)
&#9;&#9;&#9;KineticModel:AddVelocity(-Scroller.PixelsPerWheelTurn)
&#9;&#9;&#9;KineticModel:Release()
&#9;&#9;end
&#9;end

&#9;function Scroller.ScrollUp()
&#9;&#9;if Scroller.CanScroll() then
&#9;&#9;&#9;--print(&quot;[Scroller] - Scroll up&quot;)
&#9;&#9;&#9;--local OldVelocity = KineticModel.Velocity

&#9;&#9;&#9;StopStepEvent()

&#9;&#9;&#9;-- KineticModel:ResetSpeed()
&#9;&#9;&#9;-- KineticModel:SetVelocity(Scroller.PixelsPerWheelTurn)
&#9;&#9;&#9;KineticModel:AddVelocity(Scroller.PixelsPerWheelTurn)
&#9;&#9;&#9;KineticModel:Release()
&#9;&#9;end
&#9;end

&#9;function Scroller.ScrollTo(NewPosition, DoNotAnimate)
&#9;&#9;-- @param NewPosition The new position to scroll to. Should be based upon range.

&#9;&#9;StopStepEvent()
&#9;&#9;KineticModel:ScrollTo(NewPosition, DoNotAnimate)
&#9;end

&#9;function Scroller:AddScrollBar(ScrollBarContainer, DoNotDecorate)
&#9;&#9;--- Add&apos;s a ScrollBar in the &apos;ScrollBarContainer&apos;, linked to this scrolling frame. Will generate the scroll bar and
&#9;&#9;--  Parent to the ScrollBarContainer. 
&#9;&#9;-- @param ScrollBarContainer the container that it should be generated in. A frame object.
&#9;&#9;-- @pre ScrollBarContainer is a Gui, and it&apos;s actually called on the class it comes from...
&#9;&#9;-- @post ScrollBarContainer is decorated unless DoNotDecorate is set to true,
&#9;&#9;--        There is now a scroll bar inside of ScrollBarContainer linked to the
&#9;&#9;--        Scroller. 
&#9;&#9;
&#9;&#9;--TODO: Add support for horizontal rendering

&#9;&#9;local Scrollbar = {}
&#9;&#9;Scrollbar.ScrollBarContainer = ScrollBarContainer
&#9;&#9;local KineticModel = Scroller.KineticModel
&#9;&#9;local Backing

&#9;&#9;local Bar = Make(&quot;ImageButton&quot;, {
&#9;&#9;&#9;Name                   = &quot;ScrollBar&quot;;
&#9;&#9;&#9;Parent                 = ScrollBarContainer;
&#9;&#9;&#9;ZIndex                 = math.max(math.min(10, ScrollBarContainer.ZIndex + 1), 0);
&#9;&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;&#9;BackgroundColor3       = Color3.new(0, 0, 0);
&#9;&#9;&#9;Active                 = true;
&#9;&#9;})
&#9;&#9;Scrollbar.Bar = Bar

&#9;&#9;function Scrollbar.ResizeBar() -- Resizes the scrollbar&apos;s bar. :D
&#9;&#9;&#9;if Scroller.Axis == &apos;Y&apos; then -- Make sure we resize on the correct axis. 
&#9;&#9;&#9;&#9;Bar.Size = UDim2.new(1, 0, (Scroller.Container.AbsoluteSize.Y / Scroller.Content.AbsoluteSize.Y), 0)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Bar.Size = UDim2.new((Scroller.Container.AbsoluteSize.X / Scroller.Content.AbsoluteSize.X), 0, 1, 0)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;function Scrollbar.Render(NewPosition) -- Rerenders the bar. 

&#9;&#9;&#9;-- Repositions the ScrollBar. Probably called every time the scroller is moved. 

&#9;&#9;&#9;-- Prerequests: Scrollbar has been resized correctlyi. 
&#9;&#9;&#9;-- PostResults: ScrollBar is positioned correctly...

&#9;&#9;&#9;local MaxDisplayRange = ScrollBarContainer.AbsoluteSize[Axis] - Bar.AbsoluteSize[Axis] -- Range displayable by the scrollbar...
&#9;&#9;&#9;local MinimumScrollerRange, MaximumScrollerRange = KineticModel:GetRange()
&#9;&#9;&#9;local TotalScrollerRange = MaximumScrollerRange - MinimumScrollerRange -- Total range of the scroller
&#9;&#9;&#9;local PercentScrolled = math.abs(KineticModel:Clamp(NewPosition) / TotalScrollerRange)

&#9;&#9;&#9;--print(&quot;[Scroller][ScrollBar] - Render @ &quot;..NewPosition..&quot;; PercentScrolled @ &quot;..PercentScrolled..&quot;; Display @ &quot;..(MaxDisplayRange * PercentScrolled))

&#9;&#9;&#9;if Scroller.Axis == &apos;Y&apos; then
&#9;&#9;&#9;&#9;Bar.Position = UDim2.new(0, 0, 0, MaxDisplayRange * PercentScrolled)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Bar.Position = UDim2.new(0, MaxDisplayRange * PercentScrolled, 0, 0)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;function Scrollbar.OnEnterDisplay()
&#9;&#9;&#9;if Backing then
&#9;&#9;&#9;&#9;Backing.BackgroundColor3 = ScrollbarMouseOverColor3
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;function Scrollbar.OnLeaveDisplay()
&#9;&#9;&#9;if Backing then
&#9;&#9;&#9;&#9;Backing.BackgroundColor3 = ScrollbarDefaultColor3
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;local EventId = 0;

&#9;&#9;function Scrollbar.StopScrollFromWhitespace()
&#9;&#9;&#9;EventId = EventId + 1;
&#9;&#9;end

&#9;&#9;function Scrollbar.MouseDownOnWhitespace(PositionX, PositionY)
&#9;&#9;&#9;local PositionDown = Vector2.new(PositionX, PositionY)
&#9;&#9;&#9;EventId = EventId + 1
&#9;&#9;&#9;local LocalEventId = EventId

&#9;&#9;&#9;while LocalEventId == EventId do
&#9;&#9;&#9;&#9;KineticModel:ResetSpeed()
&#9;&#9;&#9;&#9;if math.abs(Bar.AbsolutePosition[Scroller.Axis] - PositionDown[Scroller.Axis] + Bar.AbsoluteSize[Scroller.Axis]/2) &lt; Bar.AbsoluteSize[Scroller.Axis]/2 then
&#9;&#9;&#9;&#9;&#9;-- print(&quot;[Scroller][ScrollBar] - Stop Down&quot;)
&#9;&#9;&#9;&#9;&#9;Scrollbar.StopScrollFromWhitespace()
&#9;&#9;&#9;&#9;elseif Bar.AbsolutePosition[Scroller.Axis] &lt; PositionDown[Scroller.Axis] then
&#9;&#9;&#9;&#9;&#9;KineticModel:SetVelocity(-Scroller.Container.AbsoluteSize[Scroller.Axis])
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;KineticModel:SetVelocity(Scroller.Container.AbsoluteSize[Scroller.Axis])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;KineticModel:Release()
&#9;&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;function Scrollbar.StartDrag(PositionX, PositionY)
&#9;&#9;&#9;-- Start&apos;s the &apos;Drag&apos; on the scrollbar, so it really fires on Button1Down

&#9;&#9;&#9;if ScrollbarPressed then
&#9;&#9;&#9;&#9;print(&quot;[Scroller] - Scroller is already pressed&quot;)
&#9;&#9;&#9;&#9;return false
&#9;&#9;&#9;end

&#9;&#9;&#9;Scroller.ScrollStarted:fire(KineticModel.DisplayPosition)

&#9;&#9;&#9;StopStepEvent()
&#9;&#9;&#9;KineticModel:ResetSpeed()
&#9;&#9;&#9;StepEvent = RunService.Heartbeat:connect(function() Scroller.Drag(Mouse.X, Mouse.Y) end)

&#9;&#9;&#9;ScrollbarPressed = Scrollbar
&#9;&#9;&#9;ReferencePosition = Vector2.new(PositionX, PositionY)[Axis]

&#9;&#9;&#9;MouseDrag.Parent = ScreenGui
&#9;&#9;&#9;KineticModel:ResetSpeed()


&#9;&#9;&#9;-- print(&quot;[Scroller] - Start drag, reference position @ &quot;..tostring(ReferencePosition))
&#9;&#9;end

&#9;&#9;if not DoNotDecorate then
&#9;&#9;&#9;Backing = CreateFlatBacking(Bar, 1)
&#9;&#9;&#9;Backing.BackgroundColor3 = ScrollbarDefaultColor3
&#9;&#9;&#9;Backing.BackgroundTransparency = 0.5;
&#9;&#9;end

&#9;&#9;Bar.MouseButton1Down:connect(Scrollbar.StartDrag) -- Hookup events...
&#9;&#9;Bar.MouseButton1Up:connect(Scrollbar.StopScrollFromWhitespace)

&#9;&#9;ScrollBarContainer.Active = true
&#9;&#9;if ScrollBarContainer:IsA(&quot;GuiButton&quot;) then
&#9;&#9;&#9;-- These events actually do have to be hooked up, if the container is a thing.
&#9;&#9;&#9;ScrollBarContainer.MouseButton1Down:connect(Scrollbar.MouseDownOnWhitespace) -- Hookup events...
&#9;&#9;&#9;ScrollBarContainer.MouseButton1Up:connect(Scrollbar.StopScrollFromWhitespace)
&#9;&#9;&#9;ScrollBarContainer.MouseEnter:connect(Scrollbar.OnEnterDisplay)
&#9;&#9;&#9;ScrollBarContainer.MouseLeave:connect(Scrollbar.OnLeaveDisplay)
&#9;&#9;else
&#9;&#9;&#9;Bar.MouseEnter:connect(Scrollbar.OnEnterDisplay)
&#9;&#9;&#9;Bar.MouseLeave:connect(Scrollbar.OnLeaveDisplay)
&#9;&#9;end
&#9;&#9;Scrollbar.ResizeBar()
&#9;&#9;Scrollbars[#Scrollbars+1] = Scrollbar -- Add the scrollbar &apos;Object&apos; to the list of scrollbars. 
&#9;end

&#9;local function OnAbsoluteSizeAdjust(Property)
&#9;&#9;-- Whenever a component changes size, it adjusts the range. This function is for hooking up to .Changed events.

&#9;&#9;if Property == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;Scroller:AdjustRange() -- Make sure we don&apos;t get into an absoltue loop.
&#9;&#9;end
&#9;end

&#9;KineticModel.OnPositionChange = function(NewPosition)
&#9;&#9;-- Goes off when the position changes. 

&#9;&#9;--print(&quot;[Scroller] - Position Changed to &quot;..NewPosition)
&#9;&#9;if Axis == &apos;Y&apos; then
&#9;&#9;&#9;Content.Position = UDim2.new(Content.Position.X.Scale, Content.Position.X.Offset, 0, NewPosition)
&#9;&#9;else
&#9;&#9;&#9;Content.Position = UDim2.new(0, NewPosition, NewPositionContent.Position.Y.Scale, Content.Position.Y.Offset)
&#9;&#9;end

&#9;&#9;for _, Scrollbar in pairs(Scrollbars) do
&#9;&#9;&#9;Scrollbar.Render(NewPosition)
&#9;&#9;end
&#9;end

&#9;Content.Active = true
&#9;if Content:IsA(&quot;GuiButton&quot;) then
&#9;&#9;-- Content.MouseEnter:connect(function()
&#9;&#9;-- &#9;Scroller.EnabledMouseScroll()
&#9;&#9;-- &#9;--[[for _, Scrollbar in pairs(Scrollbars) do
&#9;&#9;-- &#9;&#9;Scrollbar.OnEnterDisplay()
&#9;&#9;-- &#9;end--]]
&#9;&#9;-- end)
&#9;&#9;-- Content.MouseLeave:connect(function()
&#9;&#9;-- &#9;Scroller.DisableMouseScroll()
&#9;&#9;-- &#9;--[[for _, Scrollbar in pairs(Scrollbars) do
&#9;&#9;-- &#9;&#9;Scrollbar.OnLeaveDisplay()
&#9;&#9;-- &#9;end--]]
&#9;&#9;-- end)
&#9;&#9;Content.MouseButton1Down:connect(Scroller.StartDrag)
&#9;end

&#9;Content.MouseWheelForward:connect(function()
&#9;&#9;--print(&quot;[Scroller] - Wheel Move Forward&quot;)
&#9;&#9;Scroller.ScrollUp()
&#9;end)
&#9;Content.MouseWheelBackward:connect(function()
&#9;&#9;--print(&quot;[Scroller] - Wheel Move Backwards&quot;)
&#9;&#9;Scroller.ScrollDown()
&#9;end)

&#9;--MouseDrag.MouseMoved:connect(Scroller.Drag)
&#9;MouseDrag.MouseButton1Up:connect(function()
&#9;&#9;Scroller.StopDrag()
&#9;end)
&#9;Container.Changed:connect(OnAbsoluteSizeAdjust)
&#9;Content.Changed:connect(OnAbsoluteSizeAdjust)

&#9;Scroller:AdjustRange()

&#9;KineticModel.OnScrollStop = function(Position)
&#9;&#9;Scroller.ScrollFinished:fire(KineticModel.DisplayPosition)
&#9;end
end)
lib.MakeScroller = MakeScroller

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX23">
					<Properties>
						<string name="Name">ScreenCover</string>
						<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local RunService = game:GetService(&quot;RunService&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local EnumInterpreter   = LoadCustomLibrary(&quot;EnumInterpreter&quot;)
local qMath             = LoadCustomLibrary(&quot;qMath&quot;);

local lib    = {}

-- ScreenCover.lua
-- @author Quenty
-- Last Modified February 3rd, 2014

qSystems:import(getfenv(0));

lib.STYLES = {}
lib.TYPES = {
&#9;&quot;TransitionOut&quot;;
&#9;&quot;TransitionIn&quot;;
}

local function MakeCover(Properties)
&#9;-- Generates a cover frame that is basically standard. :D

&#9;Properties = Properties or {}

&#9;return Modify(Make(&quot;Frame&quot;, {
&#9;&#9;&#9;--Parent               = ScreenGui;
&#9;&#9;&#9;Size                   = UDim2.new(1, 0, 1, 2);
&#9;&#9;&#9;Position               = UDim2.new(0, 0, 0, -2); -- Fix ROBLOX&apos;s glitches...
&#9;&#9;&#9;BackgroundColor3       = Color3.new(0, 0, 0);
&#9;&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;&#9;Visible                = false;
&#9;&#9;&#9;Name                   = &quot;ScreenCover&quot;;
&#9;&#9;&#9;ZIndex                 = 10;
&#9;&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;}), Properties)
end

lib.MakeCover = MakeCover
lib.makeCover = MakeCover

local function SmoothInOut(Percent, Factor)
&#9;if Percent &lt; 0.5 then
&#9;&#9;return ((Percent*2)^Factor)/2
&#9;else
&#9;&#9;return (-((-(Percent*2) + 2)^Factor))/2 + 1
&#9;end
end

local function SmoothIn(Percent, Factor)
&#9;return Percent^Factor
end

local function SmoothOut(Percent, Factor)
&#9;return Percent^(1/Factor)
end

local Offset = 10
local function CenterCircleGui(BaseCover, TopFrame, BottomFrame, LeftFrame, RightFrame, CircleGui) 

&#9;CircleGui.Position = UDim2.new(0.5, -CircleGui.Size.X.Offset/2, 0.5, -CircleGui.Size.Y.Offset/2);

&#9;--- Center&apos;s the circle gui and resizes the surrounding labels
&#9;TopFrame.Size = UDim2.new(1, Offset, 0, (BaseCover.AbsoluteSize.Y - CircleGui.Size.Y.Offset)/2 + Offset/2)
&#9;TopFrame.Position = UDim2.new(0, -Offset/2, 0.5, -(CircleGui.Size.Y.Offset/2 + TopFrame.Size.Y.Offset))

&#9;BottomFrame.Size = TopFrame.Size; --UDim2.new(1, Offset, 0, (BaseCover.AbsoluteSize.Y - CircleGui.Size.Y.Offset)/2 + Offset/2)
&#9;BottomFrame.Position = UDim2.new(0, -Offset/2, 0.5, (CircleGui.Size.Y.Offset/2))

&#9;LeftFrame.Size = UDim2.new(0, (BaseCover.AbsoluteSize.X - CircleGui.Size.X.Offset)/2 + Offset/2, 1, Offset)
&#9;LeftFrame.Position = UDim2.new(0.5, -(CircleGui.Size.X.Offset/2 + LeftFrame.Size.X.Offset), 0, -Offset/2)
&#9;-- LeftFrame.Position = UDim2.new(0, -Offset, 0.5, -CircleGui.Size.Y.Offset/2 - Offset/2)

&#9;RightFrame.Size = LeftFrame.Size-- UDim2.new(0, (BaseCover.AbsoluteSize.X - CircleGui.Size.X.Offset)/2 + Offset/2, 1, Offset)
&#9;RightFrame.Position = UDim2.new(0.5, (CircleGui.Size.X.Offset/2), 0, -Offset/2)
&#9;-- RightFrame.Size = UDim2.new(0.5, -CircleGui.Size.X.Offset/2 + Offset, 0, CircleGui.Size.Y.Offset  + Offset)
&#9;-- RightFrame.Position = UDim2.new(1, -CircleGui.Size.X.Offset, 0.5, -CircleGui.Size.Y.Offset/2 - Offset/2)
end

local function GenerateCircleGui(BaseCover, CircleSize, ZIndex)
&#9;ZIndex = ZIndex or 1;

&#9;local CircleGui = Make(&quot;ImageLabel&quot;, {
&#9;&#9;Archivable             = false;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;Image                  = &quot;http://www.roblox.com/asset/?id=148523274&quot;;
&#9;&#9;Size                   = UDim2.new(0, CircleSize, 0, CircleSize);
&#9;&#9;Parent                 = BaseCover;
&#9;&#9;ZIndex = ZIndex;
&#9;})

&#9;-- Stretch accross the whole top.
&#9;local TopFrame = Make(&quot;Frame&quot;, {
&#9;&#9;Archivable       = false;
&#9;&#9;BorderSizePixel  = 0;
&#9;&#9;BackgroundColor3 = Color3.new(0, 0, 0);
&#9;&#9;Name             = &quot;TopFrame&quot;;
&#9;&#9;Parent           = BaseCover;
&#9;&#9;ZIndex = ZIndex;
&#9;})

&#9;-- Stretch accross the whole bottom.
&#9;local BottomFrame = Make(&quot;Frame&quot;, {
&#9;&#9;Archivable       = false;
&#9;&#9;BorderSizePixel  = 0;
&#9;&#9;BackgroundColor3 = Color3.new(0, 0, 0);
&#9;&#9;Name             = &quot;BottomFrame&quot;;
&#9;&#9;Parent           = BaseCover;
&#9;&#9;ZIndex = ZIndex;
&#9;})

&#9;local LeftFrame = Make(&quot;Frame&quot;, {
&#9;&#9;Archivable       = false;
&#9;&#9;BorderSizePixel  = 0;
&#9;&#9;BackgroundColor3 = Color3.new(0, 0, 0);
&#9;&#9;Name             = &quot;LeftFrame&quot;;
&#9;&#9;Parent           = BaseCover;
&#9;&#9;ZIndex = ZIndex;
&#9;})

&#9;local RightFrame = Make(&quot;Frame&quot;, {
&#9;&#9;Archivable       = false;
&#9;&#9;BorderSizePixel  = 0;
&#9;&#9;BackgroundColor3 = Color3.new(0, 0, 0);
&#9;&#9;Name             = &quot;RightFrame&quot;;
&#9;&#9;Parent           = BaseCover;
&#9;&#9;ZIndex = ZIndex;
&#9;})

&#9;return CircleGui, TopFrame, BottomFrame, LeftFrame, RightFrame
end

local StyleFunctions = {
&#9;Fade = {
&#9;&#9;TransitionOut = function(Time, BaseCover) -- Basically, it&apos;ll hand the function a &quot;BaseCover&quot;, which presumadly covers the whole screen.  It&apos;ll also hand it a
&#9;&#9;-- time to animate. From there on, it&apos;s expected that the function will execute in the time given, and end up with the BaseCover covering the whole screen...
&#9;&#9;-- with no extra objects in it. :)

&#9;&#9;-- Since this is &apos;TransitionOut&apos;, it&apos;ll start at 0, and go to 1 transparency...

&#9;&#9;&#9;local StartTime = time();
&#9;&#9;&#9;local FinishTime = Time + StartTime
&#9;&#9;&#9;while FinishTime &gt; time() do
&#9;&#9;&#9;&#9;BaseCover.BackgroundTransparency =  (time() - StartTime) / Time
&#9;&#9;&#9;&#9;wait(0.03);
&#9;&#9;&#9;end
&#9;&#9;&#9;BaseCover.BackgroundTransparency = 1;
&#9;&#9;&#9;return true;
&#9;&#9;end;
&#9;&#9;TransitionIn = function(Time, BaseCover)
&#9;&#9;&#9;local StartTime = time();
&#9;&#9;&#9;local FinishTime = Time + StartTime
&#9;&#9;&#9;while FinishTime &gt; time() do
&#9;&#9;&#9;&#9;BaseCover.BackgroundTransparency =  1 - ((time() - StartTime) / Time)
&#9;&#9;&#9;&#9;wait(0.03);
&#9;&#9;&#9;end
&#9;&#9;&#9;BaseCover.BackgroundTransparency = 0;
&#9;&#9;&#9;return true;
&#9;&#9;end;
&#9;};
&#9;SlideDown = {
&#9;&#9;-- Optimal with fast animation times.

&#9;&#9;TransitionIn = function(Time, BaseCover, AnimationStyles)
&#9;&#9;&#9;local NewCover = BaseCover:Clone()
&#9;&#9;&#9;NewCover.Parent = BaseCover
&#9;&#9;&#9;NewCover.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;&#9;NewCover.Position = UDim2.new(0, 0, -1, 0)
&#9;&#9;&#9;NewCover.BackgroundTransparency = 0;
&#9;&#9;&#9;NewCover:TweenPosition(UDim2.new(0, 0, 0, 0), &quot;In&quot;, AnimationStyles.EasingStyle or (&quot;Quad&quot;), Time, true)
&#9;&#9;&#9;BaseCover.BackgroundTransparency = 1
&#9;&#9;&#9;wait(Time)
&#9;&#9;&#9;NewCover:Destroy()
&#9;&#9;&#9;BaseCover.BackgroundTransparency = 0
&#9;&#9;&#9;return true;
&#9;&#9;end;
&#9;&#9;TransitionOut = function(Time, BaseCover, AnimationStyles)
&#9;&#9;&#9;local NewCover = BaseCover:Clone()
&#9;&#9;&#9;NewCover.Parent = BaseCover
&#9;&#9;&#9;NewCover.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;&#9;NewCover.Position = UDim2.new(0, 0, 0, 0)
&#9;&#9;&#9;NewCover:TweenPosition(UDim2.new(0, 0, 1, 0), &quot;Out&quot;, AnimationStyles.EasingStyle or (&quot;Quad&quot;), Time, true)
&#9;&#9;&#9;BaseCover.BackgroundTransparency = 1
&#9;&#9;&#9;wait(Time)
&#9;&#9;&#9;NewCover:Destroy()
&#9;&#9;&#9;return true;
&#9;&#9;end;
&#9;};
&#9;SlideUp = {
&#9;&#9;-- Optimal with fast animation times.

&#9;&#9;TransitionIn = function(Time, BaseCover, AnimationStyles)
&#9;&#9;&#9;local NewCover = BaseCover:Clone()
&#9;&#9;&#9;NewCover.Parent = BaseCover
&#9;&#9;&#9;NewCover.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;&#9;NewCover.Position = UDim2.new(0, 0, 1, 0)
&#9;&#9;&#9;NewCover.BackgroundTransparency = 0;
&#9;&#9;&#9;NewCover:TweenPosition(UDim2.new(0, 0, 0, 0), &quot;In&quot;, AnimationStyles.EasingStyle or (&quot;Quad&quot;), Time, true)
&#9;&#9;&#9;BaseCover.BackgroundTransparency = 1
&#9;&#9;&#9;wait(Time)
&#9;&#9;&#9;NewCover:Destroy()
&#9;&#9;&#9;BaseCover.BackgroundTransparency = 0
&#9;&#9;&#9;return true;
&#9;&#9;end;
&#9;&#9;TransitionOut = function(Time, BaseCover, AnimationStyles)
&#9;&#9;&#9;local NewCover = BaseCover:Clone()
&#9;&#9;&#9;NewCover.Parent = BaseCover
&#9;&#9;&#9;NewCover.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;&#9;NewCover.Position = UDim2.new(0, 0, 0, 0)
&#9;&#9;&#9;NewCover:TweenPosition(UDim2.new(0, 0, -1, 0), &quot;Out&quot;, AnimationStyles.EasingStyle or (&quot;Quad&quot;), Time, true)
&#9;&#9;&#9;BaseCover.BackgroundTransparency = 1
&#9;&#9;&#9;wait(Time)
&#9;&#9;&#9;NewCover:Destroy()
&#9;&#9;&#9;return true;
&#9;&#9;end;
&#9;};
&#9;DiagonalSquares = {
&#9;&#9;TransitionIn = function(Time, BaseCover, AnimationStyles)
&#9;&#9;&#9;-- SquareSize must be divisible by 2. 
&#9;&#9;&#9;-- If the squareSize is too small, you can get wait() lag (I think).

&#9;&#9;&#9;SquareSize                       = qMath.roundUp(AnimationStyles.SquareSize or 76, 2);
&#9;&#9;&#9;local NewCover                   = BaseCover:Clone()
&#9;&#9;&#9;NewCover.Name                    = &quot;Square&quot;
&#9;&#9;&#9;NewCover.Size                    = UDim2.new(0, 0, 0, 0);
&#9;&#9;&#9;NewCover.BackgroundTransparency  = 0;
&#9;&#9;&#9;BaseCover.BackgroundTransparency = 1;
&#9;&#9;&#9;
&#9;&#9;&#9;
&#9;&#9;&#9;local MaxSize                    = qMath.roundUp(math.max(BaseCover.AbsoluteSize.X, BaseCover.AbsoluteSize.Y) * 1.6, SquareSize) + SquareSize
&#9;&#9;&#9;local Squares                    = {}
&#9;&#9;&#9;local ValX                       = 0;
&#9;&#9;&#9;local ValY                       = 0;
&#9;&#9;&#9;local WaitEach                   = (Time/2)/(MaxSize/SquareSize)

&#9;&#9;&#9;while ValY &lt;= MaxSize do
&#9;&#9;&#9;&#9;ValX = 0;
&#9;&#9;&#9;&#9;while ValX &lt;= ValY do
&#9;&#9;&#9;&#9;&#9;local Square = NewCover:Clone()
&#9;&#9;&#9;&#9;&#9;Square.Archivable = false;
&#9;&#9;&#9;&#9;&#9;Square.Position = UDim2.new(0, ValX + (SquareSize/2), 0, ValY - (ValX) + (SquareSize/2));
&#9;&#9;&#9;&#9;&#9;Square.Parent = BaseCover;
&#9;&#9;&#9;&#9;&#9;local NewPosition = Square.Position - UDim2.new(0, SquareSize/2, 0, SquareSize/2)
&#9;&#9;&#9;&#9;&#9;table.insert(Squares, Square)

&#9;&#9;&#9;&#9;&#9;delay(WaitEach * (ValY/SquareSize), function() 
&#9;&#9;&#9;&#9;&#9;&#9;Square:TweenSizeAndPosition(UDim2.new(0, SquareSize, 0, SquareSize), NewPosition, &quot;In&quot;, &quot;Quad&quot;, Time/2, true)
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;ValX = ValX + SquareSize
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;ValY = ValY + SquareSize
&#9;&#9;&#9;end
&#9;&#9;&#9;wait(Time)

&#9;&#9;&#9;BaseCover.BackgroundTransparency = 0;
&#9;&#9;&#9;for _, Square in pairs(Squares) do
&#9;&#9;&#9;&#9;Square:Destroy();
&#9;&#9;&#9;end
&#9;&#9;&#9;return true;
&#9;&#9;end;
&#9;&#9;TransitionOut = function(Time, BaseCover, AnimationStyles)
&#9;&#9;&#9;SquareSize                      = qMath.roundUp(AnimationStyles.SquareSize or 76, 2);
&#9;&#9;&#9;
&#9;&#9;&#9;local NewCover                  = BaseCover:Clone()
&#9;&#9;&#9;NewCover.Name                   = &quot;Square&quot;
&#9;&#9;&#9;NewCover.Size                   = UDim2.new(0, SquareSize, 0, SquareSize);
&#9;&#9;&#9;
&#9;&#9;&#9;local MaxSize                   = qMath.roundUp(math.max(BaseCover.AbsoluteSize.X, BaseCover.AbsoluteSize.Y) * 1.6, SquareSize) + SquareSize
&#9;&#9;&#9;local Squares                   = {}
&#9;&#9;&#9;local ValX                      = 0;
&#9;&#9;&#9;local ValY                      = MaxSize;
&#9;&#9;&#9;local WaitEach                  = (Time/2)/(MaxSize/SquareSize)

&#9;&#9;&#9;while ValY &gt;= 0 do
&#9;&#9;&#9;&#9;ValX = 0;
&#9;&#9;&#9;&#9;while ValX &lt;= ValY do
&#9;&#9;&#9;&#9;&#9;local Square = NewCover:Clone()
&#9;&#9;&#9;&#9;&#9;Square.Archivable = false;
&#9;&#9;&#9;&#9;&#9;Square.Parent = BaseCover;
&#9;&#9;&#9;&#9;&#9;Square.Position = UDim2.new(0, ValX, 0, ValY - ValX);
&#9;&#9;&#9;&#9;&#9;local NewPosition = Square.Position + UDim2.new(0, (SquareSize/2), 0, (SquareSize/2));
&#9;&#9;&#9;&#9;&#9;table.insert(Squares, Square)

&#9;&#9;&#9;&#9;&#9;delay(WaitEach * (ValY/SquareSize), function() 
&#9;&#9;&#9;&#9;&#9;&#9;Square:TweenSizeAndPosition(UDim2.new(0, 0, 0, 0), NewPosition, &quot;Out&quot;, &quot;Quad&quot;, Time/2, true)
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;ValX = ValX + SquareSize
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;ValY = ValY - SquareSize
&#9;&#9;&#9;end

&#9;&#9;&#9;BaseCover.BackgroundTransparency = 1;
&#9;&#9;&#9;wait(Time)
&#9;&#9;&#9;for _, Square in pairs(Squares) do
&#9;&#9;&#9;&#9;Square:Destroy();
&#9;&#9;&#9;end
&#9;&#9;&#9;return true;
&#9;&#9;end;
&#9;};
&#9;StraightSquare = {
&#9;&#9;TransitionIn = function(Time, BaseCover, AnimationStyles)
&#9;&#9;&#9;-- SquareSize must be divisible by 2. 
&#9;&#9;&#9;-- If the squareSize is too small, you can get wait() lag (I think).

&#9;&#9;&#9;SquareSize                       = qMath.roundUp(AnimationStyles.SquareSize or 76, 2);
&#9;&#9;&#9;local NewCover                   = BaseCover:Clone()
&#9;&#9;&#9;NewCover.Name                    = &quot;Square&quot;
&#9;&#9;&#9;NewCover.Size                    = UDim2.new(0, 0, 0, 0);
&#9;&#9;&#9;NewCover.BackgroundTransparency  = 0;
&#9;&#9;&#9;BaseCover.BackgroundTransparency = 1;
&#9;&#9;&#9;
&#9;&#9;&#9;
&#9;&#9;&#9;local MaxSize                    = qMath.roundUp(math.max(BaseCover.AbsoluteSize.X, BaseCover.AbsoluteSize.Y) * 1.6, SquareSize) + SquareSize
&#9;&#9;&#9;local Squares                    = {}
&#9;&#9;&#9;local ValX                       = 0;
&#9;&#9;&#9;local ValY                       = 0;
&#9;&#9;&#9;local WaitEach                   = (Time/2)/(MaxSize/SquareSize)

&#9;&#9;&#9;while ValY &lt;= MaxSize do
&#9;&#9;&#9;&#9;ValX = 0;
&#9;&#9;&#9;&#9;while ValX &lt;= MaxSize do
&#9;&#9;&#9;&#9;&#9;local Square = NewCover:Clone()
&#9;&#9;&#9;&#9;&#9;Square.Archivable = false;
&#9;&#9;&#9;&#9;&#9;Square.Position = UDim2.new(0, ValX, 0, ValY);
&#9;&#9;&#9;&#9;&#9;Square.Parent = BaseCover;
&#9;&#9;&#9;&#9;&#9;local NewPosition = Square.Position - UDim2.new(0, SquareSize/2, 0, SquareSize/2)
&#9;&#9;&#9;&#9;&#9;table.insert(Squares, Square)

&#9;&#9;&#9;&#9;&#9;delay(WaitEach * (ValX/SquareSize), function() 
&#9;&#9;&#9;&#9;&#9;&#9;Square:TweenSizeAndPosition(UDim2.new(0, SquareSize, 0, SquareSize), NewPosition, &quot;In&quot;, &quot;Quad&quot;, Time/2, true)
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;ValX = ValX + SquareSize
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;ValY = ValY + SquareSize
&#9;&#9;&#9;end
&#9;&#9;&#9;wait(Time)

&#9;&#9;&#9;BaseCover.BackgroundTransparency = 0;
&#9;&#9;&#9;for _, Square in pairs(Squares) do
&#9;&#9;&#9;&#9;Square:Destroy();
&#9;&#9;&#9;end
&#9;&#9;&#9;return true;
&#9;&#9;end;
&#9;&#9;TransitionOut = function(Time, BaseCover, AnimationStyles)
&#9;&#9;&#9;print(&quot;No out&quot;)
&#9;&#9;end;
&#9;};
&#9;Circle = {
&#9;&#9;TransitionIn = function(Time, BaseCover, AnimationStyles)
&#9;&#9;&#9;local CircleSize = math.max(BaseCover.AbsoluteSize.X, BaseCover.AbsoluteSize.Y)*math.sqrt(2) -- Presuming image takes up whole area.
&#9;&#9;&#9;BaseCover.BackgroundTransparency = 1;

&#9;&#9;&#9;local CircleGui, TopFrame, BottomFrame, LeftFrame, RightFrame = GenerateCircleGui(BaseCover, CircleSize, BaseCover.ZIndex)

&#9;&#9;&#9;local function ResizeCircle(Radius)
&#9;&#9;&#9;&#9;Radius = Round(Radius, 2)
&#9;&#9;&#9;&#9;CircleGui.Size = UDim2.new(0, Radius, 0, Radius)
&#9;&#9;&#9;&#9;CenterCircleGui(BaseCover, TopFrame, BottomFrame, LeftFrame, RightFrame, CircleGui)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;local StartTime = time();
&#9;&#9;&#9;local FinishTime = Time + StartTime
&#9;&#9;&#9;while FinishTime &gt; time() do
&#9;&#9;&#9;&#9;local Percent = (1 - ((time() - StartTime) / Time)) * CircleSize
&#9;&#9;&#9;&#9;ResizeCircle(Percent)
&#9;&#9;&#9;&#9;RunService.RenderStepped:wait(0)
&#9;&#9;&#9;&#9;---wait(0.03);
&#9;&#9;&#9;end
&#9;&#9;&#9;ResizeCircle(0)

&#9;&#9;&#9;BaseCover.BackgroundTransparency = 0;

&#9;&#9;&#9;CircleGui:Destroy()
&#9;&#9;&#9;TopFrame:Destroy()
&#9;&#9;&#9;BottomFrame:Destroy()
&#9;&#9;&#9;LeftFrame:Destroy()
&#9;&#9;&#9;RightFrame:Destroy()

&#9;&#9;&#9;return true;
&#9;&#9;end;
&#9;&#9;TransitionOut = function(Time, BaseCover, AnimationStyles)
&#9;&#9;&#9;local CircleSize = math.max(BaseCover.AbsoluteSize.X, BaseCover.AbsoluteSize.Y)*math.sqrt(2) -- Presuming image takes up whole area.
&#9;&#9;&#9;BaseCover.BackgroundTransparency = 1;

&#9;&#9;&#9;local CircleGui, TopFrame, BottomFrame, LeftFrame, RightFrame = GenerateCircleGui(BaseCover, 0, BaseCover.ZIndex)

&#9;&#9;&#9;local function ResizeCircle(Radius)
&#9;&#9;&#9;&#9;Radius = Round(Radius, 2)
&#9;&#9;&#9;&#9;CircleGui.Size = UDim2.new(0, Radius, 0, Radius)
&#9;&#9;&#9;&#9;CenterCircleGui(BaseCover, TopFrame, BottomFrame, LeftFrame, RightFrame, CircleGui)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;local StartTime = time();
&#9;&#9;&#9;local FinishTime = Time + StartTime
&#9;&#9;&#9;while FinishTime &gt; time() do
&#9;&#9;&#9;&#9;local Percent = ((time() - StartTime) / Time) * CircleSize
&#9;&#9;&#9;&#9;ResizeCircle(Percent)
&#9;&#9;&#9;&#9;RunService.RenderStepped:wait(0)
&#9;&#9;&#9;&#9;-- wait(0.03);
&#9;&#9;&#9;end
&#9;&#9;&#9;ResizeCircle(CircleSize)

&#9;&#9;&#9;CircleGui:Destroy()
&#9;&#9;&#9;TopFrame:Destroy()
&#9;&#9;&#9;BottomFrame:Destroy()
&#9;&#9;&#9;LeftFrame:Destroy()
&#9;&#9;&#9;RightFrame:Destroy()

&#9;&#9;&#9;return true;
&#9;&#9;end;
&#9;};
}

for StyleName, StyleData in pairs(StyleFunctions) do
&#9;lib.STYLES[#lib.STYLES+1] = StyleName;
&#9;StyleData.EnumID = #lib.STYLES
end

--[[
StyleFunctions.Squares.TransitionIn()

--]]

--[[

AnimationStyles = {
&#9;AnimationStyle = STYLES;
&#9;Type = TYPES;
&#9;AnimationTime = NUMBER;
}
--]]

local function MakeScreenCover(BaseCover, AnimationStyles)
&#9;local AnimationTime = AnimationStyles.AnimationTime or 1;
&#9;local AnimationStyle = EnumInterpreter.GetEnumName(lib.STYLES, (AnimationStyles.AnimationStyle or &quot;Fade&quot;)) -- Guarantee exact results (Lowercase, uppercase, etc. )
&#9;local Type = EnumInterpreter.GetEnumName(lib.TYPES, (AnimationStyles.Type or &quot;TransitionOut&quot;))

&#9;--print(&quot;[ScreenCover] - running animation: Type: &quot;..Type..&quot;; Style: &quot;..AnimationStyle..&quot;; Time: &quot;..AnimationTime)

&#9;BaseCover.Visible = true;
&#9;BaseCover.Transparency = (Type == &quot;TransitionOut&quot; and 0 or 1);

&#9;--local timeStart = tick();

&#9;StyleFunctions[AnimationStyle][Type](AnimationTime, BaseCover, AnimationStyles)

&#9;--print(&quot;[ScreenCover] - Time elapsed: &quot;..tick() - timeStart);
&#9;return BaseCover;
end

lib.MakeScreenCover = MakeScreenCover
lib.makeScreenCover = MakeScreenCover

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX24">
					<Properties>
						<string name="Name">qGUI</string>
						<ProtectedString name="Source">local Players            = game:GetService(&quot;Players&quot;)
local StarterPack        = game:GetService(&quot;StarterPack&quot;)
local StarterGui         = game:GetService(&quot;StarterGui&quot;)
local Lighting           = game:GetService(&quot;Lighting&quot;)
local Debris             = game:GetService(&quot;Debris&quot;)
local Teams              = game:GetService(&quot;Teams&quot;)
local BadgeService       = game:GetService(&quot;BadgeService&quot;)
local InsertService      = game:GetService(&quot;InsertService&quot;)
local HttpService        = game:GetService(&quot;HttpService&quot;)
local ReplicatedStorage  = game:GetService(&quot;ReplicatedStorage&quot;)
local RunService         = game:GetService(&quot;RunService&quot;)
local MarketplaceService = game:GetService(&quot;MarketplaceService&quot;)
local UserInputService   = game:GetService(&quot;UserInputService&quot;)
local Terrain            = Workspace.Terrain

local NevermoreEngine    = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary  = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local qMath             = LoadCustomLibrary(&quot;qMath&quot;)
local qCFrame           = LoadCustomLibrary(&quot;qCFrame&quot;)
local Table             = LoadCustomLibrary(&quot;Table&quot;)
local qColor3           = LoadCustomLibrary(&quot;qColor3&quot;)

qSystems:import(getfenv(0));

local lib = {}

local DEFAULTS = {}

local WEAK_MODE = {
&#9;K = {__mode=&quot;k&quot;};
&#9;V = {__mode=&quot;v&quot;};
&#9;KV = {__mode=&quot;kv&quot;};
}

local COLORS = {
&#9;

}

-- qGUI.lua
-- @author Quenty
-- A group of utility functions to be used by ROBLOX GUIs

--[[

Change Log
February 15th, 2014
- Updated TweenTransparency method to use single thread update model for efficiency.
- Updated TweenColor3 method to use a single thread update model for efficiency.

--]]


local function GetScreen(object)
&#9;-- Given a GUI object, returns it&apos;s screenGui. 

&#9;--[[
&#9;GetScreen ( Instance `object` )
&#9;&#9;returns ScreenGui `screen`

&#9;Gets the nearest ascending ScreenGui of `object`.
&#9;Returns `object` if it is a ScreenGui.
&#9;Returns nil if `object` isn&apos;t the descendant of a ScreenGui.

&#9;Arguments:
&#9;&#9;`object`
&#9;&#9;&#9;The instance to get the ascending ScreenGui from.

&#9;Returns:
&#9;&#9;`screen`
&#9;&#9;&#9;The ascending screen.
&#9;&#9;&#9;Will be nil if `object` isn&apos;t the descendant of a ScreenGui.
&#9;--]]

&#9;local screen = object
&#9;while not screen:IsA(&quot;ScreenGui&quot;) do
&#9;&#9;screen = screen.Parent
&#9;&#9;if screen == nil then return nil end
&#9;end
&#9;return screen
end
lib.GetScreen = GetScreen
lib.getScreen = GetScreen
lib.get_screen = GetScreens

local function NewColor3(red, green, blue)
&#9;-- Given a red, green, and blue, it&apos;ll return a formatted Color3 object. 
&#9;return Color3.new(red/255, green/255, blue/255)
end
lib.NewColor3 = NewColor3
lib.newColor3 = NewColor3
lib.new_color3 = NewColor3

lib.MakeColor3 = NewColor3
lib.makeColor3 = NewColor3

local function GetCenteringPosition(Object)
&#9;-- Return&apos;s the center of
&#9;return UDim2.new(0.5, -Object.AbsoluteSize.X/2, 0.5, -Object.AbsoluteSize.Y/2)
end
lib.GetCenteringPosition = GetCenteringPosition
lib.getCenteringPosition = GetCenteringPosition
lib.get_centering_position = GetCenteringPosition

local function GetHalfSize(Object)
&#9;-- Return&apos;s half the size of an object. 

&#9;local ObjectSize = Object.Size
&#9;return UDim2.new(ObjectSize.X.Scale / 2, ObjectSize.X.Offset /2, ObjectSize.Y.Scale / 2, ObjectSize.Y.Offset / 2)
end
lib.GetHalfSize = GetHalfSize
lib.getHalfSize = GetHalfSize
lib.get_half_size = GetHalfSize

local function Center(Object)
&#9;-- Centers an object (Sized with offset) into the middle of the screen.

&#9;Object.Position = GetCenteringPosition(Object)
end
lib.Center = Center
lib.center = center

local function MouseOver(Mouse, Frame)
&#9;local TopBound &#9;&#9;= Frame.AbsolutePosition.Y
&#9;local BottomBound &#9;= Frame.AbsolutePosition.Y + Frame.AbsoluteSize.Y
&#9;local LeftBound&#9;&#9;= Frame.AbsolutePosition.X
&#9;local RightBound&#9;&#9;= Frame.AbsolutePosition.X + Frame.AbsoluteSize.X
&#9;if Mouse.Y &gt; TopBound and Mouse.Y &lt; BottomBound and Mouse.X &gt; LeftBound and Mouse.X &lt; RightBound then
&#9;&#9;return true
&#9;else
&#9;&#9;return false
&#9;end
end
lib.MouseOver = MouseOver
lib.mouseOver = MouseOver
lib.mouse_over = MouseOver

local function SubtractColor3(a, b)
&#9;local R = a.r + b.r
&#9;local G = a.g + b.g
&#9;local B = a.b + b.b
&#9;return Color3.new(R, G, B)
end
lib.SubtractColor3 = SubtractColor3
lib.subtractColor3 = SubtractColor3
lib.subtract_color3 = SubtractColor3

local function MultiplyColor3(Num, Color)
&#9;-- Multiplies a Color3 by Num

&#9;local R = Color.r * Num
&#9;local G = Color.g * Num
&#9;local B = Color.b * Num
&#9;return Color3.new(R, G, B)
end
lib.MultiplyColor3 = MultiplyColor3
lib.multiplyColor3 = MultiplyColor3
lib.multiply_color3 = MultiplyColor3

local function InverseColor3(Color)
&#9;-- Inverses a Color3...

&#9;return Color3.new(1 - Color.r, 1 - Color.g, 1 - Color.b)
end
lib.InverseColor3 = InverseColor3
lib.inverseColor3 = InverseColor3
lib.inverse_color3 = InverseColor3

local function IsPhone(ScreenGui)
&#9;-- Return&apos;s if ROBLOX is being played on a phone or not.

&#9;if ScreenGui.AbsoluteSize.Y &lt; 600 and UserInputService.TouchEnabled then 
&#9;&#9;return true
&#9;end 
&#9;return false 
end
lib.isPhone = IsPhone
lib.IsPhone = IsPhone
lib.is_phone = IsPhone

local function TouchOnly()
&#9;-- Return&apos;s if it&apos;s TouchOnly

&#9;return not UserInputService.MouseEnabled 
end
lib.TouchOnly = TouchOnly
lib.touchOnly = TouchOnly
lib.touch_only = TouchOnly

local function UDim2OffsetFromVector2(Vector2ConvertFrom)
&#9;-- Return&apos;s a UDim2 generated from the Vector2ConvertFrom

&#9;return UDim2.new(0, Vector2ConvertFrom.X, 0, Vector2ConvertFrom.Y)
end
lib.UDim2OffsetFromVector2 = UDim2OffsetFromVector2
lib.uDim2OffsetFromVector2 = UDim2OffsetFromVector2
lib.udim2_offset_from_vector2 = UDim2OffsetFromVector2


local function WorldToScreen(ScreenSize, Camera, Position)
&#9;--- Converts a 3D point to a 2D point on the screen. 
&#9;-- @param ScreenSize Vector2, the current screensize.
&#9;-- @param Camera The current camera (to do the operation on)
&#9;-- @param Position = The Vector3 position
&#9;-- @return X (In scale), Y (in scale) and Z (Stud distance))

&#9;-- Credit to TreyReynolds for magic.

&#9;local VSY              = ScreenSize.Y
&#9;local CoordinateFrame  = Camera.CoordinateFrame
&#9;
&#9;local ScreenLimitY     = math.tan(math.rad(Camera.FieldOfView)/2)*2
&#9;-- local ScreenLimitX     = ScreenLimitY*Mouse.ViewSizeX/VSY
&#9;
&#9;local RelativePosition = CoordinateFrame:inverse() * Position

&#9;return 0.5 - RelativePosition.x/RelativePosition.z/(ScreenLimitY*ScreenSize.X/VSY), 0.5 + RelativePosition.y/RelativePosition.z/ScreenLimitY, -RelativePosition.z
end

--[[
do
&#9;local PointToObjectSpace = CFrame.new().pointToObjectSpace
&#9;local atan2              = math.atan2
&#9;local tan                = math.tan
&#9;local Vector2New         = Vector2.new
&#9;local abs                = math.abs
&#9;local max                = math.max
&#9;local min                = math.min
&#9;local pi                 = math.pi

&#9;local PiOver360 = pi / 360
&#9;-- local Sign = Sign

&#9;local function WorldToScreen(Position, Mouse, Camera)
&#9;&#9;-- Translates a position in ROBLOX space to ScreenSpace.  
&#9;&#9;-- Math credit to xXxMoNkEyMaNxXx
&#9;&#9;-- Returns if it&apos;s on the screen, then the ScreenPosition, and then the angle at which the object is (if it&apos;s off the screen?) Not sure entirely.
&#9;&#9;
&#9;&#9;local RealPosition = PointToObjectSpace(Camera.CoordinateFrame, Position)
&#9;&#9;local RealPositionX = RealPosition.x
&#9;&#9;local RealPositionY = RealPosition.y
&#9;&#9;local RealPositionZ = RealPosition.z

&#9;&#9;local Angle = atan2(RealPositionX, -RealPositionY) -- Rotate 90 degrees ccw so that angles start at &quot;straight down&quot;
&#9;&#9;local Theta
&#9;&#9;local ViewSize = Vector2New(Mouse.ViewSizeX, Mouse.ViewSizeY) / 2
&#9;&#9;if RealPositionZ &lt; 0 then -- Object is in front
&#9;&#9;&#9;local ATY = tan(Camera.FieldOfView * PiOver360)
&#9;&#9;&#9;local AT1 = Vector2New(ATY * ViewSize.X / ViewSize.Y, ATY)
&#9;&#9;&#9;local UPOS = Vector2New(-RealPositionX, RealPositionY) / RealPositionZ
&#9;&#9;&#9;local SPOS = ViewSize + ViewSize * UPOS / AT1
&#9;&#9;&#9;if SPOS.X &gt;= 0 and SPOS.X &lt;= Mouse.ViewSizeX and SPOS.Y &gt;= 0 and SPOS.Y &lt;= Mouse.ViewSizeY then
&#9;&#9;&#9;&#9;return true, SPOS, Angle
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Theta = true
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;Theta = true
&#9;&#9;end
&#9;&#9;if Theta then
&#9;&#9;&#9;return false, 
&#9;&#9;&#9;ViewSize + Vector2New(Sign(RealPositionX) * abs(max(-ViewSize.x, min(ViewSize.x, ViewSize.y * RealPositionX/RealPositionY))), -Sign(RealPositionY) * abs(max(-ViewSize.y,min(ViewSize.y,ViewSize.x * RealPositionY/RealPositionX)))),
&#9;&#9;&#9;Angle
&#9;&#9;end
&#9;end
end
--]]

lib.WorldToScreen = WorldToScreen
lib.worldToScreen = WorldToScreen
lib.world_to_screen = WorldToScreen

local function MultiplyUDim2Offset(Original, Factor)
&#9;return UDim2.new(Original.X.Scale, Original.X.Offset * Factor, Original.Y.Scale, Original.Y.OFfset * Factor)
end
lib.MultiplyUDim2Offset = MultiplyUDim2Offset
lib.multiplyUDim2Offset = MultiplyUDim2Offset

local function PickRandomColor3(List)
&#9;return List[math.random(1, #List)]
end
lib.PickRandomColor3 = PickRandomColor3
lib.pickRandomColor3 = PickRandomColor3

local TweenTransparency, StopTransparencyTween do
&#9;local ProcessList = {}
&#9;-- setmetatable(ProcessList, WEAK_MODE.K)
&#9;local ActivelyProcessing = false

&#9;local function SetProperties(Gui, Percent, StartProperties, NewProperties)
&#9;&#9;-- Maybe there&apos;s a better way to do this?

&#9;&#9;for Index, EndValue in next, NewProperties do
&#9;&#9;&#9;local StartProperty = StartProperties[Index]
&#9;&#9;&#9;Gui[Index] = StartProperty + (EndValue - StartProperty) * Percent
&#9;&#9;end
&#9;end

&#9;local function UpdateTweenModels()
&#9;&#9;local CurrentTick = tick()
&#9;&#9;ActivelyProcessing = false

&#9;&#9;for Gui, TweenState in next, ProcessList do
&#9;&#9;&#9;if Gui and Gui:IsDescendantOf(game) then
&#9;&#9;&#9;&#9;ActivelyProcessing = tick()

&#9;&#9;&#9;&#9;local TimeElapsed = (CurrentTick - TweenState.StartTime)
&#9;&#9;&#9;&#9;local Duration    = TweenState.Duration

&#9;&#9;&#9;&#9;if TimeElapsed &gt; Duration then
&#9;&#9;&#9;&#9;&#9;-- Then we end it.
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;SetProperties(Gui, 1, TweenState.StartProperties, TweenState.NewProperties) 
&#9;&#9;&#9;&#9;&#9;ProcessList[Gui] = nil
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;-- Otherwise do the animations.

&#9;&#9;&#9;&#9;&#9;SetProperties(Gui, TimeElapsed/Duration, TweenState.StartProperties, TweenState.NewProperties)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;ProcessList[Gui] = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function StartProcessUpdate()
&#9;&#9;if not (ActivelyProcessing and ActivelyProcessing + 0.1 &gt;= tick()) then
&#9;&#9;&#9;ActivelyProcessing = tick()
&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;while ActivelyProcessing do
&#9;&#9;&#9;&#9;&#9;UpdateTweenModels()
&#9;&#9;&#9;&#9;&#9;wait(0.05)
&#9;&#9;&#9;&#9;&#9;-- RunService.RenderStepped:wait(0.05)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end

&#9;function TweenTransparency(Gui, NewProperties, Duration, Override)
&#9;&#9;-- Override tween system to tween the transparency of properties. Unfortunately, overriding is per a GUI as of now. 
&#9;&#9;--- Tween&apos;s the Transparency values in a GUI,
&#9;&#9;-- @param Gui The GUI to tween the Transparency&apos;s upon
&#9;&#9;-- @param NewProperties The properties to be changed. It will take the current
&#9;&#9;--                      properties and tween to the new ones. This table should be
&#9;&#9;--                      setup so {Index = NewValue} that is, for example, 
&#9;&#9;--                      {TextTransparency = 1}.
&#9;&#9;-- @param Time The amount of time to spend transitioning.
&#9;&#9;-- @param [Override] If true, it will override a previous animation, otherwise, it will not.

&#9;&#9;if not ProcessList[Gui] or Override then
&#9;&#9;&#9;-- Fill StartProperties
&#9;&#9;&#9;local StartProperties = {}
&#9;&#9;&#9;for Index, _ in pairs(NewProperties) do
&#9;&#9;&#9;&#9;StartProperties[Index] = Gui[Index]&#9;
&#9;&#9;&#9;end

&#9;&#9;&#9;-- And set NewState
&#9;&#9;&#9;local NewState = {
&#9;&#9;&#9;&#9;StartTime       = tick();
&#9;&#9;&#9;&#9;Duration        = Duration or error(&quot;No duration&quot;);
&#9;&#9;&#9;&#9;-- Gui          = Gui;
&#9;&#9;&#9;&#9;StartProperties = StartProperties;
&#9;&#9;&#9;&#9;NewProperties   = NewProperties;
&#9;&#9;&#9;}

&#9;&#9;&#9;ProcessList[Gui] = NewState
&#9;&#9;&#9;StartProcessUpdate()
&#9;&#9;end
&#9;end

&#9;function StopTransparencyTween(Gui)
&#9;&#9;-- Overrides all the current transparency animations in a GUI. Perhaps useful.
&#9;&#9;-- @param Gui The GUI to stop the tween the Transparency&apos;s upon

&#9;&#9;ProcessList[Gui] = nil
&#9;end


&#9;lib.TweenTransparency = TweenTransparency
&#9;lib.tweenTransparency = TweenTransparency

&#9;lib.StopTransparencyTween = StopTransparencyTween
&#9;lib.stopTransparencyTween = StopTransparencyTween
end

local TweenColor3, StopColor3Tween do
&#9;local ProcessList = {}
&#9;-- setmetatable(ProcessList, WEAK_MODE.K)
&#9;local ActivelyProcessing = false

&#9;local LerpColor3 = qColor3.LerpColor3
&#9;local function SetProperties(Gui, Percent, StartProperties, NewProperties)
&#9;&#9;-- Maybe there&apos;s a better way to do this?

&#9;&#9;for Index, EndValue in next, NewProperties do
&#9;&#9;&#9;local StartProperty = StartProperties[Index]
&#9;&#9;&#9;Gui[Index] = LerpColor3(StartProperty, EndValue, Percent)
&#9;&#9;end
&#9;end

&#9;local function UpdateTweenModels()
&#9;&#9;local CurrentTick = tick()
&#9;&#9;ActivelyProcessing = false

&#9;&#9;for Gui, TweenState in next, ProcessList do
&#9;&#9;&#9;if Gui and Gui:IsDescendantOf(game) then
&#9;&#9;&#9;&#9;ActivelyProcessing = tick()

&#9;&#9;&#9;&#9;local TimeElapsed = (CurrentTick - TweenState.StartTime)
&#9;&#9;&#9;&#9;local Duration    = TweenState.Duration

&#9;&#9;&#9;&#9;if TimeElapsed &gt; Duration then
&#9;&#9;&#9;&#9;&#9;-- Then we end it.
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;SetProperties(Gui, 1, TweenState.StartProperties, TweenState.NewProperties) 
&#9;&#9;&#9;&#9;&#9;ProcessList[Gui] = nil
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;-- Otherwise do the animations.

&#9;&#9;&#9;&#9;&#9;SetProperties(Gui, TimeElapsed/Duration, TweenState.StartProperties, TweenState.NewProperties)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;ProcessList[Gui] = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function StartProcessUpdate()
&#9;&#9;if not (ActivelyProcessing and ActivelyProcessing + 0.1 &gt;= tick()) then
&#9;&#9;&#9;ActivelyProcessing = tick()
&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;while ActivelyProcessing do
&#9;&#9;&#9;&#9;&#9;UpdateTweenModels()
&#9;&#9;&#9;&#9;&#9;wait(0.05)
&#9;&#9;&#9;&#9;&#9;-- RunService.RenderStepped:wait(0.05)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end
&#9;
&#9;function TweenColor3(Gui, NewProperties, Duration, Override)
&#9;&#9;--- Tween&apos;s the Color3 values in a GUI,
&#9;&#9;-- @param Gui The GUI to tween the Color3&apos;s upon
&#9;&#9;-- @param NewProperties The properties to be changed. It will take the current
&#9;&#9;--                      properties and tween to the new ones. This table should be
&#9;&#9;--                      setup so {Index = NewValue} that is, for example, 
&#9;&#9;--                      {BackgroundColor3 = Color3.new(1, 1, 1)}.
&#9;&#9;-- @param Duration The amount of time to spend transitioning.
&#9;&#9;-- @param [Override] If true, it will override a previous animation, otherwise, it will not.

&#9;&#9;if not ProcessList[Gui] or Override then
&#9;&#9;&#9;-- Fill StartProperties
&#9;&#9;&#9;local StartProperties = {}
&#9;&#9;&#9;for Index, _ in pairs(NewProperties) do
&#9;&#9;&#9;&#9;StartProperties[Index] = Gui[Index]&#9;
&#9;&#9;&#9;end

&#9;&#9;&#9;-- And set NewState
&#9;&#9;&#9;local NewState = {
&#9;&#9;&#9;&#9;StartTime       = tick();
&#9;&#9;&#9;&#9;Duration        = Duration or error(&quot;No duration&quot;);
&#9;&#9;&#9;&#9;-- Gui          = Gui;
&#9;&#9;&#9;&#9;StartProperties = StartProperties;
&#9;&#9;&#9;&#9;NewProperties   = NewProperties;
&#9;&#9;&#9;}

&#9;&#9;&#9;ProcessList[Gui] = NewState
&#9;&#9;&#9;StartProcessUpdate()
&#9;&#9;end
&#9;end

&#9;function StopColor3Tween(Gui)
&#9;&#9;-- Overrides all the current animations of Color3 in the GUI. 
&#9;&#9;-- @param Gui The GUI to stop the tween animations on

&#9;&#9;ProcessList[Gui] = nil
&#9;end

&#9;lib.TweenColor3 = TweenColor3
&#9;lib.tweenColor3 = TweenColor3

&#9;lib.StopColor3Tween = StopColor3Tween
&#9;lib.stopColor3Tween = StopColor3Tween
end

local function ResponsiveCircleClickEffect(Gui, X, Y, Time)
&#9;--- Google design thing.

&#9;Time = Time or 0.6;

&#9;X = X or Gui.AbsolutePosition.X + Gui.AbsoluteSize.X/2
&#9;Y = Y or Gui.AbsolutePosition.Y + Gui.AbsoluteSize.Y/2

&#9;X = X - Gui.AbsolutePosition.X
&#9;Y = Y - Gui.AbsolutePosition.Y

&#9;local StartDiameter = 6;

&#9;local ParentFrame                  = Instance.new(&quot;Frame&quot;, Gui)
&#9;ParentFrame.ClipsDescendants       = true;
&#9;ParentFrame.Archivable             = false;
&#9;ParentFrame.BorderSizePixel        = 0;
&#9;ParentFrame.BackgroundTransparency = 1;
&#9;ParentFrame.Name                   = &quot;Circle_Effect&quot;;
&#9;ParentFrame.Size                   = UDim2.new(1, 0, 1, 0);
&#9;ParentFrame.ZIndex                 = Gui.ZIndex + 1
&#9;
&#9;local Circle                       = Instance.new(&quot;ImageLabel&quot;);
&#9;Circle.Image                       = &quot;http://www.roblox.com/asset/?id=172318712&quot;
&#9;Circle.Name                        = &quot;Circle&quot;;
&#9;Circle.ImageTransparency           = 0.75;
&#9;Circle.BackgroundTransparency      = 1;
&#9;Circle.BorderSizePixel             = 0;
&#9;Circle.Archivable                  = false;
&#9;Circle.Size                        = UDim2.new(0, StartDiameter, 0, StartDiameter);
&#9;Circle.ZIndex                      = Gui.ZIndex + 1
&#9;
&#9;Circle.Position                    = UDim2.new(0, X-StartDiameter/2, 0, Y-StartDiameter/2)

&#9;if Gui.AbsoluteSize.X &gt; Gui.AbsoluteSize.Y then
&#9;&#9;Gui.SizeConstraint = &quot;RelativeXX&quot;
&#9;else
&#9;&#9;Gui.SizeConstraint = &quot;RelativeYY&quot;
&#9;end

&#9;local NewDiameter = math.max(Gui.AbsoluteSize.X, Gui.AbsoluteSize.Y)
&#9;local NewSize = UDim2.new(0, NewDiameter * 2.82842712475, 0,  NewDiameter * 2.82842712475)
&#9;local NewPosition = UDim2.new(0, X - (NewDiameter * 1.41421356237), 0, Y - (NewDiameter * 1.41421356237))
&#9;
&#9;Circle.Parent                      = ParentFrame
&#9;ParentFrame.Parent                 = Gui;

&#9;Circle:TweenSizeAndPosition(NewSize, NewPosition, &quot;Out&quot;, &quot;Linear&quot;, Time/2, true)
&#9;TweenTransparency(Circle, {ImageTransparency = 0.5}, Time/3, true)
&#9;delay(Time/3, function()
&#9;&#9;TweenTransparency(Circle, {ImageTransparency = 1}, Time*2/3, true)
&#9;&#9;wait(Time*2/3 + 0.1)
&#9;&#9;ParentFrame:Destroy()
&#9;end)
end
lib.ResponsiveCircleClickEffect = ResponsiveCircleClickEffect


local function GenerateMouseDrag()
&#9;-- Generate&apos;s a dragger to catch the mouse...
&#9;return Make(&quot;ImageButton&quot;, {
&#9;&#9;Active                 = false;
&#9;&#9;Size                   = UDim2.new(1.5, 0, 1.5, 0);
&#9;&#9;AutoButtonColor        = false;
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;Name                   = &quot;MouseDrag&quot;;
&#9;&#9;Position               = UDim2.new(-0.25, 0, -0.25, 0);
&#9;&#9;ZIndex                 = 10;
&#9;})
end
lib.GenerateMouseDrag = GenerateMouseDrag
lib.generateMouseDrag = GenerateMouseDrag

local function AddTexturedWindowTemplate(Frame, Radius, Type)
&#9;-- Makes a &apos;Textured&apos; window...  9Scale thingy?

&#9;Type = Type or &apos;Frame&apos;;

&#9;local TopLeft = Make(Type, {
&#9;&#9;Archivable             = false;
&#9;&#9;BackgroundColor3       = Frame.BackgroundColor3;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Name                   = &quot;TopLeft&quot;;
&#9;&#9;Parent                 = Frame;
&#9;&#9;Position               = UDim2.new(0, 0, 0, 0);
&#9;&#9;Size                   = UDim2.new(0, Radius, 0, Radius);
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;ZIndex                 = Frame.ZIndex;
&#9;});

&#9;local TopRight = Make(Type, {
&#9;&#9;Archivable             = false;
&#9;&#9;BackgroundColor3       = Frame.BackgroundColor3;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Name                   = &quot;TopRight&quot;;
&#9;&#9;Parent                 = Frame;
&#9;&#9;Position               = UDim2.new(0, 0, 1, -Radius);
&#9;&#9;Size                   = UDim2.new(0, Radius, 0, Radius);
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;ZIndex                 = Frame.ZIndex;
&#9;});

&#9;local BottomLeft = Make(Type, {
&#9;&#9;Archivable             = false;
&#9;&#9;BackgroundColor3       = Frame.BackgroundColor3;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Name                   = &quot;BottomLeft&quot;;
&#9;&#9;Parent                 = Frame;
&#9;&#9;Position               = UDim2.new(1, -Radius, 0, 0);
&#9;&#9;Size                   = UDim2.new(0, Radius, 0, Radius);
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;ZIndex                 = Frame.ZIndex;
&#9;});

&#9;local BottomRight = Make(Type, {
&#9;&#9;Archivable             = false;
&#9;&#9;BackgroundColor3       = Frame.BackgroundColor3;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Name                   = &quot;BottomRight&quot;;
&#9;&#9;Parent                 = Frame;
&#9;&#9;Position               = UDim2.new(1, -Radius, 1, -Radius);
&#9;&#9;Size                   = UDim2.new(0, Radius, 0, Radius);
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;ZIndex                 = Frame.ZIndex;
&#9;});

&#9;local Middle = Make(Type, {
&#9;&#9;Archivable             = false;
&#9;&#9;BackgroundColor3       = Frame.BackgroundColor3;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Name                   = &quot;Middle&quot;;
&#9;&#9;Parent                 = Frame;
&#9;&#9;Position               = UDim2.new(0, Radius, 0, 0);
&#9;&#9;Size                   = UDim2.new(1, -Radius*2, 1, 0);
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;ZIndex                 = Frame.ZIndex;
&#9;});

&#9;local MiddleLeft = Make(Type, {
&#9;&#9;Archivable             = false;
&#9;&#9;BackgroundColor3       = Frame.BackgroundColor3;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Name                   = &quot;MiddleLeft&quot;;
&#9;&#9;Parent                 = Frame;
&#9;&#9;Position               = UDim2.new(0, 0, 0, Radius);
&#9;&#9;Size                   = UDim2.new(0, Radius, 1, -Radius*2);
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;ZIndex                 = Frame.ZIndex;
&#9;});

&#9;local MiddleRight = Make(Type, {
&#9;&#9;Archivable             = false;
&#9;&#9;BackgroundColor3       = Frame.BackgroundColor3;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Name                   = &quot;MiddleRight&quot;;
&#9;&#9;Parent                 = Frame;
&#9;&#9;Position               = UDim2.new(1, -Radius, 0, Radius);
&#9;&#9;Size                   = UDim2.new(0, Radius, 1, -Radius*2);
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;ZIndex                 = Frame.ZIndex;
&#9;});

&#9;return TopLeft, TopRight, BottomLeft, BottomRight, Middle, MiddleLeft, MiddleRight
end
lib.AddTexturedWindowTemplate = AddTexturedWindowTemplate
lib.addTexturedWindowTemplate = AddTexturedWindowTemplate

local function AddNinePatch(Frame, Image, ImageSize, Radius, Type)
&#9;--- Makes a NinePatch in the frame, with the image. 
&#9;-- @param Frame The frame to texturize
&#9;-- @param Radius the radius you want the image to be at
&#9;-- @param Type The type (Class) that the frame should be, either an ImageLabel or an ImageButton
&#9;-- @param Image The URL of the image in question
&#9;-- @param ImageSize The size of the image overall, suggested to be 99/divisible by 3. Vector2 value.

&#9;Properties = Properties or {}
&#9;Type = Type or &quot;ImageLabel&quot;;
&#9;local TopLeft, TopRight, BottomLeft, BottomRight, Middle, MiddleLeft, MiddleRight = AddTexturedWindowTemplate(Frame, Radius, Type)

&#9;Middle.Size = UDim2.new(1, -Radius*2, 1, -Radius*2); -- Fix middle...
&#9;Middle.Position = UDim2.new(0, Radius, 0, Radius);

&#9;local MiddleTop = Make(Type)({
&#9;&#9;Archivable             = false;
&#9;&#9;BackgroundColor3       = Frame.BackgroundColor3;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Name                   = &quot;MiddleTop&quot;;
&#9;&#9;Parent                 = Frame;
&#9;&#9;Position               = UDim2.new(0, Radius, 0, 0);
&#9;&#9;Size                   = UDim2.new(1, -Radius*2, 0, Radius);
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;ZIndex                 = Frame.ZIndex;
&#9;});

&#9;local MiddleBottom = Make(Type)({
&#9;&#9;Archivable             = false;
&#9;&#9;BackgroundColor3       = Frame.BackgroundColor3;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Name                   = &quot;MiddleBottom&quot;;
&#9;&#9;Parent                 = Frame;
&#9;&#9;Position               = UDim2.new(0, Radius, 1, -Radius);
&#9;&#9;Size                   = UDim2.new(1, -Radius*2, 0, Radius);
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;ZIndex                 = Frame.ZIndex;
&#9;});

&#9;for _, Item in pairs({TopLeft, TopRight, BottomLeft, BottomRight, Middle, MiddleLeft, MiddleRight, MiddleTop, MiddleBottom}) do
&#9;&#9;Modify(Item, Properties)
&#9;&#9;Item.Image = Image;
&#9;&#9;Item.ImageRectSize = Vector2.new(ImageSize.X/3, ImageSize.Y/3)
&#9;end

&#9;TopRight.ImageRectOffset     = Vector2.new(ImageSize.X * (2/3), 0)
&#9;MiddleRight.ImageRectOffset  = Vector2.new(ImageSize.X * (2/3), ImageSize.Y/3)
&#9;BottomRight.ImageRectOffset  = Vector2.new(ImageSize.X * (2/3), ImageSize.Y * (2/3))
&#9;
&#9;--TopLeft.ImageRectOffset    = Vector2.new(0, 0);
&#9;MiddleLeft.ImageRectOffset   = Vector2.new(0, ImageSize.Y/3)
&#9;BottomLeft.ImageRectOffset   = Vector2.new(0, ImageSize.Y * (2/3))
&#9;
&#9;Middle.ImageRectOffset       = Vector2.new(ImageSize.X/3, ImageSize.Y/3)
&#9;MiddleTop.ImageRectOffset    = Vector2.new(0, ImageSize.Y/3)
&#9;MiddleBottom.ImageRectOffset = Vector2.new(ImageSize.Y * (2/3), ImageSize.Y/3)

&#9;return TopLeft, TopRight, BottomLeft, BottomRight, Middle, MiddleLeft, MiddleRight, MiddleTop, MiddleBottom
end
lib.AddNinePatch = AddNinePatch
lib.addNinePatch = AddNinePatch

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX25">
					<Properties>
						<string name="Name">LensGlare</string>
						<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local Lighting          = game:GetService(&quot;Lighting&quot;)
local Players          = game:GetService(&quot;Players&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local qGUI              = LoadCustomLibrary(&quot;qGUI&quot;)
local qCFrame           = LoadCustomLibrary(&quot;qCFrame&quot;)
local qMath             = LoadCustomLibrary(&quot;qMath&quot;)

qSystems:Import(getfenv(0));

local lib = {}

--- This library not only handles glare, but also handles lens flares. Huzzah!
-- LensGlare.lua
-- @author Quenty
-- Last Modified February 3rd, 2014

local function IsNight()
&#9;-- Is it nighttime? Now we know!

&#9;local MinutesAfterMidnight = Lighting:GetMinutesAfterMidnight()
&#9;return MinutesAfterMidnight &lt;= 345 or MinutesAfterMidnight &gt;= 1110
end

local function GetSunPositionOnScreenRelativeToCamera(Camera, Magnitude)
&#9;-- Only used for lens flare effect, I suppose...  Does what it&apos;s name says... 
&#9;-- @param Camera The camera to send
&#9;-- @param Magnitude How far away from the camera the part will be rendered.

&#9;-- Magnitude = Magnitude or 10
&#9;local CoordinateFrame = Camera.CoordinateFrame
&#9;return CFrame.new(CoordinateFrame.p, CoordinateFrame.p + Lighting:GetSunDirection()) * CFrame.new(0, 0, -(Magnitude - 1))
end
lib.GetSunPositionOnScreenRelativeToCamera = GetSunPositionOnScreenRelativeToCamera
lib.getSunPositionOnScreenRelativeToCamera = GetSunPositionOnScreenRelativeToCamera


local MakeLensGlare = Class(function(LensGlare, ScreenGui) 
&#9;-- Makes a lensflare. Update() should be called every frame or so. 
&#9;-- I am deeply embarassed by this code.

&#9;local Gui = Make(&quot;Frame&quot;, {
&#9;&#9;Archivable             = false;
&#9;&#9;BackgroundColor3       = Color3.new(1, 1, 1);
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Name                   = &quot;LensGlare&quot;;
&#9;&#9;Parent                 = ScreenGui;
&#9;&#9;Position               = UDim2.new(0, 0, 0, -2);
&#9;&#9;Size                   = UDim2.new(1, 0, 1, 2);
&#9;&#9;Visible                = true;
&#9;&#9;ZIndex                 = 1;
&#9;})

&#9;LensGlare.Gui = Gui

&#9;local function Step(Mouse)

&#9;&#9;local CameraAngle = (Workspace.CurrentCamera.CoordinateFrame.p - Workspace.CurrentCamera.Focus.p).unit
&#9;&#9;local SunAngleUnit = Lighting:GetSunDirection()

&#9;&#9;

&#9;&#9;--print(&quot;[LensGlare] - Transparency = &quot; .. Transparency..&quot; magnitude: &quot;..(SunAngleUnit - CameraAngle).magnitude)
&#9;&#9;if not IsNight() then
&#9;&#9;&#9;local Transparency = 1.45 - (SunAngleUnit - CameraAngle).magnitude / 3

&#9;&#9;&#9;local SunPositionGlobal = GetSunPositionOnScreenRelativeToCamera(Workspace.CurrentCamera, 10).p
&#9;&#9;&#9;local SunIsOnScreen, SunPositionOnScreen, Angle = qGUI.WorldToScreen(SunPositionGlobal, Mouse, Workspace.CurrentCamera)
&#9;&#9;&#9;if SunIsOnScreen then
&#9;&#9;&#9;&#9;Gui.BackgroundTransparency = Transparency
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Gui.BackgroundTransparency = 1
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;Gui.BackgroundTransparency = 1
&#9;&#9;end
&#9;end

&#9;LensGlare.Step = Step
end)
lib.MakeLensGlare = MakeLensGlare
lib.makeLensGlare = MakeLensGlare

local PickRandomColor3 = qGUI.PickRandomColor3

local MakeLensFlare = Class(function(LensFlare, ScreenGui)
&#9;-- Generates lens flare GUI&apos;s, and repositions them every time Step() is called.
&#9;-- This code is sad.

&#9;local Configuration = {
&#9;&#9;SunFlareSizeMax    = 80;
&#9;&#9;SunFlareEndSizeMax = 60;
&#9;&#9;SmallPieces        = 5; -- How many pieces inbetween
&#9;&#9;SmallPieceSizeMin  = 40;
&#9;&#9;SmallPieceSizeMax  = 60;
&#9;&#9;MaxTransparency    = 0.7;
&#9;}

&#9;local ColorList = {
&#9;&#9;qGUI.NewColor3(170, 170, 255);
&#9;&#9;qGUI.NewColor3(170, 255, 127);
&#9;&#9;qGUI.NewColor3(255, 170, 127);
&#9;&#9;qGUI.NewColor3(255, 170, 255);
&#9;&#9;qGUI.NewColor3(255, 255, 127);
&#9;&#9;qGUI.NewColor3(255, 255, 255);
&#9;&#9;qGUI.NewColor3(255, 170, 000);
&#9;}

&#9;local Guis = {}
&#9;Guis.Container = Make(&quot;Frame&quot;, {
&#9;&#9;Archivable             = false;
&#9;&#9;BackgroundColor3       = Color3.new(1, 1, 1);
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;Name                   = &quot;qLensFlare&quot;;
&#9;&#9;Parent                 = ScreenGui;
&#9;&#9;Size                   = UDim2.new(1, 0, 1, 0);
&#9;&#9;Visible                = true;
&#9;})
&#9;local SmallGuys          = {} -- All those small little guys between the 2 large glares. 
&#9;local SmallPieceCount    = Configuration.SmallPieces
&#9;local MaxTransparency    =  Configuration.MaxTransparency
&#9;local Cartisian2ToVector = qMath.Cartisian2ToVector

&#9;local function MakeSmallGuy(Gui, Size, PositionFactor)
&#9;&#9;return {
&#9;&#9;&#9;Gui            = Gui;
&#9;&#9;&#9;Size           = Size;
&#9;&#9;&#9;PositionFactor = PositionFactor;
&#9;&#9;&#9;HalfSize       = qGUI.GetHalfSize(Gui);
&#9;&#9;}
&#9;end

&#9;for Index = 1, Configuration.SmallPieces do
&#9;&#9;local Size = math.random(Configuration.SmallPieceSizeMin, Configuration.SmallPieceSizeMax)
&#9;&#9;local Gui = Make(&quot;Frame&quot;, {
&#9;&#9;&#9;BackgroundColor3       = PickRandomColor3(ColorList);
&#9;&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;&#9;Name                   = &quot;SmallGuyInbetweenFlare&quot;..Index;
&#9;&#9;&#9;Parent                 = Guis.Container;
&#9;&#9;&#9;Size                   = UDim2.new(0, Size, 0, Size);
&#9;&#9;&#9;Visible                = true;
&#9;&#9;})

&#9;&#9;SmallGuys[Index] = MakeSmallGuy(Gui, Size, 1 - (((Index/(SmallPieceCount + 2) + (1/SmallPieceCount))) * 2))
&#9;end

&#9;do -- Add initial frames in.
&#9;&#9;local SunFlare = Make(&quot;Frame&quot;, { -- Flare on the sun. 
&#9;&#9;&#9;BackgroundColor3       = PickRandomColor3(ColorList);
&#9;&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;&#9;Name                   = &quot;LargeLensFlare&quot;;
&#9;&#9;&#9;Parent                 = Guis.Container;
&#9;&#9;&#9;Size                   = UDim2.new(0, Configuration.SunFlareSizeMax, 0, Configuration.SunFlareSizeMax);
&#9;&#9;&#9;Visible                = true;
&#9;&#9;&#9;ZIndex = 2;
&#9;&#9;})
&#9;&#9;SmallGuys[#SmallGuys+1] = MakeSmallGuy(SunFlare, Configuration.SunFlareSizeMax, 1)
&#9;&#9;local SunFlareEnd = Make(&quot;Frame&quot;, { -- Flare on the sun. 
&#9;&#9;&#9;BackgroundColor3       = PickRandomColor3(ColorList);
&#9;&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;&#9;Name                   = &quot;LargeLensFlareEnd&quot;;
&#9;&#9;&#9;Parent                 = Guis.Container;
&#9;&#9;&#9;Size                   = UDim2.new(0, Configuration.SunFlareEndSizeMax, 0, Configuration.SunFlareEndSizeMax);
&#9;&#9;&#9;Visible                = true;
&#9;&#9;})
&#9;&#9;SmallGuys[#SmallGuys+1] = MakeSmallGuy(SunFlareEnd, Configuration.SunFlareEndSizeMax, -1)
&#9;end


&#9;LensFlare.Guis = Guis
&#9;
&#9;local function PositionSunFlareFromCartisian2(SunFlareFrame, SunPositionVector2, SizeFactor, DefaultSize, HalfSize)
&#9;&#9;--local SunPositionVector2 = qMath.Cartisian2ToVector(SunPositionCartisian2, ScreenMiddle)
&#9;&#9;
&#9;&#9;local Size = DefaultSize * SizeFactor -- 1 = full size (Direct look at sun), 0 = not shown 
&#9;&#9;SunFlareFrame.Transparency = 1 - ((SizeFactor) * (1 - MaxTransparency)) 
&#9;&#9;SunFlareFrame.Size         = UDim2.new(0, Size, 0, Size)
&#9;&#9;SunFlareFrame.Position     = qGUI.UDim2OffsetFromVector2(SunPositionVector2) - HalfSize;
&#9;end

&#9;local function Render(SunPositionVector2, Mouse)
&#9;&#9;-- Incrediably confusing/annoying vector math. :D
&#9;&#9;-- Render&apos;s / Positions the GUI&apos;s... Called each step. SunPositionVector2 is the position of the sun on the screen, offset. 

&#9;&#9;
&#9;&#9;local ScreenMiddle             = Vector2.new(Mouse.ViewSizeX, Mouse.ViewSizeY) / 2
&#9;&#9;local SizeFactor               = 1 - math.min(1, (ScreenMiddle - SunPositionVector2).magnitude / (Mouse.ViewSizeX/2)) -- So at the outside edge, it&apos;s 0, and at the center, it&apos;s 1
&#9;&#9;
&#9;&#9;--print(&quot;[LensGlare] - SizeFactor: &quot; .. SizeFactor)

&#9;&#9;local SunPositionCartisian2    = qMath.Vector2ToCartisian(SunPositionVector2, ScreenMiddle) -- Convert to cartisians so we can work with the middle of the screen, due to the nature of lens flares. 
&#9;&#9;local EndSunPositionCartisian2 = qMath.InvertCartisian2(SunPositionCartisian2) -- Invert it...

&#9;&#9;-- PositionSunFlareFromCartisian2(Guis.SunFlare, SunPositionVector2, SizeFactor, Configuration.SunFlareSizeMax, qGUI.GetHalfSize(SunFlareFrame))
&#9;&#9;-- PositionSunFlareFromCartisian2(Guis.SunFlareEnd, Cartisian2ToVector(EndSunPositionCartisian2, ScreenMiddle), SizeFactor, Configuration.SunFlareEndSizeMax, qGUI.GetHalfSize(SunFlareFrame))


&#9;&#9;--for Index = 1, SmallPieceCount do
&#9;&#9;for _, SmallGuy in pairs(SmallGuys) do
&#9;&#9;&#9;-- local SmallGuy           = SmallGuys[Index]
&#9;&#9;&#9;-- local PositionFactor     = 1 - (((Index/(SmallPieceCount+2) + (1/SmallPieceCount))) * 2) -- 1 - (1/12 - 11/12, 1 spacing on both sides) * 2
&#9;&#9;&#9;local SmallGuyCartisian2 = SunPositionCartisian2 * SmallGuy.PositionFactor
&#9;&#9;&#9;local Position           = Cartisian2ToVector(SmallGuyCartisian2, ScreenMiddle)
&#9;&#9;&#9;PositionSunFlareFromCartisian2(SmallGuy.Gui, Position, SizeFactor, SmallGuy.Size, SmallGuy.HalfSize)
&#9;&#9;end

&#9;&#9;--Guis.SunFlare.Position = qGUI.UDim2OffsetFromVector2(SunPositionVector2) - qGUI.GetHalfSize(Guis.SunFlare);
&#9;&#9;--Guis.SunFlareEndqGUI.UDim2OffsetFromVector2(EndSunPositionCartisian2) 
&#9;end

&#9;local function StopRendering()
&#9;&#9;-- Guis.SunFlare.BackgroundTransparency    = 1
&#9;&#9;-- Guis.SunFlareEnd.BackgroundTransparency = 1
&#9;&#9;for _, SmallGuy in pairs(SmallGuys) do
&#9;&#9;&#9;SmallGuy.Gui.BackgroundTransparency = 1
&#9;&#9;end
&#9;end

&#9;local IsRendering = false
&#9;local WorldToScreen = qGUI.WorldToScreen

&#9;local function Step(Mouse)
&#9;&#9;-- assert(Mouse, &quot;[LensFlare] - Mouse is nil&quot;)

&#9;&#9;local CurrentCamera = Workspace.CurrentCamera
&#9;&#9;local CoordinateFrame = CurrentCamera.CoordinateFrame

&#9;&#9;local SunPositionGlobal = GetSunPositionOnScreenRelativeToCamera(CurrentCamera, 900).p
&#9;&#9;local SunIsOnScreen, SunPositionOnScreen, Angle = WorldToScreen(SunPositionGlobal, Mouse, CurrentCamera)

&#9;&#9;if SunIsOnScreen then
&#9;&#9;&#9;local Ray = Ray.new( -- We need to ray cast to see if the sun is being blocked at all...
&#9;&#9;&#9;&#9;CoordinateFrame.p,
&#9;&#9;&#9;&#9;SunPositionGlobal - CoordinateFrame.p
&#9;&#9;&#9;&#9;-- (CoordinateFrame.p - CurrentCamera.Focus.p).Unit * -999
&#9;&#9;&#9;)

&#9;&#9;&#9;-- local Part, EndPoint = Workspace:FindPartOnRayWithIgnoreList(Ray, {Players.LocalPlayer.Character})
&#9;&#9;&#9;local Part, EndPoint = Workspace:FindPartOnRay(Ray, Players.LocalPlayer.Character)
&#9;&#9;&#9;if not Part then
&#9;&#9;&#9;&#9;IsRendering = true
&#9;&#9;&#9;&#9;Render(SunPositionOnScreen, Mouse, SunIsOnScreen)
&#9;&#9;&#9;elseif IsRendering then
&#9;&#9;&#9;&#9;-- Track whether or not we are rendering.

&#9;&#9;&#9;&#9;IsRendering = false
&#9;&#9;&#9;&#9;StopRendering()
&#9;&#9;&#9;&#9;-- Render(nil, Mouse, false) -- Stop rendering.
&#9;&#9;&#9;end
&#9;&#9;elseif IsRendering then
&#9;&#9;&#9;IsRendering = false
&#9;&#9;&#9;StopRendering()
&#9;&#9;end
&#9;end
&#9;LensFlare.Step = Step
end)
lib.MakeLensFlare = MakeLensFlare
lib.makeLensFlare = MakeLensFlare

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX26">
					<Properties>
						<string name="Name">Compass</string>
						<ProtectedString name="Source">local ReplicatedStorage       = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine         = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary       = NevermoreEngine.LoadLibrary

local qSystems                = LoadCustomLibrary(&quot;qSystems&quot;)
local qGUI                    = LoadCustomLibrary(&quot;qGUI&quot;)
local OverriddenConfiguration = LoadCustomLibrary(&quot;OverriddenConfiguration&quot;)

qSystems:Import(getfenv(0));

local lib = {}

-- Compass.lua
-- @author Quenty

local Tau = math.pi * 2

local function GetRotationDirection(LastRotation, CurrentRotation)
&#9;--- Identifies the direction to rotate given the last rotation and the current rotation.
&#9;-- @param LastRotation The last rotation (in radians).
&#9;-- @param CurrentRotation The current rotation
&#9;-- @return RotationDirection If positive, then you should add, otherwise, subtract (Will return 1 or -1)
&#9;-- @return ChangeInRotation The amount changed (Basically, the difference between the two points). This is returned so you can
&#9;--                        scale the compass. (In radians)


&#9;local RotationDirection
&#9;local Difference = math.abs(CurrentRotation - LastRotation) % Tau; 
&#9;local ChangeInRotation = math.min(Tau - Difference, Difference) 

&#9;if ((CurrentRotation - LastRotation + Tau) % Tau &lt; math.pi) then
&#9;&#9;RotationDirection = 1
&#9;else
&#9;&#9;RotationDirection = -1
&#9;end

&#9;return RotationDirection, ChangeInRotation
end
lib.GetRotationDirection = GetRotationDirection

local function GetCameraRotation(CoordinateFrame, Focus)
&#9;-- Get&apos;s a camera&apos;s XZ plane rotation (Rotation along the Y axis) in radians
&#9;-- @param CoordinateFrame The CoordinateFrame of the camera
&#9;-- @param Focus The focus of the camera

&#9;-- 0 degrees is north (I think?)

&#9;-- assert(Focus, &quot;No focus?&quot;)

&#9;return math.atan2(CoordinateFrame.X - Focus.X, CoordinateFrame.Z - Focus.Z) + math.pi
end

local MakeCompassModel = Class(function(CompassModel)
&#9;--- This is an inertia model compass thing. 

&#9;local SmoothnessFactor = 4 -- The &quot;smoothing&quot; factor of compass model. Increase for a faster speed.
&#9;local RealAngle        = 0 -- The real angle of the camera.
&#9;local Angle            = 0 -- Smoothed angle

&#9;local LastUpdatePoint = tick()

&#9;local function Step(Camera)
&#9;&#9;--- Updates the compass, with &quot;step.&quot; Should be called to refresh the model, and will update the spin accordingly.
&#9;&#9;-- With a &quot;low&quot; step-time (that is, more than 1 second or something) compass may spin super fast, jumping around. Adjust smoothness factor or something to compensate.
&#9;&#9;-- @param Camera The current camera.

&#9;&#9;local CurrentTime = tick()
&#9;&#9;local Delta = CurrentTime - LastUpdatePoint
&#9;&#9;local Rotation = GetCameraRotation(Camera.CoordinateFrame, Camera.Focus)
&#9;&#9;RealAngle = Rotation

&#9;&#9;local Direction, ChangeInRotation = GetRotationDirection(Angle, Rotation)
&#9;&#9;Angle = math.abs((Angle + Direction * ChangeInRotation * Delta * SmoothnessFactor) % Tau)


&#9;&#9;LastUpdatePoint = CurrentTime

&#9;&#9;return Angle, RealAngle
&#9;end
&#9;CompassModel.Step = Step
&#9;CompassModel.step = Step

&#9;local function GetAngle()
&#9;&#9;--- Returns the smoothed angle 

&#9;&#9;return Angle
&#9;end
&#9;CompassModel.GetAngle = GetAngle
&#9;CompassModel.getAngle = GetAngle

&#9;local function GetRealAngle()
&#9;&#9;--- Return&apos;s the actual angle of the camera

&#9;&#9;return RealAngle
&#9;end
&#9;CompassModel.GetRealAngle = GetRealAngle
&#9;CompassModel.getRealAngle = GetRealAngle

&#9;local function SetSmoothnessFactor(NewSmoothnessFactor)
&#9;&#9;--- Set&apos;s the smoothness factor of the inertia compass.
&#9;&#9;-- @param NewSmoothnessFactor The smoothness factor. (Number)

&#9;&#9;assert(type(NewSmoothnessFactor) == &quot;number&quot;)

&#9;&#9;SmoothnessFactor = NewSmoothnessFactor
&#9;end
&#9;CompassModel.SetSmoothnessFactor = SetSmoothnessFactor
&#9;CompassModel.setSmoothnessFactor = SetSmoothnessFactor

&#9;local function GetRelativeAngle(Camera, TargetPosition)
&#9;&#9;--- Get&apos;s the relative angle from the camera to a &quot;target&quot; position in the world coordinates.
&#9;&#9;-- @param Camera The camera to get the relative angle on.
&#9;&#9;-- @param TargetPosition The world target position.
&#9;&#9;-- @pre Step has been called.

&#9;&#9;-- assert(TargetPosition, &quot;No TargetPosition&quot;)

&#9;&#9;local RelativeAngle = GetCameraRotation(Camera.CoordinateFrame, TargetPosition) 
&#9;&#9;-- print(&quot;RelativeAngle: &quot; .. Round(RelativeAngle, 0.01) .. &quot;; Angle: &quot; .. Round(Angle, 0.01) .. &quot;; Angle - RelativeAngle = &quot; .. Round(Angle - RelativeAngle, 0.01))

&#9;&#9;return RelativeAngle
&#9;end
&#9;CompassModel.GetRelativeAngle = GetRelativeAngle
&#9;CompassModel.getRelativeAngle = GetRelativeAngle
end)
lib.MakeCompassModel = MakeCompassModel
lib.makeCompassModel = MakeCompassModel


local function GetPercentPosition(CurrentAngle, Angle, ThetaVisible)
&#9;--- Get&apos;s a percent position for a GUI. Tries to handle the wrap-around based upon CurrentAngle and Angle.
&#9;-- @param CurrentAngle The current angle of the compass.
&#9;-- @param Angle The angle that the percent is needed.
&#9;-- @param ThetaVisible The area shown by the compass (the rest will be hidden). (In radians)
&#9;-- @return Percent in [0, 1]. May be greater than range (for scaling purposes). 

&#9;local SmallBounds = Angle - ThetaVisible/2
&#9;local RelativeAngle = CurrentAngle - SmallBounds
&#9;local PercentPosition = RelativeAngle / ThetaVisible

&#9;local MaximumPercent = Tau / ThetaVisible
&#9;local SwitchPoint = MaximumPercent/2 -- The point left, or right, where it will &quot;switch&quot; over to be on the other side (Aka wrap around).

&#9;if PercentPosition &lt; -SwitchPoint + ThetaVisible/2 then -- Factor in the &quot;shown&quot; area to when it&apos;ll switch over.
&#9;&#9;return PercentPosition + MaximumPercent
&#9;elseif PercentPosition &gt; SwitchPoint then
&#9;&#9;return PercentPosition - MaximumPercent
&#9;else
&#9;&#9;return PercentPosition
&#9;end
end
lib.GetPercentPosition = GetPercentPosition

local function GetGuiTransparency(PercentPosition, SolidArea)
&#9;--- Return&apos;s a GUI&apos;s transparency based on it&apos;s percent position.

&#9;local Distance = math.abs(0.5 - PercentPosition)
&#9;local Range = SolidArea/2
&#9;local ExternalRange = (1 - SolidArea)/2
&#9;local Transparency = (Distance-Range) / ExternalRange

&#9;if Transparency &gt;= 1 then
&#9;&#9;return 1
&#9;elseif Transparency &lt;= 0 then
&#9;&#9;return 0
&#9;else
&#9;&#9;return Transparency
&#9;end
end
lib.GetGuiTransparency = GetGuiTransparency


local MakeStripCompass = Class(function(StripCompass, Configuration)
&#9;--- Makes a skyrim style &quot;strip&quot; compass.
&#9;-- @param Configuration The configuration to use (overrides).

&#9;local Configuration = OverriddenConfiguration.new(Configuration, {
&#9;&#9;ThetaVisible     = math.pi/2; -- The area shown by the compass (the rest will be hidden). (In radians)
&#9;&#9;SolidArea     = 0.8; -- Area in the center where GUIs are not transparent. (Percentage). (Will fade out to ends).
&#9;&#9;ZIndex        = 1;
&#9;&#9;DefaultWidth  = 300; -- The user can modify Container however they want, so these don&apos;t matter too much
&#9;&#9;DefaultHeight = 40; -- The user can modify Container however they want, so these don&apos;t matter too much

&#9;&#9;DefaultYOffset = 60;

&#9;&#9;DefaultBackgroundTransparency = 0.8; -- Default BackgroundTransparency of the frame.
&#9;&#9;MouseOverBackgroundTransparency = 0.3; -- Mouse over transparency.
&#9;&#9;AnimationTime = 0.2; -- On mouse over. 
&#9;})

&#9;local Container = Make(&quot;Frame&quot;, {
&#9;&#9;Archivable             = false;
&#9;&#9;BackgroundColor3       = Color3.new(0, 0, 0);
&#9;&#9;BackgroundTransparency = Configuration.DefaultBackgroundTransparency;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;ClipsDescendants       = false;
&#9;&#9;Name                   = &quot;StripCompassFrame&quot;;
&#9;&#9;Position               = UDim2.new(0.5, -Configuration.DefaultWidth/2, 0, Configuration.DefaultYOffset);
&#9;&#9;Size                   = UDim2.new(0, Configuration.DefaultWidth, 0, Configuration.DefaultHeight);
&#9;&#9;Visible                = true;
&#9;&#9;ZIndex                 = Configuration.ZIndex;
&#9;})
&#9;StripCompass.Gui = Container

&#9;local CompassModel = MakeCompassModel()
&#9;StripCompass.CompassModel = CompassModel

&#9;local CurrentInterestPoints = {} -- Stores interest points in the world.
&#9;local CurrentCoordinateDirections = {} -- Stores stuff like NSEW

&#9;-- local function GetPercentPosition(CurrentAngle, Angle)
&#9;-- &#9;--- Get&apos;s a percent position for a GUI. Tries to handle the wrap-around based upon CurrentAngle and Angle.
&#9;-- &#9;-- @param CurrentAngle The current angle of the compass.
&#9;-- &#9;-- @param Angle The angle that the percent is needed.
&#9;-- &#9;-- @return Percent in [0, 1]. May be greater than range (for scaling purposes). 

&#9;-- &#9;local SmallBounds = Angle - Configuration.ThetaVisible/2
&#9;-- &#9;local RelativeAngle = CurrentAngle - SmallBounds
&#9;-- &#9;local PercentPosition = RelativeAngle / Configuration.ThetaVisible

&#9;-- &#9;-- We want to distribute the compass&apos;s &quot;pointers&quot; equally on both sides. So if the Angle is 

&#9;-- &#9;-- Mental notes.
&#9;-- &#9;-- Angle @ 180
&#9;-- &#9;-- [0, 180] [180, 360]
&#9;-- &#9;-- 

&#9;-- &#9;-- Angle @ 270
&#9;-- &#9;-- [90, 270] [270, 90]

&#9;-- &#9;-- if Angle &lt; CurrentAngle - 180 or Angle &gt; CurrentAngle + 180 then we are on the opposite side. However, 
&#9;-- &#9;-- if Angle is [90, 270]

&#9;-- &#9;-- if Angle &gt; CurrentAngle + math.pi then

&#9;-- &#9;local MaximumPercent = Tau / Configuration.ThetaVisible
&#9;-- &#9;local SwitchPoint = MaximumPercent/2 -- The point left, or right, where it will &quot;switch&quot; over to be on the other side (Aka wrap around).

&#9;-- &#9;if PercentPosition &lt; -SwitchPoint + Configuration.ThetaVisible/2 then -- Factor in the &quot;shown&quot; area to when it&apos;ll switch over.
&#9;-- &#9;&#9;return PercentPosition + MaximumPercent
&#9;-- &#9;elseif PercentPosition &gt; SwitchPoint then
&#9;-- &#9;&#9;return PercentPosition - MaximumPercent
&#9;-- &#9;else
&#9;-- &#9;&#9;return PercentPosition
&#9;-- &#9;end
&#9;-- end

&#9;-- local function GetGuiTransparency(PercentPosition)
&#9;-- &#9;--- Return&apos;s a GUI&apos;s transparency based on it&apos;s percent position.

&#9;-- &#9;local Distance = math.abs(0.5 - PercentPosition)
&#9;-- &#9;local Range = Configuration.SolidArea/2
&#9;-- &#9;local ExternalRange = (1 - Configuration.SolidArea)/2
&#9;-- &#9;local Transparency = (Distance-Range) / ExternalRange

&#9;-- &#9;if Transparency &gt;= 1 then
&#9;-- &#9;&#9;return 1
&#9;-- &#9;elseif Transparency &lt;= 0 then
&#9;-- &#9;&#9;return 0
&#9;-- &#9;else
&#9;-- &#9;&#9;return Transparency
&#9;-- &#9;end
&#9;-- end

&#9;local function Step(Camera)
&#9;&#9;--- Updates the compass model.
&#9;&#9;-- @param Camera The current camera.

&#9;&#9;local CurrentAngle, RealAngle = CompassModel.Step(Camera)
&#9;&#9;-- print(&quot;[Compass] - CurrentAngle = &quot; .. Round(CurrentAngle, 0.01) .. &quot;; Real Angle = &quot; .. Round(RealAngle, 0.01))

&#9;&#9;for _, CoordinateDirection in pairs(CurrentCoordinateDirections) do
&#9;&#9;&#9;local PercentPosition = GetPercentPosition(CurrentAngle, CoordinateDirection.Angle, Configuration.ThetaVisible)

&#9;&#9;&#9;local Gui = CoordinateDirection.Gui
&#9;&#9;&#9;Gui.Position = UDim2.new(PercentPosition, -Gui.AbsoluteSize.X/2, 0.5, -Gui.AbsoluteSize.Y/2)

&#9;&#9;&#9;local Transparency = GetGuiTransparency(PercentPosition, Configuration.SolidArea)
&#9;&#9;&#9;CoordinateDirection.SetTransparency(Gui, Transparency)
&#9;&#9;end

&#9;&#9;for _, InterestPoint in pairs(CurrentInterestPoints) do
&#9;&#9;&#9;local RelativeAngle = CompassModel.GetRelativeAngle(Camera, InterestPoint.Point)
&#9;&#9;&#9;local PercentPosition = GetPercentPosition(CurrentAngle, RelativeAngle, Configuration.ThetaVisible)

&#9;&#9;&#9;local Gui = InterestPoint.Gui
&#9;&#9;&#9;Gui.Position = UDim2.new(PercentPosition, -Gui.AbsoluteSize.X/2, 0.5, -Gui.AbsoluteSize.Y/2)

&#9;&#9;&#9;local Transparency = GetGuiTransparency(PercentPosition, Configuration.SolidArea)
&#9;&#9;&#9;InterestPoint.SetTransparency(Gui, Transparency)
&#9;&#9;end
&#9;end
&#9;StripCompass.Step = Step
&#9;StripCompass.step = Step

&#9;local function AddCoordinateDirection(Angle, Gui, SetTransparency)
&#9;&#9;--- Adds a new coordainte direction to the compass. 
&#9;&#9;-- @param Angle Angle on the compass, relative to &quot;N&quot; (0 radians).
&#9;&#9;-- @param Gui The Gui to display.
&#9;&#9;-- @param SetTransparency Sets the transparency of the GUI. If not given, it will not set the transparency (and your GUI will look ugly.)


&#9;&#9;local CoordinateDirection           = {}
&#9;&#9;CoordinateDirection.Angle           = Angle
&#9;&#9;CoordinateDirection.Gui             = Gui
&#9;&#9;CoordinateDirection.SetTransparency = SetTransparency

&#9;&#9;Gui.Parent = Container

&#9;&#9;CurrentCoordinateDirections[Gui] = CoordinateDirection
&#9;end
&#9;StripCompass.AddCoordinateDirection = AddCoordinateDirection
&#9;StripCompass.addCoordinateDirection = AddCoordinateDirection

&#9;local function RemoveCoordinateDirection(Gui)
&#9;&#9;--- Remove&apos;s a coordiante direction.
&#9;&#9;-- @param Gui The Gui to remove (linked to the CoordinateDirection)

&#9;&#9;if CurrentCoordinateDirections[Gui] then
&#9;&#9;&#9;Gui.Parent = nil
&#9;&#9;&#9;CurrentCoordinateDirections[Gui] = nil
&#9;&#9;else
&#9;&#9;&#9;error(&quot;[StripCompass] - Could not find CoordinateDirection with given GUI&quot;)
&#9;&#9;end
&#9;end
&#9;StripCompass.RemoveCoordinateDirection = RemoveCoordinateDirection
&#9;StripCompass.removeCoordinateDirection = RemoveCoordinateDirection

&#9;local function AddInterestPoint(Point, Gui, SetTransparency)
&#9;&#9;--- Adds a new interest point.
&#9;&#9;-- @param Point A vector3 point (as the interest)
&#9;&#9;-- @param Gui A GUI object to use as rendering.
&#9;&#9;-- @param SetTransparency Sets the transparency of the GUI. If not given, it will not set the transparency (and your GUI will look ugly.)

&#9;&#9;local NewInterestPoint           = {}
&#9;&#9;NewInterestPoint.Point           = Point
&#9;&#9;NewInterestPoint.Gui             = Gui
&#9;&#9;NewInterestPoint.SetTransparency = SetTransparency

&#9;&#9;Gui.Parent = Container

&#9;&#9;CurrentInterestPoints[Gui] = NewInterestPoint
&#9;end
&#9;StripCompass.AddInterestPoint = AddInterestPoint
&#9;StripCompass.addInterestPoint = AddInterestPoint

&#9;local function RemoveInterestPoint(Gui)
&#9;&#9;if CurrentInterestPoints[Gui] then
&#9;&#9;&#9;Gui.Parent = nil
&#9;&#9;&#9;CurrentInterestPoints[Gui] = nil
&#9;&#9;else
&#9;&#9;&#9;error(&quot;[StripCompass] - Could not identify InterestPoint with the given GUI&quot;)
&#9;&#9;end
&#9;end
&#9;StripCompass.RemoveInterestPoint = RemoveInterestPoint
&#9;StripCompass.removeInterestPoint = RemoveInterestPoint

&#9;Container.MouseEnter:connect(function()
&#9;&#9;qGUI.TweenTransparency(Container, {BackgroundTransparency = Configuration.MouseOverBackgroundTransparency}, Configuration.AnimationTime, true)
&#9;end)

&#9;Container.MouseLeave:connect(function()
&#9;&#9;qGUI.TweenTransparency(Container, {BackgroundTransparency = Configuration.DefaultBackgroundTransparency}, Configuration.AnimationTime, true)
&#9;end)
end)
lib.MakeStripCompass = MakeStripCompass
lib.makeStripCompass = MakeStripCompass

local MakeCircleCompass = Class(function(CircleCompass, Frame, Configuration)
&#9;--- Makes a CircleCompass based around the ShipInterface circle system, where an arc is drawn from (through) the bottom left and right corners, that is
&#9;-- tangent to the top of the frame.

&#9;local Width            = Frame.Size.X.Offset
&#9;local Height           = Frame.Size.Y.Offset -- CANNOT BE &gt; WIDTH / 2. PANIC. PANIC. MAYBE. TREY IS CRAY CRAY
&#9;local Radius           = (Height/2) + ((Width*Width)/(8 * Height)) 
&#9;&#9;-- + Height/2 - 5 -- Adding Height/2 -5 so it is 5 below the top of the
&#9;local ArcLength        = (2 * Height + Width*Width / (2 * Height)) * math.atan(2 * Height / Width )
&#9;local ThetaVisible     = ArcLength/Radius -- Theta visible in the box.&#9;(Number, will be [-HalfThetaVisible, HalfThetaVisible])
&#9;local HalfThetaVisible = ThetaVisible/2

&#9;local Configuration = OverriddenConfiguration.new(Configuration, {
&#9;&#9;SolidArea     = 0.8; -- Area in the center where GUIs are not transparent. (Percentage). (Will fade out to ends).
&#9;})

&#9;local CompassModel = MakeCompassModel()
&#9;CircleCompass.CompassModel = CompassModel

&#9;local CurrentInterestPoints = {} -- Stores interest points in the world.
&#9;local CurrentCoordinateDirections = {} -- Stores stuff like NSEW

&#9;local function GetPositionAndRotation(Gui, PercentPosition)
&#9;&#9;local RadianTheta  = HalfThetaVisible * (PercentPosition - 0.5)
&#9;&#9;local NewLocationX = math.sin(RadianTheta) * Radius
&#9;&#9;local NewLocationY = math.cos(RadianTheta) * Radius

&#9;&#9;local Position = UDim2.new(0.5, NewLocationX - Gui.Size.X.Offset/2, 0, Radius - NewLocationY)
&#9;&#9;local Rotation = RadianTheta * 180 / math.pi

&#9;&#9;return Position, Rotation
&#9;end

&#9;local function Step(Camera)
&#9;&#9;--- Updates the compass model.
&#9;&#9;-- @param Camera The current camera.

&#9;&#9;local CurrentAngle, RealAngle = CompassModel.Step(Camera)
&#9;&#9;-- print(&quot;[Compass] - CurrentAngle = &quot; .. Round(CurrentAngle, 0.01) .. &quot;; Real Angle = &quot; .. Round(RealAngle, 0.01))

&#9;&#9;for _, CoordinateDirection in pairs(CurrentCoordinateDirections) do
&#9;&#9;&#9;local PercentPosition = GetPercentPosition(CurrentAngle, CoordinateDirection.Angle, ThetaVisible)

&#9;&#9;&#9;local Gui = CoordinateDirection.Gui
&#9;&#9;&#9;local Position, Rotation = GetPositionAndRotation(Gui, PercentPosition)
&#9;&#9;&#9;Gui.Position = Position
&#9;&#9;&#9;Gui.Rotation = Rotation

&#9;&#9;&#9;local Transparency = GetGuiTransparency(PercentPosition, Configuration.SolidArea)
&#9;&#9;&#9;CoordinateDirection.SetTransparency(Gui, Transparency)
&#9;&#9;end

&#9;&#9;for _, InterestPoint in pairs(CurrentInterestPoints) do
&#9;&#9;&#9;--assert(InterestPoint.Point, &quot;No point&quot;)

&#9;&#9;&#9;local RelativeAngle = CompassModel.GetRelativeAngle(Camera, InterestPoint.Point)
&#9;&#9;&#9;local PercentPosition = GetPercentPosition(CurrentAngle, RelativeAngle, ThetaVisible)

&#9;&#9;&#9;local Gui = InterestPoint.Gui
&#9;&#9;&#9;local Position, Rotation = GetPositionAndRotation(Gui, PercentPosition)
&#9;&#9;&#9;Gui.Position = Position
&#9;&#9;&#9;Gui.Rotation = Rotation

&#9;&#9;&#9;local Transparency = GetGuiTransparency(PercentPosition, Configuration.SolidArea)
&#9;&#9;&#9;InterestPoint.SetTransparency(Gui, Transparency)
&#9;&#9;end
&#9;end
&#9;CircleCompass.Step = Step
&#9;CircleCompass.step = Step

&#9;local function AddCoordinateDirection(Angle, Gui, SetTransparency)
&#9;&#9;--- Adds a new coordainte direction to the compass. 
&#9;&#9;-- @param Angle Angle on the compass, relative to &quot;N&quot; (0 radians).
&#9;&#9;-- @param Gui The Gui to display.
&#9;&#9;-- @param SetTransparency Sets the transparency of the GUI. If not given, it will not set the transparency (and your GUI will look ugly.)

&#9;&#9;local CoordinateDirection           = {}
&#9;&#9;CoordinateDirection.Angle           = Angle
&#9;&#9;CoordinateDirection.Gui             = Gui
&#9;&#9;CoordinateDirection.SetTransparency = SetTransparency

&#9;&#9;Gui.Parent = Frame

&#9;&#9;CurrentCoordinateDirections[Gui] = CoordinateDirection
&#9;end
&#9;CircleCompass.AddCoordinateDirection = AddCoordinateDirection
&#9;CircleCompass.addCoordinateDirection = AddCoordinateDirection

&#9;local function UpdateCoordinateDirection(Gui, NewAngle)
&#9;&#9;CurrentCoordinateDirections[Gui].Angle = NewAngle
&#9;end
&#9;CircleCompass.UpdateCoordinateDirection = UpdateCoordinateDirection
&#9;CircleCompass.UpdateCoordinateDirection = UpdateCoordinateDirection

&#9;local function RemoveCoordinateDirection(Gui)
&#9;&#9;--- Remove&apos;s a coordiante direction.
&#9;&#9;-- @param Gui The Gui to remove (linked to the CoordinateDirection)

&#9;&#9;if CurrentCoordinateDirections[Gui] then
&#9;&#9;&#9;Gui.Parent = nil
&#9;&#9;&#9;CurrentCoordinateDirections[Gui] = nil
&#9;&#9;else
&#9;&#9;&#9;error(&quot;[CircleCompass] - Could not find CoordinateDirection with given GUI&quot;)
&#9;&#9;end
&#9;end
&#9;CircleCompass.RemoveCoordinateDirection = RemoveCoordinateDirection
&#9;CircleCompass.removeCoordinateDirection = RemoveCoordinateDirection

&#9;local function AddInterestPoint(Point, Gui, SetTransparency)
&#9;&#9;--- Adds a new interest point.
&#9;&#9;-- @param Point A vector3 point (as the interest)
&#9;&#9;-- @param Gui A GUI object to use as rendering.
&#9;&#9;-- @param SetTransparency Sets the transparency of the GUI. If not given, it will not set the transparency (and your GUI will look ugly.)

&#9;&#9;assert(Point, &quot;No point!&quot;)

&#9;&#9;local NewInterestPoint           = {}
&#9;&#9;NewInterestPoint.Point           = Point
&#9;&#9;NewInterestPoint.Gui             = Gui
&#9;&#9;NewInterestPoint.SetTransparency = SetTransparency

&#9;&#9;Gui.Parent = Frame

&#9;&#9;CurrentInterestPoints[Gui] = NewInterestPoint
&#9;end
&#9;CircleCompass.AddInterestPoint = AddInterestPoint
&#9;CircleCompass.addInterestPoint = AddInterestPoint

&#9;local function UpdateInterestPoint(Gui, NewPoint)
&#9;&#9;CurrentInterestPoints[Gui].Point = NewPoint
&#9;end
&#9;CircleCompass.UpdateInterestPoint = UpdateInterestPoint
&#9;CircleCompass.updateInterestPoint = UpdateInterestPoint

&#9;local function RemoveInterestPoint(Gui)
&#9;&#9;if CurrentInterestPoints[Gui] then
&#9;&#9;&#9;Gui.Parent = nil
&#9;&#9;&#9;CurrentInterestPoints[Gui] = nil
&#9;&#9;else
&#9;&#9;&#9;error(&quot;[CircleCompass] - Could not identify InterestPoint with the given GUI&quot;)
&#9;&#9;end
&#9;end
&#9;CircleCompass.RemoveInterestPoint = RemoveInterestPoint
&#9;CircleCompass.removeInterestPoint = RemoveInterestPoint
end)
lib.MakeCircleCompass = MakeCircleCompass
lib.makeCircleCompass = MakeCircleCompass

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX27">
					<Properties>
						<string name="Name">ParticleEngine</string>
						<ProtectedString name="Source">local WindSpeed    = 10

local sin          = math.sin
local cos          = math.cos
local tan          = math.tan
local sqrt         = math.sqrt
local insert       = table.insert
local remove       = table.remove
local atan2        = math.atan2
local max          = math.max
local abs          = math.abs
local random       = math.random
local v3           = Vector3.new
local v2           = Vector2.new
local ud2          = UDim2.new
local tick         = tick
local ray          = Ray.new
local RayCast      = game.Workspace.FindPartOnRay
local Dot = v3().Dot
local lib = {}

local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))

local function MakeParticleEngineServer()
&#9;--- Required for networking....

&#9;local Engine = {}

&#9;local RemoteEvent = NevermoreEngine.GetEventStreamObject(&quot;ParticleEventDistributor&quot;)

&#9;local function ParticleNew(p) -- PropertiesTable
&#9;&#9;p.Position      = p.Position or error(&quot;No Position Yo&quot;)
&#9;&#9;p.Velocity      = p.Velocity or v3()
&#9;&#9;p.Size          = p.Size or v2(0.2,0.2)
&#9;&#9;p.Bloom         = p.Bloom or v2(0,0)
&#9;&#9;p.Gravity       = p.Gravity or v3()
&#9;&#9;p.LifeTime      = p.LifeTime;
&#9;&#9;p.Color         = p.Color or Color3.new(1,1,1)
&#9;&#9;p.Transparency  = p.Transparency or 0.5

&#9;&#9;RemoteEvent:FireAllClients(p)

&#9;&#9;return p
&#9;end
&#9;Engine.ParticleNew = ParticleNew

&#9;RemoteEvent.OnServerEvent:connect(function(Player, p)
&#9;&#9;-- print(&quot;Server -- New particle&quot;)
&#9;&#9;p.Global = nil

&#9;&#9;for _, PlayerX in pairs(game.Players:GetPlayers()) do
&#9;&#9;&#9;if PlayerX ~= Player then
&#9;&#9;&#9;&#9;RemoteEvent:FireClient(PlayerX, p)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)

&#9;return Engine
end
lib.MakeParticleEngineServer = MakeParticleEngineServer


local function RealMakeEngine(Screen)
&#9;print(&quot;[ParticleEngine] - Creating new Particle Engine!!!!&quot;)
&#9;assert(Screen, &quot;Need screen&quot;)

&#9;local Engine = {}
&#9;Engine.Active = true

&#9;local MaxParticles = 400 --lol 3000 if you have a good computer lol.

&#9;--[[
&#9;To generate a new particle
&#9;ParticleNew{
&#9;&#9;Position          = Vector3

&#9;&#9;--Nonrequired 
&#9;&#9;Global            = Bool
&#9;&#9;Velocity          = Vector3
&#9;&#9;Gravity           = Vector3
&#9;&#9;WindResistance    = Number
&#9;&#9;LifeTime          = Number
&#9;&#9;Size              = Vector2
&#9;&#9;Bloom             = Vector2
&#9;&#9;Transparency      = Number
&#9;&#9;Color             = Color3
&#9;&#9;Occlusion         = Bool
&#9;&#9;RemoveOnCollision = function(BasePart Hit, Vector3 Position))
&#9;&#9;Function          = function(Table ParticleProperties, Number dt, Number t)
&#9;}

&#9;To remove a particle
&#9;ParticleRemove(Table ParticleProperties)

&#9;]]

&#9;local Time = tick()

&#9;local Player         = game.Players.LocalPlayer
&#9;local RemoteEvent    = NevermoreEngine.GetEventStreamObject(&quot;ParticleEventDistributor&quot;)

&#9;-- Screen = Screen or Instance.new(&quot;ScreenGui&quot;, Player.PlayerGui)

&#9;local ParticleFrames = {}

&#9;local ScreenSizeX 
&#9;local ScreenSizeY 
&#9;local PlaneSizeY 
&#9;local PlaneSizeX  

&#9;local function NewParticle(Name)
&#9;&#9;local NewParticle           = Instance.new(&quot;Frame&quot;)
&#9;&#9;NewParticle.BorderSizePixel = 0
&#9;&#9;NewParticle.Name            = Name;
&#9;&#9;NewParticle.Archivable      = false

&#9;&#9;return NewParticle
&#9;end

&#9;--Generate the GUIs
&#9;for Index=1, MaxParticles do
&#9;&#9;ParticleFrames[Index] = NewParticle(&quot;_Particle&quot;)
&#9;end

&#9;local function ParticleUpdateScreenInformation(Camera)
&#9;&#9;ScreenSizeX = Screen.AbsoluteSize.x
&#9;&#9;ScreenSizeY = Screen.AbsoluteSize.y
&#9;&#9;PlaneSizeY  = 2*tan(Camera.FieldOfView*0.0087266462599716)
&#9;&#9;PlaneSizeX  = PlaneSizeY*ScreenSizeX/ScreenSizeY
&#9;end
&#9;ParticleUpdateScreenInformation(Workspace.CurrentCamera)

&#9;local function SetScreen(NewScreen)
&#9;&#9;assert(NewScreen, &quot;Must be a screen!&quot;)

&#9;&#9;Screen = NewScreen
&#9;&#9;print(&quot;[ParticleEngine] - NewScreen: &quot; .. Screen:GetFullName())
&#9;end
&#9;Engine.SetScreen = SetScreen

&#9;local function ParticleWind(p)--Position
&#9;&#9;local xy,yz,zx=p.x+p.y,p.y+p.z,p.z+p.x
&#9;&#9;return v3((sin(yz+Time*2)+sin(yz+Time))/2+sin((yz+Time)/10),(sin(zx+Time*2)+sin(zx+Time))/2+sin((zx+Time)/10),(sin(xy+Time*2)+sin(xy+Time))/2+sin((xy+Time)/10))/2
&#9;end

&#9;local function ParticleUpdateProperties(f,p,dt)--Frame,ParticleProperties,ChangeInTime,Time
&#9;&#9;p.Position = p.Position+p.Velocity*dt
&#9;&#9;local w    = p.WindResistance and (ParticleWind(p.Position)*WindSpeed-p.Velocity)*p.WindResistance or v3()
&#9;&#9;p.Velocity = p.Velocity+(p.Gravity+w)*dt
&#9;end

&#9;local function ParticleRender(Camera, f, p, ci)--CameraInverse
&#9;&#9;local rp=ci*p.Position
&#9;&#9;local lsp=p.LastScreenPosition
&#9;&#9;if rp.z&lt;-1 and lsp then
&#9;&#9;&#9;local sp                 = rp/rp.z
&#9;&#9;&#9;local b                  = p.Bloom
&#9;&#9;&#9;local bgt                = p.Transparency
&#9;&#9;&#9;local PositionX          = (0.5-sp.x/PlaneSizeX)*ScreenSizeX
&#9;&#9;&#9;local PositionY          = (0.5+sp.y/PlaneSizeY)*ScreenSizeY
&#9;&#9;&#9;local PreSizeY           = -p.Size.y/rp.z*ScreenSizeY/PlaneSizeY
&#9;&#9;&#9;local SizeX              = -p.Size.x/rp.z*ScreenSizeY/PlaneSizeY + b.x
&#9;&#9;&#9;local rppx,rppy          = PositionX-lsp.x,PositionY-lsp.y
&#9;&#9;&#9;local SizeY              = PreSizeY+sqrt(rppx*rppx+rppy*rppy) + b.y
&#9;&#9;&#9;p.LastScreenPosition     = v2(PositionX,PositionY)

&#9;&#9;&#9;local Visible = true

&#9;&#9;&#9;if p.Occlusion then
&#9;&#9;&#9;&#9;local c=Camera.CoordinateFrame.p
&#9;&#9;&#9;&#9;local Vec = p.Position-c
&#9;&#9;&#9;&#9;local Mag = Vec.magnitude
&#9;&#9;&#9;&#9;if Mag &gt; 999 then
&#9;&#9;&#9;&#9;&#9;Vec = Vec * (999/Mag)
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;if RayCast(Workspace,ray(c,Vec),Player.Character, true) then
&#9;&#9;&#9;&#9;&#9;Visible = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;if Visible then
&#9;&#9;&#9;&#9;f.Parent                 = Screen
&#9;&#9;&#9;&#9;f.Position               = ud2(0, (PositionX+lsp.x-SizeX)/2, 0, (PositionY+lsp.y-SizeY)/2)
&#9;&#9;&#9;&#9;f.Size                   = ud2(0, SizeX, 0,SizeY)
&#9;&#9;&#9;&#9;f.Rotation               = 90+atan2(rppy,rppx)*57.295779513082
&#9;&#9;&#9;&#9;f.BackgroundColor3       = p.Color
&#9;&#9;&#9;&#9;f.BackgroundTransparency = bgt+(1-bgt)*(1-PreSizeY/SizeY)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;f.Parent = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;f.Parent = nil
&#9;&#9;&#9;if rp.z&gt;0 then
&#9;&#9;&#9;&#9;p.LastScreenPosition = nil
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;sp                   = rp/rp.z
&#9;&#9;&#9;&#9;p.LastScreenPosition = Vector2.new((0.5-sp.x/PlaneSizeX)*ScreenSizeX,(0.5+sp.y/PlaneSizeY)*ScreenSizeY)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local NewParticles = {}
&#9;local RemovingParticles = {}
&#9;local Priority = {}

&#9;local Particles = {}



&#9;local function AddNewParticles()
&#9;&#9;local WorkingOn = NewParticles
&#9;&#9;local Removing = RemovingParticles
&#9;&#9;RemovingParticles = {}
&#9;&#9;NewParticles = {}

&#9;&#9;local PrioritiySize = #Priority
&#9;&#9;local ParticleSize = #Particles

&#9;&#9;for Index = 1, #Removing do
&#9;&#9;&#9;local Particle = Removing[Index]

&#9;&#9;&#9;if Particle.TablePosition then
&#9;&#9;&#9;&#9;if Particle.Priority then
&#9;&#9;&#9;&#9;&#9;local Index = Particle.TablePosition
&#9;&#9;&#9;&#9;&#9;while Index &lt; PrioritiySize do
&#9;&#9;&#9;&#9;&#9;&#9;Priority[Index] = Priority[Index + 1]
&#9;&#9;&#9;&#9;&#9;&#9;Priority[Index].TablePosition = Index
&#9;&#9;&#9;&#9;&#9;&#9;Index = Index + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;Priority[PrioritiySize] = nil
&#9;&#9;&#9;&#9;&#9;PrioritiySize = PrioritiySize - 1

&#9;&#9;&#9;&#9;&#9;Particle.Frame:Destroy()
&#9;&#9;&#9;&#9;&#9;Particle.Frame = nil
&#9;&#9;&#9;&#9;&#9;Particle.TablePosition = nil
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;local Index = Particle.TablePosition
&#9;&#9;&#9;&#9;&#9;while Index &lt; ParticleSize do
&#9;&#9;&#9;&#9;&#9;&#9;Particles[Index] = Particles[Index + 1]
&#9;&#9;&#9;&#9;&#9;&#9;Particles[Index].TablePosition = Index
&#9;&#9;&#9;&#9;&#9;&#9;Index = Index + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;Particles[ParticleSize] = nil
&#9;&#9;&#9;&#9;&#9;ParticleSize = ParticleSize - 1

&#9;&#9;&#9;&#9;&#9;Particle.TablePosition = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;for Index = 1, #WorkingOn do
&#9;&#9;&#9;local Particle = WorkingOn[Index]
&#9;&#9;&#9;if Particle.Priority then
&#9;&#9;&#9;&#9;Particle.Frame = NewParticle(&quot;_PriorityParticle&quot;)

&#9;&#9;&#9;&#9;Priority[#Priority+1] = Particle
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;insert(Particles, 1, Particle)
&#9;&#9;&#9;&#9;Particles[MaxParticles] = nil
&#9;&#9;&#9;end

&#9;&#9;&#9;--[[local LastParticle = Particles[MaxParticles]
&#9;&#9;&#9;if LastParticle then
&#9;&#9;&#9;&#9;if LastParticle.Frame then
&#9;&#9;&#9;&#9;&#9;LastParticle.Frame:Destroy()
&#9;&#9;&#9;&#9;&#9;LastParticle.Frame = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;Particles[MaxParticles] = nil
&#9;&#9;&#9;end--]]
&#9;&#9;end
&#9;end

&#9;local function ParticleRemove(p)
&#9;&#9;RemovingParticles[#RemovingParticles+1] = p
&#9;end
&#9;Engine.ParticleRemove = ParticleRemove

&#9;local Terrain = Workspace.Terrain
&#9;local Workspace = Workspace

&#9;local function HandleParticleUpdate(Camera, CameraInverse, Frame, Particle, t, dt)
&#9;&#9;--- Handles both priority and regular particles

&#9;&#9;if Particle.LifeTime - t &lt;= 0 then
&#9;&#9;&#9;ParticleRemove(Particle)
&#9;&#9;else
&#9;&#9;&#9;if Particle.Function then
&#9;&#9;&#9;&#9;-- Call this first, so any changes are reflected immediately

&#9;&#9;&#9;&#9;Particle.Function(Particle, dt, t)
&#9;&#9;&#9;end

&#9;&#9;&#9;local OldPosition = Particle.Position

&#9;&#9;&#9;ParticleUpdateProperties(Frame, Particle, dt, t)

&#9;&#9;&#9;if Particle.RemoveOnCollision then
&#9;&#9;&#9;&#9;local Displacement = Particle.Position - OldPosition
&#9;&#9;&#9;&#9;local Distance = Displacement.magnitude

&#9;&#9;&#9;&#9;if Distance &gt; 999 then
&#9;&#9;&#9;&#9;&#9;Displacement = Displacement * (999/Distance)
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;local Hit, Position = RayCast(Workspace, ray(OldPosition, Displacement), Player.Character, true)
&#9;&#9;&#9;&#9;if Hit then
&#9;&#9;&#9;&#9;&#9;if type(Particle.RemoveOnCollision) == &quot;function&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;if not Particle.RemoveOnCollision(Particle, Hit, Position) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ParticleRemove(Particle)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;ParticleRemove(Particle)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;ParticleRender(Camera, Frame, Particle, CameraInverse)
&#9;&#9;end
&#9;end

&#9;-- _G.AverageProcessTime=0
&#9;local function ParticleUpdate()
&#9;&#9;--- This guy is expensive
&#9;&#9;-- Should be in a loop, so no need for debounce
&#9;&#9;local Camera = Workspace.CurrentCamera

&#9;&#9;AddNewParticles()
&#9;&#9;ParticleUpdateScreenInformation(Camera)

&#9;&#9;local t=tick()
&#9;&#9;local dt=t-Time
&#9;&#9;Time=t

&#9;&#9;local CameraInverse = Camera.CoordinateFrame:inverse()

&#9;&#9;for Index = 1, MaxParticles do
&#9;&#9;&#9;local Particle = Particles[Index]
&#9;&#9;&#9;local Frame = ParticleFrames[Index]

&#9;&#9;&#9;if Particle then
&#9;&#9;&#9;&#9;Particle.TablePosition = Index
&#9;&#9;&#9;&#9;HandleParticleUpdate(Camera, CameraInverse, Frame, Particle, t, dt)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Frame.Parent = nil -- Instead of .Visible, it&apos;s faster on the rendering side. (99% sure) 
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;for Index = 1, #Priority do
&#9;&#9;&#9;local Particle = Priority[Index]
&#9;&#9;&#9;local Frame = Particle.Frame

&#9;&#9;&#9;Particle.TablePosition = Index

&#9;&#9;&#9;HandleParticleUpdate(Camera, CameraInverse, Frame, Particle, t, dt)
&#9;&#9;end
&#9;&#9;-- _G.AverageProcessTime=_G.AverageProcessTime*0.95+(tick()-t)*0.05
&#9;&#9;-- print(#Priority)
&#9;end
&#9;Engine.ParticleUpdate = ParticleUpdate

&#9;local function ParticleNew(p)--PropertiesTable
&#9;&#9;p.Position      = p.Position or v3()
&#9;&#9;p.Velocity      = p.Velocity or v3()
&#9;&#9;p.Size          = p.Size or v2(0.2,0.2)
&#9;&#9;p.Bloom         = p.Bloom or v2()
&#9;&#9;p.TablePosition = 1
&#9;&#9;p.Gravity       = p.Gravity or v3()
&#9;&#9;p.Color         = p.Color or Color3.new(1,1,1)
&#9;&#9;p.Transparency  = p.Transparency or 0.5


&#9;&#9;if p.Global then
&#9;&#9;&#9;p.Global = nil
&#9;&#9;&#9;local Function, RemoveOnCollision = p.Function, p.RemoveOnCollision
&#9;&#9;&#9;p.Function, p.RemoveOnCollision = nil, (p.RemoveOnCollision and true or nil)

&#9;&#9;&#9;RemoteEvent:FireServer(p)

&#9;&#9;&#9;p.Function, p.RemoveOnCollision = Function, RemoveOnCollision
&#9;&#9;end

&#9;&#9;p.LifeTime      = p.LifeTime and p.LifeTime+tick()
&#9;&#9;NewParticles[#NewParticles+1] = p
&#9;end
&#9;RemoteEvent.OnClientEvent:connect(ParticleNew)
&#9;Engine.ParticleNew = ParticleNew

&#9;local RenderStepped = game:GetService(&quot;RunService&quot;).RenderStepped

&#9;local UpdateId = 0

&#9;return Engine
end

local Engine

local function GetParticleEngine(Screen)
&#9;assert(Screen, &quot;Need screen!&quot;)

&#9;if not Engine then
&#9;&#9;Engine = RealMakeEngine(Screen)
&#9;else
&#9;&#9;Engine.SetScreen(Screen)
&#9;end

&#9;return Engine
end
lib.GetParticleEngine = GetParticleEngine

return lib
</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX28">
					<Properties>
						<string name="Name">ScreenGeometry</string>
						<ProtectedString name="Source">local Utility = {}
local Player = game:GetService(&quot;Players&quot;).LocalPlayer

local PlayerMouse = Player and Player:GetMouse()

-- ScreenGeometry.lua
-- http://developer.roblox.com/forum/lounge/5546-complex-geometry
-- @author xLEGOx, modified by Quenty
-- Last Updated July 26th, 2014

function Utility.ViewSizeX()
&#9;local x = PlayerMouse.ViewSizeX
&#9;if x == 0 then
&#9;&#9;return 1024
&#9;else
&#9;&#9;return x
&#9;end
end

function Utility.ViewSizeY()
&#9;local y = PlayerMouse.ViewSizeY
&#9;if y == 0 then
&#9;&#9;return 768
&#9;else
&#9;&#9;return y
&#9;end
end

function Utility.AspectRatio()
&#9;return Utility.ViewSizeX() / Utility.ViewSizeY()
end

function Utility.PointToScreenSpace(at)
&#9;local point = Workspace.CurrentCamera.CoordinateFrame:pointToObjectSpace(at)
&#9;local aspectRatio = Utility.AspectRatio()
&#9;local hfactor = math.tan(math.rad(Workspace.CurrentCamera.FieldOfView)/2)
&#9;local wfactor = aspectRatio*hfactor
&#9;--
&#9;local x = (point.x/point.z) / -wfactor
&#9;local y = (point.y/point.z) /  hfactor
&#9;--
&#9;return Vector2.new(Utility.ViewSizeX()*(0.5 + 0.5*x), Utility.ViewSizeY()*(0.5 + 0.5*y))
end

function Utility.WidthToScreenSpace(depth, width)
&#9;local aspectRatio = Utility.AspectRatio()
&#9;local hfactor = math.tan(math.rad(Workspace.CurrentCamera.FieldOfView)/2)
&#9;local wfactor = aspectRatio*hfactor
&#9;--
&#9;return Utility.ViewSizeX() * 0.5 * width / depth / wfactor
end

function Utility.ScreenSpaceToWorld(x, y, depth)
&#9;local aspectRatio = Utility.AspectRatio()
&#9;local hfactor = math.tan(math.rad(Workspace.CurrentCamera.FieldOfView)/2)
&#9;local wfactor = aspectRatio*hfactor
&#9;--
&#9;local xf, yf = x/Utility.ViewSizeX()*2 - 1, y/Utility.ViewSizeY()*2 - 1
&#9;local xpos = xf * -wfactor * depth
&#9;local ypos = yf *  hfactor * depth
&#9;--
&#9;return Vector3.new(xpos, ypos, depth)
end

function Utility.GetDepthForWidth(partWidth, visibleSize) -- part size, s size -&gt; depth
&#9;local aspectRatio = Utility.AspectRatio()
&#9;local hfactor = math.tan(math.rad(Workspace.CurrentCamera.FieldOfView)/2)  -- 0.7
&#9;local wfactor = aspectRatio*hfactor  -- 1.05
&#9;--
&#9;return -0.5*Utility.ViewSizeX()*partWidth/(visibleSize*wfactor)
end

function Utility.GetWidthForDepth(depth, visibleSize)
&#9;local aspectRatio = Utility.AspectRatio()
&#9;local hfactor = math.tan(math.rad(Workspace.CurrentCamera.FieldOfView)/2)
&#9;local wfactor = aspectRatio*hfactor
&#9;return -2*depth*visibleSize*wfactor/Utility.ViewSizeX()
end

function Utility.ScreenSpaceToWorldWithHeight(x, y, screenHeight, depth)
&#9;local aspectRatio = Utility.AspectRatio()
&#9;local hfactor = math.tan(math.rad(Workspace.CurrentCamera.FieldOfView)/2)
&#9;local wfactor = aspectRatio*hfactor
&#9;local sx, sy = Utility.ViewSizeX(), Utility.ViewSizeY()
&#9;--
&#9;local worldHeight = -(screenHeight/sy) * 2 * hfactor * depth
&#9;--
&#9;local xf, yf = x/sx*2 - 1, y/sy*2 - 1
&#9;local xpos = xf * -wfactor * depth
&#9;local ypos = yf *  hfactor * depth
&#9;--
&#9;return Vector3.new(xpos, ypos, depth), worldHeight
end

function Utility.HeightToScreenHeight(height, depth)
&#9;local hfactor = math.tan(math.rad(Workspace.CurrentCamera.FieldOfView))
&#9;local sy = Utility.ViewSizeY()
&#9;return -height*sy / (2*hfactor*depth)
end

-- xXxMonkeyManxXx

local pi=math.pi
local abs=math.abs
local max=math.max
local tan=math.tan

function Utility.GetSideSlopes(GUIPaddingX, GUIPaddingY)
&#9;GUIPaddingX, GUIPaddingY = GUIPaddingX or 0, GUIPaddingY or 0

&#9;local ScreenSizeX, ScreenSizeY = Utility.ViewSizeX(), Utility.ViewSizeY()
&#9;local CameraFOV = Workspace.CurrentCamera.FieldOfView

&#9;local SlopeY = tan(CameraFOV*pi/360)
&#9;return SlopeY*ScreenSizeX/ScreenSizeY*(1-GUIPaddingX/ScreenSizeX), --slopeX
&#9;       SlopeY*(1-GUIPaddingY/ScreenSizeY) --slopeY
end

function Utility.GetChangeInDepthForPoint(CoordinateFrame, point, slopeX, slopeY)
&#9;--- Calculates the change in depth (Y axis) needed to get the point to render on the screen
&#9;--- SlopeX and SlopeY are retrieved from GetSideSlopes

&#9;local RelPos = CoordinateFrame:pointToObjectSpace(point)

&#9;return max(abs(RelPos.x)/slopeX-RelPos.z, abs(RelPos.y)/slopeY-RelPos.z)
&#9;--return max((RelPos.x)/slopeX-RelPos.z, (RelPos.y)/slopeY-RelPos.z)
end

return Utility</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX29">
					<Properties>
						<string name="Name">TitleGenerator</string>
						<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local qGUI          = LoadCustomLibrary(&quot;qGUI&quot;)
local Maid          = LoadCustomLibrary(&quot;Maid&quot;)

qSystems:Import(getfenv(0))

local lib = {}

-- TitleGenerator.lua
-- @author Quenty

local function GenerateTitle(ScreenGui, Text, TopLabelText, BottomLabelText) &#9;
&#9;-- Generates a title that looks like this
&#9;--[[
&#9;

&#9;--------------
&#9;   T I T L E
&#9;--------------

&#9;Which is then GCed after a while. 
&#9;TopLabelText may be used to create a text above the top white bar, and 
&#9;BottomLabelText below the bottom white bar
&#9;--]]
&#9;-- @param ScreenGui The screenGUi (or parent) to put in. It will be centered to this. Recommened ScreenGui
&#9;-- @param Text The text to use
&#9;-- @param [TopLabelText] The &quot;top label&quot; text to use.
&#9;-- @param [BottomLabelText] - The &quot;bottom label&quot; text to use

&#9;local Configuration = {
&#9;&#9;Height             = 90; -- How high is the whole thing? Bars will be offset by LabelHeight.
&#9;&#9;ZIndex             = 10; -- What ZIndex does it use?
&#9;&#9;LifeTime           = 3;  -- How long does it last?
&#9;&#9;AnimationTime      = 1;  -- How long does it animate in/out?
&#9;&#9;ShadowTransparency = 0.9; -- Use text stroke transparency to make more contrast.
&#9;&#9;BarTransparency    = 0.3; -- How transparency are the bars.
&#9;&#9;BarHeight          = 4;
&#9;&#9;ExpandFactor       = 8; -- When it disappears

&#9;&#9;LabelHeight = 20; -- The Top and bottom labels.
&#9;}

&#9;local Container = Make(&quot;Frame&quot;, {
&#9;&#9;Archivable             = false;
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Name                   = &quot;TitleContainer&quot;;
&#9;&#9;Parent                 = TextLabel;
&#9;&#9;ZIndex                 = Configuration.ZIndex;
&#9;&#9;ClipsDescendants       = true;
&#9;})
&#9;Container.Parent = ScreenGui

&#9;-- Middle Label
&#9;local MiddleLabelSize
&#9;local MiddleTextLabels = {} do
&#9;&#9;Text = Text:upper()

&#9;&#9;local SizeX = 0
&#9;&#9;for Index = 1, #Text do
&#9;&#9;&#9;local Character = Text:sub(Index, Index)
&#9;&#9;&#9;if Character ~= &quot; &quot; then
&#9;&#9;&#9;&#9;local TextLabel = Make(&quot;TextLabel&quot;, {
&#9;&#9;&#9;&#9;&#9;Archivable             = false;
&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;&#9;&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;&#9;&#9;&#9;Font                   = &quot;Arial&quot;;
&#9;&#9;&#9;&#9;&#9;FontSize               = &quot;Size36&quot;;
&#9;&#9;&#9;&#9;&#9;Name                   = &quot;MiddleLabel&quot; .. Character;
&#9;&#9;&#9;&#9;&#9;Parent                 = Container;
&#9;&#9;&#9;&#9;&#9;Size                   = UDim2.new(0, 0, 1, 0);
&#9;&#9;&#9;&#9;&#9;Text                   = Character;
&#9;&#9;&#9;&#9;&#9;TextColor3             = Color3.new(1, 1, 1);
&#9;&#9;&#9;&#9;&#9;TextStrokeTransparency = 1;
&#9;&#9;&#9;&#9;&#9;TextTransparency       = 1;
&#9;&#9;&#9;&#9;&#9;TextXAlignment         = &quot;Left&quot;;
&#9;&#9;&#9;&#9;&#9;ZIndex                 = Configuration.ZIndex;
&#9;&#9;&#9;&#9;})

&#9;&#9;&#9;&#9;-- Alternate sliding in from left or right.
&#9;&#9;&#9;&#9;if Index % 2 == 0 then
&#9;&#9;&#9;&#9;&#9;TextLabel.Position = UDim2.new(0, 0, 0.5, -Configuration.Height/2);
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;TextLabel.Position = UDim2.new(1, 0, 0.5, -Configuration.Height/2);
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;local Position = UDim2.new(0.25, SizeX, 0, 0) -- The middle 50% of the frame will contain characters.

&#9;&#9;&#9;&#9;delay(Configuration.AnimationTime * ((Index/#Text)/2), function()
&#9;&#9;&#9;&#9;&#9;TextLabel:TweenPosition(Position, &quot;Out&quot;, &quot;Quad&quot;, Configuration.AnimationTime/2, true)
&#9;&#9;&#9;&#9;&#9;qGUI.TweenTransparency(TextLabel, {TextTransparency = 0, TextStrokeTransparency = Configuration.ShadowTransparency}, Configuration.AnimationTime/2, true)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;SizeX = SizeX + TextLabel.TextBounds.X + 5
&#9;&#9;&#9;&#9;MiddleTextLabels[#MiddleTextLabels+1] = TextLabel;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;SizeX = SizeX + 10
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;MiddleLabelSize = SizeX
&#9;end

&#9;-- TopLabel
&#9;local TopLabels = {} if TopLabelText then
&#9;&#9;TopLabelText = TopLabelText:upper()

&#9;&#9;local SizeX = 0
&#9;&#9;for Index = 1, #TopLabelText do
&#9;&#9;&#9;local Character = TopLabelText:sub(Index, Index)
&#9;&#9;&#9;if Character ~= &quot; &quot; then
&#9;&#9;&#9;&#9;local TextLabel = Make(&quot;TextLabel&quot;, {
&#9;&#9;&#9;&#9;&#9;Archivable             = false;
&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;&#9;&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;&#9;&#9;&#9;Font                   = &quot;Arial&quot;;
&#9;&#9;&#9;&#9;&#9;FontSize               = &quot;Size14&quot;;
&#9;&#9;&#9;&#9;&#9;Name                   = &quot;TopLabel&quot; .. Character;
&#9;&#9;&#9;&#9;&#9;Parent                 = Container;
&#9;&#9;&#9;&#9;&#9;Size                   = UDim2.new(0, 0, 0, Configuration.LabelHeight);
&#9;&#9;&#9;&#9;&#9;Text                   = Character;
&#9;&#9;&#9;&#9;&#9;TextColor3             = Color3.new(1, 1, 1);
&#9;&#9;&#9;&#9;&#9;TextStrokeTransparency = 1;
&#9;&#9;&#9;&#9;&#9;TextTransparency       = 1;
&#9;&#9;&#9;&#9;&#9;TextXAlignment         = &quot;Left&quot;;
&#9;&#9;&#9;&#9;&#9;ZIndex                 = Configuration.ZIndex;
&#9;&#9;&#9;&#9;})

&#9;&#9;&#9;&#9;TextLabel.Position = UDim2.new(1, 0, 0, 0); -- We&apos;ll slide in from the right.

&#9;&#9;&#9;&#9;local Position = UDim2.new(3/16, SizeX, 0, 0)

&#9;&#9;&#9;&#9;delay(Configuration.AnimationTime * ((Index/#TopLabelText)/2), function()
&#9;&#9;&#9;&#9;&#9;TextLabel:TweenPosition(Position, &quot;Out&quot;, &quot;Quad&quot;, Configuration.AnimationTime/2, true)
&#9;&#9;&#9;&#9;&#9;qGUI.TweenTransparency(TextLabel, {TextTransparency = 0, TextStrokeTransparency = Configuration.ShadowTransparency}, Configuration.AnimationTime/2, true)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;SizeX = SizeX + TextLabel.TextBounds.X + 3

&#9;&#9;&#9;&#9;TopLabels[#TopLabels+1] = TextLabel
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;SizeX = SizeX + 5
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;-- BottomLabel
&#9;local BottomLabels = {} if BottomLabelText then
&#9;&#9;BottomLabelText = BottomLabelText:upper()

&#9;&#9;local SizeX = 0
&#9;&#9;for Index = #BottomLabelText, 1, -1 do
&#9;&#9;&#9;local Character = BottomLabelText:sub(Index, Index)
&#9;&#9;&#9;if Character ~= &quot; &quot; then
&#9;&#9;&#9;&#9;local TextLabel = Make(&quot;TextLabel&quot;, {
&#9;&#9;&#9;&#9;&#9;Archivable             = false;
&#9;&#9;&#9;&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;&#9;&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;&#9;&#9;&#9;Font                   = &quot;Arial&quot;;
&#9;&#9;&#9;&#9;&#9;FontSize               = &quot;Size14&quot;;
&#9;&#9;&#9;&#9;&#9;Name                   = &quot;BottomLabel&quot; .. Character;
&#9;&#9;&#9;&#9;&#9;Parent                 = Container;
&#9;&#9;&#9;&#9;&#9;Size                   = UDim2.new(0, 0, 0, Configuration.LabelHeight);
&#9;&#9;&#9;&#9;&#9;Text                   = Character;
&#9;&#9;&#9;&#9;&#9;TextColor3             = Color3.new(1, 1, 1);
&#9;&#9;&#9;&#9;&#9;TextStrokeTransparency = 1;
&#9;&#9;&#9;&#9;&#9;TextTransparency       = 1;
&#9;&#9;&#9;&#9;&#9;TextXAlignment         = &quot;Right&quot;;
&#9;&#9;&#9;&#9;&#9;ZIndex                 = Configuration.ZIndex;
&#9;&#9;&#9;&#9;})

&#9;&#9;&#9;&#9;TextLabel.Position = UDim2.new(0, 0, 1, -Configuration.LabelHeight); -- We&apos;ll slide in from the left

&#9;&#9;&#9;&#9;local Position = UDim2.new(13/16, -SizeX, 1, -Configuration.LabelHeight)

&#9;&#9;&#9;&#9;delay(Configuration.AnimationTime * (((#BottomLabelText - Index)/#BottomLabelText)/2), function()
&#9;&#9;&#9;&#9;&#9;TextLabel:TweenPosition(Position, &quot;Out&quot;, &quot;Quad&quot;, Configuration.AnimationTime/2, true)
&#9;&#9;&#9;&#9;&#9;qGUI.TweenTransparency(TextLabel, {TextTransparency = 0, TextStrokeTransparency = Configuration.ShadowTransparency}, Configuration.AnimationTime/2, true)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;SizeX = SizeX + TextLabel.TextBounds.X + 3-- Compenstate for letter?

&#9;&#9;&#9;&#9;BottomLabels[#BottomLabels+1] = TextLabel
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;SizeX = SizeX + 5
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;-- Add decoration
&#9;local TopStripe = Make(&quot;Frame&quot;, {
&#9;&#9;Archivable             = false;
&#9;&#9;BackgroundColor3       = Color3.new(1, 1, 1);
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Name                   = &quot;TopDecoration&quot;;
&#9;&#9;Parent                 = Container;
&#9;&#9;Position               = UDim2.new(0.25/2, 0, 0, Configuration.LabelHeight);
&#9;&#9;Size                   = UDim2.new(0.75, 0, 0, Configuration.BarHeight);
&#9;&#9;ZIndex                 = Configuration.ZIndex;
&#9;})

&#9;local BottomStripe = Make(&quot;Frame&quot;, {
&#9;&#9;Archivable             = false;
&#9;&#9;BackgroundColor3       = Color3.new(1, 1, 1);
&#9;&#9;BackgroundTransparency = 1;
&#9;&#9;BorderSizePixel        = 0;
&#9;&#9;Name                   = &quot;BottomDecoration&quot;;
&#9;&#9;Parent                 = Container;&#9;
&#9;&#9;Position               = UDim2.new(0.25/2, 0, 1, -Configuration.BarHeight - Configuration.LabelHeight);
&#9;&#9;Size                   = UDim2.new(0.75, 0, 0, Configuration.BarHeight);
&#9;&#9;ZIndex                 = Configuration.ZIndex;
&#9;})

&#9;qGUI.TweenTransparency(TopStripe, {BackgroundTransparency = Configuration.BarTransparency}, Configuration.AnimationTime, true)
&#9;qGUI.TweenTransparency(BottomStripe, {BackgroundTransparency = Configuration.BarTransparency}, Configuration.AnimationTime, true)

&#9;-- Container.Size = UDim2.new(0, Configuration.BarHeight*2, 0, Configuration.Height)
&#9;-- Container.Position = UDim2.new(0.5, 0, 0.5, -Configuration.Height)

&#9;Container.Size = UDim2.new(0, MiddleLabelSize*2, 0, 0)
&#9;Container.Position = UDim2.new(0.5, -MiddleLabelSize, 0.5, -Configuration.Height/2)

&#9;Container:TweenSizeAndPosition(UDim2.new(0, MiddleLabelSize*2, 0, Configuration.Height), UDim2.new(0.5, -MiddleLabelSize, 0.5, -Configuration.Height), &quot;Out&quot;, &quot;Quad&quot;, Configuration.AnimationTime, true)

&#9;--- GC / Removal
&#9;delay(Configuration.LifeTime, function()
&#9;&#9;-- Bars
&#9;&#9;qGUI.TweenTransparency(TopStripe, {BackgroundTransparency = 1}, Configuration.AnimationTime, true)
&#9;&#9;qGUI.TweenTransparency(BottomStripe, {BackgroundTransparency = 1}, Configuration.AnimationTime, true)

&#9;&#9;Container:TweenSizeAndPosition(UDim2.new(0, MiddleLabelSize*2, 0, Configuration.Height*Configuration.ExpandFactor), UDim2.new(0.5, -MiddleLabelSize, 0.5, -Configuration.Height*(Configuration.ExpandFactor/2 + 0.5)), &quot;In&quot;, &quot;Quad&quot;, Configuration.AnimationTime, true)

&#9;&#9;-- Midle animation
&#9;&#9;for Index, TextLabel in pairs(MiddleTextLabels) do
&#9;&#9;&#9;delay(Configuration.AnimationTime * ((Index/#Text)/2), function()
&#9;&#9;&#9;&#9;TextLabel:TweenPosition(UDim2.new(Index % 2 == 0 and 1 or 0, 0, 0, 0), &quot;In&quot;, &quot;Quad&quot;, Configuration.AnimationTime/2, true)
&#9;&#9;&#9;&#9;qGUI.TweenTransparency(TextLabel, {TextTransparency = 1, TextStrokeTransparency=1}, Configuration.AnimationTime/2, true)
&#9;&#9;&#9;end)
&#9;&#9;end

&#9;&#9;-- Top Animation
&#9;&#9;for Index, TextLabel in pairs(TopLabels) do
&#9;&#9;&#9;delay(Configuration.AnimationTime * ((Index/#Text)/2), function()
&#9;&#9;&#9;&#9;TextLabel:TweenPosition(UDim2.new(0, 0, 0, 0), &quot;In&quot;, &quot;Quad&quot;, Configuration.AnimationTime/2, true)
&#9;&#9;&#9;&#9;qGUI.TweenTransparency(TextLabel, {TextTransparency = 1, TextStrokeTransparency=1}, Configuration.AnimationTime/2, true)
&#9;&#9;&#9;end)
&#9;&#9;end

&#9;&#9;-- Bottom Animation
&#9;&#9;for Index, TextLabel in pairs(BottomLabels) do
&#9;&#9;&#9;delay(Configuration.AnimationTime * (((Index)/#Text)/2), function()
&#9;&#9;&#9;&#9;TextLabel:TweenPosition(UDim2.new(1, 0, 1, -Configuration.LabelHeight), &quot;In&quot;, &quot;Quad&quot;, Configuration.AnimationTime/2, true)
&#9;&#9;&#9;&#9;qGUI.TweenTransparency(TextLabel, {TextTransparency = 1, TextStrokeTransparency=1}, Configuration.AnimationTime/2, true)
&#9;&#9;&#9;end)
&#9;&#9;end


&#9;&#9;wait(Configuration.AnimationTime)

&#9;&#9;-- CLEAN UP -- 
&#9;&#9;for _, TextLabel in pairs(MiddleTextLabels) do
&#9;&#9;&#9;TextLabel:Destroy()
&#9;&#9;end

&#9;&#9;for Index, TextLabel in pairs(TopLabels) do
&#9;&#9;&#9;TextLabel:Destroy()
&#9;&#9;end

&#9;&#9;TopStripe:Destroy()
&#9;&#9;BottomStripe:Destroy()
&#9;&#9;Container:Destroy()
&#9;end)
end
lib.GenerateTitle = GenerateTitle
lib.generateTitle = GenerateTitle

return lib</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="Backpack" referent="RBX30">
				<Properties>
					<string name="Name">qSystems</string>
				</Properties>
				<Item class="ModuleScript" referent="RBX31">
					<Properties>
						<string name="Name">Type</string>
						<ProtectedString name="Source">-- @author Mark Otaris (ColorfulBody, JulienDethurens) and Quenty
-- Last modified December 28th, 2013

-- This library contains a collection of clever hacks.
-- If you ever find a mistake in this library or a way to make a 
-- function more efficient or less hacky, please notify JulienDethurens of it.

-- As far as is known, the functions in this library are foolproof. 
-- It cannot be fooled by a fake value that looks like a real one. 
-- If it says a value is a CFrame, then it _IS_ a CFrame, period.


local lib = {}

local function set(object, property, value)
&#9;-- Sets the &apos;property&apos; property of &apos;object&apos; to &apos;value&apos;.
&#9;-- This is used with pcall to avoid creating functions needlessly.
&#9;object[property] = value
end

function lib.isAnInstance(value)
&#9;-- Returns whether &apos;value&apos; is an Instance value.
&#9;local _, result = pcall(Game.IsA, value, &apos;Instance&apos;)
&#9;return result == true
end

function lib.isALibrary(value)
&#9;-- Returns whether &apos;value&apos; is a RbxLibrary.
&#9;-- Finds its result by checking whether the value&apos;s GetApi function (if it has one) can be dumped (and therefore is a non-Lua function).
&#9;if pcall(function() assert(type(value.GetApi) == &apos;function&apos;) end) then -- Check if the value has a GetApi function.
&#9;&#9;local success, result = pcall(string.dump, value.GetApi) -- Try to dump the GetApi function.
&#9;&#9;return result == &quot;unable to dump given function&quot; -- Return whether the GetApi function could be dumped.
&#9;end
&#9;return false
end

function lib.isAnEnum(value)
&#9;-- Returns whether the value is an enum.
&#9;return pcall(Enum.Material.GetEnumItems, value) == true
end

function lib.coerceIntoEnum(value, enum)
&#9;-- Coerces a value into an enum item, if possible, throws an error otherwise.
&#9;if lib.isAnEnum(enum) then
&#9;&#9;for _, enum_item in next, enum:GetEnumItems() do
&#9;&#9;&#9;if value == enum_item or value == enum_item.Name or value == enum_item.Value then return enum_item end
&#9;&#9;end
&#9;else
&#9;&#9;error(&quot;The &apos;enum&apos; argument must be an enum.&quot;, 2)
&#9;end
&#9;error(&quot;The value cannot be coerced into a enum item of the specified type.&quot;, 2)
end

function lib.isOfEnumType(value, enum)
&#9;-- Returns whether &apos;value&apos; is coercible into an enum item of the type &apos;enum&apos;.
&#9;if lib.isAnEnum(enum) then
&#9;&#9;return pcall(lib.coerceIntoEnum, value, enum) == true
&#9;else
&#9;&#9;error(&quot;The &apos;enum&apos; argument must be an enum.&quot;, 2)
&#9;end
end

function lib.isAColor3(value)
&#9;-- Returns whether &apos;value&apos; is a Color3 value.
&#9;return pcall(set, Instance.new(&apos;Color3Value&apos;), &apos;Value&apos;, value) == true
end

function lib.isACoordinateFrame(value)
&#9;-- Returns whether &apos;value&apos; is a CFrame value.
&#9;return pcall(set, Instance.new(&apos;CFrameValue&apos;), &apos;Value&apos;, value) == true
end

function lib.isABrickColor(value)
&#9;-- Returns whether &apos;value&apos; is a BrickColor value.
&#9;return pcall(set, Instance.new(&apos;BrickColorValue&apos;), &apos;Value&apos;, value) == true
end

function lib.isARay(value)
&#9;-- Returns whether &apos;value&apos; is a Ray value.
&#9;return pcall(set, Instance.new(&apos;RayValue&apos;), &apos;Value&apos;, value) == true
end

function lib.isAVector3(value)
&#9;-- Returns whether &apos;value&apos; is a Vector3 value.
&#9;return pcall(set, Instance.new(&apos;Vector3Value&apos;), &apos;Value&apos;, value) == true
end

function lib.isAVector2(value)
&#9;-- Returns whether &apos;value&apos; is a Vector2 value.
&#9;return pcall(function() return Vector2.new() + value end) == true
end

function lib.isAUdim2(value)
&#9;-- Returns whether &apos;value&apos; is a UDim2 value.
&#9;return pcall(set, Instance.new(&apos;Frame&apos;), &apos;Position&apos;, value) == true
end

function lib.isAUDim(value)
&#9;-- Returns whether &apos;value&apos; is a UDim value.
&#9;return pcall(function() return UDim.new() + value end) == true
end

function lib.isAAxis(value)
&#9;-- Returns whether &apos;value&apos; is an Axes value.
&#9;return pcall(set, Instance.new(&apos;ArcHandles&apos;), &apos;Axes&apos;, value) == true
end

function lib.isAFace(value)
&#9;-- Returns whether &apos;value&apos; is a Faces value.
&#9;return pcall(set, Instance.new(&apos;Handles&apos;), &apos;Faces&apos;, value) == true
end

function lib.isASignal(value)
&#9;-- Returns whether &apos;value&apos; is a RBXScriptSignal.
&#9;local success, connection = pcall(function() return Game.AllowedGearTypeChanged.connect(value) end)
&#9;if success and connection then
&#9;&#9;connection:disconnect()
&#9;&#9;return true
&#9;end
end

&#9;
function lib.getType(value)
&#9;-- Returns the most specific obtainable type of a value it can.
&#9;-- Useful for error messages or anything that is meant to be shown to the user.

&#9;local valueType = type(value)

&#9;if valueType == &apos;userdata&apos; then
&#9;&#9;if lib.isAnInstance(value) then return value.ClassName
&#9;&#9;elseif lib.isAColor3(value) then return &apos;Color3&apos;
&#9;&#9;elseif lib.isACoordinateFrame(value) then return &apos;CFrame&apos;
&#9;&#9;elseif lib.isABrickColor(value) then return &apos;BrickColor&apos;
&#9;&#9;elseif lib.isAUDim2(value) then return &apos;UDim2&apos;
&#9;&#9;elseif lib.isAUDim(value) then return &apos;UDim&apos;
&#9;&#9;elseif lib.isAVector3(value) then return &apos;Vector3&apos;
&#9;&#9;elseif lib.isAVector2(value) then return &apos;Vector2&apos;
&#9;&#9;elseif lib.isARay(value) then return &apos;Ray&apos;
&#9;&#9;elseif lib.isAnEnum(value) then return &apos;Enum&apos;
&#9;&#9;elseif lib.isASignal(value) then return &apos;RBXScriptSignal&apos;
&#9;&#9;elseif lib.isALibrary(value) then return &apos;RbxLibrary&apos;
&#9;&#9;elseif lib.isAAxis(value) then return &apos;Axes&apos;
&#9;&#9;elseif lib.isAFace(value) then return &apos;Faces&apos;
&#9;&#9;end
&#9;else
&#9;&#9;return valueType;
&#9;end
end

function lib.isAnInt(value)
&#9;-- Returns whether &apos;value&apos; is an interger or not
&#9;return type(value) == &quot;number&quot; and value % 1 == 1;
end


function lib.isPositiveInt(number)
&#9;-- Returns whether &apos;value&apos; is a positive interger or not.  
&#9;-- Useful for money transactions, and is used in the method isAnArray ( )
&#9;return type(value) == &quot;number&quot; and number &gt; 0 and math.floor(number) == number
end


function lib.isAnArray(value)
&#9;-- Returns if &apos;value&apos; is an array or not

&#9;if type(value) == &quot;table&quot; then
&#9;&#9;local maxNumber = 0;
&#9;&#9;local totalCount = 0;

&#9;&#9;for index, _ in next, value do
&#9;&#9;&#9;if lib.isPositiveInt(index) then
&#9;&#9;&#9;&#9;maxNumber = math.max(maxNumber, index)
&#9;&#9;&#9;&#9;totalCount = totalCount + 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;return false;
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;return maxNumber == totalCount;
&#9;else
&#9;&#9;return false;
&#9;end
end

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX32">
					<Properties>
						<string name="Name">OverriddenConfiguration</string>
						<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local Players           = game:GetService(&quot;Players&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)

qSystems:Import(getfenv(0));

-- OverriddenConfiguration.lua
-- @author Quenty
-- Last modified January 25th, 2014

--[[-- Change log
-- Janaurty 26th, 2014
- Added change log
- Updated so UserConfiguration may be nil

-- January 25th, 2014
- Wrote initial script

--]]
local lib = {}

local function MakeOverridenConfiguration(UserConfiguration, DefaultConfiguration)
&#9;--- Makes a configuration that can be overridden be a user when constructing. Shallow update.
&#9;-- @param UserConfiguration Table. The configuration that the user provides. May be incomplete or empty.
&#9;-- @param DefaultConfiguration Table. The default configuration. 
&#9;
&#9;if UserConfiguration then
&#9;&#9;local NewTable = {}

&#9;&#9;for Index, Value in pairs(DefaultConfiguration) do
&#9;&#9;&#9;if UserConfiguration[Index] then
&#9;&#9;&#9;&#9;NewTable[Index] = UserConfiguration[Index]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;NewTable[Index] = Value
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;return NewTable
&#9;else
&#9;&#9;return DefaultConfiguration
&#9;end
end
lib.MakeOverridenConfiguration = MakeOverridenConfiguration
lib.makeOverridenConfiguration = MakeOverridenConfiguration
lib.New = MakeOverridenConfiguration
lib.new = MakeOverridenConfiguration

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX33">
					<Properties>
						<string name="Name">EnumInterpreter</string>
						<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local qString           = LoadCustomLibrary(&quot;qString&quot;)

local lib               = {}

-- EnumInterpreter.lua
-- @author Quenty
-- Last Modified February 3rd, 2014

qSystems:import(getfenv(0));

local function Scan(Table, StringName)
&#9;for Index, Value in pairs(Table) do
&#9;&#9;if qString.CompareStrings(Value, StringName) then
&#9;&#9;&#9;return Index;
&#9;&#9;end
&#9;end
&#9;return nil;
end

local function ScanName(Table, StringName)
&#9;for Index, Value in pairs(Table) do
&#9;&#9;if qString.CompareStrings(Value, StringName) then
&#9;&#9;&#9;return Value;
&#9;&#9;end
&#9;end
&#9;return nil;
end

local function GetEnum(EnumTable, EnumValue) 
--[[ Given a table structured like this:

&#9;Foods = {
&#9;&#9;&quot;Pizza&quot;;
&#9;&#9;&quot;Pie&quot;;
&#9;&#9;&quot;Vanilla&quot;;
&#9;}

&#9;And an EnumValue, like one of the following:
&#9;&#9;pizza
&#9;&#9;pie
&#9;&#9;vanilla
&#9;&#9;0
&#9;&#9;1
&#9;&#9;2

&#9;It&apos;ll return the enum ID (Number)...

&#9;&#9;pizze --&gt; 0
&#9;&#9;0 --&gt; 0

&#9;&#9;etc. 
--]]

&#9;if tonumber(EnumValue) and EnumTable[tonumber(EnumValue)] then
&#9;&#9;return EnumValue;
&#9;else
&#9;&#9;local ScanResult = Scan(EnumTable, EnumValue)
&#9;&#9;if ScanResult and tonumber(ScanResult) then
&#9;&#9;&#9;return ScanResult;
&#9;&#9;else
&#9;&#9;&#9;error(&quot;EnumValue expected, could not interpret &apos;&quot;..tostring(EnumValue)..&quot;&apos; into an Enum #&quot;)
&#9;&#9;end
&#9;end
end

lib.getEnum = GetEnum;
lib.GetEnum = GetEnum;
lib.get_enum = GetEnum;

local function GetEnumName(EnumTable, EnumValue)
&#9;if tonumber(EnumValue) and EnumTable[tonumber(EnumValue)] then
&#9;&#9;return EnumTable[tonumber(EnumValue)];
&#9;else
&#9;&#9;local ScanResult = ScanName(EnumTable, EnumValue)
&#9;&#9;if ScanResult then
&#9;&#9;&#9;return ScanResult;
&#9;&#9;else
&#9;&#9;&#9;error(&quot;EnumValue expected, could not interpret &apos;&quot;..tostring(EnumValue)..&quot;&apos; into an Enum #&quot;)
&#9;&#9;end
&#9;end
end

lib.getEnumName = GetEnumName;
lib.GetEnumName = GetEnumName;
lib.get_enum_name = GetEnumName;



return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX34">
					<Properties>
						<string name="Name">EasyConfiguration</string>
						<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local Type              = LoadCustomLibrary(&quot;Type&quot;)

qSystems:Import(getfenv(0));

-- EasyConfiguration.lua
-- @author Quenty
-- Last Modified February 3rd, 2014

local lib = {}

local AcceptableTypes = { -- Anything in here has a .Value property. 
&#9;[&quot;StringValue&quot;]         = true;
&#9;[&quot;IntValue&quot;]            = true;
&#9;[&quot;NumberValue&quot;]         = true;
&#9;[&quot;BrickColorValue&quot;]     = true;
&#9;[&quot;BoolValue&quot;]           = true;
&#9;[&quot;Color3Value&quot;]         = true;
&#9;[&quot;Vector3Value&quot;]        = true;
&#9;[&quot;IntConstrainedValue&quot;] = true;
}

local function TypeIsAcceptable(TypeName)
&#9;return AcceptableTypes[TypeName]
end
lib.TypeIsAcceptable = TypeIsAcceptable;
lib.typeIsAcceptable = TypeIsAcceptable

local function AddSubDataLayer(DataName, Parent)
&#9;-- For organization of data. Adds another configuration with the name &quot;DataName&quot;, if one can&apos;t be found, and then returns it. 

&#9;local DataContainer = Parent:FindFirstChild(DataName) or Make(&quot;Configuration&quot;, {
&#9;&#9;Name = DataName;
&#9;&#9;Parent = Parent;
&#9;&#9;Archivable = true;
&#9;})

&#9;return DataContainer
end
lib.AddSubDataLayer = AddSubDataLayer
lib.addSubDataLayer = AddSubDataLayer

local EasyConfigCache = {}
setmetatable(EasyConfigCache, {__mode = &quot;k&quot;})

local function MakeEasyConfiguration(Configuration)
&#9;if EasyConfigCache[Configuration] then
&#9;&#9;return EasyConfigCache[Configuration]
&#9;else
&#9;&#9;local NewConfiguration = {}

&#9;&#9;local function Get(ObjectName)
&#9;&#9;&#9;return Configuration:FindFirstChild(ObjectName)
&#9;&#9;end

&#9;&#9;setmetatable(NewConfiguration, {
&#9;&#9;&#9;__index = function(_, value)

&#9;&#9;&#9;&#9;if not type(value) == &quot;string&quot; then
&#9;&#9;&#9;&#9;&#9;error(&quot;Only Indexing with strings is supported with easyConfiguration&quot;, 2)
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;local loweredValue = value:lower()

&#9;&#9;&#9;&#9;if loweredValue == &quot;add&quot; or loweredValue == &quot;addvalue&quot; then
&#9;&#9;&#9;&#9;&#9;--[[ 
&#9;&#9;&#9;&#9;&#9;So they can do stuff like... Config.AddValue(&apos;IntValue&apos;, {
&#9;&#9;&#9;&#9;&#9;&#9;Name = &quot;PizzaEaten&quot;
&#9;&#9;&#9;&#9;&#9;&#9;Value = 0;
&#9;&#9;&#9;&#9;&#9;})

&#9;&#9;&#9;&#9;&#9;--]]
&#9;&#9;&#9;&#9;&#9;return function(valueType, values)
&#9;&#9;&#9;&#9;&#9;&#9;local Object

&#9;&#9;&#9;&#9;&#9;&#9;if values and values.Name and type(values.Name) == &quot;string&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Object = Get(values.Name)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if Object and Object.ClassName ~= valueType then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;[EasyConfiguration] - Invalid class &apos;&quot;..Object.ClassName..&quot;&apos; in configuration, being replaced by new data &apos;&quot;..valueType..&quot;&apos;&quot;);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Object:Destroy()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Object = nil;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;[EasyConfiguration] - No values received in the add method of easy configuration. Please give a table of default properties including the name. &quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;if not Object then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local newInstance = Instance.new(valueType)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Modify(newInstance, values)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;newInstance.Parent = Configuration
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;elseif loweredValue == &quot;get&quot; or loweredValue == &quot;getvalue&quot; then
&#9;&#9;&#9;&#9;&#9;return function(name)
&#9;&#9;&#9;&#9;&#9;&#9;return Get(name)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;elseif loweredValue == &quot;getcontainer&quot; then
&#9;&#9;&#9;&#9;&#9;return function(name)
&#9;&#9;&#9;&#9;&#9;&#9;return Get(name)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;local Object = Configuration:FindFirstChild(value)
&#9;&#9;&#9;&#9;&#9;if Object and AcceptableTypes[Object.ClassName] then
&#9;&#9;&#9;&#9;&#9;&#9;return Object.Value
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;[EasyConfiguration] - &quot; .. (Object and &quot;Object &apos;&quot;..value..&quot;&apos; was a &quot;..Type.getType(Object)..&quot; value, and not acceptable, so no return was given&quot; or &quot;Could not find Object &apos;&quot;..value..&quot;&apos; in the configuration&quot;), 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;&#9;__newindex = function(_, value, newValue)
&#9;&#9;&#9;&#9;if type(value) == &quot;string&quot; then
&#9;&#9;&#9;&#9;&#9;local Object = Get(value)
&#9;&#9;&#9;&#9;&#9;if Object and AcceptableTypes[Object.ClassName] then
&#9;&#9;&#9;&#9;&#9;&#9;Object.Value = newValue;
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;[EasyConfiguration] - Value &apos;&quot; .. value .. &quot;&apos; was not accepted, or wasn&apos;t in the configuration&quot;, 2);
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&quot;[EasyConfiguration] - Index with a string&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;})

&#9;&#9;EasyConfigCache[Configuration] = NewConfiguration
&#9;&#9;return NewConfiguration;
&#9;end
end

lib.Make = MakeEasyConfiguration;
lib.MakeEasyConfiguration = MakeEasyConfiguration;

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="Backpack" referent="RBX35">
					<Properties>
						<string name="Name">DataTypes</string>
					</Properties>
					<Item class="ModuleScript" referent="RBX36">
						<Properties>
							<string name="Name">qColor3</string>
							<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local qString           = LoadCustomLibrary(&quot;qString&quot;)
local qMath             = LoadCustomLibrary(&quot;qMath&quot;)

qSystems:Import(getfenv(0));

local RbxUtility = LoadLibrary(&quot;RbxUtility&quot;)

local lib = {}

--- Manipulation and seralization of Color3 Values
-- @author Quenty
-- Last modified January 3rd, 2013

local function EncodeColor3(Color3)
&#9;--- Encodes a Color3 in JSON
&#9;-- @param Color3 The Color3 to encode
&#9;-- @return String The string representation in JSON of the Color3 value.

&#9;local NewData = {
&#9;&#9;Color3.r;
&#9;&#9;Color3.g;
&#9;&#9;Color3.b;
&#9;}

&#9;return RbxUtility.EncodeJSON(NewData)
end
lib.EncodeColor3 = EncodeColor3
lib.encodeColor3 = EncodeColor3
lib.Encode = EncodeColor3
lib.encode = EncodeColor3

local function DecodeColor3(Data)
&#9;--- decode&apos;s a previously encoded Color3.
&#9;-- @param Data String of JSON, that was encoded.
&#9;-- @return Color3 if it could be decoded, otherwise, nil
&#9;
&#9;if Data then
&#9;&#9;local DecodedData = RbxUtility.DecodeJSON(Data)
&#9;&#9;if DecodedData then
&#9;&#9;&#9;return Color3.new(unpack(DecodedData))
&#9;&#9;else
&#9;&#9;&#9;return nil
&#9;&#9;end
&#9;else
&#9;&#9;return nil
&#9;end
end
lib.DecodeColor3 = DecodeColor3
lib.decodeColor3 = DecodeColor3
lib.Decode = DecodeColor3
lib.decode = DecodeColor3

local LerpNumber = qMath.LerpNumber

local function LerpColor3(ColorOne, ColorTwo, Alpha)
&#9;--- Interpolates between two color3 values. 
&#9;-- @param ColorOne The first Color
&#9;-- @param ColorTwo The second color
&#9;-- @param Alpha The amount to interpolate between
&#9;-- @return The resultent Color3 value. 
&#9;
&#9;return Color3.new(LerpNumber(ColorOne.r, ColorTwo.r, Alpha), LerpNumber(ColorOne.g, ColorTwo.g, Alpha), LerpNumber(ColorOne.b, ColorTwo.b, Alpha))
end
lib.LerpColor3 = LerpColor3
lib.lerpColor3 = LerpColor3

return lib</ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX37">
						<Properties>
							<string name="Name">qInstance</string>
							<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)

qSystems:Import(getfenv(0))

local lib = {}

-- See Type library for more identification stuff.
-- @author Quenty
-- Last Modified Februrary 9th, 2014

--[[
Change log

February 15th, 2014
- Added GetPartVolume

--]]

local function GetBricks(StartInstance)
&#9;local List = {}

&#9;-- if StartInstance:IsA(&quot;BasePart&quot;) then
&#9;-- &#9;List[#List+1] = StartInstance
&#9;-- end

&#9;CallOnChildren(StartInstance, function(Item)
&#9;&#9;if Item:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;List[#List+1] = Item;
&#9;&#9;end
&#9;end)

&#9;return List;
end
lib.GetBricks  = GetBricks
lib.get_bricks = GetBricks
lib.getBricks  = GetBricks

local function GetBricksWithIgnore(StartInstance, NoInclude)
&#9;--- Get&apos;s the bricks in a model, but will not get a brick that is &quot;NoInclude&quot;

&#9;local List = {}

&#9;CallOnChildren(StartInstance, function(Item)
&#9;&#9;if Item:IsA(&quot;BasePart&quot;) and Item ~= NoInclude then
&#9;&#9;&#9;List[#List+1] = Item;
&#9;&#9;end
&#9;end)

&#9;return List;
end
lib.GetBricksWithIgnore = GetBricksWithIgnore
lib.getBricksWithIgnore = GetBricksWithIgnore

local function GetBricksWithIgnoreFunction(StartInstance, DoIgnore)
&#9;--- Get&apos;s the bricks in a model, but will not get a brick that is &quot;NoInclude&quot;

&#9;local List = {}

&#9;CallOnChildren(StartInstance, function(Item)
&#9;&#9;if Item:IsA(&quot;BasePart&quot;) and not DoIgnore(Item) then
&#9;&#9;&#9;List[#List+1] = Item
&#9;&#9;end
&#9;end)

&#9;return List
end
lib.GetBricksWithIgnoreFunction = GetBricksWithIgnoreFunction
lib.getBricksWithIgnoreFunction = GetBricksWithIgnoreFunction

local function GetPartVolume(Part, CountWedgesAsSolids)
&#9;-- Returns a parts volume.
&#9;-- @param Part The part to get the volume for
&#9;-- @param CountWedgesAsSolids Boolean, if true, counts a wedge part as a solid.
&#9;
&#9;local Size = Part.Size
&#9;if Part:IsA(&quot;Part&quot;) or CountWedgesAsSolids then
&#9;&#9;return Size.X * Size.Y * Size.Z
&#9;elseif Part:IsA(&quot;WedgePart&quot;) then
&#9;&#9;return (Size.X * Size.Y * Size.Z) / 2
&#9;elseif Part:IsA(&quot;CornerWedgePart&quot;) then
&#9;&#9;return (Size.X * Size.Y * Size.Z) / 3
&#9;else
&#9;&#9;error(&quot;[GetPartVolume] - Not a part&quot;)
&#9;end
end
lib.GetPartVolume = GetPartVolume
lib.getPartVolume = GetPartVolume
lib.get_part_volume = GetPartVolume


return lib</ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX38">
						<Properties>
							<string name="Name">qString</string>
							<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local Type              = LoadCustomLibrary(&quot;Type&quot;)
local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)

qSystems:Import(getfenv(0));

-- @author Quenty
-- Revised January 2nd, 2013
-- This script provides utility functions for strings

-- Change Log --
--- Removed VerifyArg methods

local lib = {}

local function CompareStrings(firstString, secondString)
&#9;-- Compares two strings, ignoring capitals.
&#9;-- @return Boolean if the string found match

&#9;return string.lower(firstString) == string.lower(secondString);
end
lib.CompareStrings = CompareStrings;
lib.compareStrings = CompareStrings;
lib.compare_strings = CompareStrings;
lib.Compare = CompareStrings
lib.compare = CompareStrings
-- lib.Equals = CompareStrings
-- lib.equals = CompareStrings

local function CompareCutFirst(firstString, secondString)
&#9;-- Compare&apos;s two strings, but only the beginning of the first string, to see if it matches the second one
&#9;-- @param firstString The string to &quot;cut&quot; off of
&#9;-- @param secondString The string to compare direct to
&#9;-- @return Boolean if a match or not

&#9;return string.lower(firstString):sub(1, #secondString) == string.lower(secondString);
end
lib.CompareCutFirst = CompareCutFirst;
lib.compareCutFirst = CompareCutFirst;
lib.compare_cut_first = CompareCutFirst;

local function CutoutPrefix(firstString, prefix)

&#9;return firstString:sub(#prefix + 1);
end

local PatternCache = {}
setmetatable(PatternCache, {__mode = &quot;k&quot;})

local function BreakString(StringA, Seperator)
&#9;-- Tokenizer system.. In heinsight, 2 years later, Should really be a factory function. Urgh. 
&#9;-- @param Seperator The deliminator 

&#9;local Pattern = Seperator 
&#9;local ActualSeperator = Seperator 

&#9;if type(Seperator) ~= &quot;string&quot; then 
&#9;&#9;if PatternCache[Seperator] then
&#9;&#9;&#9;Pattern = PatternCache[Seperator]
&#9;&#9;&#9;ActualSeperator = Seperator[1]
&#9;&#9;else
&#9;&#9;&#9;Pattern = &quot;[&quot; 
&#9;&#9;&#9;for _, PotentialSeperator in pairs(Seperator) do 
&#9;&#9;&#9;&#9;if #PotentialSeperator == 1 then 
&#9;&#9;&#9;&#9;&#9;Pattern = Pattern..&quot;%&quot;..PotentialSeperator 
&#9;&#9;&#9;&#9;&#9;ActualSeperator = PotentialSeperator; 
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;error(&quot;A Seperator must be 1 character, it was &quot;..#PotentialSeperator..&quot; characters long.&quot;); 
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;end 
&#9;&#9;&#9;Pattern = Pattern..&quot;]&quot;; 
&#9;&#9;&#9;PatternCache[Seperator] = Pattern
&#9;&#9;end
&#9;elseif #Seperator ~= 1 then
&#9;&#9;error(&quot;Seperator must be 1  character, it was &quot;..#Seperator..&quot; characters long.&quot;); 
&#9;end 

&#9;local Parts = {} 
&#9;for NewString in string.gmatch(StringA..ActualSeperator, &quot;.-&quot;..Pattern) do 
&#9;&#9;if not (#NewString &lt;= 1) then
&#9;&#9;&#9;Parts[#Parts+1] = NewString:sub(1, #NewString-1); 
&#9;&#9;-- else
&#9;&#9;-- &#9;print(&quot;Empty string: &apos;&quot;..NewString..&quot;&apos;&quot;)
&#9;&#9;end
&#9;end 

&#9;return Parts; 
end
lib.breakString = BreakString;
lib.BreakString = BreakString;
lib.break_string = BreakString;

local function TrimString(str, pattern)
&#9;pattern = pattern or &quot;%s&quot;;
&#9;-- %S is whitespaces
&#9;-- When we find the first non space character defined by ^%s 
&#9;-- we yank out anything in between that and the end of the string 
&#9;-- Everything else is replaced with %1 which is essentially nothing  

&#9;-- Credit Sorcus, Modified by Quenty
&#9;return (str:gsub(&quot;^&quot;..pattern..&quot;*(.-)&quot;..pattern..&quot;*$&quot;, &quot;%1&quot;))
end 
lib.TrimString = TrimString
lib.trimString = TrimString
lib.trim_string = TrimString

local function TrimStringFront(str, pattern)
&#9;pattern = pattern or &quot;%s&quot;;

&#9;-- Only trims the front of the string...
&#9;return (str:gsub(&quot;^&quot;..pattern..&quot;*(.-)&quot;..pattern..&quot;*&quot;, &quot;%1&quot;))
end 
lib.TrimStringFront = TrimStringFront
lib.trimStringFront = TrimStringFront
lib.trim_stream_front = TrimStringFront

local function GetRestOfSemiTokenizedString(StringA, Seperator, Counts)
&#9;-- Get&apos;s the rest of a string past a tokenizer count...

&#9;-- Much hax.

&#9;local Count = 0
&#9;local PartToCutOff = 0
&#9;local Pattern = Seperator 
&#9;local ActualSeperator = Seperator 

&#9;if type(Seperator) ~= &quot;string&quot; then 
&#9;&#9;if PatternCache[Seperator] then
&#9;&#9;&#9;Pattern = PatternCache[Seperator]
&#9;&#9;&#9;ActualSeperator = Seperator[1]
&#9;&#9;else
&#9;&#9;&#9;Pattern = &quot;[&quot; 
&#9;&#9;&#9;for _, PotentialSeperator in pairs(Seperator) do 
&#9;&#9;&#9;&#9;if #PotentialSeperator == 1 then 
&#9;&#9;&#9;&#9;&#9;Pattern = Pattern..&quot;%&quot;..PotentialSeperator 
&#9;&#9;&#9;&#9;&#9;ActualSeperator = PotentialSeperator; 
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;error(&quot;A Seperator must be 1 character, it was &quot;..#PotentialSeperator..&quot; characters long.&quot;); 
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;end 
&#9;&#9;&#9;Pattern = Pattern..&quot;]&quot;; 
&#9;&#9;&#9;PatternCache[Seperator] = Pattern
&#9;&#9;end
&#9;elseif #Seperator ~= 1 then
&#9;&#9;error(&quot;Seperator must be 1  character, it was &quot;..#Seperator..&quot; characters long.&quot;); 
&#9;end

&#9;for NewString in string.gmatch(StringA..ActualSeperator, &quot;.-&quot;..Pattern) do 
&#9;&#9;if not (#NewString &lt;= 1) then
&#9;&#9;&#9;PartToCutOff = PartToCutOff + #NewString
&#9;&#9;&#9;Count = Count + 1
&#9;&#9;&#9;if Count &gt;= Counts then
&#9;&#9;&#9;&#9;return TrimStringFront(StringA:sub(PartToCutOff), Pattern)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;PartToCutOff = PartToCutOff + 1;
&#9;&#9;end
&#9;end
end
lib.GetRestOfSemiTokenizedString = GetRestOfSemiTokenizedString
lib.getRestOfSemiTokenizedString = GetRestOfSemiTokenizedString
lib.get_rest_of_semi_tokenized_string = GetRestOfSemiTokenizedString

local function IsWhitespace(Text) 
&#9;return string.match(Text, &quot;[%s]+&quot;) == Text
end
lib.isWhitespace = IsWhitespace
lib.IsWhitespace = IsWhitespace
lib.is_whitespace = IsWhitespace

local function DumbElipseLimit(Text, CharacterLimit) 
&#9;if #Text &gt; CharacterLimit then 
&#9;&#9;Text = Text:sub(1, CharacterLimit-3)..&quot;...&quot; 
&#9;end 
&#9;return Text 
end
lib.DumbElipseLimit = DumbElipseLimit
lib.dumbElipseLimit = DumbElipseLimit

local function CheckNumOfCharacterInString(TheString, Character)
&#9;local Number = 0
&#9;for ID in string.gmatch(TheString, Character) do 
&#9;&#9;Number = Number + 1;
&#9;end
&#9;--print(&quot;Checked Num for \&quot;&quot;..TheStr&#9;ng..&quot;\&quot; with the Character \&quot;&quot;..Character..&quot;\&quot; and got &quot;..Number)
&#9;return Number;
end
lib.CheckNumOfCharacterInString = CheckNumOfCharacterInString
lib.checkNumOfCharacterInString = CheckNumOfCharacterInString


local function GetRomanNumeral(Number)
&#9;--- Return&apos;s the Roman Numeral version of the number
&#9;-- @param Number The number to convert

&#9;if type(Number) == &quot;number&quot; then
&#9;&#9;local Numbers = {1000; 900; 500; 400; 100; 90; 50; 40; 10; 9; 5; 4; 1;};
&#9;&#9;local Numerals = {&quot;M&quot;; &quot;CM&quot;; &quot;D&quot;; &quot;CD&quot;; &quot;C&quot;; &quot;XC&quot;; &quot;L&quot;; &quot;XL&quot;; &quot;X&quot;; &quot;IX&quot;; &quot;V&quot;; &quot;IV&quot;; &quot;I&quot;;}
&#9;&#9;local Result = &quot;&quot;;
&#9;&#9;if Number &lt; 0 or Number &gt;= 4000 then
&#9;&#9;&#9;return nil;
&#9;&#9;elseif Number == 0 then
&#9;&#9;&#9;return &quot;N&quot;;
&#9;&#9;else
&#9;&#9;&#9;for Index=1, 13 do
&#9;&#9;&#9;&#9;while Number &gt;= Numbers[Index] do
&#9;&#9;&#9;&#9;&#9;Number = Number - Numbers[Index];
&#9;&#9;&#9;&#9;&#9;Result = Result..Numerals[Index];
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return Result;
&#9;elseif type(Number == &quot;string&quot;) then
&#9;&#9;Number = string.upper(Number);
&#9;&#9;local Result = 0;

&#9;&#9;local RomanDigit = {
&#9;&#9;&#9;[&quot;I&quot;] = 1;
&#9;&#9;&#9;[&quot;V&quot;] = 5;
&#9;&#9;&#9;[&quot;X&quot;] = 10;
&#9;&#9;&#9;[&quot;L&quot;] = 50;
&#9;&#9;&#9;[&quot;C&quot;] = 100;
&#9;&#9;&#9;[&quot;D&quot;] = 500;
&#9;&#9;&#9;[&quot;M&quot;] = 1000;
&#9;&#9;}

&#9;&#9;local SpecialRomanDigit = {
&#9;&#9;&#9;[&quot;I&quot;] = 1;
&#9;&#9;&#9;[&quot;X&quot;] = 10;
&#9;&#9;&#9;[&quot;C&quot;] = 100;
&#9;&#9;}

&#9;&#9;if Number == &quot;N&quot; then 
&#9;&#9;&#9;return 0;
&#9;&#9;elseif CheckNumOfCharacterInString(Number, &quot;V&quot;) &gt;= 2 or CheckNumOfCharacterInString(Number, &quot;L&quot;) &gt;= 2 or CheckNumOfCharacterInString(Number, &quot;D&quot;) &gt;= 2 then --(#{string.find(Number, &quot;V*.V&quot;)} &gt;= 2) or (#{string.find(Number, &quot;L*.L&quot;)} &gt;= 2) or (#{string.find(Number, &quot;D*.D&quot;)} &gt;= 2) then
&#9;&#9;&#9;print(&quot;Rule 4&quot;);
&#9;&#9;&#9;return nil; 
&#9;&#9;end

&#9;&#9;local Last = &quot;Z&quot;
&#9;&#9;local Count = 1;

&#9;&#9;for i=1, #Number do
&#9;&#9;&#9;local Numeral = string.sub(Number, i, i)
&#9;&#9;&#9;if not RomanDigit[Numeral] then
&#9;&#9;&#9;&#9;print(&quot;Invalid Numeral&quot;);
&#9;&#9;&#9;&#9;return nil;
&#9;&#9;&#9;end
&#9;&#9;&#9;if Numeral == Last then
&#9;&#9;&#9;&#9;Count = Count + 1;
&#9;&#9;&#9;&#9;if Count &gt;= 4 then
&#9;&#9;&#9;&#9;&#9;print(&quot;Rule 4 (Second check)&quot;);
&#9;&#9;&#9;&#9;&#9;return nil;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Count = 1;
&#9;&#9;&#9;end
&#9;&#9;&#9;Last = Numeral
&#9;&#9;end

&#9;&#9;local Pointer = 1;
&#9;&#9;local Values = {}
&#9;&#9;local MaxDigit = 1000;

&#9;&#9;while Pointer &lt;= #Number do
&#9;&#9;&#9;local Numeral = string.sub(Number, Pointer, Pointer)
&#9;&#9;&#9;local Digit = RomanDigit[Numeral]

&#9;&#9;&#9;if Digit &gt; MaxDigit then
&#9;&#9;&#9;&#9;print(&quot;Rule 3&quot;);
&#9;&#9;&#9;&#9;return nil;
&#9;&#9;&#9;end

&#9;&#9;&#9;local NextDigit = 0;
&#9;&#9;&#9;if Pointer &lt;= #Number - 1 then
&#9;&#9;&#9;&#9;local NextNumeral = string.sub(Number, Pointer+1, Pointer+1);
&#9;&#9;&#9;&#9;NextDigit = RomanDigit[NextNumeral]

&#9;&#9;&#9;&#9;if NextDigit &gt; Digit then
&#9;&#9;&#9;&#9;&#9;if (not SpecialRomanDigit[Numeral]) or NextDigit &gt; (Digit * 10) or CheckNumOfCharacterInString(Number, Numeral) &gt; 3 then --(#{string.find(Number, Numeral..&quot;*.&quot;..Numeral)} &gt;= 3) then
&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;Rule 3 (Second check)&quot;);
&#9;&#9;&#9;&#9;&#9;&#9;return nil;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;MaxDigit = Digit - 1;
&#9;&#9;&#9;&#9;&#9;Digit = NextDigit - Digit
&#9;&#9;&#9;&#9;&#9;Pointer = Pointer + 1;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;Values[#Values + 1] = Digit
&#9;&#9;&#9;Pointer = Pointer + 1;
&#9;&#9;end

&#9;&#9;--print(&quot;#Values = &quot;..#Values)
&#9;&#9;for Index = 1, #Values-1 do
&#9;&#9;&#9;print(Index..&quot; : &quot;..Values[Index])
&#9;&#9;&#9;if Values[Index] &lt; Values[Index + 1] then
&#9;&#9;&#9;&#9;print(&quot;Rule 5&quot;);
&#9;&#9;&#9;&#9;return nil;
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;local Total = 0;
&#9;&#9;for Index, Digit in pairs(Values) do
&#9;&#9;&#9;Total = Total + Digit;
&#9;&#9;end
&#9;&#9;return Total;
&#9;end
end
lib.GetRomanNumeral = GetRomanNumeral
lib.getRomanNumeral = GetRomanNumeral

return lib</ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX39">
						<Properties>
							<string name="Name">Table</string>
							<ProtectedString name="Source">-- This library handles a variety of table-based operations, which can be quite useful.
-- @author Quenty
-- Revised January 1st, 2013

local lib = {}

local function Count(Table)
&#9;local Count = 0;
&#9;for _, _ in pairs(Table) do
&#9;&#9;Count = Count + 1
&#9;end
&#9;return Count
end
lib.Count = Count
lib.count = Count

local function CopyAndAppendTable(OriginalTable, Appendees)
&#9;-- Copies a table, and appends the values in appendees.

&#9;local NewTable = {}

&#9;for Index, Value in pairs(OriginalTable) do
&#9;&#9;NewTable[Index] = Value;
&#9;end

&#9;for Index, Value in pairs(Appendees) do
        NewTable[Index] = Value;
    end

&#9;return NewTable;
end
lib.CopyAndAppend = CopyAndAppendTable
lib.copyAndAppend = CopyAndAppendTable
lib.copy_and_append = CopyAndAppendTable


local GetStringTable
function GetStringTable(Array, Indent, PrintValue)
&#9;-- Print&apos;s `Array` recursively with `Indent` as the initial indent
&#9;-- Cheap method, but not optimal either... Used for debugging. :D

&#9;PrintValue = PrintValue or tostring(Array);
&#9;Indent = Indent or 0
&#9;for Index, Value in pairs(Array) do
&#9;&#9;local FormattedText = &quot;\n&quot; .. string.rep(&quot;  &quot;, Indent) .. tostring(Index) .. &quot;: &quot;
&#9;&#9;if type(Value) == &quot;table&quot; then
&#9;&#9;&#9;PrintValue = PrintValue .. FormattedText
&#9;&#9;&#9;PrintValue = GetStringTable(Value, Index + 1, PrintValue)
&#9;&#9;else
&#9;&#9;&#9;PrintValue = PrintValue .. FormattedText .. tostring(Value)
&#9;&#9;end
&#9;end
&#9;return PrintValue
end
lib.GetStringTable = GetStringTable
lib.getStringTable = GetStringTable
lib.get_string_table = GetStringTable


local function Append(Table, NewTable, Callback)
&#9;-- Addes all of NewTable&apos;s values to Table..

&#9;if Callback then
&#9;&#9;for _, Item in pairs(NewTable) do
&#9;&#9;&#9;if Callback(Item) then
&#9;&#9;&#9;&#9;table.insert(Table, Item)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;for _, Item in pairs(NewTable) do
&#9;&#9;&#9;table.insert(Table, Item)
&#9;&#9;end
&#9;end

&#9;return Table
end
lib.Append = Append
lib.append = Append

local function DirectAppend(Table, NewTable, Callback)
-- Addes al of NewTable&apos;s values to Table..
&#9;if Callback then
&#9;&#9;for Index, Item in pairs(NewTable) do
&#9;&#9;&#9;if Callback(Item) then
&#9;&#9;&#9;&#9;Table[Index] = Item
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;for Index, Item in pairs(NewTable) do
&#9;&#9;&#9;Table[Index] = Item
&#9;&#9;end
&#9;end

&#9;return Table
end
lib.DirectAppend = DirectAppend
lib.directAppend = DirectAppend

local function CopyTable(OriginalTable)
&#9;local OriginalType = type(OriginalTable)
&#9;local Copy
&#9;if OriginalType == &apos;table&apos; then
&#9;&#9;Copy = {}
&#9;&#9;for Index, Value in pairs(OriginalTable) do
&#9;&#9;&#9;Copy[Index] = Value
&#9;&#9;end
&#9;else
&#9;&#9;Copy = OriginalTable
&#9;end
&#9;return Copy
end

lib.Copy = CopyTable
lib.copy = CopyTable


local DeepCopy

function DeepCopyTable(OriginalTable)
&#9;local OriginalType = type(OriginalTable)
&#9;local Copy
&#9;if OriginalType == &apos;table&apos; then
&#9;&#9;Copy = {}
&#9;&#9;for Index, Value in next, OriginalTable, nil do
&#9;&#9;&#9;Copy[DeepCopy(Index)] = DeepCopy(Value)
&#9;&#9;end
&#9;&#9;setmetatable(Copy, DeepCopy(getmetatable(OriginalTable)))
&#9;else
&#9;&#9;Copy = OriginalTable
&#9;end
&#9;return Copy
end

lib.DeepCopy = DeepCopyTable
lib.deepCopy = DeepCopyTable
lib.deep_copy = DeepCopyTable

local function Swap(Table, A, B)
&#9;local Copy = Table[A]
&#9;Table[A] = Table[B]
&#9;Table[B] = Copy
end

local function ShellSort(Table, GetValue)
&#9;-- Shell Sort -- Pretty efficient... GetValue should return a number of some sort. Will sort from Least to Greatest.

&#9;local TableSize = #Table
&#9;local Gap = #Table
&#9;repeat
&#9;&#9;local Switched
&#9;&#9;repeat
&#9;&#9;&#9;Switched = false;
&#9;&#9;&#9;local Index = 1
&#9;&#9;&#9;while Index + Gap &lt;= TableSize do
&#9;&#9;&#9;&#9;if GetValue(Table[Index]) &gt; GetValue(Table[Index+Gap]) then
&#9;&#9;&#9;&#9;&#9;Swap(Table, Index, Index + Gap)
&#9;&#9;&#9;&#9;&#9;Switched = true;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;Index = Index + 1;
&#9;&#9;&#9;end
&#9;&#9;until not Switched
&#9;&#9;Gap = math.floor(Gap / 2)
&#9;until Gap == 0
end
lib.ShellSort = ShellSort
lib.shellSort = ShellSort
lib.shell_sort = ShellSort

return lib</ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX40">
						<Properties>
							<string name="Name">qMath</string>
							<ProtectedString name="Source">local lib = {}

-- qMath.lua
-- @author Quenty

local function ClampNumber(Number, Lower, Upper)
&#9;if Number &gt; Upper then
&#9;&#9;return Upper, true
&#9;elseif Number &lt; Lower then
&#9;&#9;return Lower, true
&#9;else
&#9;&#9;return Number, false
&#9;end
end
lib.ClampNumber = ClampNumber;
lib.clampNumber = ClampNumber;


local function RoundUp(Number, Base)
&#9;return math.ceil(Number/Base) * Base;
end
lib.RoundUp = RoundUp
lib.roundUp = RoundUp

local function RoundDown(Number, Base)
&#9;return math.floor(Number/Base) * Base;
end
lib.RoundDown = RoundDown
lib.roundDown = RoundDown

local function RoundNumber(number, divider)
&#9;--verifyArg(number, &quot;number&quot;, &quot;number&quot;)
&#9;--verifyArg(divider, &quot;number&quot;, &quot;divider&quot;, true)

&#9;divider = divider or 1
&#9;return (math.floor((number/divider)+0.5)*divider)
end
lib.roundNumber = RoundNumber
lib.RoundNumber = RoundNumber
lib.round_number = RoundNumber


local function Sign(Number)
&#9;if Number == 0 then
&#9;&#9;return 0
&#9;else
&#9;&#9;return Number / math.abs(Number) 
&#9;end
end
lib.Sign = Sign
lib.sign = Sign


local function Vector2ToCartisian(Vector2ToConvert, ScreenMiddle)
&#9;--return Vector2.new(Vector2ToConvert.x - ScreenMiddle.x, ScreenMiddle.y - Vector2ToConvert.y)
&#9;return Vector2ToConvert - ScreenMiddle
end
lib.Vector2ToCartisian = Vector2ToCartisian
lib.vector2ToCartisian = Vector2ToCartisian


local function Cartisian2ToVector(CartisianToConvert, ScreenMiddle)
&#9;--return Vector2.new(CartisianToConvert.x + ScreenMiddle.x, ScreenMiddle.y - CartisianToConvert.y)
&#9;return CartisianToConvert + ScreenMiddle
end
lib.Cartisian2ToVector = Cartisian2ToVector 
lib.cartisian2ToVector = Cartisian2ToVector


local function InvertCartisian2(CartisianVector2)
&#9;-- Insert&apos;s a CartisianVector2 value.
&#9;
&#9;return -CartisianVector2
end
lib.InvertCartisian2 =InvertCartisian2
lib.invertCartisian2 =InvertCartisian2

local function LerpNumber(ValueOne, ValueTwo, Alpha)
&#9;--- Interpolates betweeen two numbers, given an Alpha
&#9;-- @param ValueOne A number, the first one, should be less than ValueTwo
&#9;-- @param ValueTwo A number, the second one, should be greater than ValueTwo
&#9;-- @param Alpha The percent, a number in the range [0, 1], that will be used to define
&#9;--              how interpolated it is between ValueOne And ValueTwo
&#9;-- @return The lerped number. 

&#9;return ValueOne + ((ValueTwo - ValueOne) * Alpha)
end
lib.LerpNumber = LerpNumber 
lib.lerpNumber = LerpNumber

return lib</ProtectedString>
						</Properties>
					</Item>
				</Item>
				<Item class="Backpack" referent="RBX41">
					<Properties>
						<string name="Name">DataStructures</string>
					</Properties>
					<Item class="ModuleScript" referent="RBX42">
						<Properties>
							<string name="Name">CircularBuffer</string>
							<ProtectedString name="Source">local CircularBuffer = {}

-- A circular buffer, of defined size.
-- @author Quenty
-- Last modified Janurary 5th, 2014

--[[-- Update Log --
February 1st, 2014
- Added way to set data

January 25th, 2014
- Added Insert function / command

January 23rd, 2014
- Added replace function
- Added update log
- Added read only BufferSize property 

January 5th, 2014
- Write initial script

--]]

local function MakeCircularBuffer(BufferSize, Data)
&#9;--- A queue that has a limited &quot;size&quot; until it starts pushing
&#9;-- old items back out.
&#9;-- @param BufferSize The amount of elements in the queue before they
&#9;--                   are pushed out. 
&#9;-- @param Data Data to preuse. 

&#9;local Data = Data or {}
&#9;local NewBuffer = {}
&#9;NewBuffer.BufferSize = BufferSize -- Read only. 

&#9;BufferSize = BufferSize + 1

&#9;function NewBuffer:Add(NewItem)
&#9;&#9;--- Add&apos;s a new item to the buffer.
&#9;&#9;-- @return The removed item, if one was removed. 

&#9;&#9;table.insert(Data, 1, NewItem)

&#9;&#9;local Removed = Data[BufferSize]
&#9;&#9;Data[BufferSize] = nil
&#9;&#9;return Removed
&#9;end

&#9;function NewBuffer:GetData()
&#9;&#9;return Data
&#9;end

&#9;function NewBuffer:Replace(Index, NewItem)
&#9;&#9;--- Replace&apos;s the data in [Index] with the NewItem derived. 
&#9;&#9;-- @param Index Interger, an already existing / filled index. Will error if not. 
&#9;&#9;-- @param NewItem The item to replace the current existing item. Should not be nil. 
&#9;&#9;-- @return The old data

&#9;&#9;local OldData = Data[Index]
&#9;&#9;if OldData ~= nil then
&#9;&#9;&#9;Data[Index] = NewItem
&#9;&#9;else
&#9;&#9;&#9;error(&quot;[CircularBuffer] - Data[&quot; .. Index .. &quot;] does not exist. Cannot replace&quot;);
&#9;&#9;end

&#9;&#9;return OldData
&#9;end

&#9;function NewBuffer:Insert(Index, NewItem)
&#9;&#9;--- Insert&apos;s the new item at index, shifting the index and everything to the right (backwards).
&#9;&#9;-- Returns the old item that is removed, if an item is ermoved. 

&#9;&#9;table.insert(Data, Index, NewItem)

&#9;&#9;local Removed = Data[BufferSize]
&#9;&#9;Data[BufferSize] = nil
&#9;&#9;
&#9;&#9;return Removed
&#9;end

&#9;return NewBuffer
end
CircularBuffer.MakeCircularBuffer = MakeCircularBuffer
CircularBuffer.makeCircularBuffer = MakeCircularBuffer
CircularBuffer.make_circular_buffer = MakeCircularBuffer
CircularBuffer.New = MakeCircularBuffer
CircularBuffer.new = MakeCircularBuffer

return CircularBuffer</ProtectedString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX43">
					<Properties>
						<string name="Name">LightingManager</string>
						<ProtectedString name="Source">local Lighting = game:GetService(&quot;Lighting&quot;)
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qGUI = LoadCustomLibrary(&quot;qGUI&quot;)
local qMath = LoadCustomLibrary(&quot;qMath&quot;)

local TweenTimeOfDay do
&#9;local TweenId
&#9;
&#9;function TweenTimeOfDay(Start, Finish, TweenTime)
&#9;&#9;TweenId = TweenId + 1
&#9;&#9;local LocalTweenId = TweenId
&#9;
&#9;&#9;Spawn(function()
&#9;&#9;&#9;Lighting.TimeOfDay = Finish;
&#9;&#9;&#9;local MinutesFinish = Lighting:GetMinutesAfterMidnight()
&#9;&#9;&#9;Lighting.TimeOfDay = Start;
&#9;&#9;&#9;local MinutesStart = Lighting:GetMinutesAfterMidnight()
&#9;&#9;&#9;local TimeStart = tick()
&#9;&#9;&#9;-- print(&quot;[LIGHTING] - Tween @ &quot;..MinutesStart..&quot; to &quot;..MinutesFinish..&quot; in &quot;..TweenTime)
&#9;
&#9;&#9;&#9;while LocalTweenId == TweenId do
&#9;&#9;&#9;&#9;if TimeStart + TweenTime &lt;= tick() then
&#9;&#9;&#9;&#9;&#9;Lighting:SetMinutesAfterMidnight(MinutesFinish)
&#9;&#9;&#9;&#9;&#9;TweenId = TweenId + 1
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;local CurrentMinutesAfter = (tick() - TimeStart) / TweenTime
&#9;&#9;&#9;&#9;&#9;Lighting:SetMinutesAfterMidnight(qMath.LerpNumber(MinutesStart, MinutesFinish, CurrentMinutesAfter))
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if LocalTweenId == TweenId then
&#9;&#9;&#9;&#9;Lighting.TimeOfDay = Finish;
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

local LightingManager = {} do
&#9;local Color3Values = {
&#9;&#9;[&quot;FogColor&quot;] = true;
&#9;&#9;[&quot;Ambient&quot;] = true;
&#9;&#9;[&quot;ColorShift_Bottom&quot;] = true;
&#9;&#9;[&quot;ColorShift_Top&quot;] = true;
&#9;&#9;[&quot;OutdoorAmbient&quot;] = true;
&#9;&#9;[&quot;ShadowColor&quot;] = true;
&#9;}
&#9;
&#9;local BooleanValues = {
&#9;&#9;[&quot;Outlines&quot;] = true;
&#9;&#9;[&quot;GlobalShadows&quot;] = true;
&#9;}
&#9;
&#9;local NumberValues = {
&#9;&#9;[&quot;FogEnd&quot;] = true;
&#9;&#9;[&quot;FogStart&quot;] = true;
&#9;&#9;[&quot;Brightness&quot;] = true;
&#9;}
&#9;
&#9;function LightingManager.TweenProperties(PropertyTable, Time)
&#9;&#9;Time = Time or 0
&#9;&#9;
&#9;&#9;local TweenColor3Table = {}
&#9;&#9;local DoTweenColor3 = false
&#9;&#9;local TweenNumberTable = {}
&#9;&#9;local DoTweenNumber = false
&#9;&#9;
&#9;&#9;for PropertyName, Value in pairs(PropertyTable) do
&#9;&#9;&#9;if Color3Values[PropertyName] then
&#9;&#9;&#9;&#9;TweenColor3Table[PropertyName] = Value
&#9;&#9;&#9;&#9;DoTweenColor3 = true
&#9;&#9;&#9;elseif NumberValues[PropertyName] then
&#9;&#9;&#9;&#9;TweenNumberTable[PropertyName] = Value
&#9;&#9;&#9;&#9;DoTweenNumber = true
&#9;&#9;&#9;elseif BooleanValues[PropertyName] then
&#9;&#9;&#9;&#9;Lighting[PropertyName] = Value
&#9;&#9;&#9;elseif PropertyName == &quot;TimeOfDay&quot; then
&#9;&#9;&#9;&#9;TweenTimeOfDay(Lighting.TimeOfDay, Value, Time)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;No property with the value &quot; .. PropertyName .. &quot; that is tweenable&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if DoTweenColor3 and Time &gt; 0 then
&#9;&#9;&#9;qGUI.TweenColor3(Lighting, TweenColor3Table, Time, true)
&#9;&#9;else
&#9;&#9;&#9;for Property, Value in pairs(TweenColor3Table) do
&#9;&#9;&#9;&#9;Lighting[Property] = Value
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if DoTweenNumber and Time &gt; 0 then
&#9;&#9;&#9;qGUI.TweenTransparency(Lighting, TweenNumberTable, Time, true)
&#9;&#9;else
&#9;&#9;&#9;for Property, Value in pairs(TweenNumberTable) do
&#9;&#9;&#9;&#9;Lighting[Property] = Value
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

return LightingManager
</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX44">
					<Properties>
						<string name="Name">qPhysics</string>
						<ProtectedString name="Source">local lib = {}

-- qPhysics
-- @author Quenty
-- @owner Trey Reynolds

local function GetConnectedParts(Part)
&#9;local Parts = Part:GetConnectedParts(true)
&#9;Parts[#Parts+1] = Part
&#9;return Parts
end
lib.GetConnectedParts = GetConnectedParts
lib.getConnectedParts = GetConnectedParts

local function GetCenterOfMass(Parts)
&#9;--- Return&apos;s the world vector center of mass.
&#9;-- Lots of help from Hippalectryon :D

&#9;local TotalMass = 0
&#9;local SumOfMasses = Vector3.new(0, 0, 0)

&#9;for _, Part in pairs(Parts) do
&#9;&#9;-- Part.BrickColor = BrickColor.new(&quot;Bright yellow&quot;)
&#9;&#9;TotalMass = TotalMass + Part:GetMass()
&#9;&#9;SumOfMasses = SumOfMasses + Part:GetMass() * Part.Position
&#9;end

&#9;-- print(&quot;Sum of masses: &quot; .. tostring(SumOfMasses))
&#9;-- print(&quot;Total mass:    &quot; .. tostring(TotalMass))

&#9;return SumOfMasses/TotalMass, TotalMass
end
lib.GetCenterOfMass = GetCenterOfMass
lib.getCenterOfMass = GetCenterOfMass

-- Moment of Inertia of any rectangular prism.
-- 1/12 * m * sum(deminsionlengths^2)

local function MomentOfInertia(Part, Axis, Origin)
&#9;--- Calculates the moment of inertia of a cuboid.

&#9;-- Part is part
&#9;-- Axis is the axis
&#9;-- Origin is the origin of the axis

&#9;local PartSize = Part.Size

&#9;local Mass  = Part:GetMass()
&#9;local Radius  = (Part.Position - Origin):Cross(Axis)
&#9;local r2 = Radius:Dot(Radius)
&#9;local ip = Mass * r2--Inertia based on Position
&#9;local s2 = PartSize*PartSize
&#9;local sa = (Part.CFrame-Part.Position):inverse()*Axis
&#9;local id = (Vector3.new(s2.y+s2.z, s2.z+s2.x, s2.x+s2.y)):Dot(sa*sa)*Mass/12 -- Inertia based on Direction
&#9;return ip+id
end
lib.MomentOfInertia = MomentOfInertia
lib.momentOfInertia = MomentOfInertia

local function BodyMomentOfInertia(Parts, Axis, Origin)
&#9;--- Given a connected body of parts, returns the moment of inertia of these parts
&#9;-- @param Parts The parts to use
&#9;-- @param Axis the axis to use (Should be torque, or offset cross force)
&#9;-- @param Origin The origin of the axis (should be center of mass of the parts)
&#9;
&#9;local TotalBodyInertia = 0

&#9;for _, Part in pairs(Parts) do
&#9;&#9;TotalBodyInertia = TotalBodyInertia + MomentOfInertia(Part, Axis, Origin)
&#9;end

&#9;return TotalBodyInertia
end
lib.BodyMomentOfInertia = BodyMomentOfInertia
lib.bodyMomentOfInertia = BodyMomentOfInertia

local function ApplyForce(Part, Force, ForcePosition)
&#9;--- Applies a force to a ROBLOX body
&#9;-- @param Force the force vector to apply
&#9;-- @param ForcePosition The position that the force is to be applied from (World vector). 

&#9;-- Credit to TreyReynolds for this code.

&#9;-- It should be noted that setting the velocity to one part of a connected part on ROBLOX sets the velocity of the whole physics model.
&#9;-- http://xboxforums.create.msdn.com/forums/p/34179/196459.aspx
&#9;-- http://www.cs.cmu.edu/~baraff/sigcourse/notesd1.pdf

&#9;local Parts = GetConnectedParts(Part)

&#9;ForcePosition = ForcePosition or Part.Position

&#9;local CenterOfMass, TotalMass = GetCenterOfMass(Parts)
&#9;local Offset = (CenterOfMass - ForcePosition)
&#9;local Torque = Offset:Cross(Force)

&#9;local MomentOfInertia = BodyMomentOfInertia(Parts, Torque, CenterOfMass)
&#9;local RotAcceleration = MomentOfInertia ~= 0 and Torque/MomentOfInertia or Vector3.new(0, 0, 0) -- We cannot divide by 0

&#9;-- print(&quot;Torque:        &quot; .. tostring(Torque))
&#9;-- print(&quot;RotAccelerion: &quot; .. tostring(RotAcceleration))

&#9;local Acceleration = Force/TotalMass

&#9;-- print(&quot;Acceleration: &quot; .. tostring(Acceleration))

&#9;Part.RotVelocity = Part.RotVelocity + RotAcceleration
&#9;Part.Velocity = Part.Velocity + Acceleration
end
lib.ApplyForce = ApplyForce
lib.applyForce = ApplyForce

local function AcceleratePart(Part, EmittingPart, Acceleration)
&#9;--- Accelerates a part utilizing newton&apos;s laws. EmittingPart is the part it&apos;s emitted from.

&#9;-- Force = Mass * Acceleration

&#9;local Force = Acceleration * Part:GetMass()
&#9;local Position = Part.Position

&#9;ApplyForce(Part, Force, Position)
&#9;ApplyForce(EmittingPart, -Force, Position)
end
lib.AcceleratePart = AcceleratePart
lib.acceleratePart = AcceleratePart

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX45">
					<Properties>
						<string name="Name">qPlayer</string>
						<ProtectedString name="Source">local Players = game:GetService(&quot;Players&quot;)
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local qCFrame          = LoadCustomLibrary(&quot;qCFrame&quot;)

qSystems:Import(getfenv(0));

-- qPlayer.lua
-- Just utilities involving players (and teams).

local lib = {}

local function IsTeamMate(PlayerOne, PlayerTwo)
&#9;--- Are playerone and playertwo teammates?

&#9;if PlayerOne.Neutral == PlayerTwo.Neutral then
&#9;&#9;if PlayerOne.Neutral then
&#9;&#9;&#9;return true
&#9;&#9;else
&#9;&#9;&#9;return PlayerOne.TeamColor.Name == PlayerTwo.TeamColor.Name
&#9;&#9;end
&#9;else
&#9;&#9;return false
&#9;end
end
lib.IsTeamMate = IsTeamMate
lib.isTeamMate = IsTeamMate

local function GetPlayersWithinRadius(PlayerList, Position, Radius)
&#9;--- Useful for explosions are stuff...
&#9;--- @param PlayerList A list of players where CheckCharacter(Player) has returned true

&#9;local PlayersFound = {}

&#9;for _, Player in pairs(PlayerList) do
&#9;&#9;if (Player.Character.Torso.Position - Position).magnitude &lt;= Radius then
&#9;&#9;&#9;PlayersFound[#PlayersFound+1] = Player
&#9;&#9;end
&#9;end

&#9;return PlayersFound
end
lib.GetPlayersWithinRadius = GetPlayersWithinRadius
lib.getPlayersWithinRadius = GetPlayersWithinRadius

local function GetPlayersWithinBlastRadius(PlayerList, Position, Radius, IgnoreList, IgnoreInvisible, IgnoreCollisions, TerrainCellsAreCubes)
&#9;--- Useful for explosions are stuff, although not super useful. Uses raycasting to check out the situation.

&#9;-- @param PlayerList A list of players where CheckCharacter(Player) has returned true
&#9;-- @param Radius the radius to check for. Must be less than 1000
&#9;-- @param Position the position to check at. 
&#9;-- @param IgnoreList The ignore list to use. Probably throw the projectile in that. Since we&apos;re using advance raycast, it may add items to this list.
&#9;-- @param [TerrainCellsAreCubes] default = true

&#9;TerrainCellsAreCubes = TerrainCellsAreCubes == nil and true or TerrainCellsAreCubes

&#9;local PlayersFound = {}

&#9;for _, Player in pairs(PlayerList) do
&#9;&#9;local TorsoPosition = Player.Character.Torso.Position
&#9;&#9;local Direction = (TorsoPosition - Position)
&#9;&#9;if Direction.magnitude &lt;= Radius then
&#9;&#9;&#9;local CastRay = Ray.new(Position, Direction.unit * Radius)
&#9;&#9;&#9;local Hit, Position = qCFrame.AdvanceRaycast(CastRay, IgnoreList, IgnoreInvisible, IgnoreCollisions, TerrainCellsAreCubes)

&#9;&#9;&#9;if Hit:IsDescendantOf(Player.Character) then
&#9;&#9;&#9;&#9;PlayersFound[#PlayersFound+1] = Player
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(&quot;Obstruction&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;return PlayersFound
end
lib.GetPlayersWithinBlastRadius = GetPlayersWithinBlastRadius
lib.getPlayersWithinBlastRadius = GetPlayersWithinBlastRadius

local function GetPlayersWithValidCharacters()
&#9;local PlayersFound = {}

&#9;for _, Player in pairs(Players:GetPlayers()) do
&#9;&#9;if CheckCharacter(Player) then
&#9;&#9;&#9;PlayersFound[#PlayersFound+1] = Player
&#9;&#9;end
&#9;end

&#9;return PlayersFound
end
lib.GetPlayersWithValidCharacters = GetPlayersWithValidCharacters
lib.getPlayersWithValidCharacters = GetPlayersWithValidCharacters

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX46">
					<Properties>
						<string name="Name">Triangle</string>
						<ProtectedString name="Source">local ReplicatedStorage  = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine    = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary  = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)

qSystems:import(getfenv(0));

local lib = {}

-- Triangle.lua
-- @author Quenty, aparently algorithm is from xLEGOx, cannot confirm though. 
-- This library handles drawing (and redrawning) triangles. 

local function ParaD(A, B, C)
&#9;local DotProduct = (B-A).x*(C-A).x + (B-A).y*(C-A).y + (B-A).z*(C-A).z
&#9;return DotProduct / (A-B).magnitude
end

local function PerpD(A, B, C)
&#9;local par = ParaD(A, B, C)
&#9;return math.sqrt((C-A).magnitude^2 - par^2)
end

local function MakeDefaultBrick(Parent)
&#9;return Make(&quot;WedgePart&quot;, {
&#9;&#9;FormFactor    = &quot;Custom&quot;;
&#9;&#9;TopSurface    = &quot;Smooth&quot;;
&#9;&#9;BottomSurface = &quot;Smooth&quot;;
&#9;&#9;Anchored      = true;
&#9;&#9;Size          = Vector3.new(0.2, 7, 7);
&#9;&#9;Name          = &quot;WedgePart&quot;;
&#9;&#9;Parent = Parent;
&#9;&#9;CanCollide = false;

&#9;&#9;Make(&quot;SpecialMesh&quot;,{
&#9;&#9;&#9;MeshType = &quot;Wedge&quot;;
&#9;&#9;&#9;Name     = &quot;Mesh&quot;;
&#9;&#9;})
&#9;})
end

local sqrt       = math.sqrt
local NewCFrame  = CFrame.new
local NewVector3 = Vector3.new
local Dot        = Vector3.new().Dot
local Cross      = Vector3.new().Cross


local function GetWedgeCFrames(VectorA, VectorB, VectorC, TriangleWidth)
&#9;--- Draws a triangle (with a width of 0) between the three given vectors. Used when welding. 
&#9;-- @param Part0 The part to use as the first part. If not provided, it will be generated. It must have a SpecialMesh inside of it called &quot;Mesh&quot; with a MeshType of &quot;Wedge&quot;.
&#9;-- @param Part1 The part to use as the second part. If not provided, it will be generated. It must have a SpecialMesh inside of it called &quot;Mesh&quot; with a MeshType of &quot;Wedge&quot;.
&#9;-- @param VectorA The first vector (duh)
&#9;-- @param VectorB     ...
&#9;-- @param VectorC     ...

&#9;local SegmentAB = (VectorA - VectorB)
&#9;local SegmentBC = (VectorB - VectorC)
&#9;local SegmentCA = (VectorC - VectorA)

&#9;local SegmentABMagnitude = SegmentAB.magnitude
&#9;local SegmentBCMagnitude = SegmentBC.magnitude
&#9;local SegmentCAMagnitude = SegmentCA.magnitude

&#9;-- Strategy: Get SegmentAB to be the longest segment. 
&#9;-- Strategy: Rotate segments so the longest one is AB.

&#9;if SegmentCAMagnitude &gt; SegmentABMagnitude and SegmentCAMagnitude &gt; SegmentBCMagnitude then
&#9;&#9;-- Rotate clockwise.

&#9;&#9;VectorA, VectorB, VectorC = VectorC, VectorA, VectorB
&#9;&#9;SegmentAB, SegmentBC, SegmentCA = SegmentCA, SegmentAB, SegmentBC
&#9;&#9;-- SegmentABMagnitude, SegmentBCMagnitude, SegmentCAMagnitude = SegmentCAMagnitude, SegmentABMagnitude, SegmentBCMagnitude
&#9;&#9;SegmentABMagnitude = SegmentCAMagnitude
&#9;elseif SegmentBCMagnitude &gt; SegmentABMagnitude and SegmentBCMagnitude &gt; SegmentCAMagnitude then
&#9;&#9;-- Counterclockwise. 

&#9;&#9;VectorA, VectorB, VectorC = VectorB, VectorC, VectorA
&#9;&#9;SegmentAB, SegmentBC, SegmentCA = SegmentBC, SegmentCA, SegmentAB
&#9;&#9;-- SegmentABMagnitude, SegmentBCMagnitude, SegmentCAMagnitude = SegmentBCMagnitude, SegmentCAMagnitude, SegmentABMagnitude
&#9;&#9;SegmentABMagnitude = SegmentBCMagnitude
&#9;end

&#9;-- SegmentAB is now the longest. It is split at the projection of 

&#9;-- Strategy: Use Herons to get the area of the triangle
&#9;-- local SemiPerimeter = (SegmentABMagnitude + SegmentBCMagnitude + SegmentCAMagnitude) / 2
&#9;-- local WedgeArea     = sqrt(SemiPerimeter * (SemiPerimeter - SegmentABMagnitude) * (SemiPerimeter - SegmentBCMagnitude) * (SemiPerimeter - SegmentCAMagnitude))
&#9;-- local Height = 2 * WedgeArea / SegmentABMagnitude

&#9;if WedgeArea ~= 0 then
&#9;&#9;-- Project AC onto AB to get the split point

&#9;&#9;-- local SplitLength = (((-SegmentCA):Dot(SegmentAB)/(-SegmentABMagnitude*SegmentABMagnitude))*SegmentAB).magnitude
&#9;&#9;local SplitLength = -Dot(SegmentCA, SegmentAB)/SegmentABMagnitude

&#9;&#9;local Center0 = VectorC + SegmentCA/-2
&#9;&#9;local Center1 = VectorB + SegmentBC/-2

&#9;&#9;local DirectionVectorC = -SegmentAB
&#9;&#9;local DirectionVectorA = Cross(DirectionVectorC, SegmentCA)
&#9;&#9;local DirectionVectorAMagnitude = DirectionVectorA.magnitude -- This happens to also be the area of the wedge.

&#9;&#9;local Height = DirectionVectorAMagnitude / SegmentABMagnitude

&#9;&#9;DirectionVectorA = DirectionVectorA / DirectionVectorAMagnitude
&#9;&#9;DirectionVectorC = DirectionVectorC.unit

&#9;&#9;local DirectionVectorB = Cross(DirectionVectorC, DirectionVectorA)

&#9;&#9;return NewCFrame(
&#9;&#9;&#9;Center0.X, Center0.Y, Center0.Z, 
&#9;&#9;&#9;-DirectionVectorA.x, -DirectionVectorB.x, DirectionVectorC.x,
&#9;&#9;&#9;-DirectionVectorA.Y, -DirectionVectorB.Y, DirectionVectorC.Y,
&#9;&#9;&#9;-DirectionVectorA.Z, -DirectionVectorB.Z, DirectionVectorC.Z
&#9;&#9;), -- CFrame0
&#9;&#9;NewVector3(TriangleWidth, Height, SplitLength), -- Wedge0 size
&#9;&#9;NewCFrame(
&#9;&#9;&#9;Center1.X, Center1.Y, Center1.Z, 
&#9;&#9;&#9;DirectionVectorA.x, -DirectionVectorB.x, -DirectionVectorC.x,
&#9;&#9;&#9;DirectionVectorA.Y, -DirectionVectorB.Y, -DirectionVectorC.Y,
&#9;&#9;&#9;DirectionVectorA.Z, -DirectionVectorB.Z, -DirectionVectorC.Z
&#9;&#9;), -- Frame1
&#9;&#9;NewVector3(TriangleWidth, Height, SegmentABMagnitude-SplitLength) -- Wedge1 size
&#9;else
&#9;&#9;--- Not a triangle. 
&#9;&#9;return NewCFrame(VectorA), NewVector3(0, 0, 0), NewCFrame(VectorA), NewVector3(0, 0, 0)
&#9;end
end
lib.GetWedgeCFrames = GetWedgeCFrames
lib.getWedgeCFrames = GetWedgeCFrames


--[[
local function GetWedgeCFrames(VectorA, VectorB, VectorC, TriangleWidth)
&#9;--- Draws a triangle (with a width of 0) between the three given vectors. Used when welding. 
&#9;-- @param Part0 The part to use as the first part. If not provided, it will be generated. It must have a SpecialMesh inside of it called &quot;Mesh&quot; with a MeshType of &quot;Wedge&quot;.
&#9;-- @param Part1 The part to use as the second part. If not provided, it will be generated. It must have a SpecialMesh inside of it called &quot;Mesh&quot; with a MeshType of &quot;Wedge&quot;.
&#9;-- @param VectorA The first vector (duh)
&#9;-- @param VectorB     ...
&#9;-- @param VectorC     ...

&#9;-- @return Part0 and Part1&apos;s suppose to be CFrame. Thier mesh will be adjusted already. 

&#9;local A, B, C

&#9;do -- Identify the longest &quot;segment&quot; and make sure A is the longest one. 
&#9;&#9;local Segment1 = (VectorA - VectorB).magnitude
&#9;&#9;local Segment2 = (VectorB - VectorC).magnitude
&#9;&#9;local Segment3 = (VectorC - VectorA).magnitude

&#9;&#9;local SegmentMax = math.max(Segment1, Segment2, Segment3)

&#9;&#9;if Segment1 == SegmentMax then
&#9;&#9;&#9;A = VectorA
&#9;&#9;&#9;B = VectorB
&#9;&#9;&#9;C = VectorC
&#9;&#9;elseif Segment2 == SegmentMax then
&#9;&#9;&#9;A = VectorB
&#9;&#9;&#9;B = VectorC
&#9;&#9;&#9;C = VectorA&#9;
&#9;&#9;elseif Segment3 == SegmentMax then
&#9;&#9;&#9;A = VectorC
&#9;&#9;&#9;B = VectorA
&#9;&#9;&#9;C = VectorB
&#9;&#9;end
&#9;end

&#9;-- Actual triangle drawing part.
&#9;-- local Ambiguious = false -- Not sure what this tracks. :/

&#9;local Perpendicular = PerpD(A, B, C)
&#9;local para          = ParaD(A, B, C)
&#9;local dif_para      = (A-B).magnitude - para&#9;
&#9;
&#9;if Perpendicular == 0 then -- We&apos;ve got a none real triangle.
&#9;&#9;print(&quot;[Triangle] - Impossible triangle, rendering has half failed.&quot;);

&#9;&#9;local Part0Size = Vector3.new(0.2, 0.2, (B-A).magnitude)
&#9;&#9;local Part1Size = Vector3.new(0.2, 0.2, (B-A).magnitude)

&#9;&#9;-- We&apos;ll just center &apos;em and be done with it. Technically won&apos;t render anything.
&#9;&#9;return CFrame.new(B + Vector3.new(B, A)/2, A), Part0Size, CFrame.new(B + Vector3.new(B, A)/2, A), Part1Size
&#9;else
&#9;&#9;local Part0Size   = Vector3.new(1, Perpendicular, para)
&#9;&#9;local Part0CFrame = CFrame.new(B, A) 
&#9;&#9;
&#9;&#9;local Top_Look    = (Part0CFrame * CFrame.Angles(math.pi/2, 0, 0)).lookVector
&#9;&#9;local Mid_Point   = A + CFrame.new(A, B).lookVector * para
&#9;&#9;local Needed_Look = CFrame.new(Mid_Point, C).lookVector
&#9;&#9;local DotProduct  = math.max(-1, math.min(1, Top_Look.x*Needed_Look.x + Top_Look.y*Needed_Look.y + Top_Look.z*Needed_Look.z))
&#9;&#9;Part0CFrame       = Part0CFrame * CFrame.Angles(0, 0, math.acos(DotProduct))
&#9;&#9;if ((Part0CFrame * CFrame.Angles(math.pi/2, 0, 0)).lookVector - Needed_Look).magnitude &gt; 0.01 then
&#9;&#9;&#9;Part0CFrame   = Part0CFrame * CFrame.Angles(0, 0, -2*math.acos(DotProduct))
&#9;&#9;&#9;-- print(&quot;Enter if statement&quot;)
&#9;&#9;end
&#9;&#9;Part0CFrame       = Part0CFrame * CFrame.new(0, Perpendicular/2, -(dif_para + para/2))
&#9;&#9;
&#9;&#9;local Part1Size   = Vector3.new(1, Perpendicular, dif_para)
&#9;&#9;local Part1CFrame = CFrame.new(B, A) * CFrame.Angles(0, 0, math.acos(DotProduct)) * CFrame.Angles(0, math.pi, 0)
&#9;&#9;-- print(CFrame.new(B, A))
&#9;&#9;-- print(CFrame.Angles(0, 0, math.acos(DotProduct)))
&#9;&#9;-- print(math.acos(DotProduct))
&#9;&#9;-- print(DotProduct)
&#9;&#9;-- print(CFrame.Angles(0, math.pi, 0))
&#9;&#9;-- print(Part1CFrame)
&#9;&#9;if ((Part1CFrame * CFrame.Angles(math.pi/2, 0, 0)).lookVector - Needed_Look).magnitude &gt; 0.01 then
&#9;&#9;&#9;Part1CFrame   = Part1CFrame * CFrame.Angles(0, 0, 2*math.acos(DotProduct))
&#9;&#9;&#9;-- print(&quot;Enter if statement&quot;)
&#9;&#9;&#9;-- print(Part1CFrame)
&#9;&#9;end
&#9;&#9;Part1CFrame       = Part1CFrame * CFrame.new(0, Perpendicular/2, dif_para/2)
&#9;&#9;-- print(Part1CFrame)
&#9;&#9;return Part0CFrame, Part0Size, Part1CFrame, Part1Size
&#9;end
end
lib.GetWedgeCFrames = GetWedgeCFrames
lib.getWedgeCFrames = GetWedgeCFrames
--]]

local function DrawTriangle(Part0, Part1, VectorA, VectorB, VectorC)
&#9;--- Draws a triangle (with a width of 0) between the three given vectors.
&#9;-- @param [Part0] The part to use as the first part. If not provided, it will be generated. It must have a SpecialMesh inside of it called &quot;Mesh&quot; with a MeshType of &quot;Wedge&quot;.
&#9;-- @param [Part1] The part to use as the second part. If not provided, it will be generated. It must have a SpecialMesh inside of it called &quot;Mesh&quot; with a MeshType of &quot;Wedge&quot;.
&#9;-- @param VectorA The first vector (duh)
&#9;-- @param VectorB     ...
&#9;-- @param VectorC     ...

&#9;-- @return Part0 and Part1


&#9;Part0 = Part0 or MakeDefaultBrick(Workspace)
&#9;Part1 = Part1 or MakeDefaultBrick(Workspace)

&#9;local A, B, C

&#9;do -- Identify the longest &quot;segment&quot; and make sure A is the longest one. 
&#9;&#9;local Segment1 = (VectorA - VectorB).magnitude
&#9;&#9;local Segment2 = (VectorB - VectorC).magnitude
&#9;&#9;local Segment3 = (VectorC - VectorA).magnitude

&#9;&#9;local SegmentMax = math.max(Segment1, Segment2, Segment3)

&#9;&#9;if Segment1 == SegmentMax then
&#9;&#9;&#9;A = VectorA
&#9;&#9;&#9;B = VectorB
&#9;&#9;&#9;C = VectorC
&#9;&#9;elseif Segment2 == SegmentMax then
&#9;&#9;&#9;A = VectorB
&#9;&#9;&#9;B = VectorC
&#9;&#9;&#9;C = VectorA&#9;
&#9;&#9;elseif Segment3 == SegmentMax then
&#9;&#9;&#9;A = VectorC
&#9;&#9;&#9;B = VectorA
&#9;&#9;&#9;C = VectorB
&#9;&#9;end
&#9;end

&#9;-- Actual triangle drawing part.
&#9;-- local Ambiguious = false -- Not sure what this tracks. :/

&#9;--TODO: Convert to using variables instaed of setting CFrame direct.

&#9;local Perpendicular = PerpD(A, B, C)
&#9;local para          = ParaD(A, B, C)
&#9;local dif_para      = (A-B).magnitude - para&#9;
&#9;
&#9;if Perpendicular == 0 then -- We&apos;ve got a none real triangle.
&#9;&#9;print(&quot;[Triangle] - Impossible triangle, rendering has half failed.&quot;);

&#9;&#9;Part0.Mesh.Scale = Vector3.new(0, 0, 0)
&#9;&#9;Part1.Mesh.Scale = Vector3.new(0, 0, 0)
&#9;&#9;Part0.Size = Vector3.new(0.2, 0.2, (B-A).magnitude)
&#9;&#9;Part1.Size = Vector3.new(0.2, 0.2, (B-A).magnitude)

&#9;&#9;-- We&apos;ll just center &apos;em and be done with it. Technically won&apos;t render anything.
&#9;&#9;Part0.CFrame = CFrame.new(B + Vector3.new(B, A)/2, A)
&#9;&#9;Part1.CFrame = CFrame.new(B + Vector3.new(B, A)/2, A)
&#9;else
&#9;&#9;Part0.Mesh.Scale    = Vector3.new(0.1, 1, 1)
&#9;&#9;Part0.Size          = Vector3.new(0.2, Perpendicular, para)
&#9;&#9;Part0.CFrame        = CFrame.new(B, A) 
&#9;&#9;
&#9;&#9;local Top_Look      = (Part0.CFrame * CFrame.Angles(math.pi/2, 0, 0)).lookVector
&#9;&#9;local Mid_Point     = A + CFrame.new(A, B).lookVector * para
&#9;&#9;local Needed_Look   = CFrame.new(Mid_Point, C).lookVector
&#9;&#9;local DotProduct    = math.max(-1, math.min(1, Top_Look.x*Needed_Look.x + Top_Look.y*Needed_Look.y + Top_Look.z*Needed_Look.z))
&#9;&#9;Part0.CFrame        = Part0.CFrame * CFrame.Angles(0, 0, math.acos(DotProduct))
&#9;&#9;if ((Part0.CFrame * CFrame.Angles(math.pi/2, 0, 0)).lookVector - Needed_Look).magnitude &gt; 0.01 then
&#9;&#9;&#9;Part0.CFrame    = Part0.CFrame * CFrame.Angles(0, 0, -2*math.acos(DotProduct))
&#9;&#9;&#9;-- Ambiguious      = true
&#9;&#9;end
&#9;&#9;Part0.CFrame        = Part0.CFrame * CFrame.new(0, Perpendicular/2, -(dif_para + para/2))

&#9;&#9;Part1.Mesh.Scale    = Vector3.new(0, 1, 1)
&#9;&#9;Part1.Size          = Vector3.new(0.2, Perpendicular, dif_para)
&#9;&#9;Part1.CFrame        = CFrame.new(B, A) * CFrame.Angles(0, 0, math.acos(DotProduct)) * CFrame.Angles(0, math.pi, 0)
&#9;&#9;if ((Part1.CFrame * CFrame.Angles(math.pi/2, 0, 0)).lookVector - Needed_Look).magnitude &gt; 0.01 then
&#9;&#9;&#9;Part1.CFrame    = Part1.CFrame * CFrame.Angles(0, 0, 2*math.acos(DotProduct))
&#9;&#9;&#9;-- Ambiguious      = true
&#9;&#9;end
&#9;&#9;Part1.CFrame        = Part1.CFrame * CFrame.new(0, Perpendicular/2, dif_para/2)
&#9;end

&#9;return Part0, Part1
end
lib.DrawTriangle = DrawTriangle
lib.drawTriangle = DrawTriangle

local function GetWedgeCFramesTwo(n1, n2, n3, TriangleWidth)
&#9;-- Appears to glitch out sometimes.

&#9;--- CREDIT BLOBBYBLOB &lt;3
&#9;--- Second version, hopefully more efficient.
&#9;
&#9;-- http://asset-markotaris.rhcloud.com/134668170

    --Node1 and Node3 both connect to Node2 and to InterimNode, but not to each other.
    --The distance between Node1 and Node3 should be the greatest distance here. In case
    --the triangle is obtuse, this is very important.

    --     local c1, s1, c2, s2 = GetMetrics(n1, n2, n3);

    local Node1, Node2, Node3;
    local InterimNode;

    --Assign Node1, 2 and 3.
    local d1, d2, d3 = (n1 - n2).magnitude, (n2 - n3).magnitude, (n3 - n1).magnitude;
    if d1 &gt; d2 and d1 &gt; d3 then
        Node1, Node2, Node3 = n2, n3, n1;
    elseif d2 &gt; d3 then
        Node1, Node2, Node3 = n3, n1, n2;
    else
        Node1, Node2, Node3 = n1, n2, n3;
    end
    InterimNode = (Node3 - Node1).unit:Dot(Node2 - Node1) * (Node3 - Node1).unit + Node1;

    --Vec1, 2, and 3 indicate the lookVectors for the three faces of the wedge. They&apos;ll need a
    --bit of negation to get them working correctly when it comes time to build the CFrame.
    local Vec3 = (Node3 - Node1).unit;
    local Vec1 = (Vec3:Cross(Node2 - Node1)).unit;
    local Vec2 = Vec3:Cross(Vec1);

    --Part1 bridges between Node1, Node2, and InterimNode.
    local Position1 = Node1:Lerp(Node2, .5);

    --Part2 bridges between Node2, Node3, and InterimNode.
    local Position2 = Node3:Lerp(Node2, .5);

    return
        CFrame.new(Position1.x, Position1.y, Position1.z, 
&#9;&#9;&#9;-Vec1.x, -Vec2.x, Vec3.x, 
&#9;&#9;&#9;-Vec1.y, -Vec2.y, Vec3.y, 
&#9;&#9;&#9;-Vec1.z, -Vec2.z, Vec3.z
&#9;&#9;) * CFrame.new(TriangleWidth / 2, 0, 0),
        Vector3.new(TriangleWidth, (InterimNode - Node2).magnitude, (InterimNode - Node1).magnitude),
        CFrame.new(Position2.x, Position2.y, Position2.z, 
        &#9;Vec1.x, -Vec2.x, -Vec3.x, 
        &#9;Vec1.y, -Vec2.y, -Vec3.y, 
        &#9;Vec1.z, -Vec2.z, -Vec3.z) * CFrame.new(-TriangleWidth / 2, 0, 0),
        Vector3.new(TriangleWidth, (InterimNode - Node2).magnitude, (InterimNode - Node3).magnitude);
end
lib.GetWedgeCFramesTwo = GetWedgeCFramesTwo
lib.getWedgeCFramesTwo = GetWedgeCFramesTwo


-- CREDIT TO STRAVANT

local function CFrameFromTopBack(at, top, back)
&#9;local right = top:Cross(back)
&#9;return CFrame.new(at.x, at.y, at.z,
&#9;                  right.x, top.x, back.x,
&#9;                  right.y, top.y, back.y,
&#9;                  right.z, top.z, back.z)
end
 
--&quot;Fill&quot; function. a, b, and c are the vertices of the triangle to fill.
-- Returns a model containing the one or two parts. (In general two
-- right angle wedge parts are needed, but if the verts already form a 
-- right angle, only one is needed)
local function GetWedgeCFramesThree(a, b, c, TriangleWidth)
&#9;--test
&#9;-- local fill = Instance.new(&apos;Model&apos;)
&#9;-- fill.Name = &apos;Fill&apos;
 
&#9;--rearrange to make right angle triangels fill right
&#9;local edg1 = (c-a):Dot((b-a).unit)
&#9;local edg2 = (a-b):Dot((c-b).unit)
&#9;local edg3 = (b-c):Dot((a-c).unit)
&#9;if edg1 &lt;= (b-a).magnitude and edg1 &gt;= 0 then
&#9;&#9;a, b, c = a, b, c
&#9;elseif edg2 &lt;= (c-b).magnitude and edg2 &gt;= 0 then
&#9;&#9;a, b, c = b, c, a
&#9;elseif edg3 &lt;= (a-c).magnitude and edg3 &gt;= 0 then
&#9;&#9;a, b, c = c, a, b
&#9;else 
&#9;&#9;error(&quot;unreachable&quot;)
&#9;end
 
&#9;--calculate lengths
&#9;local len1 = (c-a):Dot((b-a).unit)
&#9;local len2 = (b-a).magnitude - len1
&#9;local width = (a + (b-a).unit*len1 - c).magnitude
 
&#9;--calculate &quot;base&quot; CFrame to pasition parts by
&#9;local maincf = CFrameFromTopBack(a, (b-a):Cross(c-b).unit, -(b-a).unit)
 &#9;
&#9;--make parts
&#9;if len1 &gt; 0.2 and len2 &gt; 0.2 then
&#9;&#9;-- local w1 = Instance.new(&apos;WedgePart&apos;, fill)
&#9;&#9;-- w1.BottomSurface = &apos;Smooth&apos;
&#9;&#9;-- w1.FormFactor = &apos;Custom&apos;
&#9;&#9;-- --
&#9;&#9;-- w1.Size = Vector3.new(0.2, width, len1)
&#9;&#9;-- w1.CFrame = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)

&#9;&#9;return maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2),
&#9;&#9;Vector3.new(TriangleWidth, width, len1),
&#9;&#9;maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2),
&#9;&#9;Vector3.new(0.2, width, len2)
&#9;elseif len2 &gt; 0.2 then
&#9;&#9;-- local w2 = Instance.new(&apos;WedgePart&apos;, fill)
&#9;&#9;-- w2.BottomSurface = &apos;Smooth&apos;
&#9;&#9;-- w2.FormFactor = &apos;Custom&apos;
&#9;&#9;-- --
&#9;&#9;-- w2.Size = Vector3.new(0.2, width, len2)
&#9;&#9;-- w2.CFrame = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
&#9;&#9;local CFrameStuff = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
&#9;&#9;local SizeStuff = Vector3.new(0.2, width, len2)
&#9;&#9;return CFrameStuff, SizeStuff, CFrameStuff, SizeStuff
&#9;elseif len1 &gt; 0.2 then
&#9;&#9;local CFrameStuff = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
&#9;&#9;local SizeStuff = Vector3.new(0.2, width, len1)
&#9;&#9;return CFrameStuff, SizeStuff, CFrameStuff, SizeStuff
&#9;else
&#9;&#9;print(&quot;Triangle fail&quot;)

&#9;&#9;local CFrameStuff = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
&#9;&#9;local SizeStuff = Vector3.new(0.2, width, len1)
&#9;&#9;return CFrameStuff, SizeStuff, CFrameStuff, SizeStuff
&#9;end
 
&#9;-- return fill
end
lib.GetWedgeCFramesThree = GetWedgeCFramesThree
lib.getWedgeCFramesThree = GetWedgeCFramesThree

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX47">
					<Properties>
						<string name="Name">qSystems</string>
						<ProtectedString name="Source">local Players            = game:GetService(&quot;Players&quot;)
local StarterPack        = game:GetService(&quot;StarterPack&quot;)
local StarterGui         = game:GetService(&quot;StarterGui&quot;)
local Lighting           = game:GetService(&quot;Lighting&quot;)
local Debris             = game:GetService(&quot;Debris&quot;)
local Teams              = game:GetService(&quot;Teams&quot;)
local BadgeService       = game:GetService(&quot;BadgeService&quot;)
local InsertService      = game:GetService(&quot;InsertService&quot;)
local HttpService        = game:GetService(&quot;HttpService&quot;)
local ReplicatedStorage  = game:GetService(&quot;ReplicatedStorage&quot;)
local RunService         = game:GetService(&quot;RunService&quot;)
local MarketplaceService = game:GetService(&quot;MarketplaceService&quot;)
local TestService        = game:GetService(&quot;TestService&quot;)
local Terrain            = Workspace.Terrain

local NevermoreEngine    = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary  = NevermoreEngine.LoadLibrary

-------------------------
-- Documentation Stuff --
-------------------------

-- @author Quenty
-- Revised Janurary 4th, 2014
-- This script handles a variety of tasks and generic functions that are useful for
-- ROBLOX game developement. It is meant to be imported into another script.
-- @return The qSystems library. 

--[[
Updates and Changes log
August 18th, 2014
- Removed isA method
- Cleaned up commented code
- Removed classOrServiceAlreadyExists

August 14th, 2014
- Updated Make() so it doesn&apos;t create a new function to function (no pun intended)
- Removed warn() function, as ROBLOX has a native one.

March 6th, 2014
- Updated WaitForChild to have a time limit
- Modified WaitForChild to make sure the parent isn&apos;t nil

February 9th, 2014
- Updated CheckCharacter to check for HumanoidRootPart

January 26th, 2014
- Removed old code
- Fixed issue with constructor and class system

January 25th, 2014
- Updated Class System to return extra parameters from constructor pass constructed object. 

Janurary 4th, 2014
- Removed the class and service list for performance reasons

January 2nd, 2014
- Add Sign function

January 1st, 2014
- Fixed CheckCharacter to work with Local scripts (Replication change)

December 28th, 2013
- Removed VerifyArg and error functions
- Updated Headercode for new NevermoreEngine
- Started change log
- Setup qSystems to work with module scripts.
- Added new alias to roundnumber (Round)
]]
&#9;
local Type                    = LoadCustomLibrary(&apos;Type&apos;)

local lib                     = {}

-----------------------
-- General functions --
-----------------------

-- Creates a signal, like before, but this time uses internal Lua signals that allow for the sending of recursive
-- tables versus using ROBLOX&apos;s parsing system. 
local function CreateSignalInternal()

&#9;local this = {}
&#9;local mListeners = {}
&#9;local mListenerCount = 0
&#9;local mWaitProxy = nil
&#9;local mWaitReturns = nil
&#9;local mHasWaiters = false

&#9;function this:connect(func)
&#9;&#9;if self ~= this then error(&quot;connect must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;if type(func) ~= &apos;function&apos; then
&#9;&#9;&#9;error(&quot;Argument #1 of connect must be a function, got a &quot;..type(func), 2)
&#9;&#9;end
&#9;&#9;mListenerCount = mListenerCount + 1
&#9;&#9;local conn = {}
&#9;&#9;function conn:disconnect()
&#9;&#9;&#9;if mListeners[conn] then
&#9;&#9;&#9;&#9;mListeners[conn] = nil
&#9;&#9;&#9;&#9;mListenerCount = mListenerCount - 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;mListeners[conn] = func
&#9;&#9;return conn
&#9;end

&#9;function this:disconnect()
&#9;&#9;if self ~= this then error(&quot;disconnect must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;for k, v in pairs(mListeners) do
&#9;&#9;&#9;mListeners[k] = nil
&#9;&#9;end
&#9;&#9;mListenerCount = 0
&#9;end

&#9;function this:wait()
&#9;&#9;if self ~= this then error(&quot;wait must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;if not mWaitProxy then
&#9;&#9;&#9;mWaitProxy = Instance.new(&apos;BoolValue&apos;)
&#9;&#9;end
&#9;&#9;mHasWaiters = true
&#9;&#9;mWaitProxy.Changed:wait()
&#9;&#9;return unpack(mWaitReturns)
&#9;end

&#9;function this:fire(...)
&#9;&#9;if self ~= this then error(&quot;fire must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;local arguments;
&#9;&#9;if mListenerCount &gt; 0 or mHasWaiters then
&#9;&#9;&#9;arguments = {...}
&#9;&#9;end
&#9;&#9;if mHasWaiters then
&#9;&#9;&#9;mHasWaiters = false
&#9;&#9;&#9;mWaitReturns = arguments
&#9;&#9;&#9;mWaitProxy.Value = not mWaitProxy.Value
&#9;&#9;&#9;mWaitReturns = nil
&#9;&#9;end
&#9;&#9;if mListenerCount &gt; 0 then
&#9;&#9;&#9;for _, handlerFunc in pairs(mListeners) do
&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;handlerFunc(unpack(arguments))
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;function this:fireSync(...)
&#9;&#9;if self ~= this then error(&quot;fire must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;local arguments;
&#9;&#9;if mListenerCount &gt; 0 or mHasWaiters then
&#9;&#9;&#9;arguments = {...}
&#9;&#9;end
&#9;&#9;if mHasWaiters then
&#9;&#9;&#9;mHasWaiters = false
&#9;&#9;&#9;mWaitReturns = arguments
&#9;&#9;&#9;mWaitProxy.Value = not mWaitProxy.Value
&#9;&#9;&#9;mWaitReturns = nil
&#9;&#9;end
&#9;&#9;if mListenerCount &gt; 0 then
&#9;&#9;&#9;for _, handlerFunc in pairs(mListeners) do
&#9;&#9;&#9;&#9;handlerFunc(...)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;function this:destroy()
&#9;&#9;this:disconnect()
&#9;&#9;this.mListeners = nil
&#9;&#9;this.mListenerCount = nil
&#9;&#9;this.mWaitProxy = nil
&#9;&#9;this.mWaitReturns = nil
&#9;&#9;this.mHasWaiters = nil
&#9;&#9;this.destroy = nil
&#9;&#9;this.Destroy = nil
&#9;&#9;this.fire = nil
&#9;&#9;this.wait = nil
&#9;&#9;this.connect = nil
&#9;&#9;this.fireSync = nil
&#9;&#9;this = nil
&#9;end

&#9;function this:Destroy()
&#9;&#9;this:destroy()
&#9;end
&#9;
&#9;return this;
end
lib.CreateSignalInternal = CreateSignalInternal
lib.createSignalInternal = CreateSignalInternal
lib.create_internal_signal = CreateSignalInternal
lib.CreateSignal = CreateSignalInternal 
lib.createSignal = CreateSignalInternal
lib.create_signal = CreateSignalInternal

local function RoundNumber(Number, Divider)
&#9;-- Rounds a Number, with 1.5 rounding up to 2, and so forth, by default. 
&#9;-- @param Number the Number to round
&#9;-- @param [Divider] optional Number of which to &quot;round&quot; to. If nothing is given, it will default to 1. 

&#9;Divider = Divider or 1

&#9;return (math.floor((Number/Divider)+0.5)*Divider)
end
lib.roundNumber = RoundNumber
lib.RoundNumber = RoundNumber
lib.round_number = RoundNumber
lib.Round = RoundNumber
lib.round = RoundNumber


local function Modify(Instance, Values)
&#9;-- Modifies an Instance by using a table.  

&#9;assert(type(Values) == &quot;table&quot;, &quot;Values is not a table&quot;);

&#9;for Index, Value in next, Values do
&#9;&#9;if type(Index) == &quot;number&quot; then
&#9;&#9;&#9;Value.Parent = Instance
&#9;&#9;else
&#9;&#9;&#9;Instance[Index] = Value
&#9;&#9;end
&#9;end
&#9;return Instance
end
lib.modify = Modify
lib.Modify = Modify


local function Make(ClassType, Properties)
&#9;-- Using a syntax hack to create a nice way to Make new items.  

&#9;return Modify(Instance.new(ClassType), Properties)
end
lib.make = Make;
lib.Make = Make;


local function WaitForChild(Parent, Name, TimeLimit)
&#9;-- Waits for a child to appear. Not efficient, but it shoudln&apos;t have to be. It helps with debugging. 
&#9;-- Useful when ROBLOX lags out, and doesn&apos;t replicate quickly.
&#9;-- @param TimeLimit If TimeLimit is given, then it will return after the timelimit, even if it hasn&apos;t found the child.

&#9;assert(Parent ~= nil, &quot;Parent is nil&quot;)
&#9;assert(type(Name) == &quot;string&quot;, &quot;Name is not a string.&quot;)

&#9;local Child     = Parent:FindFirstChild(Name)
&#9;local StartTime = tick()
&#9;local Warned    = false

&#9;while not Child and Parent do
&#9;&#9;wait(0)
&#9;&#9;Child = Parent:FindFirstChild(Name)
&#9;&#9;if not Warned and StartTime + (TimeLimit or 5) &lt;= tick() then
&#9;&#9;&#9;Warned = true
&#9;&#9;&#9;warn(&quot;Infinite yield possible for WaitForChild(&quot; .. Parent:GetFullName() .. &quot;, &quot; .. Name .. &quot;)&quot;)
&#9;&#9;&#9;if TimeLimit then
&#9;&#9;&#9;&#9;return Parent:FindFirstChild(Name)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;if not Parent then
&#9;&#9;warn(&quot;Parent became nil.&quot;)
&#9;end

&#9;return Child
end
lib.waitForChild = WaitForChild
lib.WaitForChild = WaitForChild
lib.wait_for_child = WaitForChild

local function CallOnChildren(Instance, FunctionToCall)
&#9;-- Calls a function on each of the children of a certain object, using recursion.  

&#9;FunctionToCall(Instance)

&#9;for _, Child in next, Instance:GetChildren() do
&#9;&#9;CallOnChildren(Child, FunctionToCall)
&#9;end
end
lib.callOnChildren = CallOnChildren
lib.CallOnChildren = CallOnChildren
lib.call_on_children = CallOnChildren


local function getNearestParent(instance, className)
&#9;-- Returns the nearest parent of a certain class, or returns nil

&#9;local ancestor = instance
&#9;repeat
&#9;&#9;ancestor = ancestor.Parent
&#9;&#9;if ancestor == nil then
&#9;&#9;&#9;return nil
&#9;&#9;end
&#9;until ancestor:IsA(className)
&#9;return ancestor
end
lib.getNearestParent = getNearestParent;
lib.GetNearestParent = getNearestParent;
lib.get_nearest_parent = getNearestParent;


local function GetHumanoid(Descendant)
&#9;-- Return&apos;s a humanoid in the parent structure if it can find it. Intended to be used in Workspace only.
&#9;-- Useful for weapon scripts, and all that, especially to work on non player targets.
&#9;-- Will scan *up* to workspace. If workspace has a humanoid in it, it won&apos;t find it.

&#9;-- Will work even if there are non-humanoid objects named &quot;Humanoid&quot;
&#9;-- However, only works on objects named &quot;Humanoid&quot; (this is intentional)

&#9;-- @param Descendant The child you&apos;re searching up from. Really, this is for weapon scripts. 

&#9;while true do
&#9;&#9;local Humanoid = Descendant:FindFirstChild(&quot;Humanoid&quot;)

&#9;&#9;if Humanoid then
&#9;&#9;&#9;if Humanoid:IsA(&quot;Humanoid&quot;) then
&#9;&#9;&#9;&#9;return Humanoid
&#9;&#9;&#9;else -- Incase there are other humanoids in there.
&#9;&#9;&#9;&#9;for _, Item in pairs(Descendant:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;if Item.Name == &quot;Humanoid&quot; and Item:IsA(&quot;Humanoid&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;return Item
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;if Descendant.Parent and Descendant.Parent ~= Workspace then
&#9;&#9;&#9;Descendant = Descendant.Parent
&#9;&#9;else
&#9;&#9;&#9;return nil
&#9;&#9;end
&#9;end
end
lib.GetHumanoid = GetHumanoid
lib.getHumanoid = GetHumanoid


local function GetCharacter(Descendant)
&#9;-- Returns the Player and Charater that a descendent is part of, if it is part of one.
&#9;-- @param Descendant A child of the potential character. 

&#9;local Charater = Descendant
&#9;local Player   = Players:GetPlayerFromCharacter(Charater)

&#9;while not Player do
&#9;&#9;if Charater.Parent then
&#9;&#9;&#9;Charater = Charater.Parent
&#9;&#9;&#9;Player   = Players:GetPlayerFromCharacter(Charater)
&#9;&#9;else
&#9;&#9;&#9;return nil
&#9;&#9;end
&#9;end

&#9;-- Found the player, character must be true.
&#9;return Charater, Player
end
lib.getCharacter = GetCharacter
lib.GetCharacter = GetCharacter
lib.get_character = GetCharacter

lib.GetPlayerFromCharacter = GetCharacter
lib.getPlayerFromCharacter = GetCharacter
lib.get_player_from_character = GetCharacter

local function CheckPlayer(Player)
&#9;--- Makes sure a player has all necessary components.
&#9;-- @return Boolean If the player has all the right components

&#9;return Player and Player:IsA(&quot;Player&quot;) 
end
lib.checkPlayer = CheckPlayer
lib.CheckPlayer = CheckPlayer
lib.check_player = CheckPlayer


local function CheckCharacter(Player)
&#9;-- Makes sure a character has all the right &quot;parts&quot;
&#9;
&#9;if CheckPlayer(Player) then
&#9;&#9;local Character = Player.Character;

&#9;&#9;if Character then
&#9;&#9;&#9;
&#9;&#9;&#9;return Character.Parent
&#9;&#9;&#9;&#9;and Character:FindFirstChild(&quot;Humanoid&quot;)
&#9;&#9;&#9;&#9;and Character:FindFirstChild(&quot;HumanoidRootPart&quot;)
&#9;&#9;&#9;&#9;and Character:FindFirstChild(&quot;Torso&quot;) 
&#9;&#9;&#9;&#9;and Character:FindFirstChild(&quot;Head&quot;) 
&#9;&#9;&#9;&#9;and Character.Humanoid:IsA(&quot;Humanoid&quot;)
&#9;&#9;&#9;&#9;and Character.Head:IsA(&quot;BasePart&quot;)
&#9;&#9;&#9;&#9;and Character.Torso:IsA(&quot;BasePart&quot;)
&#9;&#9;&#9;&#9;and true
&#9;&#9;end
&#9;else
&#9;&#9;warn(&quot;[CheckCharacter] - Character Check failed!&quot;)
&#9;end

&#9;return nil
end
lib.checkCharacter = CheckCharacter
lib.CheckCharacter = CheckCharacter
lib.check_character = CheckCharacter


local function GetIndexByValue(Values, Value)
&#9;-- Return&apos;s the index of a Value. 

&#9;for Index, TableValue in next, Values do
&#9;&#9;if Value == TableValue then
&#9;&#9;&#9;return Index;
&#9;&#9;end
&#9;end

&#9;return nil
end
lib.getIndexByValue = GetIndexByValue
lib.GetIndexByValue = GetIndexByValue
lib.get_index_by_value = GetIndexByValue

lib.getIndex = getIndexByValue
lib.GetIndex = getIndexByValue
lib.get_index = getIndexByValue

local function Class(Constructor, Metatable)
&#9;--- Provides a wrapper for new classes. 

&#9;local ConstructNewClass

&#9;if Metatable then
&#9;&#9;function ConstructNewClass(...)
&#9;&#9;&#9;local newClass = {}

&#9;&#9;&#9;setmetatable(newClass, Metatable)

&#9;&#9;&#9;local Results = {Constructor(newClass, ...)}
&#9;&#9;&#9;return newClass, unpack(Results)
&#9;&#9;end
&#9;else
&#9;&#9;function ConstructNewClass(...)
&#9;&#9;&#9;local newClass = {}
&#9;&#9;&#9;local Results = {Constructor(newClass, ...)}
&#9;&#9;&#9;return newClass, unpack(Results)
&#9;&#9;end
&#9;end

&#9;return ConstructNewClass
end
lib.class = Class;
lib.Class = Class;

local function Sign(Number)
&#9;-- Return&apos;s the mathetmatical sign of an object
&#9;if Number == 0 then
&#9;&#9;return 0
&#9;elseif Number &gt; 0 then
&#9;&#9;return 1
&#9;else
&#9;&#9;return -1
&#9;end
end
lib.Sign = Sign
lib.sign = Sign


return lib</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="Backpack" referent="RBX48">
				<Properties>
					<string name="Name">QuentyAdminCommands</string>
				</Properties>
				<Item class="ModuleScript" referent="RBX49">
					<Properties>
						<string name="Name">QACSettings</string>
						<ProtectedString name="Source">-- QACSettings.lua
-- @author Quenty
-- Maintains QAC settings


-- WARNING: MoreArguments and SpecificGroups can really mess up this system if given the wrong values, such as an alphanumeral value

return {
&#9;CommandsAreInvisibleOnPseudoChat = true;
&#9;CommandSeperators = {
&#9;&#9;&quot; &quot;; &quot;!&quot;; &quot;&gt;&quot;; &quot;&lt;&quot;; &quot;:&quot;};
&#9;MoreArguments = {&quot;,&quot;; &quot;;&quot;};
&#9;SpecificGroups = {&quot;.&quot;; &quot;/&quot;}; -- Stuff like &quot;Kill Quenty,Team.Player1&quot;
&#9;PrintHeader = &quot;[CommandSystem] - &quot;;
&#9;Authorized = {
&#9;&#9;-- Testing purposes
&#9;&#9;&quot;Player1&quot;;
&#9;&#9;-- &quot;Player&quot;;
&#9;&#9;&quot;Quenty&quot;;
&#9;&#9;-- &quot;Mauv&quot;;
&#9;&#9;-- &quot;ColorfulBody&quot;;
&#9;&#9;-- &quot;Merely&quot;;
&#9;&#9;-- &quot;Seranok&quot;;
&#9;&#9;-- &quot;blobbyblob&quot;;
&#9;&#9;-- &quot;xXxMoNkEyMaNxXx&quot;;
&#9;&#9;-- &quot;treyreynolds&quot;;
&#9;&#9;-- &quot;Azureous&quot;;
&#9;&#9;-- &quot;Anaminus&quot;;
&#9;&#9;-- &quot;sim0nsays&quot;;
&#9;&#9;-- &quot;tone&quot;;
&#9;&#9;-- &quot;Shobobo99&quot;;
&#9;&#9;-- &quot;Worsen&quot;;
&#9;&#9;-- &quot;RagdorTheSharp&quot;;
&#9;}
};</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX50">
					<Properties>
						<string name="Name">PlayerTagTracker</string>
						<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local Players           = game:GetService(&quot;Players&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)

qSystems:Import(getfenv(0))

-- PlayerTagTracker.lua
-- This script is used to &quot;tag&quot; a player, and keep track of their &quot;status&quot;. Meant to be used
-- serverside only. 
-- @author Quenty
-- Last Modified January 20th, 2014

--[[--Change Log--
January 23rd, 2014
- Updated to new class system

January 20th, 2014
- Added change log
- Wrote initial script
--]]

local lib = {}

local MakePlayerTagTracker = Class(function(PlayerTagTracker, DoNotGCTags)
&#9;--- Tracks players / tags players.
&#9;-- @param [DoNotGCTags] Boolean, whether or not the system should remove player&apos;s tags when they leave. 

&#9;DoNotGCTags = DoNotGCTags or false

&#9;local TagCache = {}

&#9;local function GetPlayerTagCache(Player)
&#9;&#9;--- Return&apos;s a player&apos;s tag cache. Used internally
&#9;&#9;-- @param Player The player to get the cache of
&#9;&#9;-- @return Table, the Cache

&#9;&#9;local Cache = TagCache[Player.userId]
&#9;&#9;if not Cache then
&#9;&#9;&#9;Cache = {}
&#9;&#9;&#9;TagCache[Player.userId] = Cache
&#9;&#9;end
&#9;&#9;return Cache
&#9;end

&#9;local function IsTagged(Player, TagName, TagId)
&#9;&#9;--- Returns whether or not a player is tagged. If the player is not in game, returns false. 
&#9;&#9;-- @param Player The player to check
&#9;&#9;-- @param TagName String, The name of the tag to check (Not caps sensitive)
&#9;&#9;-- @param [TagId] If given, makes sure the TagId is matched. 
&#9;&#9;-- @return Boolean, true if tagged, false otherwise.

&#9;&#9;if Player and Player:IsA(&quot;Player&quot;) and Player.Parent == Players then
&#9;&#9;&#9;local Cache = GetPlayerTagCache(Player)
&#9;&#9;&#9;if TagId then
&#9;&#9;&#9;&#9;if Cache[TagName:lower()] == TagId then
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;return false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;return Cache[TagName:lower()] ~= nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;end
&#9;PlayerTagTracker.IsTagged = IsTagged
&#9;PlayerTagTracker.isTagged = IsTagged
&#9;PlayerTagTracker.GetTagStatus = IsTagged
&#9;PlayerTagTracker.getTagStatus = IsTagged
&#9;PlayerTagTracker.TagStatus = IsTagged
&#9;PlayerTagTracker.tagStatus = IsTagged

&#9;local function Tag(Player, TagName)
&#9;&#9;--- Sets a tag to the player to true. 
&#9;&#9;-- @param Player The player to tag
&#9;&#9;-- @param TagName String, The name of the tag to tag. Not caps sensitive. 
&#9;&#9;-- @return The TagId idnetified 

&#9;&#9;local Cache = GetPlayerTagCache(Player)
&#9;&#9;Cache[TagName:lower()] = math.floor(tick())

&#9;&#9;return Cache[TagName:lower()]
&#9;end
&#9;PlayerTagTracker.Tag = Tag
&#9;PlayerTagTracker.tag = Tag

&#9;local function Untag(Player, TagName)
&#9;&#9;--- Sets a tag to the player to false
&#9;&#9;-- @param Player The player to untag
&#9;&#9;-- @param TagName String, The name of the tag to tag. Not caps sensitive. 

&#9;&#9;local Cache = GetPlayerTagCache(Player)
&#9;&#9;Cache[TagName:lower()] = nil
&#9;end
&#9;PlayerTagTracker.Untag = Untag
&#9;PlayerTagTracker.untag = Untag

&#9;-- Setup GC 
&#9;if not DoNotGCTags then
&#9;&#9;Players.PlayerRemoving:connect(function(Player)
&#9;&#9;&#9;TagCache[Player] = nil
&#9;&#9;end)
&#9;end
end)
lib.MakePlayerTagTracker = MakePlayerTagTracker
lib.makePlayerTagTracker = MakePlayerTagTracker
lib.New = MakePlayerTagTracker 
lib.new = MakePlayerTagTracker

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX51">
					<Properties>
						<string name="Name">PlayerId</string>
						<ProtectedString name="Source">local Players           = Game:GetService(&quot;Players&quot;)
local Teams             = Game:GetService(&quot;Teams&quot;)
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local Type              = LoadCustomLibrary(&quot;Type&quot;)
local qString           = LoadCustomLibrary(&quot;qString&quot;)
local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local Table             = LoadCustomLibrary(&quot;Table&quot;)

local lib               = {}
qSystems:Import(getfenv(0));

-- PlayerId.lua
-- Last modified on January 23rd, 2014
-- @author Quenty

--[[-- Update Log --
January 23rd, 2014
- Updated to new class system

January 19th, 2014
- Updated to use module scripts.
- Added update log
- Converted name from &quot;qPlayerSystem&quot; to &quot;PlayerId&quot; which makes a lot more sense
- Added &quot;UserId&quot; to default list
- Added Random.3534 (some number) so we can select more than one random player at once.
- Added more aliases to methods in PlayerIdSystem

--]]
local MakeShortcutReference = Class(function(ShortcutReference, CheckFunction)
&#9;--- Creates a new checker that returns whether or not a player is considered X
&#9;-- @param CheckFunction A function that returns a table of valid players

&#9;function ShortcutReference:Check(Players, User, ...)
&#9;&#9;--- Returns a table of players that qualify
&#9;&#9;-- @param Players A list of players to check
&#9;&#9;-- @param User The current player &quot;Checking&quot; so commands like &quot;me&quot; work. May be nil
&#9;&#9;-- @param ... Extra data / arguments (As strings) to check for / user
&#9;&#9;
&#9;&#9;return CheckFunction(Players, User, ...)
&#9;end
end)

local MakePlayerIdSystem = Class(function(PlayerIdSystem, MoreArguments, SpecificGroups)
&#9;--- A system used to Id a player from a string. Parses strings using custom parser templates. 
&#9;-- @param MoreArguments A table of characters that &quot;seperate&quot; or &quot;break&quot; a string. apart. 
&#9;-- @param SpecificGroups Another tablel that breaks it apart.  

&#9;-- WARNING: MoreArguments and SpecificGroups can really mess up this system if given the wrong values, such as an alphanumeral value (which could also be a player name).

&#9;local PlayerReferences = {} -- Player references are shortcuts where you first id the player, and then the shortcut. Ex: Quenty.Team
&#9;local ShortcutReferences = {}
&#9;local SimpleReference = {} -- An Alias system for shortened names...
&#9;PlayerIdSystem.SimpleReference = SimpleReference -- For stuff like SimpleReference[&quot;EpicPerson&quot;] = &quot;Quenty&quot; so you can do kill/EpicPerson and it kills Quenty

&#9;MoreArguments = MoreArguments or error(&quot;No more arguments&quot;)
&#9;SpecificGroups = SpecificGroups or error(&quot;No SpecificGroups&quot;)

&#9;local function GetPlayerReference(Name)
&#9;&#9;for ReferenceName, ReferenceFunction in pairs(PlayerReferences) do
&#9;&#9;&#9;if qString.CompareCutFirst(ReferenceName, Name) then
&#9;&#9;&#9;&#9;return ReferenceFunction
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function GetPlayersFromString(self, String, User)
&#9;&#9;--- Given a string, get a player from it.
&#9;&#9;-- @param String The string to parse. Not case sensitive. 
&#9;&#9;-- @param [User] The user that is &quot;using&quot; the system. May be nil. 

&#9;&#9;local Targets = {}
&#9;&#9;local AllPlayers = Players:GetPlayers();

&#9;&#9;local function CanAdd(Player)
&#9;&#9;&#9;--- Returns false if the Player is in the list already.  
&#9;&#9;&#9;-- @param Player The player to check for 
&#9;&#9;&#9;-- @return Boolean, whether or not the player can be added.

&#9;&#9;&#9;for _, Item in pairs(Targets) do
&#9;&#9;&#9;&#9;if Item == Player then
&#9;&#9;&#9;&#9;&#9;return false;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return true;
&#9;&#9;end

&#9;&#9;local function Add(Player)
&#9;&#9;&#9;--- Locally used function, adds the player to the Target list
&#9;&#9;&#9;-- @param Player The player to add, if the player can be added.

&#9;&#9;&#9;if CanAdd(Player) then
&#9;&#9;&#9;&#9;Targets[#Targets+1] = Player
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;local function AddTable(List)
&#9;&#9;&#9;-- Adds every &quot;Player&quot; in the list to the Target list, if they can be added. 
&#9;&#9;&#9;-- @param List The list of players to add.

&#9;&#9;&#9;for _, Value in pairs(List) do
&#9;&#9;&#9;&#9;Add(Value)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;String = String:lower() -- Make the string not caps sensitive. 

&#9;&#9;local SeperatedIntoSectors = qString.BreakString(String, MoreArguments)

&#9;&#9;for _, BrokenString in pairs(SeperatedIntoSectors) do
&#9;&#9;&#9;local SecondBreak = qString.BreakString(BrokenString, SpecificGroups)
&#9;&#9;&#9;--local NameLength = #BrokenString; 

&#9;&#9;&#9;local ShortcutReferenceName = SecondBreak[1]; -- Like &quot;Group.363434&quot;, where the Name would be &quot;Group&quot;
&#9;&#9;&#9;
&#9;&#9;&#9;local SecondBreakModified = {} -- Without the first one, so it may be used in argument passing of ArgumentObjects
&#9;&#9;&#9;for index = 2, #SecondBreak do
&#9;&#9;&#9;&#9;SecondBreakModified[index-1] = SecondBreak[index];
&#9;&#9;&#9;end

&#9;&#9;&#9;local ReferenceObject --= ShortcutReferences[ShortcutReferenceName];
&#9;&#9;&#9;for Name, Item in pairs(ShortcutReferences) do
&#9;&#9;&#9;&#9;if not ReferenceObject and qString.CompareStrings(Name, ShortcutReferenceName) then
&#9;&#9;&#9;&#9;&#9;ReferenceObject = Item
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;if ReferenceObject then -- So we found a match, like kill/team.admins 
&#9;&#9;&#9;&#9;local Received = ReferenceObject:Check(AllPlayers, User, unpack(SecondBreakModified))

&#9;&#9;&#9;&#9;if type(Received) == &quot;table&quot; then
&#9;&#9;&#9;&#9;&#9;AddTable(Received) -- Get the list, then add it to Targets
&#9;&#9;&#9;&#9;elseif Type.isAnInstance(Received) == &quot;Instance&quot; and game.IsA(Received, &quot;Player&quot;) then
&#9;&#9;&#9;&#9;&#9;Add(Received)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&quot;[PlayerIdSystem] - Did not receive a correct value type from the reference object &apos;&quot;..ShortcutReferenceName..&quot;&apos;! Got a &quot;..Type.getType(Received)..&quot; value&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if SimpleReference[ShortcutReferenceName] then
&#9;&#9;&#9;&#9;&#9;print(&quot;[PlayerIdSystem] - Getting from SimpleReferences&quot;)
&#9;&#9;&#9;&#9;&#9;AddTable(PlayerIdSystem:GetPlayersFromString(SimpleReference[ShortcutReferenceName]))
&#9;&#9;&#9;&#9;else

&#9;&#9;&#9;&#9;&#9;if #SecondBreak &gt; 1 then -- Instances like Player1.Team, where the seperator indicates that the player cannot be a team. 
&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;[PlayerIdSystem] - Player reference activated, reference name &apos;&quot; .. SecondBreak[2] .. &quot;&apos;&quot;);

&#9;&#9;&#9;&#9;&#9;&#9;local PlayerReferenceName = SecondBreak[2]
&#9;&#9;&#9;&#9;&#9;&#9;local PlayerReference = GetPlayerReference(PlayerReferenceName)

&#9;&#9;&#9;&#9;&#9;&#9;if PlayerReference then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;for _, Player in pairs(AllPlayers) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local PlayerName = Player.Name
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if qString.CompareCutFirst(PlayerName, SecondBreak[1]) then -- Player1.Team will be {&quot;Player1&quot;, &quot;Team&quot;}
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AddTable(PlayerReference(AllPlayers, User, Player))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;[PlayerIdSystem] - No player reference found with the name &apos;&quot; .. PlayerReferenceName .. &quot;&apos;&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;for _, Player in pairs(AllPlayers) do -- Loop through the players 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local PlayerName = Player.Name
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if qString.CompareCutFirst(PlayerName, BrokenString) then -- and try to find matches of names
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Add(Player)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;return Targets
&#9;end
&#9;PlayerIdSystem.GetPlayersFromString = GetPlayersFromString
&#9;PlayerIdSystem.getPlayersFromString = GetPlayersFromString
&#9;PlayerIdSystem.Get = GetPlayersFromString
&#9;PlayerIdSystem.get = GetPlayersFromString

&#9;local function AddShortcut(self, Name, CheckFunction)
&#9;&#9;--- Adds a new &quot;reference&quot; to the system
&#9;&#9;-- @param Name The name of the checker. Can be aliased by the AddAlias command. String.
&#9;&#9;-- @param CheckFunction A function that should check players.
&#9;&#9;&#9;--- Returns a table of players that qualify
&#9;&#9;&#9;-- @param Players A list of players to check
&#9;&#9;&#9;-- @param User The current player &quot;Checking&quot; so commands like &quot;me&quot; work. May be nil
&#9;&#9;&#9;-- @param ... Extra data / arguments (As strings) to check for / user

&#9;&#9;local NewReference = MakeShortcutReference(CheckFunction)
&#9;&#9;ShortcutReferences[Name:lower()] = NewReference;
&#9;end
&#9;PlayerIdSystem.AddShortcut = AddShortcut
&#9;PlayerIdSystem.AddShortcut = AddShortcut

&#9;local function AddPlayerReference(self, Names, CheckFunction)
&#9;&#9;--- Adds a player reference, so players can do &quot;kill player.team&quot;
&#9;&#9;-- @param Names a table of aliases/names to id to.

&#9;&#9;-- CheckFunction(AllPlayers, User, Player)
&#9;&#9;&#9;-- Must return a table. 
&#9;&#9;&#9;-- @param User The user getting the player, may be nil. 
&#9;&#9;&#9;-- @param AllPlayers A table of all players
&#9;&#9;&#9;-- @return A table. Always. 
&#9;&#9;for _, Name in pairs(Names) do
&#9;&#9;&#9;PlayerReferences[Name:lower()] = CheckFunction
&#9;&#9;end
&#9;end
&#9;PlayerIdSystem.AddPlayerReference = AddPlayerReference
&#9;PlayerIdSystem.addPlayerReference = AddPlayerReference

&#9;local function AddAlias(self, Name, NewAliasName)
&#9;&#9;--- Aliases a current reference for a new one.
&#9;&#9;-- @param Name The name of the current alias.
&#9;&#9;-- @param NewAliasName The name of the new alias. Is not caps sensitive. 

&#9;&#9;if type(NewAliasName) == &quot;string&quot; then
&#9;&#9;&#9;local Object = ShortcutReferences[Name:lower()] 

&#9;&#9;&#9;if not Object then
&#9;&#9;&#9;&#9;error(&quot;[PlayerIdSystem] - Could not find the object of &apos;&quot;..Name..&quot;&apos; in database, so the Alias of &apos;&quot;..NewAliasName..&quot;&apos; could not be set&quot;)
&#9;&#9;&#9;elseif ShortcutReferences[NewAliasName:lower()] then
&#9;&#9;&#9;&#9;warn(&quot;[PlayerIdSystem] - You are overwriting &quot;..NewAliasName..&quot; in the ShortcutReferences database with &apos;&quot;..Name..&quot;&apos;&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;ShortcutReferences[NewAliasName:lower()] = Object
&#9;&#9;elseif type(NewAliasName) == &quot;table&quot; then
&#9;&#9;&#9;for _, Item in pairs(NewAliasName) do
&#9;&#9;&#9;&#9;PlayerIdSystem:AddAlias(Name, Item)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;argumentError(&quot;NewAliasName&quot;, false, &quot;table or string&quot;, Type.getType(NewAliasName))
&#9;&#9;end
&#9;end
&#9;PlayerIdSystem.AddAlias = AddAlias
&#9;PlayerIdSystem.addAlias = AddAlias
&#9;PlayerIdSystem.Alias = AddAlias
&#9;PlayerIdSystem.alias = AddAlias

&#9;local function RemoveAlias(Name)
&#9;&#9;--- Removes a current aliase from the list 
&#9;&#9;-- @param Name String, the alias to remove. 

&#9;&#9;ShortcutReferences[Name:lower()] = nil;
&#9;end
&#9;PlayerIdSystem.RemoveAlias = RemoveAlias
&#9;PlayerIdSystem.removeAlias = RemoveAlias
&#9;PlayerIdSystem.Remove = RemoveAlias
&#9;PlayerIdSystem.remove = RemoveAlias
end)
lib.MakePlayerIdSystem = MakePlayerIdSystem
lib.makePlayerIdSystem = MakePlayerIdSystem
lib.MakePlayerId = MakePlayerIdSystem
lib.makePlayerId = MakePlayerIdSystem


local function MakeDefaultPlayerIdSystem(MoreArguments, SpecificGroups)
&#9;--- Generates the default system of a &apos;PlayerArgumentSystem&apos;
&#9;-- @param MoreArguments A table of characters that &quot;seperate&quot; or &quot;break&quot; a string. apart. 
&#9;-- @param SpecificGroups Another tablel that breaks it apart.  

&#9;local DefaultPlayerIdSystem = MakePlayerIdSystem(MoreArguments, SpecificGroups)

&#9;DefaultPlayerIdSystem:AddShortcut(&quot;All&quot;, function(Players, User)
&#9;&#9;&#9;return Players
&#9;&#9;end)
&#9;&#9;DefaultPlayerIdSystem:Alias(&quot;All&quot;, {&quot;Everyone&quot;, &quot;Everybody&quot;, &quot;everyman&quot;})

&#9;DefaultPlayerIdSystem:AddShortcut(&quot;Random&quot;, function(Players, User, Number)
&#9;&#9;&#9;if #Players &gt;= 1 then
&#9;&#9;&#9;&#9;if tonumber(Number) then
&#9;&#9;&#9;&#9;&#9;--- Select a number of random players...
&#9;&#9;&#9;&#9;&#9;local List = {}
&#9;&#9;&#9;&#9;&#9;local ToFind = tonumber(Number)

&#9;&#9;&#9;&#9;&#9;local PlayerList = Table.Copy(Players)
&#9;&#9;&#9;&#9;&#9;while ToFind &gt; 0 and PlayerList[1] do
&#9;&#9;&#9;&#9;&#9;&#9;local SelectedIndex = math.random(1, #PlayerList)
&#9;&#9;&#9;&#9;&#9;&#9;List[#List + 1] = PlayerList[SelectedIndex]

&#9;&#9;&#9;&#9;&#9;&#9;-- Swap the selected and the top
&#9;&#9;&#9;&#9;&#9;&#9;PlayerList[SelectedIndex] = PlayerList[#PlayerList]
&#9;&#9;&#9;&#9;&#9;&#9;PlayerList[#PlayerList] = nil
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;return List
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;return {Players[math.random(1, #Players)]}
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;warn(&quot;[PlayerId] - There are no players to select from, so random pick failed. &quot;)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;DefaultPlayerIdSystem:Alias(&quot;Random&quot;, {&quot;Rand&quot;})

&#9;DefaultPlayerIdSystem:AddShortcut(&quot;Guests&quot;, function(Players, User)
&#9;&#9;&#9;local List = {}

&#9;&#9;&#9;for _, Player in pairs(Players) do
&#9;&#9;&#9;&#9;if qString.CompareCutFirst(Player.Name, &quot;Guest &quot;) then
&#9;&#9;&#9;&#9;&#9;List[#List+1] = Player
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;return List;
&#9;&#9;end)
&#9;
&#9;DefaultPlayerIdSystem:AddShortcut(&quot;Self&quot;, function(Players, User)
&#9;&#9;&#9;if User then
&#9;&#9;&#9;&#9;return {User}
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;warn(&quot;[PlayerId] - No user was given, so it was impossible to identify a user from the list&quot;)
&#9;&#9;&#9;&#9;return nil
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;DefaultPlayerIdSystem:Alias(&quot;Self&quot;, {&quot;Myself&quot;, &quot;Me&quot;})

&#9;DefaultPlayerIdSystem:AddShortcut(&quot;Team&quot;, function(Players, User, TeamName) -- Fairly sketchy, because usually team names have spaces, which can&apos;t beused, because 
&#9;&#9;&#9;if TeamName and type(TeamName) == &quot;string&quot; then
&#9;&#9;&#9;&#9;local FoundTeam
&#9;&#9;&#9;&#9;local List = {}

&#9;&#9;&#9;&#9;if not FoundTeam then -- Incase kill/Team.NameHere
&#9;&#9;&#9;&#9;&#9;for _, Team in pairs(Teams:GetTeams()) do -- Search by name. 
&#9;&#9;&#9;&#9;&#9;&#9;if qString.CompareCutFirst(Team.Name, TeamName) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;FoundTeam = Team
&#9;&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not FoundTeam then -- Look for a team color match? Sure!
&#9;&#9;&#9;&#9;&#9;for _, Team in pairs(Teams:GetTeams()) do
&#9;&#9;&#9;&#9;&#9;&#9;if qString.CompareCutFirst(Team.TeamColor.Name, TeamName) then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;FoundTeam = Team
&#9;&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not FoundTeam then
&#9;&#9;&#9;&#9;&#9;if qString.CompareCutFirst(&quot;Neutral&quot;, TeamName) then -- Incase kill/Team.neutra
&#9;&#9;&#9;&#9;&#9;&#9;local NeutralTeam
&#9;&#9;&#9;&#9;&#9;&#9;for _, Team in pairs(Teams:GetTeams()) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if qString.CompareCutFirst(Team.Name, &quot;Neutral&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;NeutralTeam = Team
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if NeutralTeam then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;FoundTeam = NeutralTeam
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;for _, Player in pairs(Players) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if Player.Neutral then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;List[#List + 1] = Player 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;return List
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not FoundTeam then
&#9;&#9;&#9;&#9;&#9;print(&quot;[PlayerIdSystem] - Could not find team with Team Search...&quot;)
&#9;&#9;&#9;&#9;&#9;return nil
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;local TeamColorName = FoundTeam.TeamColor.Name

&#9;&#9;&#9;&#9;&#9;for _, Player in pairs(Players) do
&#9;&#9;&#9;&#9;&#9;&#9;if Player.TeamColor.Name == TeamColorName and not Player.Neutral then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;List[#List + 1] = Player 
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;return List
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;local TeamColorName = User.TeamColor.Name -- Default to user team...
&#9;&#9;&#9;local List = {}
&#9;&#9;&#9;
&#9;&#9;&#9;for _, Player in pairs(Players) do
&#9;&#9;&#9;&#9;if Player.TeamColor.Name == TeamColorName and not Player.Neutral then
&#9;&#9;&#9;&#9;&#9;List[#List + 1] = Player 
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;return List
&#9;&#9;end)
&#9;DefaultPlayerIdSystem:Alias(&quot;Team&quot;, {&quot;T&quot;, &quot;TeamName&quot;})

&#9;DefaultPlayerIdSystem:AddShortcut(&quot;Group&quot;, function(Players, User, GroupId, RankId) 
&#9;&#9;if GroupId and tonumber(GroupId) then
&#9;&#9;&#9;local List = {}
&#9;&#9;&#9;for _, Player in pairs(Players) do
&#9;&#9;&#9;&#9;if Player:IsInGroup(tonumber(GroupId)) then
&#9;&#9;&#9;&#9;&#9;if RankId and tonumber(RankId) then
&#9;&#9;&#9;&#9;&#9;&#9;if Player:GetRankInGroup(tonumber(GroupId)) &gt;= RankId then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;List[#List+1] = Player
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;List[#List+1] = Player
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return List;
&#9;&#9;else
&#9;&#9;&#9;error(&quot;[PlayerId] - Group ID Required.&quot;)
&#9;&#9;end
&#9;end)

&#9;DefaultPlayerIdSystem:AddShortcut(&quot;UserId&quot;, function(Players, User, Id)
&#9;&#9;if Id then
&#9;&#9;&#9;local List = {}
&#9;
&#9;&#9;&#9;for _, Player in pairs(Players) do
&#9;&#9;&#9;&#9;if Player.userId == Id then
&#9;&#9;&#9;&#9;&#9;List[#List+1] = Player
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;
&#9;&#9;&#9;return List
&#9;&#9;else
&#9;&#9;&#9;error(&quot;[PlayerId] - Id required&quot;)
&#9;&#9;end
&#9;end)
&#9;DefaultPlayerIdSystem:Alias(&quot;UserId&quot;, {&quot;Id&quot;, &quot;PlayerId&quot;, &quot;Uid&quot;})


&#9;-- PLAYER REFERENCE --
&#9;DefaultPlayerIdSystem:AddPlayerReference({&quot;Team&quot;, &quot;T&quot;, &quot;TeamMembers&quot;}, function(Players, User, IndexedPlayer) -- Stuff like &quot;kill Player1.Team&quot;
&#9;&#9;local List = {}

&#9;&#9;if IndexedPlayer.Neutral then
&#9;&#9;&#9;for _, Player in pairs(Players) do
&#9;&#9;&#9;&#9;if Player.Neutral then
&#9;&#9;&#9;&#9;&#9;List[#List + 1] = Player
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local TeamColorName = IndexedPlayer.TeamColor.Name

&#9;&#9;&#9;for _, Player in pairs(Players) do
&#9;&#9;&#9;&#9;if Player.TeamColor.Name == TeamColorName and not Player.Neutral then
&#9;&#9;&#9;&#9;&#9;List[#List + 1] = Player 
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;return List
&#9;end)

&#9;DefaultPlayerIdSystem:AddPlayerReference({&quot;Friends&quot;}, function(Players, User, IndexedPlayer) -- Stuff like &quot;kill Player1.Team&quot;
&#9;&#9;local List = {}

&#9;&#9;for _, Player in pairs(Players) do
&#9;&#9;&#9;if Player ~= IndexedPlayer then
&#9;&#9;&#9;&#9;if Player:IsFriendsWith(IndexedPlayer.userId) then
&#9;&#9;&#9;&#9;&#9;List[#List + 1] = Player
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;return List
&#9;end)

&#9;DefaultPlayerIdSystem:AddPlayerReference({&quot;BestFriends&quot;, &quot;BFriends&quot;}, function(Players, User, IndexedPlayer) -- Stuff like &quot;kill Player1.Team&quot;
&#9;&#9;local List = {}

&#9;&#9;for _, Player in pairs(Players) do
&#9;&#9;&#9;if Player ~= IndexedPlayer then
&#9;&#9;&#9;&#9;if Player:IsBestFriendsWith(IndexedPlayer.userId) then
&#9;&#9;&#9;&#9;&#9;List[#List + 1] = Player
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;return List
&#9;end)

&#9;return DefaultPlayerIdSystem
end
lib.MakeDefaultPlayerIdSystem = MakeDefaultPlayerIdSystem
lib.makeDefaultPlayerIdSystem = MakeDefaultPlayerIdSystem
lib.MakeDefaultPlayerId = MakeDefaultPlayerIdSystem
lib.makeDefaultPlayerId = MakeDefaultPlayerIdSystem

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX52">
					<Properties>
						<string name="Name">NevermoreCommandsLocal</string>
						<ProtectedString name="Source">local Players               = game:GetService(&quot;Players&quot;)
local ReplicatedStorage     = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine       = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary     = NevermoreEngine.LoadLibrary

local qSystems              = LoadCustomLibrary(&quot;qSystems&quot;)
qSystems:Import(getfenv(0))

-- NevermoreCommandsLocal
-- @author Quenty
-- Module should load client side in order to enable certain commands in Nevermore. May add support later
-- to handle a GUI interface. 

-- Created August 14th, 2014
-- Last updated August 14th, 2014

assert(script.Name == &quot;NevermoreCommandsLocal&quot;)

local NevermoreCommandsLocal = {}
local NevermoreRemoteEvent = NevermoreEngine.GetRemoteEvent(&quot;NevermoreCommands&quot;)

local LocalPlayer = Players.LocalPlayer

local ClientRequests = {} do-- Requests from the server. 
&#9;local RequestList = {}

&#9;local function GetRequest(Name)
&#9;&#9;return RequestList[Name:lower()]
&#9;end

&#9;function ClientRequests:AddRequestHandler(RequestName, FunctionExecute)
&#9;&#9;assert(RequestList[RequestName:lower()] == nil, &quot;RequestList[&quot; .. RequestName:lower() .. &quot;] is already filled.&quot;)

&#9;&#9;RequestList[RequestName:lower()] = FunctionExecute
&#9;end

&#9;NevermoreRemoteEvent.OnClientEvent:connect(function(RequestName, ...)
&#9;&#9;-- Errrrr.... this may definitely disconnect if player GUI reset not enabled.
&#9;&#9;
&#9;&#9;if RequestName and type(RequestName) == &quot;string&quot; then
&#9;&#9;&#9;local RequestFunction = GetRequest(RequestName)
&#9;&#9;&#9;if RequestFunction then

&#9;&#9;&#9;&#9;local Args = {...}
&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;RequestFunction(unpack(Args))
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;warn(&quot;[NevermoreCommandsLocal] - Request handle for name &apos;&quot; .. RequestName .. &quot;&apos; is unregistered, failed to execute.&quot;);
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;warn(&quot;[NevermoreCommandsLocal] - Invalid RequestName, type not string.&quot;)
&#9;&#9;end
&#9;end)
end


do
&#9;local LastCharacterCFrame

&#9;ClientRequests:AddRequestHandler(&quot;Freecam&quot;, function()
&#9;&#9;if CheckCharacter(LocalPlayer) then
&#9;&#9;&#9;LastCharacterCFrame = LocalPlayer.Character.Torso.CFrame
&#9;&#9;else
&#9;&#9;&#9;LastCharacterCFrame = nil
&#9;&#9;end

&#9;&#9;LocalPlayer.Character = nil
&#9;end)

&#9;ClientRequests:AddRequestHandler(&quot;Unfreecam&quot;, function()
&#9;&#9;Workspace.CurrentCamera:Destroy();
&#9;&#9;wait(0)
&#9;&#9;while not Workspace.CurrentCamera do
&#9;&#9;&#9;wait(0)
&#9;&#9;end
&#9;&#9;Workspace.CurrentCamera.CameraType = &quot;Custom&quot;;
&#9;&#9;Workspace.CurrentCamera.CameraSubject = LocalPlayer.Character;

&#9;&#9;if LastCharacterCFrame and CheckCharacter(LocalPlayer) then
&#9;&#9;&#9;LocalPlayer.Character.Torso.CFrame = LastCharacterCFrame
&#9;&#9;end

&#9;&#9;LastCharacterCFrame = nil
&#9;end)
end

do
&#9;local LastSong

&#9;local function RemoveLastSong()
&#9;&#9;if LastSong then
&#9;&#9;&#9;LastSong:Stop()
&#9;&#9;&#9;LastSong:Destroy()
&#9;&#9;&#9;LastSong = nil
&#9;&#9;end
&#9;end

&#9;local function PlaySong(SongId)
&#9;&#9;local NewSound = Make(&quot;Sound&quot;, {
&#9;&#9;&#9;SoundId    = &quot;rbxassetid://&quot; .. SongId;
&#9;&#9;&#9;Volume     = 1;
&#9;&#9;&#9;Archivable = false;
&#9;&#9;&#9;Parent     = LocalPlayer.PlayerGui;
&#9;&#9;&#9;Name       = SongId;
&#9;&#9;&#9;Looped     = true;
&#9;&#9;&#9;Pitch      = 1;
&#9;&#9;})

&#9;&#9;NewSound:Play()

&#9;&#9;LastSong = NewSound;
&#9;end

&#9;ClientRequests:AddRequestHandler(&quot;PlaySong&quot;, function(SongId)
&#9;&#9;if SongId and tonumber(SongId) then
&#9;&#9;&#9;RemoveLastSong()
&#9;&#9;&#9;PlaySong(SongId)
&#9;&#9;else
&#9;&#9;&#9;warn(&quot;[NevermoreCommandsLocal] - Could not execute, songId was null&quot;)
&#9;&#9;end
&#9;end)

&#9;ClientRequests:AddRequestHandler(&quot;StopSong&quot;, function()
&#9;&#9;RemoveLastSong()
&#9;end)


end

return NevermoreCommandsLocal</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX53">
					<Properties>
						<string name="Name">CommandSystems</string>
						<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local Type              = LoadCustomLibrary(&quot;Type&quot;)
local qString           = LoadCustomLibrary(&quot;qString&quot;)
local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local QACSettings       = LoadCustomLibrary(&quot;QACSettings&quot;)

qSystems:Import(getfenv(0));

local lib = {}

-- CommandSystems.lua
-- This library forms the basis of Nevermore&apos;s admin commands
-- @author Quenty
-- Last revised January 26th, 2014 

--[[-- Update Log --
Januarty 26th, 2014
- Modified to use QACSettings
- Updated to remove Service function
- Updated to new class system

January 14th, 2014
- Updated to use Settings.QAC and camal case. 
- Added documentation to certain modules

January 1st, 2014
- Updated to use module scripts

--]]

---------------------------------
-- Command and Argument System --
---------------------------------

--[[

MakeArgumentWithParameters ( Class `Argument`, ... )
&#9;returns: `ArgumentWithParameters`
&#9;&#9;
Creates an `ArgumentWithParameters` class which is assigned to each command and contains the specific 
paramaters that the argument needs, such as high or low values.  

The intent of this was to allow local side scripts to have sliding values and stuff, such as humanoid 
values, but this system still does not work like that at all, which is quite disappointing.  However, 
it still allows input validation

Arguments:
&#9;`Argument`
&#9;&#9;The base argument 
&#9;`...`
&#9;&#9;Any number of arguments after this that should be whatever the base argument requires.  

Returns:
&#9;`ArgumentWithParamter`
&#9;&#9;The newly created object

--]]


local MakeArgumentWithParameters = Class(function(argument, baseArgument, ...) -- Each command get&apos;s it&apos;s own pseudo &apos;Argument&apos; class.
&#9;-- Throw away class to allow argument specifically. 

&#9;-- VerifyArg(baseArgument, &quot;Argument&quot;, &quot;baseArgument&quot;);
&#9;

&#9;local inputArguments = {...}

&#9;argument.name = baseArgument.name;
&#9;argument.requiresInput = baseArgument.requiresInput;
&#9;--argument.description = baseArgument.description;
&#9;argument.baseArgument = baseArgument

&#9;function argument:getArgumentFromString(stringInput, user) --&gt; stringInput, inputArguments, user, ...
&#9;&#9;-- Returns the argument from a string

&#9;&#9;-- VerifyArg(stringInput, &quot;string&quot;, &quot;stringInput&quot;, not argument.requiresInput);
&#9;&#9;-- VerifyArg(user, &quot;Player&quot;, &quot;user&quot;);
&#9;&#9;

&#9;&#9;return baseArgument:getArgumentFromString(stringInput, user, unpack(inputArguments));
&#9;end
end)

local MakeArgument = Class(function(argument, argumentSystem, argumentName, description, argumentFunction, requiresInput)
&#9;-- A generic argument...

&#9;&#9;-- So basically I ran into a problem with arguments. Each argument is generic, so we can have an argument for
&#9;&#9;-- numbers, and one for other stuff, but what if we want constrained numbers? Like 3-25?  We dont&apos; want a new argument
&#9;&#9;-- class to be created the long way, so...

&#9;&#9;-- So the solution was to give each command it&apos;s own argument class &apos;ArgumentWithParamter&apos;, which meant that there&apos;s 
&#9;&#9;-- a lot of tables per a command. Each command has it&apos;s own table, plus one for each argument, and then another entire
&#9;&#9;-- table per an argument. 

&#9;&#9;-- So there&apos;s an iffyness of if we really do get a better efficiency with this system. Development time is definitly 
&#9;&#9;-- faster after the fact, but.. eh. 


&#9;-- VerifyArg(argumentSystem, &quot;ArgumentSystem&quot;, &quot;argumentSystem&quot;);
&#9;-- VerifyArg(description, &quot;string&quot;, &quot;description&quot;)
&#9;-- VerifyArg(argumentName, &quot;string&quot;, &quot;argumentName&quot;);
&#9;-- VerifyArg(argumentFunction, &quot;function&quot;, &quot;argumentFunction&quot;)

&#9;argument.name = argumentName;
&#9;argument.requiresInput = requiresInput;
&#9;argument.description = description;

&#9;function argument:getArgumentFromString(stringInput, user, ...)
&#9;&#9;-- Returns the argument from a string

&#9;&#9;-- VerifyArg(stringInput, &quot;string&quot;, &quot;stringInput&quot;, not argument.requiresInput);
&#9;&#9;-- VerifyArg(user, &quot;Player&quot;, &quot;user&quot;);

&#9;&#9;return argumentFunction(stringInput, user, ...);
&#9;end

&#9;function argument:MakeSpecificArgument(...)
&#9;&#9;-- Returns a new class &apos;ArgumentWithParameters&apos;

&#9;&#9;local NewArgumentWithParams = MakeArgumentWithParameters(argument, ...);
&#9;&#9;return NewArgumentWithParams;
&#9;end
end)


local Args
local ArgumentSystem = {} do
&#9;local argumentList = {}
&#9;local argumentCount = 0;

&#9;ArgumentSystem.Arguments = {}

&#9;setmetatable(ArgumentSystem.Arguments, { -- Syntax hacks to get an argument. 
&#9;&#9;__index = function(indexedTable, newIndex)
&#9;&#9;&#9;-- VerifyArg(newIndex, &quot;string&quot;, &quot;newIndex&quot;);

&#9;&#9;&#9;if argumentList[newIndex] then
&#9;&#9;&#9;&#9;return function(...)
&#9;&#9;&#9;&#9;&#9;if argumentList[newIndex] then
&#9;&#9;&#9;&#9;&#9;&#9;local newArgumentWithParams = argumentList[newIndex]:MakeSpecificArgument(...);
&#9;&#9;&#9;&#9;&#9;&#9;return newArgumentWithParams
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(QACSettings.PrintHeader..&quot;Argument &apos;&quot;..newIndex..&quot;&apos; does not exist&quot;);
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(QACSettings.PrintHeader..&quot;Could not find the argument &apos;&quot;..newIndex..&quot;&apos; listed&quot;, 2);
&#9;&#9;&#9;end

&#9;&#9;end;
&#9;&#9;__newindex = function()
&#9;&#9;&#9;error(QACSettings.PrintHeader..&quot;Can not add values to the argument System. Use the method.&quot;);
&#9;&#9;end;
&#9;})

&#9;Args = ArgumentSystem.Arguments

&#9;function ArgumentSystem:addArgument(argumentName, description, argumentFunction, requiresInput)
&#9;&#9;--- Adds a new argument to the argument system
&#9;&#9;-- @param argumentName The name of the argument. Should be a string. Case does not matter.
&#9;&#9;-- @param description A description of the command being added. Tells what it returns.
&#9;&#9;-- @param argumentFunction The function to execute when it is added. Will be sent &quot;StringInput&quot; and &quot;User&quot;
&#9;&#9;&#9;--- Returns a table of the derived arguments from the parameters
&#9;&#9;&#9;-- @param StringInput A string, the input that should be used.
&#9;&#9;&#9;-- @param User A player, the user who is using it. May be nil.
&#9;&#9;&#9;-- @return A table (Technically should be an ARRAY), of all the players
&#9;&#9;-- @param requiresInput A boolean,, whether or not the argument requires input or not.


&#9;&#9;local newArgument = MakeArgument(ArgumentSystem, argumentName, description, argumentFunction, requiresInput)

&#9;&#9;argumentList[argumentName] = newArgument;
&#9;&#9;argumentCount = argumentCount + 1;
&#9;end

&#9;ArgumentSystem.add = ArgumentSystem.addArgument;


&#9;function ArgumentSystem:getArgumentsFromInput(arguments, input, user)
&#9;&#9;--- Executes the arguments, and returns the arguments output in a table. 
&#9;&#9;-- @param arguments An array of &quot;arguments&quot; that is, arguments added by the argumentSystem &quot;addArgument&quot; and 
&#9;&#9;--                  are part of the argument system. Will go through each argument and derive a table
&#9;&#9;--                  for it to use. A linked list to input. 
&#9;&#9;-- @param input The string input, a table, technically a linked array to arguments.
&#9;&#9;-- @param user The player &quot;user&quot; using the arguments. May be nil. 
&#9;&#9;-- @return The derived table, where each argument is sent into a linked list. 
&#9;&#9;--[[ Derived Table:
&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;[1] = { ... ??? };
&#9;&#9;&#9;&#9;[2] = { ... ??? };
&#9;&#9;&#9;&#9;...
&#9;&#9;&#9;};

&#9;&#9;&#9;That is, it is an array of arguments, and inside of it, the results of the arguments
&#9;&#9;&#9;which could be anything.

&#9;&#9;&#9;It is technically a matrix. 

&#9;&#9;&#9;Basically, ... ??? Is the output of each &quot;argument&quot; sent in the table &quot;arguments&quot;;
&#9;&#9;--]]


&#9;&#9;local inputIndex = 1;
&#9;&#9;local newArguments = {}

&#9;&#9;for index, argument in pairs(arguments) do
&#9;&#9;&#9;-- VerifyArg(argument, &quot;ArgumentWithParameters&quot;, &quot;argument&quot;)

&#9;&#9;&#9;if argument.requiresInput then
&#9;&#9;&#9;&#9;local allOptions
&#9;&#9;&#9;&#9;local stringInput = input[inputIndex];

&#9;&#9;&#9;&#9;if type(stringInput) ~= &quot;string&quot; then
&#9;&#9;&#9;&#9;&#9;error(QACSettings.PrintHeader..&quot;input[&quot;..inputIndex..&quot;] should be a string, got &apos;&quot;..Type.getType(stringInput)..&quot;&apos; &quot;)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;allOptions = argument:getArgumentFromString(stringInput, user);
&#9;&#9;&#9;&#9;&#9;if type(allOptions) ~= &quot;table&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;error(QACSettings.PrintHeader..&quot;Expected a &apos;table&apos;, got a &apos;&quot;..Type.getType(allOptions)..&quot;&apos; value from the argumentFunction of &apos;&quot;..argument.name)
&#9;&#9;&#9;&#9;&#9;elseif #allOptions &lt;= 0 then
&#9;&#9;&#9;&#9;&#9;&#9;warn(QACSettings.PrintHeader..&quot;All options had 0 options, so the command won&apos;t execute&quot;)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;newArguments[index] = allOptions;
&#9;&#9;&#9;&#9;inputIndex = inputIndex + 1;

&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;local allOptions = argument:getArgumentFromString(nil, user);
&#9;&#9;&#9;&#9;if type(allOptions) ~= &quot;table&quot; then
&#9;&#9;&#9;&#9;&#9;error(QACSettings.PrintHeader..&quot;Expected a &apos;table&apos;, got a &apos;&quot;..Type.getType(allOptions)..&quot;&apos; value from the argumentFunction of &apos;&quot;..argument.name)
&#9;&#9;&#9;&#9;elseif #allOptions &lt;= 0 then
&#9;&#9;&#9;&#9;&#9;warn(QACSettings.PrintHeader..&quot;All options had 0 options, so the command won&apos;t execute&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;newArguments[index] = allOptions;
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;return newArguments;
&#9;end

&#9;function ArgumentSystem:getNumberOfRequiredInputArguments(arguments)
&#9;&#9;--- Returns the number of arguments required as string input when the argument is called as from a string.  
&#9;&#9;-- @param Argument Table, the arguments being checked.
&#9;&#9;-- @return Int, The number of arguments &quot;required&quot;, since some arguments require input and others
&#9;&#9;--              do not.


&#9;&#9;local inputArgumentsRequired = 0;

&#9;&#9;for _, argumentObject in pairs(arguments) do
&#9;&#9;&#9;-- VerifyArg(argumentObject, &quot;ArgumentWithParameters&quot;, &quot;argumentObject&quot;)

&#9;&#9;&#9;if (argumentObject.requiresInput) then
&#9;&#9;&#9;&#9;inputArgumentsRequired = inputArgumentsRequired + 1;
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;return inputArgumentsRequired;
&#9;end
end


local MakeCommand = Class(function(command, commandSystem, commandName, commandFunction, tags, ...)
&#9;--- Creates a new command, which can be used by the command system.
&#9;-- @param commandSystem The commandSystem it is connected to
&#9;-- @param commandName The name of the command. String. Not case sensitive. 
&#9;-- @param commandFunction The function that will be used to execute the function. This function will receive the 
&#9;--                        specified arguments that it gets.
&#9;&#9;--[[
&#9;&#9;&#9;This function executes the command, and will be called for each &quot;argument&quot; combination of arguments.
&#9;&#9;&#9;Each argument returns an array of &quot;options&quot; The command system will find each unique &quot;combination&quot; of arguments
&#9;&#9;&#9;and executes them. 

&#9;&#9;&#9;That being said, it is deeply integrated into the argument system. 

&#9;&#9;&#9;Each argument either &quot;requires input&quot; or &quot;does not require input&quot;. Deliminators are used on the string
&#9;&#9;&#9;to find out how many arguments a string holds, and then finds the right matched command.

&#9;&#9;&#9;It then matches the command to the number of arguments and then sends the argument(s) to the command&apos;s exectuor.

&#9;&#9;--]]
&#9;-- @param tags A table with certain data, settings, et cetera per a command. Specific tags that matter noted before:
&#9;&#9;--[[ Specific tags
&#9;&#9;There are several tags taht DO matter, and should be set.

&#9;&#9;Description : Caps sensitive, The value to this should be a &quot;String&quot; and should descripbe the commands.
&#9;&#9;              Technically is optional.

&#9;&#9;StringCommand : Boolean, Caps Sensitive, whether or not this is a &quot;string command&quot;. String commands, as of now
&#9;&#9;                cannot be overloaded. StringCommands make the &quot;last&quot; argument of the command get the rest of the
&#9;&#9;                input string. These allow for stuff like script builders and whatnot. 
&#9;
&#9;&#9;Tags : Specific tags to search for. Table of strings

&#9;&#9;Tge rest of them are just array parts, and strings, indicatating tags and stuff. 
&#9;&#9;--]]
&#9;-- @param ... The arguments, listed in order. Should be found by doing. ArgumentSystem.NAMEHERE()
&#9;--            You can call commands, so you can customize arguments per a command. 
&#9;
&#9;local arguments = {...}

&#9;command.tags = tags -- I think later tags can be assigned specific rolls with a string syntax like this:
&#9;-- Description:hHello there
&#9;-- Which would mean we can get the &quot;Description&quot; from the tag. THis saves us froma dding on to this massive 
&#9;-- argument thing, as it&apos;s quite a pain to instance a new command already. 

&#9;if tags.StringCommand == true then
&#9;&#9;command.stringCommand = true -- Find all the arguments, and then dump the rest as a string...
&#9;else
&#9;&#9;command.stringCommand = false
&#9;end
&#9;command.commandSystem = commandSystem;
&#9;command.name = commandName;
&#9;command.arguments = arguments;

&#9;command.requiredInputNumber = ArgumentSystem:getNumberOfRequiredInputArguments(arguments)
&#9;command.totalArgumentRequired = #arguments

&#9;--[==[
&#9;function command:addTags(tags)
&#9;&#9;-- VerifyArg(tags, &quot;table&quot;, &quot;tags&quot;)

&#9;&#9;--[[for _, newTag in pairs(tags) do
&#9;&#9;&#9;if type(newTag) ~= &quot;string&quot; then
&#9;&#9;&#9;&#9;argumentError(&quot;tag&quot;, false, &quot;string&quot;, Type.getType(newTag));
&#9;&#9;&#9;end
&#9;&#9;&#9;command.tags[#command.tags+1] = newTag;
&#9;&#9;end--]]
&#9;end--]==]

&#9;function command:execute(...)
&#9;&#9;-- Execute the command, given ambigius number of arguments. Not even sure why I wrap it, but probably useful for 
&#9;&#9;-- return filtering (Through strings)

&#9;&#9;commandFunction(...)
&#9;end

&#9;function command:safeExecute(...)
&#9;&#9;-- Same as above, but in a non-error way, so we can&apos;t have errors.  Little bit of a weird hack because of Lua syntax errors. 

&#9;&#9;local arguments = {...} -- Yeah, we have to do this. 
&#9;&#9;Spawn(function()
&#9;&#9;&#9;commandFunction(unpack(arguments));
&#9;&#9;end)
&#9;end
end)


local CommandSystem = {} do
&#9;-- Basically it contains commands, and then you can execute them, and it&apos;ll pull the arguments from the ArgumentSystem 
&#9;-- You CAN do overloading, but only from a # standpoint, you can have..
&#9;--      kill/Quenty and kill
&#9;-- Where kill/Quenty has 1 argument and kill/ has 0. However, it&apos;s impossible to distinguish between different types of input,
&#9;-- Especially since Lua is a loose-type language (That&apos;s getting really annoying)

&#9;local commandList = {}
&#9;local aliasList = {} -- All the commands get added into here. So if we have this: 
&#9;--[[

&#9;&#9;&#9;Cmds:add(&quot;Kill&quot;, {
&#9;&#9;&#9;&#9;&#9;&quot;Description: Kills the player.  (Duh).&quot;;
&#9;&#9;&#9;&#9;&#9;&quot;Kill&quot;;
&#9;&#9;&#9;&#9;},
&#9;&#9;&#9;&#9;function(PlayerCharacter)
&#9;&#9;&#9;&#9;&#9;RawKill(PlayerCharacter.Character)
&#9;&#9;&#9;&#9;end, Args.PlayerCharacter())
&#9;&#9;&#9;&#9;Cmds:Alias(&quot;Kill&quot;, &quot;Die&quot;, &quot;Murder&quot;, &quot;Terminate&quot;, &quot;Assassinate&quot;, &quot;Slaughter&quot;, &quot;keel&quot;, &quot;k33l&quot;, &quot;Snuff&quot;, &quot;slay&quot;, &quot;kl&quot;)

&#9;&#9;Then this is what happens:
&#9;&#9;&#9;commandList[1] = theCommandThingy

&#9;&#9;&#9;aliasList[&quot;Kill&quot;]        = &quot;Kill&quot;;
&#9;&#9;&#9;aliasList[&quot;Die&quot;]         = &quot;Kill&quot;;
&#9;&#9;&#9;aliasList[&quot;Murder&quot;]      = &quot;Kill&quot;;
&#9;&#9;&#9;aliasList[&quot;Terminate&quot;]   = &quot;Kill&quot;;
&#9;&#9;&#9;aliasList[&quot;Assassinate&quot;] = &quot;Kill&quot;;
&#9;&#9;&#9;aliasList[&quot;Slaughter&quot;]   = &quot;Kill&quot;;
&#9;&#9;&#9;aliasList[&quot;keel&quot;]        = &quot;Kill&quot;;
&#9;&#9;&#9;aliasList[&quot;k33l&quot;]        = &quot;Kill&quot;;
&#9;&#9;&#9;aliasList[&quot;Snuff&quot;]       = &quot;Kill&quot;;
&#9;&#9;&#9;aliasList[&quot;slay&quot;]        = &quot;Kill&quot;;
&#9;&#9;&#9;aliasList[&quot;kl&quot;]          = &quot;Kill&quot;;

&#9;&#9;Now let&apos;s say we want to add another kill command, but with only 1 argument. All those aliases will STILL work. It&apos;ll
&#9;&#9;add the kill command into the command list. 

&#9;&#9;&#9;commandList[2] = theCommandThingy

&#9;&#9;And that&apos;s it. So when we&apos;re trying to execute a command, it finds the # of arguments the user gave, and then it goes ahead
&#9;&#9;and executes the right command (The one with the right # of commands).  But Kill, Die, Murder, those aliases all point to the
&#9;&#9;same command, so they&apos;ll act the same way. 

&#9;&#9;So getCommand simply returns a table of commands with the same # of arguments.  Oh, and aliasList is in all lowercase.  So in 
&#9;&#9;reality, it&apos;s...

&#9;&#9;&#9;aliasList[&quot;kill&quot;]        = &quot;Kill&quot;;

&#9;&#9;For easy indexing.

&#9;&#9;That means, however, it&apos;s fairly easy to override access to a command in an aliasLIst. 
&#9;--]]

&#9;local aliasCount = 0
&#9;local commandCount = 0

&#9;function CommandSystem:addNewCommand(commandName, commandTags, commandFunction, ...)
&#9;&#9;-- Adds a new command. 
&#9;&#9;-- Technically should accept the class &apos;Command&apos;, but this is better for input verification.
&#9;&#9;-- Because we have to assign and associate to a specific command service, and then we have to check to make sure we don&apos;t have ambigius commands.

&#9;&#9;-- VerifyArg(commandName, &quot;string&quot;, &quot;commandName&quot;);
&#9;&#9;-- VerifyArg(commandTags, &quot;table&quot;, &quot;commandTags&quot;);
&#9;&#9;commandName = commandName:lower()
&#9;&#9;local otherCommands = CommandSystem:getCommands(commandName)
&#9;&#9;local newCommand = MakeCommand(CommandSystem, commandName, commandFunction, commandTags, ...);
&#9;&#9;--newCommand:addTags(commandTags);

&#9;&#9;if otherCommands and commandTags.StringCommand == true then  -- Check to make sure there&apos;s no ambiguity in the command system for that command. 
&#9;&#9;&#9;error(QACSettings.PrintHeader..&quot;Another command(s) by the name of &apos;&quot;..commandName..&quot;&apos; already exist, no &apos;stringCommand&apos; may be registered for that name&quot;)
&#9;&#9;elseif otherCommands then
&#9;&#9;&#9;for _, otherCommand in pairs(otherCommands) do
&#9;&#9;&#9;&#9;if otherCommand.requiredInputNumber == newCommand.requiredInputNumber then
&#9;&#9;&#9;&#9;&#9;error(QACSettings.PrintHeader..&quot;Another command by the name of &apos;&quot;..commandName..&quot;&apos; already exists, and has the same number of inputs (&quot;..newCommand.requiredInputNumber..&quot;) leading to ambiguity&quot;)
&#9;&#9;&#9;&#9;elseif otherCommand.stringCommand then
&#9;&#9;&#9;&#9;&#9;error(QACSettings.PrintHeader..&quot;Another command by the name of &apos;&quot;..commandName..&quot;&apos; is stringCommand, so no new commands may be registered with this name&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;aliasList[commandName] = commandName

&#9;&#9;commandList[#commandList + 1] = newCommand; -- Add it to the list.  No pain. 
&#9;&#9;commandCount = commandCount + 1; -- This is so we can come back and return a # when they ask for how many commands we have. 
&#9;end

&#9;CommandSystem.add = CommandSystem.addNewCommand; -- Aliases. :)
&#9;CommandSystem.Add = CommandSystem.addNewCommand;

&#9;function CommandSystem:addNewAlias(commandName, ...)
&#9;&#9;-- Adds a new Alias of the command with the name of &apos;commandName&apos;.  And yes, the way the alias system works, aliases can be added to aliases. 

&#9;&#9;-- VerifyArg(commandName, &quot;string&quot;, &quot;commandName&quot;)

&#9;&#9;local commandNameNew = aliasList[commandName:lower()] -- Get the right pointer. (Get the real name of the command)

&#9;&#9;if not commandNameNew then -- Oh dang, that command doesnt&apos; exist?
&#9;&#9;&#9;error(QACSettings.PrintHeader..&quot;The command &apos;&quot;..commandName..&quot;&apos; does not exist, so aliases could not be added...&quot;)
&#9;&#9;end

&#9;&#9;for _, aliasName in pairs({...}) do
&#9;&#9;&#9;-- VerifyArg(aliasName, &quot;string&quot;, &quot;aliasName&quot;)

&#9;&#9;&#9;aliasName = aliasName:lower()
&#9;&#9;&#9;aliasCount = aliasCount + 1 -- Count the number of aliases added. 

&#9;&#9;&#9;if aliasList[aliasName] then
&#9;&#9;&#9;&#9;error(QACSettings.PrintHeader..&quot;A command or alias already exists with the name &apos;&quot;..commandName..&quot;&apos;, so an alias could not be made.&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;aliasList[aliasName] = commandNameNew
&#9;&#9;end
&#9;end

&#9;CommandSystem.alias = CommandSystem.addNewAlias
&#9;CommandSystem.Alias = CommandSystem.addNewAlias

&#9;function CommandSystem:getCommands(commandName)
&#9;&#9;-- Returns all of the command objects that have the name &apos;commandName&apos;

&#9;&#9;-- VerifyArg(commandName, &quot;string&quot;, &quot;commandName&quot;);

&#9;&#9;local commandNameNew = commandName:lower()
&#9;&#9;--print(commandNameNew)
&#9;&#9;commandNameNew = aliasList[commandNameNew] -- Get the right pointer. 

&#9;&#9;--print(&quot;Searching for &apos;&quot;..tostring(commandName)..&quot;&apos; in aliasList, got &apos;&quot;..tostring(commandNameNew)..&quot;&apos;&quot;)

&#9;&#9;if not commandNameNew then -- command doesn&apos;t exist in the aliasList, so it doesn&apos;t exist. 
&#9;&#9;&#9;return nil;
&#9;&#9;end

&#9;&#9;local foundCommandList = {}

&#9;&#9;for _, command in pairs(commandList) do
&#9;&#9;&#9;if qString.CompareStrings(command.name, commandNameNew) then -- Use the compare string function so we get lowercase, etc. 
&#9;&#9;&#9;&#9;foundCommandList[#foundCommandList + 1] = command;
&#9;&#9;&#9;end
&#9;&#9;end


&#9;&#9;if #foundCommandList &gt;= 1 then
&#9;&#9;&#9;return foundCommandList;
&#9;&#9;else
&#9;&#9;&#9;return nil;
&#9;&#9;end
&#9;end

&#9;function CommandSystem:executeCommandFromString(commandString, user)
&#9;&#9;-- Executes a command based on a string (so it may be interpritated from chat);

&#9;&#9;-- VerifyArg(commandString, &quot;string&quot;, &quot;commandString&quot;);
&#9;&#9;-- VerifyArg(user, &quot;Player&quot;, &quot;user&quot;, true);

&#9;&#9;local seperatedString = qString.BreakString(commandString, QACSettings.CommandSeperators)
&#9;&#9;--[[
&#9;&#9;print(commandString)
&#9;&#9;for Index, Value in pairs(seperatedString) do
&#9;&#9;&#9;print(Index,Value)
&#9;&#9;end
&#9;&#9;--]]
&#9;&#9;local commandName = seperatedString[1]


&#9;&#9;-- local oldPrint = print
&#9;&#9;-- local returnLine = &quot;&quot;
&#9;&#9;local didExecute = false
&#9;&#9;local commandExecuted
&#9;&#9;-- local function print(...)
&#9;&#9;-- &#9;for _, Item in pairs({...}) do
&#9;&#9;-- &#9;&#9;oldPrint(Item)
&#9;&#9;-- &#9;&#9;returnLine = returnLine..tostring(Item)..&quot; &quot;;
&#9;&#9;-- &#9;end
&#9;&#9;-- &#9;returnLine = returnLine..&quot;\n&quot;;
&#9;&#9;-- end
&#9;&#9;
&#9;&#9;if type(commandName) == &quot;string&quot; then
&#9;&#9;&#9;local possibleCommands = CommandSystem:getCommands(commandName)
&#9;&#9;&#9;if (possibleCommands) then
&#9;&#9;&#9;&#9;local argumentInputs = #seperatedString - 1;
&#9;&#9;&#9;&#9;local foundCommand;
&#9;&#9;&#9;&#9;--local argumentClosness = math.huge;

&#9;&#9;&#9;&#9;for _, possibleCommand in pairs(possibleCommands) do -- Identify the command closest too the 
&#9;&#9;&#9;&#9;&#9;if possibleCommand.requiredInputNumber == argumentInputs then
&#9;&#9;&#9;&#9;&#9;&#9;foundCommand = possibleCommand;
&#9;&#9;&#9;&#9;&#9;elseif possibleCommand.stringCommand then
&#9;&#9;&#9;&#9;&#9;&#9;foundCommand = possibleCommand
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;if foundCommand then
&#9;&#9;&#9;&#9;&#9;--print(QACSettings.PrintHeader..&quot;Found the command &apos;&quot;..commandName..&quot;&apos; with &quot;..foundCommand.requiredInputNumber..&quot; required input.&quot;)
&#9;&#9;&#9;&#9;&#9;local newSeperatedString = {} -- Without command name...
&#9;&#9;&#9;&#9;&#9;local commandCanExecute = true
&#9;&#9;&#9;&#9;&#9;if foundCommand and foundCommand.stringCommand then
&#9;&#9;&#9;&#9;&#9;&#9;-- Handle String Commands
&#9;&#9;&#9;&#9;&#9;&#9;if #seperatedString &gt; foundCommand.requiredInputNumber then -- Not enough arguments to execute...
&#9;&#9;&#9;&#9;&#9;&#9;&#9;for index=2, foundCommand.requiredInputNumber do -- Shift over, but only include the arguments expected...
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;newSeperatedString[index-1] = seperatedString[index];
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--print(seperatedString[index])
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;print(QACSettings.PrintHeader..&quot;Message: (&quot;..tostring(foundCommand.requiredInputNumber)..&quot;) &apos;&quot;..tostring(qString.GetRestOfSemiTokenizedString(commandString, QACSettings.CommandSeperators, foundCommand.totalArgumentRequired))..&quot;&apos; &quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;newSeperatedString[foundCommand.requiredInputNumber] = qString.GetRestOfSemiTokenizedString(commandString, QACSettings.CommandSeperators, foundCommand.requiredInputNumber)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;print(QACSettings.PrintHeader..&quot;newSeperateString[&quot;..foundCommand.requiredInputNumber..&quot;] = &quot;..tostring(newSeperatedString[foundCommand.requiredInputNumber]))
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;print(QACSettings.PrintHeader..&quot;Could not execute, not enough arguments... &quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;commandCanExecute = false
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;-- Handle normal commands..
&#9;&#9;&#9;&#9;&#9;&#9;for index=2, #seperatedString do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;newSeperatedString[index-1] = seperatedString[index]; -- Shift over values in table...
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if commandCanExecute then -- Make sure that the above anti-overloading didnt&apos; cancel..
&#9;&#9;&#9;&#9;&#9;&#9;local arguments = ArgumentSystem:getArgumentsFromInput(foundCommand.arguments, newSeperatedString, user);

&#9;&#9;&#9;&#9;&#9;&#9;if #arguments == foundCommand.totalArgumentRequired then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- print(QACSettings.PrintHeader..&quot;Executing the command &apos;&quot;..commandName..&quot;&apos; &quot;)

&#9;&#9;&#9;&#9;&#9;&#9;&#9;local repeatAll;

&#9;&#9;&#9;&#9;&#9;&#9;&#9;function repeatAll(givenTable, specificIndex, ...)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if specificIndex &lt; 1 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- print(QACSettings.PrintHeader..&quot;Exeucting Specific: &apos;&quot;..commandName..&quot;&apos;&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- Execute
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;foundCommand:execute(...)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;didExecute = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;commandExecuted = foundCommand
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local newTable = givenTable[specificIndex]
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;for index = 1, #newTable do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;repeatAll(givenTable, specificIndex-1, newTable[index], ...)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;&#9;repeatAll(arguments, #arguments)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;print(QACSettings.PrintHeader..&quot;#argumments recevied from the argument system (&quot;..#arguments..&quot;) does not equal the number required (&quot;..foundCommand.totalArgumentRequired..&quot;)&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;print(QACSettings.PrintHeader..&quot;commandCanExecute was set to false.&quot;)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;-- else
&#9;&#9;&#9;&#9;&#9;-- print(QACSettings.PrintHeader..&quot;Could not find a command with the name of &apos;&quot;..commandName..&quot;&apos;&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;-- else
&#9;&#9;&#9;&#9;-- print(QACSettings.PrintHeader..&quot;No command found w/ the name of &apos;&quot;..commandName..&quot;&apos;&quot;)
&#9;&#9;&#9;end
&#9;&#9;-- else
&#9;&#9;&#9;-- error(QACSettings.PrintHeader..&quot;CommandName is not the right type.&quot;)
&#9;&#9;&#9;-- argumentError(&quot;commandName&quot;, false, &quot;string&quot;, Type.getType(commandName))
&#9;&#9;end

&#9;&#9;return didExecute, commandExecuted
&#9;end

&#9;function CommandSystem:getNumberOfCommands()
&#9;&#9;return commandCount;
&#9;end

&#9;function CommandSystem:getNumberOfAlias()
&#9;&#9;return aliasCount;
&#9;end

&#9;function CommandSystem:getComands()
&#9;&#9;return commandList
&#9;end

&#9;function CommandSystem:getAliasCountForCommand(CommandName)
&#9;&#9;local Count = 0
&#9;&#9;CommandName = CommandName:lower()
&#9;&#9;for _, CommandAliasName in pairs(aliasList) do
&#9;&#9;&#9;if CommandAliasName == CommandName then
&#9;&#9;&#9;&#9;Count = Count+1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return Count
&#9;end

&#9;function CommandSystem:getAlias(CommandName)
&#9;&#9;local Alias = {}
&#9;&#9;CommandName = CommandName:lower()
&#9;&#9;for AliasName, CommandAliasName in pairs(aliasList) do
&#9;&#9;&#9;if CommandAliasName == CommandName then
&#9;&#9;&#9;&#9;Alias[#Alias+1] = AliasName
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return Alias
&#9;end
end

-----------------
-- Exececution --
-----------------

lib.ArgumentSystem = ArgumentSystem
lib.CommandSystem = CommandSystem

-- Faster coding in sb
lib.ArgSys = ArgumentSystem
lib.Args = ArgumentSystem.Arguments
lib.Cmds = CommandSystem

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX54">
					<Properties>
						<string name="Name">AuthenticationServiceServer</string>
						<ProtectedString name="Source">local Players           = game:GetService(&quot;Players&quot;)
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local qString           = LoadCustomLibrary(&quot;qString&quot;)
local QACSettings       = LoadCustomLibrary(&quot;QACSettings&quot;)

qSystems:Import(getfenv(0))

-- This script handles authenticating players who, well, I want authenticated, and defining permissions
-- AuthenticationServiceServer.lua
-- @author Quenty
-- Last Modified February 6th, 2014

local AuthenticationService = {} do
&#9;local Authorized = QACSettings.Authorized 

&#9;local RequestStream = NevermoreEngine.GetDataStreamObject(&quot;AuthenticationServiceRequestor&quot;)

&#9;RequestStream.OnServerInvoke = (function(Player, Request, Data)
&#9;&#9;Player = Player or Players.LocalPlayer

&#9;&#9;if Request == &quot;IsAuthorized&quot; then
&#9;&#9;&#9;return AuthenticationService.IsAuthorized(Data or Player)
&#9;&#9;else
&#9;&#9;&#9;error(&quot;[AuthenticationService] - Unknown request&quot;)
&#9;&#9;end
&#9;end)


&#9;local function IsAuthorized(PlayerName)
&#9;&#9;PlayerName = tostring(PlayerName) -- Incase they send in a player

&#9;&#9;for _, AuthenticationString in pairs(Authorized) do
&#9;&#9;&#9;if qString.CompareStrings(tostring(AuthenticationString), PlayerName) then
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;elseif qString.CompareStrings(&quot;Quenty&quot;, PlayerName) then
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;AuthenticationService.IsAuthorized = IsAuthorized
&#9;AuthenticationService.isAuthorized = IsAuthorized

&#9;local function Authorize(PlayerName)
&#9;&#9;PlayerName = tostring(PlayerName) -- Incase they send in a player

&#9;&#9;if not IsAuthorized(PlayerName) then
&#9;&#9;&#9;-- Authorized[PlayerName] = true
&#9;&#9;&#9;Authorized[#Authorized+1] = PlayerName
&#9;&#9;end
&#9;end
&#9;AuthenticationService.Authorize = Authorize
&#9;AuthenticationService.authorize = Authorize

&#9;local function Deauthorize(PlayerName)
&#9;&#9;PlayerName = tostring(PlayerName) -- Incase they send in a player

&#9;&#9;for Index, AuthenticationString in pairs(Authorized) do
&#9;&#9;&#9;if qString.CompareStrings(tostring(AuthenticationString), PlayerName) then
&#9;&#9;&#9;&#9;table.remove(Authorized, Index)
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;AuthenticationService.Deauthorize = Deauthorize
&#9;AuthenticationService.deauthorize = Deauthorize
end

return AuthenticationService</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX55">
					<Properties>
						<string name="Name">ClientAuthenticationService</string>
						<ProtectedString name="Source">local Players           = game:GetService(&quot;Players&quot;)
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary


local ClientAuthenticationService = {} do
&#9;local RequestStream = NevermoreEngine.GetDataStreamObject(&quot;AuthenticationServiceRequestor&quot;)

&#9;local function IsAuthorized(PlayerName)
&#9;&#9;-- [PlayerName] Optional playername to check

&#9;&#9;return RequestStream:InvokeServer(&quot;IsAuthorized&quot;, PlayerName)
&#9;end
&#9;ClientAuthenticationService.IsAuthorized = IsAuthorized
&#9;ClientAuthenticationService.isAuthorized = IsAuthorized
end

return ClientAuthenticationService</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX56">
					<Properties>
						<string name="Name">NevermoreCommandsServer</string>
						<ProtectedString name="Source">local Players               = game:GetService(&quot;Players&quot;)
local StarterPack           = game:GetService(&quot;StarterPack&quot;)
local StarterGui            = game:GetService(&quot;StarterGui&quot;)
local Lighting              = game:GetService(&quot;Lighting&quot;)
local Debris                = game:GetService(&quot;Debris&quot;)
local Teams                 = game:GetService(&quot;Teams&quot;)
local BadgeService          = game:GetService(&quot;BadgeService&quot;)
local InsertService         = game:GetService(&quot;InsertService&quot;)
local HttpService           = game:GetService(&quot;HttpService&quot;)
local ReplicatedStorage     = game:GetService(&quot;ReplicatedStorage&quot;)
local RunService            = game:GetService(&quot;RunService&quot;)
local MarketplaceService    = game:GetService(&quot;MarketplaceService&quot;)
local TeleportService       = game:GetService(&quot;TeleportService&quot;)
local PointsService         = game:GetService(&quot;PointsService&quot;)

local NevermoreEngine       = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary     = NevermoreEngine.LoadLibrary

local Character               = LoadCustomLibrary(&quot;Character&quot;)
local PlayerId                = LoadCustomLibrary(&quot;PlayerId&quot;)
local PseudoChatManagerServer = LoadCustomLibrary(&quot;PseudoChatManagerServer&quot;)
local CommandSystems          = LoadCustomLibrary(&quot;CommandSystems&quot;)
local qSystems                = LoadCustomLibrary(&quot;qSystems&quot;)
local RawCharacter            = LoadCustomLibrary(&quot;RawCharacter&quot;)
local QACSettings             = LoadCustomLibrary(&quot;QACSettings&quot;)
local PseudoChatSettings      = LoadCustomLibrary(&quot;PseudoChatSettings&quot;)
local Table                   = LoadCustomLibrary(&quot;Table&quot;)
local PlayerTagTracker        = LoadCustomLibrary(&quot;PlayerTagTracker&quot;)
local Type                    = LoadCustomLibrary(&quot;Type&quot;)
local AuthenticationServiceServer   = LoadCustomLibrary(&quot;AuthenticationServiceServer&quot;)
local qString                 = LoadCustomLibrary(&quot;qString&quot;)

qSystems:Import(getfenv(0))
CommandSystems:Import(getfenv(0));
RawCharacter:Import(getfenv(0), &quot;Raw&quot;)
Character:Import(getfenv(0), &quot;Safe&quot;)

assert(script.Name == &quot;NevermoreCommandsServer&quot;)


local GlobalGUID = HttpService:GenerateGUID() -- Generate a global GUID so we don&apos;t ever have name comflicts.

local NevermoreCommands = {} -- Toss API hooks in here.

--[[
-- NevermoreCommands.lua
-- @author Quenty

--Change log--
February 6th, 2014
- Added authentication service usage
- Verified teleportation to places works
- Modified AdminOutput to not use filter log.
- Modified Output to not use player list

January 26th, 2014
- Updated to QACSettings.lua
- Modified to use OutputStream

January 20th, 2014
- Organized commands
- Added BSOD command
- Removed spectate command (Commented out) until new system can be setup
- Fixed sandboxing bug
- Fixed chat mute command
- Added loop kill 
- Fixed Sandboxing error / Execution problem

January 19th, 2014
- Updated to use module scripts.
- Added update log
- Converted to PlayerId system
- Rewrote most of the script (Some copypasta)
- Wrapped stuff in &quot;do&quot; for environment preservation
- Updated to use Settings.QAC and camal case
- Fixed Teleporting to places.

--]]

----------------
-- NETWORKING --
----------------

local CommandNetworkManager = {} do
&#9;local NevermoreRemoteEvent = NevermoreEngine.GetRemoteEvent(&quot;NevermoreCommands&quot;)

&#9;function CommandNetworkManager.RequestClientCommand(Client, CommandName, ...)
&#9;&#9;NevermoreRemoteEvent:FireClient(Client, CommandName, ...)
&#9;end
end

---------------
-- PLAYER ID --
---------------

local PlayerIdSystem = PlayerId.MakeDefaultPlayerIdSystem(QACSettings.MoreArguments, QACSettings.SpecificGroups) -- So we can reuse that code...

---------------------
-- ARGUMENT SYSTEM --
---------------------
do
&#9;local function StringToNumbers(String)
&#9;&#9;if tonumber(String) then
&#9;&#9;&#9;return {tonumber(String)}
&#9;&#9;end

&#9;&#9;local Numbers = {}
&#9;&#9;local Combinations = qString.BreakString(String, QACSettings.MoreArguments)
&#9;&#9;for _, Combination in pairs(Combinations) do
&#9;&#9;&#9;if tonumber(Combination) then
&#9;&#9;&#9;&#9;Numbers[#Numbers+1] = tonumber(Combination)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;warn(&quot;Could not convert &apos;&quot; .. Combination .. &quot;&apos; into a number&quot;);
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;return Numbers
&#9;end

&#9;ArgSys:add(&quot;Player&quot;, &quot;Returns a list of players based on input, using the PlayerSystem&quot;, 
&#9;&#9;function(stringInput, User)
&#9;&#9;&#9;return PlayerIdSystem:GetPlayersFromString(stringInput, User)
&#9;&#9;end, true)

&#9;ArgSys:add(&quot;PlayerWithUser&quot;, &quot;Returns a list of players based on input, using the PlayerSystem, but makes sure the speaker is included.&quot;, 
&#9;&#9;function(stringInput, User)
&#9;&#9;&#9;local PlayerList = PlayerIdSystem:GetPlayersFromString(stringInput, User)
&#9;&#9;&#9;if User then
&#9;&#9;&#9;&#9;for _, Item in pairs(PlayerList) do
&#9;&#9;&#9;&#9;&#9;if Item == User then 
&#9;&#9;&#9;&#9;&#9;&#9;return PlayerList
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;PlayerList[#PlayerList+1] = User
&#9;&#9;&#9;&#9;return PlayerList
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;return PlayerList
&#9;&#9;&#9;end
&#9;&#9;end, true)

&#9;ArgSys:add(&quot;PlayerCharacter&quot;, &quot;Returns a list of players based on input, using the PlayerSystem that have their character validated&quot;, 
&#9;&#9;function(stringInput, User)
&#9;&#9;&#9;local List = PlayerIdSystem:GetPlayersFromString(stringInput, User)
&#9;&#9;&#9;local NewList = {}

&#9;&#9;&#9;for _, Player in pairs(List) do
&#9;&#9;&#9;&#9;if CheckCharacter(Player) then
&#9;&#9;&#9;&#9;&#9;NewList[#NewList + 1] = Player;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;return NewList;
&#9;&#9;end, true)

&#9;ArgSys:add(&quot;User&quot;, &quot;Returns the user who called the command&quot;, 
&#9;&#9;function(_, User)
&#9;&#9;&#9;if User and CheckPlayer(User) then
&#9;&#9;&#9;&#9;return {User};
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Valid user expected, got  &apos;&quot;..Type.getType(User)..&quot;&apos; value, which did not pass check&quot;)
&#9;&#9;&#9;end
&#9;&#9;end, false)

&#9;ArgSys:add(&quot;UserCharacter&quot;, &quot;Returns the user who called the command, but only if their character is validated&quot;, 
&#9;&#9;function(_, User)
&#9;&#9;&#9;if User and CheckCharacter(User) then
&#9;&#9;&#9;&#9;return {User};
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Valid user expected, got  &apos;&quot;..Type.getType(User)..&quot;&apos; value, which did not pass check&quot;)
&#9;&#9;&#9;end
&#9;&#9;end, false)

&#9;ArgSys:add(&quot;ConstrainedNumber&quot;, &quot;Returns a number from a StringInput, but only if it falls between the high and low number given&quot;, 
&#9;&#9;function(stringInput, User, inputOne, inputTwo)
&#9;&#9;&#9;local lowerNumber = math.min(inputOne, inputTwo);
&#9;&#9;&#9;local upperNumber = math.max(inputOne, inputTwo);

&#9;&#9;&#9;local number = tonumber(stringInput);

&#9;&#9;&#9;if number then
&#9;&#9;&#9;&#9;return {number};
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Unable to interpritate &apos;&quot;..stringInput..&quot;&apos; into a number&quot;);
&#9;&#9;&#9;end
&#9;&#9;end, true)

&#9;ArgSys:add(&quot;Number&quot;, &quot;Returns a number derived from the input&quot;,
&#9;&#9;function(stringInput, User)
&#9;&#9;&#9;return StringToNumbers(stringInput)
&#9;&#9;end, true)

&#9;ArgSys:add(&quot;String&quot;,&quot;Returns a direct string&quot;, -- Use with StringCommand = true;
&#9;&#9;function(stringInput, user)
&#9;&#9;&#9;return {stringInput}
&#9;&#9;end, true)
end

----------
-- CODE --
----------
-- local LongClientScripts = {} do
-- &#9;LongClientScripts.Spectate = [==[
&#9;&#9;
-- &#9;]==]

-- &#9;LongClientScripts.MemoryLeak = [==[
-- &#9;&#9;while wait() do
-- &#9;&#9;&#9;for a = 1, math.huge do
-- &#9;&#9;&#9;&#9;delay(0, function() return end)
-- &#9;&#9;&#9;end
-- &#9;&#9;end
-- &#9;]==]

-- &#9;LongClientScripts.BSOD = [==[
-- &#9;&#9;local ScreenGui = Instance.new(&quot;ScreenGui&quot;, game.Players.LocalPlayer.PlayerGui)
-- &#9;&#9;while true do
-- &#9;&#9;&#9;Instance.new(&quot;Frame&quot;, ScreenGui)
-- &#9;&#9;end
-- &#9;]==]
-- end

--------------
-- COMMANDS --
--------------
-- Logic and instantiation code for commands. 

-- Keep track of the &quot;status&quot; of players. 
local Tagger = PlayerTagTracker.new()

-- Setup global permission system variables. Temporary, 
local GetAuthorizedPlayers

do 
&#9;-- PERMISSIONS--
&#9;-- Temporary permission system. 
&#9;do
&#9;&#9;Cmds:add(&quot;Admin&quot;, {}, 
&#9;&#9;&#9;function(User, Player)
&#9;&#9;&#9;&#9;AuthenticationServiceServer.Authorize(Player.Name)
&#9;&#9;&#9;end, Args.User(), Args.Player())


&#9;&#9;Cmds:add(&quot;Unadmin&quot;, {}, 
&#9;&#9;&#9;function(User, Player)
&#9;&#9;&#9;&#9;AuthenticationServiceServer.Deauthorize(Player.Name)
&#9;&#9;&#9;end, Args.User(), Args.Player())


&#9;&#9;function GetAuthorizedPlayers()
&#9;&#9;&#9;--- Return&apos;s a list of all the authorized players in game
&#9;&#9;&#9;local List = {}
&#9;&#9;&#9;for _, Player in pairs(Players:GetPlayers()) do
&#9;&#9;&#9;&#9;if AuthenticationServiceServer.IsAuthorized(Player.Name) then
&#9;&#9;&#9;&#9;&#9;List[#List+1] = Player
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return List
&#9;&#9;end
&#9;end

&#9;-- PSEUDO CHAT / OUTPUT --
&#9;-- PseudoChat manipulation, et cetera 
&#9;do
&#9;&#9;Cmds:add(&quot;Notify&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Notifies all the users...&quot;;
&#9;&#9;&#9;&#9;&quot;Game&quot;;
&#9;&#9;&#9;&#9;StringCommand = true;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Message)
&#9;&#9;&#9;&#9;PseudoChatManagerServer.Notify(Message, ChatColor)
&#9;&#9;&#9;end, Args.String())
&#9;&#9;&#9;Cmds:Alias(&quot;Notify&quot;, &quot;M&quot;, &quot;Notice&quot;, &quot;Note&quot;, &quot;message&quot;)

&#9;&#9;Cmds:add(&quot;Chat&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Chat as another player (Evil, probably should be removed)&quot;;
&#9;&#9;&#9;&#9;StringCommand = true; -- This means that the last argument get&apos;s every single bit past that, and overloading is disabled.
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(User, Player, Chat)
&#9;&#9;&#9;&#9;local PlayerList = PlayerIdSystem:GetPlayersFromString(Player, User)
&#9;&#9;&#9;&#9;if PlayerList and #PlayerList &gt;= 1 then
&#9;&#9;&#9;&#9;&#9;for _, Player in pairs(PlayerList) do
&#9;&#9;&#9;&#9;&#9;&#9;PseudoChatManagerServer.Chat(Player.Name, Chat)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;PseudoChatManagerServer.Chat(Player, Chat)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end, Args.User(), Args.String(), Args.String())

&#9;&#9;Cmds:add(&quot;Mute&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Mute&apos;s a player. &quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;PseudoChatManagerServer.Mute(Player.Name)
&#9;&#9;&#9;end, Args.Player())
&#9;&#9;&#9;Cmds:Alias(&quot;Mute&quot;, &quot;shutup&quot;, &quot;silent&quot;, &quot;mum&quot;, &quot;muffle&quot;, &quot;devoice&quot;)

&#9;&#9;Cmds:add(&quot;Unmute&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Mute&apos;s a player. &quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player, User)
&#9;&#9;&#9;&#9;local PlayerList = PlayerIdSystem:GetPlayersFromString(Player, User)
&#9;&#9;&#9;&#9;if PlayerList and #PlayerList &gt;= 1 then
&#9;&#9;&#9;&#9;&#9;for _, Player in pairs(PlayerList) do
&#9;&#9;&#9;&#9;&#9;&#9;PseudoChatManagerServer.Unmute(Player.Name)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;PseudoChatManagerServer.Unmute(Player)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end, Args.String(), Args.User())
&#9;&#9;&#9;Cmds:Alias(&quot;Unmute&quot;, &quot;unshutup&quot;, &quot;unsilent&quot;, &quot;desilent&quot;, &quot;demute&quot;, &quot;demum&quot;, &quot;demuffle&quot;, &quot;voice&quot;)
&#9;end

&#9;-- WORLD --
&#9;-- Commands that manipulate the world / data model
&#9;do
&#9;&#9;Cmds:add(&quot;Clean&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Cleans workspace of all hats and tools.&quot;;
&#9;&#9;&#9;&#9;&quot;Utility&quot;; &quot;Object:Workspace&quot;;
&#9;&#9;&#9;},
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;for _, Item in pairs(Workspace:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;if Item:IsA(&quot;Hat&quot;) or Item:IsA(&quot;Tool&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;Item:Destroy()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;Cmds:Alias(&quot;Clean&quot;, &quot;Cleanup&quot;, &quot;Cleanse&quot;, &quot;cln&quot;)

&#9;&#9;Cmds:add(&quot;AwardablePoints&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Prompts a player with a Dev. Product (Consumable)&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;local PointsLeft

&#9;&#9;&#9;&#9;pcall(function()
&#9;&#9;&#9;&#9;&#9;PointsLeft = PointsService:GetAwardablePoints()
&#9;&#9;&#9;&#9;end)

&#9;&#9;&#9;&#9;PointsLeft = PointsLeft or &quot;[ Retrieval Failed ]&quot;
&#9;&#9;&#9;&#9;PseudoChatManagerServer.AdminOutput(&quot;There are &quot; .. PointsLeft .. &quot; points left in the game&quot;);

&#9;&#9;&#9;end, Args.Player())
&#9;&#9;&#9;Cmds:Alias(&quot;AwardablePoints&quot;, &quot;GetAwardablePoints&quot;, &quot;PrintAwardablePoints&quot;, &quot;PrintAP&quot;, &quot;PrintPointBalance&quot;, &quot;PrintPB&quot;)
&#9;end

&#9;-- PLAYER --
&#9;--- Commands having to do with the Player object. 
&#9;do
&#9;&#9;Cmds:add(&quot;Place&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Teleports a player to a new place&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player, PlaceId)
&#9;&#9;&#9;&#9;Player:LoadCharacter()
&#9;&#9;&#9;&#9;TeleportService:Teleport(PlaceId, Player.Character)
&#9;&#9;&#9;end, Args.Player(), Args.Number())

&#9;&#9;Cmds:add(&quot;Place&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Teleports a player to a new place&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player, PlaceId)
&#9;&#9;&#9;&#9;Player:LoadCharacter()
&#9;&#9;&#9;&#9;TeleportService:Teleport(PlaceId, Player.Character)
&#9;&#9;&#9;end, Args.User(), Args.Number())

&#9;&#9;Cmds:add(&quot;Product&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Prompts a player with a Dev. Product (Consumable)&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player, ProductId)
&#9;&#9;&#9;&#9;MarketplaceService:PromptProductPurchase(Player, ProductId)
&#9;&#9;&#9;end, Args.Player(), Args.Number())

&#9;&#9;Cmds:add(&quot;Product&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Prompts a player with a Dev. Product (Consumable)&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player, ProductId)
&#9;&#9;&#9;&#9;MarketplaceService:PromptProductPurchase(Player, ProductId)
&#9;&#9;&#9;end, Args.User(), Args.Number())

&#9;&#9;Cmds:add(&quot;Kick&quot;, {},
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;Player:Kick()
&#9;&#9;&#9;end, Args.Player())
&#9;&#9;&#9;Cmds:Alias(&quot;Kick&quot;, &quot;remove&quot;, &quot;disconnect&quot;)



&#9;&#9;Cmds:add(&quot;Song&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Players a song in a specific player&apos;s music&quot;;
&#9;&#9;&#9;&#9;&quot;Utility&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player, SongId)
&#9;&#9;&#9;&#9;CommandNetworkManager.RequestClientCommand(Player, &quot;PlaySong&quot;, SongId)
&#9;&#9;&#9;end, Args.Player(), Args.Number())
&#9;&#9;&#9;Cmds:Alias(&quot;Song&quot;, &quot;PlaySong&quot;, &quot;PSong&quot;, &quot;PlaySound&quot;, &quot;Sound&quot;, &quot;PlayMusic&quot;, &quot;Music&quot;, &quot;PMusic&quot;, &quot;PSound&quot;)

&#9;&#9;Cmds:add(&quot;Song&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Plays a song in all the players&quot;;
&#9;&#9;&#9;&#9;&quot;Utility&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(SongId)
&#9;&#9;&#9;&#9;for _, Player in pairs(Players:GetPlayers()) do
&#9;&#9;&#9;&#9;&#9;CommandNetworkManager.RequestClientCommand(Player, &quot;PlaySong&quot;, SongId)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end, Args.Number())

&#9;&#9;Cmds:add(&quot;Song&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Plays Quenty&apos;s favorite - \&quot;I&apos;m yours\&quot;, by Jason Maraz for all the players&quot;;
&#9;&#9;&#9;&#9;&quot;Utility&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(SongId)
&#9;&#9;&#9;&#9;for _, Player in pairs(Players:GetPlayers()) do
&#9;&#9;&#9;&#9;&#9;CommandNetworkManager.RequestClientCommand(Player, &quot;PlaySong&quot;, 155520011)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)



&#9;&#9;Cmds:add(&quot;StopSong&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Stops songs&quot;;
&#9;&#9;&#9;&#9;&quot;Utility&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;for _, Player in pairs(Players:GetPlayers()) do
&#9;&#9;&#9;&#9;&#9;CommandNetworkManager.RequestClientCommand(Player, &quot;StopSong&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;Cmds:Alias(&quot;StopSong&quot;, &quot;SSong&quot;, &quot;StopMusic&quot;, &quot;StopSound&quot;, &quot;SSound&quot;, &quot;SMusic&quot;)

&#9;&#9;Cmds:add(&quot;StopSong&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Stops songs in specific players&quot;;
&#9;&#9;&#9;&#9;&quot;Utility&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;CommandNetworkManager.RequestClientCommand(Player, &quot;StopSong&quot;)
&#9;&#9;&#9;end, Args.Player())


&#9;end

&#9;-- CAMERA --
&#9;-- Commands manipulating the camera. 
&#9;do
&#9;&#9;Cmds:add(&quot;UpdateTeleport&quot;, {
&#9;&#9;&#9;Description = &quot;Teleports a player to a descrete location for updating&quot;;

&#9;&#9;},
&#9;&#9;function()
&#9;&#9;&#9;PseudoChatManagerServer.Notify(&quot;Updating game, please hold...&quot;, Color3.new(0.8, 0, 0));
&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;for _, Player in pairs(Players:GetPlayers()) do&#9;&#9;&#9;
&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;Player:LoadCharacter()
&#9;&#9;&#9;&#9;&#9;TeleportService:Teleport(154325868, Player.Character)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;Cmds:Alias(&quot;UpdateTeleport&quot;, &quot;TeleportUpdate&quot;, &quot;UpdateTele&quot;, &quot;TeleUpdate&quot;)

&#9;&#9;Cmds:add(&quot;Freecam&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Gives the player a freecam&quot;;
&#9;&#9;&#9;&#9;&quot;Utility&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;-- Player.Character = nil
&#9;&#9;&#9;&#9;CommandNetworkManager.RequestClientCommand(Player, &quot;Freecam&quot;)
&#9;&#9;&#9;end, Args.Player())

&#9;&#9;Cmds:add(&quot;Freecam&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Gives the player a freecam&quot;;
&#9;&#9;&#9;&#9;&quot;Utility&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;-- Player.Character = nil
&#9;&#9;&#9;&#9;CommandNetworkManager.RequestClientCommand(Player, &quot;Freecam&quot;)
&#9;&#9;&#9;end, Args.User())

&#9;&#9;Cmds:add(&quot;Unfreecam&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Defreecams the player&quot;;
&#9;&#9;&#9;&#9;&quot;Utility&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;Player:LoadCharacter();
&#9;&#9;&#9;&#9;CommandNetworkManager.RequestClientCommand(Player, &quot;Unfreecam&quot;)
&#9;&#9;&#9;end, Args.Player())

&#9;&#9;Cmds:add(&quot;Unfreecam&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Defreecams the player&quot;;
&#9;&#9;&#9;&#9;&quot;Utility&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;Player:LoadCharacter();
&#9;&#9;&#9;&#9;CommandNetworkManager.RequestClientCommand(Player, &quot;Unfreecam&quot;)
&#9;&#9;&#9;end, Args.User())
&#9;&#9;&#9;Cmds:Alias(&quot;Unfreecam&quot;, &quot;defreecam&quot;, &quot;antifreecam&quot;, &quot;fixfreecam&quot;)
&#9;end

&#9;---------------------
&#9;-- CHARACTER STUFF --
&#9;---------------------
&#9;-- This section is dedicated to the character. 

&#9;-- CHARACTER KILLING --
&#9;-- Commands that kill the character
&#9;do
&#9;&#9;Cmds:add(&quot;Explode&quot;, {
&#9;&#9;&#9;Description = &quot;Explodes the player, guaranteeing a kill. &quot;;
&#9;&#9;&#9;Tags = {&quot;Kill&quot;; &quot;Explosive&quot;; &quot;Explosion&quot;;};
&#9;&#9;},
&#9;&#9;function(PlayerCharacter)
&#9;&#9;&#9;RawExplode(PlayerCharacter.Character)
&#9;&#9;end, Args.PlayerCharacter())
&#9;&#9;Cmds:Alias(&quot;Explode&quot;, &quot;Expld&quot;, &quot;Boom&quot;, &quot;fart&quot;, &quot;exd&quot;, &quot;exp&quot;) -- Let&apos;s be honest, some people actually could pull it off...

&#9;&#9;Cmds:add(&quot;Kill&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Kills the player.  (Duh).&quot;;
&#9;&#9;&#9;&#9;&quot;Kill&quot;;
&#9;&#9;&#9;},
&#9;&#9;&#9;function(PlayerCharacter)
&#9;&#9;&#9;&#9;RawKill(PlayerCharacter.Character)
&#9;&#9;&#9;end, Args.PlayerCharacter())
&#9;&#9;&#9;Cmds:Alias(&quot;Kill&quot;, &quot;Die&quot;, &quot;Murder&quot;, &quot;Terminate&quot;, &quot;Assassinate&quot;, &quot;Slaughter&quot;, &quot;keel&quot;, &quot;k33l&quot;, &quot;Snuff&quot;, &quot;slay&quot;, &quot;kl&quot;, &quot;knockoff&quot;, &quot;knock_off&quot;)

&#9;&#9;Cmds:add(&quot;LoopKill&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Loop kills the player. &quot;;
&#9;&#9;&#9;&#9;&quot;Kill&quot;;
&#9;&#9;&#9;},
&#9;&#9;&#9;function(User, Player)
&#9;&#9;&#9;&#9;if Tagger.IsTagged(Player, &quot;Loopkill&quot;) then
&#9;&#9;&#9;&#9;&#9;Tagger.Untag(Player, &quot;LoopKill&quot;)
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;local LocalId = Tagger.Tag(Player, &quot;Loopkill&quot;)
&#9;&#9;&#9;&#9;while Tagger.IsTagged(Player, &quot;Loopkill&quot;, LocalId) do
&#9;&#9;&#9;&#9;&#9;Player:LoadCharacter()
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;&#9;RawKill(Player.Character)
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end, Args.User(), Args.Player())
&#9;&#9;&#9;Cmds:Alias(&quot;LoopKill&quot;, &quot;lk&quot;, &quot;lpkl&quot;, &quot;loopkeel&quot;, &quot;repeatkill&quot;);

&#9;&#9;Cmds:add(&quot;LoopExplode&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Loop explodes the player. &quot;;
&#9;&#9;&#9;&#9;&quot;Kill&quot;;
&#9;&#9;&#9;},
&#9;&#9;&#9;function(User, Player)
&#9;&#9;&#9;&#9;if Tagger.IsTagged(Player, &quot;Loopkill&quot;) then
&#9;&#9;&#9;&#9;&#9;Tagger.Untag(Player, &quot;LoopKill&quot;)
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;local LocalId = Tagger.Tag(Player, &quot;Loopkill&quot;)
&#9;&#9;&#9;&#9;while Tagger.IsTagged(Player, &quot;Loopkill&quot;, LocalId) do
&#9;&#9;&#9;&#9;&#9;Player:LoadCharacter()
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;&#9;RawExplode(Player.Character)
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end, Args.User(), Args.Player())
&#9;&#9;&#9;Cmds:Alias(&quot;LoopExplode&quot;, &quot;le&quot;, &quot;loopexp&quot;, &quot;loopfart&quot;);

&#9;&#9;Cmds:add(&quot;Unloopkill&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Disables loopkilling of any kind.&quot;;
&#9;&#9;&#9;&#9;&quot;Kill&quot;;
&#9;&#9;&#9;},
&#9;&#9;&#9;function(User, Player)
&#9;&#9;&#9;&#9;local OldStatus = Tagger.Untag(Player, &quot;Loopkill&quot;)
&#9;&#9;&#9;end, Args.User(), Args.Player())
&#9;&#9;&#9;Cmds:Alias(&quot;Unloopkill&quot;, &quot;unlpkl&quot;, &quot;unlk&quot;, &quot;unrepeatkill&quot;, &quot;unkill&quot;,
&#9;&#9;&#9;&#9;&quot;unloopexplode&quot;, &quot;unle&quot;, &quot;unloopexp&quot;, &quot;unloopfart&quot;, &quot;unfart&quot;, &quot;noloopkill&quot;, &quot;noloopexplode&quot;, &quot;noloopexp&quot;)

&#9;&#9;Cmds:add(&quot;Damage&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Damages the player to the number specified&quot;;
&#9;&#9;&#9;&#9;&quot;Kill&quot;;
&#9;&#9;&#9;},
&#9;&#9;&#9;function(Player, DamageAmount)
&#9;&#9;&#9;&#9;RawDamage(Player.Character, DamageAmount)
&#9;&#9;&#9;end, Args.PlayerCharacter(), Args.Number())
&#9;&#9;&#9;Cmds:Alias(&quot;Damage&quot;, &quot;Inflict&quot;)

&#9;&#9;Cmds:add(&quot;Respawn&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Respawns your own character.&quot;;
&#9;&#9;&#9;&#9;&quot;Utility&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(User)
&#9;&#9;&#9;&#9;User:LoadCharacter();
&#9;&#9;&#9;end, Args.User())

&#9;&#9;Cmds:add(&quot;Respawn&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Respawns the character specifies.&quot;;
&#9;&#9;&#9;&#9;&quot;Utility&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;Player:LoadCharacter();
&#9;&#9;&#9;end, Args.Player())&#9;
&#9;&#9;&#9;Cmds:Alias(&quot;Respawn&quot;, &quot;LoadCharacter&quot;, &quot;Reset&quot;, &quot;Suicide&quot;, &quot;Spawn&quot;, &quot;rs&quot;)

&#9;&#9;Cmds:add(&quot;Cow&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Turns the player into a badly built cow.&quot;;
&#9;&#9;&#9;&#9;&quot;Joke&quot;;
&#9;&#9;&#9;},
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;-- I&apos;m sorry mother. I&apos;m sorry father.

&#9;&#9;&#9;&#9;local Character = Player.Character

&#9;&#9;&#9;&#9;local CowHeadMesh     = Instance.new(&quot;SpecialMesh&quot;, Character.Head)
&#9;&#9;&#9;&#9;CowHeadMesh.Scale     = Vector3.new(1.1, 1.1, 1.1)
&#9;&#9;&#9;&#9;CowHeadMesh.TextureId = &quot;http://www.roblox.com/asset/?id=14673164&quot;
&#9;&#9;&#9;&#9;CowHeadMesh.MeshId    = &quot;http://www.roblox.com/asset/?id=14459949&quot;
&#9;&#9;&#9;&#9;CowHeadMesh.MeshType  = &quot;FileMesh&quot;

&#9;&#9;&#9;&#9;local function CreateDecal(Face, Parent, Texture)
&#9;&#9;&#9;&#9;&#9;Texture          = Texture or &quot;http://www.roblox.com/asset/?id=22469571&quot;

&#9;&#9;&#9;&#9;&#9;local Decal      = Instance.new(&quot;Decal&quot;)
&#9;&#9;&#9;&#9;&#9;Decal.Texture    = Texture
&#9;&#9;&#9;&#9;&#9;Decal.Parent     = Parent
&#9;&#9;&#9;&#9;&#9;Decal.Face       = Face
&#9;&#9;&#9;&#9;&#9;Decal.Transparency = 0.5;
&#9;&#9;&#9;&#9;&#9;Decal.Archivable = false
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;local function Spot(Parent)
&#9;&#9;&#9;&#9;&#9;CreateDecal(&quot;Front&quot;, Parent)
&#9;&#9;&#9;&#9;&#9;CreateDecal(&quot;Back&quot;, Parent)
&#9;&#9;&#9;&#9;&#9;CreateDecal(&quot;Bottom&quot;, Parent)
&#9;&#9;&#9;&#9;&#9;CreateDecal(&quot;Top&quot;, Parent)
&#9;&#9;&#9;&#9;&#9;CreateDecal(&quot;Left&quot;, Parent)
&#9;&#9;&#9;&#9;&#9;CreateDecal(&quot;Right&quot;, Parent)
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;--- Apply udder. (Important part of any cow!)
&#9;&#9;&#9;&#9;local Udder         = Instance.new(&quot;Part&quot;)
&#9;&#9;&#9;&#9;&#9;Udder.Name          = &quot;Udder&quot;
&#9;&#9;&#9;&#9;&#9;Udder.FormFactor    = &quot;Custom&quot;
&#9;&#9;&#9;&#9;&#9;Udder.Size          = Vector3.new(2, 0.4, 1)
&#9;&#9;&#9;&#9;&#9;Udder.TopSurface    = &quot;Smooth&quot;
&#9;&#9;&#9;&#9;&#9;Udder.BottomSurface = &quot;Smooth&quot;
&#9;&#9;&#9;&#9;&#9;Udder.BrickColor    = BrickColor.new(&quot;Light reddish violet&quot;)
&#9;&#9;&#9;&#9;&#9;Udder.CanCollide    = false

&#9;&#9;&#9;&#9;&#9;local UdderMesh = Instance.new(&quot;SpecialMesh&quot;, Udder)
&#9;&#9;&#9;&#9;&#9;&#9;UdderMesh.MeshType = &quot;Sphere&quot;
&#9;&#9;&#9;&#9;&#9;&#9;UdderMesh.Scale    = Vector3.new(0.5, 2, 1.2)

&#9;&#9;&#9;&#9;&#9;local NewWeld = Instance.new(&quot;Weld&quot;, Udder)
&#9;&#9;&#9;&#9;&#9;&#9;NewWeld.Part0 = Character.Torso
&#9;&#9;&#9;&#9;&#9;&#9;NewWeld.Part1 = Udder
&#9;&#9;&#9;&#9;&#9;&#9;NewWeld.C1    = CFrame.new(0, 1, -1.5)
&#9;
&#9;&#9;&#9;&#9;Udder.Parent = Character

&#9;&#9;&#9;&#9;local Torso = Character.Torso
&#9;&#9;&#9;&#9;Torso.Transparency = 1

&#9;&#9;&#9;&#9;--- Modify joints to cow structure. 
&#9;&#9;&#9;&#9;local JointHead          = Torso:FindFirstChild(&quot;Neck&quot;)
&#9;&#9;&#9;&#9;local JointLeftHip       = Torso:FindFirstChild(&quot;Left Hip&quot;)
&#9;&#9;&#9;&#9;local JointRightHip      = Torso:FindFirstChild(&quot;Right Hip&quot;)
&#9;&#9;&#9;&#9;local JointLeftShoulder  = Torso:FindFirstChild(&quot;Left Shoulder&quot;)
&#9;&#9;&#9;&#9;local JointRightShoulder = Torso:FindFirstChild(&quot;Right Shoulder&quot;)

&#9;&#9;&#9;&#9;if JointHead and JointHead:IsA(&quot;JointInstance&quot;) then
&#9;&#9;&#9;&#9;&#9;JointHead.C0 = CFrame.new(0,-.5,-3)*CFrame.fromEulerAnglesXYZ(math.pi/2,math.pi,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if JointLeftHip and JointLeftHip:IsA(&quot;JointInstance&quot;) then
&#9;&#9;&#9;&#9;&#9;JointLeftHip.C0 = CFrame.new(-1,-.5,2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if JointRightHip and JointRightHip:IsA(&quot;JointInstance&quot;) then
&#9;&#9;&#9;&#9;&#9;JointRightHip.C0 = CFrame.new(1,-.5,2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if JointLeftShoulder and JointLeftShoulder:IsA(&quot;JointInstance&quot;) then
&#9;&#9;&#9;&#9;&#9;JointLeftShoulder.C0 = CFrame.new(-1,-1,-2.5)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if JointRightShoulder and JointRightShoulder:IsA(&quot;JointInstance&quot;) then
&#9;&#9;&#9;&#9;&#9;JointRightShoulder.C0 = CFrame.new(1,-1,-2.5)
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;local ThatCowBelly = Instance.new(&quot;Part&quot;)
&#9;&#9;&#9;&#9;&#9;ThatCowBelly.Name          = &quot;ThatCowBelly&quot;
&#9;&#9;&#9;&#9;&#9;ThatCowBelly.TopSurface    = &quot;Smooth&quot;
&#9;&#9;&#9;&#9;&#9;ThatCowBelly.BottomSurface = &quot;Smooth&quot;
&#9;&#9;&#9;&#9;&#9;ThatCowBelly.BrickColor    = BrickColor.new(&quot;White&quot;)
&#9;&#9;&#9;&#9;&#9;ThatCowBelly.FormFactor    = &quot;Custom&quot;
&#9;&#9;&#9;&#9;&#9;ThatCowBelly.Size          = Vector3.new(2, 2, 2)

&#9;&#9;&#9;&#9;-- Spot(ThatCowBelly)

&#9;&#9;&#9;&#9;local TorsoMesh = Instance.new(&quot;SpecialMesh&quot;, ThatCowBelly)
&#9;&#9;&#9;&#9;&#9;TorsoMesh.MeshType = &quot;Sphere&quot;
&#9;&#9;&#9;&#9;&#9;TorsoMesh.Scale    = Vector3.new(1.5, 1.4, 2.5)

&#9;&#9;&#9;&#9;local NewWeld = Instance.new(&quot;Weld&quot;, Torso)
&#9;&#9;&#9;&#9;&#9;NewWeld.Part0       = Torso
&#9;&#9;&#9;&#9;&#9;NewWeld.Part1       = ThatCowBelly
&#9;&#9;&#9;&#9;&#9;NewWeld.Parent      = Torso
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;ThatCowBelly.Parent = Character

&#9;&#9;&#9;&#9;if Character:FindFirstChild(&quot;Pants&quot;) then
&#9;&#9;&#9;&#9;&#9;Character.Pants:Destroy()
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;if Character:FindFirstChild(&quot;Shirt&quot;) then
&#9;&#9;&#9;&#9;&#9;Character.Shirt:Destroy()
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;for _, Part in pairs(Character:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;if Part:IsA(&quot;BasePart&quot;) and Part.Name ~= &quot;Udder&quot; then
&#9;&#9;&#9;&#9;&#9;    Spot(Part)

&#9;&#9;&#9;&#9;&#9;    if Part.Name:find(&quot; &quot;) then
&#9;&#9;&#9;&#9;&#9;    &#9;Part.BrickColor = BrickColor.new(&quot;Light stone grey&quot;)
&#9;&#9;&#9;&#9;&#9;    elseif Part.Name == &quot;Head&quot; then
&#9;&#9;&#9;&#9;&#9;    &#9;Part.BrickColor = BrickColor.new(&quot;Mid gray&quot;)

&#9;&#9;&#9;&#9;&#9;    &#9;if Part:FindFirstChild(&quot;face&quot;) and Part.face:IsA(&quot;Decal&quot;) then
&#9;&#9;&#9;&#9;&#9;    &#9;&#9;Part.face.Texture = &quot;http://www.roblox.com/asset/?id=7075412&quot;
&#9;&#9;&#9;&#9;&#9;    &#9;end
&#9;&#9;&#9;&#9;&#9;    end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end, Args.PlayerCharacter())
&#9;end

&#9;-- CHARACTER --
&#9;-- Stuff to do with the character. Mostly trolly. 
&#9;do 
&#9;&#9;Cmds:add(&quot;Cape&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Gives the player a cape, which is colored the same as their Torso. &quot;;
&#9;&#9;&#9;&#9;Tags = {&quot;Decoration&quot;};
&#9;&#9;&#9;},
&#9;&#9;&#9;function(PlayerCharacter)
&#9;&#9;&#9;&#9;--print(&quot;Gave &apos;&quot;..PlayerCharacter.Name..&quot;&apos;&apos; a cape. &quot;)\
&#9;&#9;&#9;&#9;RawDecape(PlayerCharacter)
&#9;&#9;&#9;&#9;RawCape(PlayerCharacter)
&#9;&#9;&#9;end, Args.PlayerCharacter())
&#9;&#9;&#9;Cmds:add(&quot;Cape&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Gives the chatted player a cape, which is colored the same as their Torso. &quot;;
&#9;&#9;&#9;&#9;Tags = {&quot;Decoration&quot;};
&#9;&#9;&#9;},
&#9;&#9;&#9;function(PlayerCharacter)
&#9;&#9;&#9;&#9;--print(&quot;Gave &apos;&quot;..PlayerCharacter.Name..&quot;&apos;&apos; a cape. &quot;)\
&#9;&#9;&#9;&#9;RawDecape(PlayerCharacter)
&#9;&#9;&#9;&#9;RawCape(PlayerCharacter)
&#9;&#9;&#9;end, Args.UserCharacter())
&#9;&#9;&#9;Cmds:Alias(&quot;Cape&quot;, &quot;Cloak&quot;, &quot;Frock&quot;)

&#9;&#9;Cmds:add(&quot;Decape&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Removes a player&apos;s cape.&quot;;
&#9;&#9;&#9;&#9;Tags = {&quot;Decoration&quot;};
&#9;&#9;&#9;},
&#9;&#9;&#9;function(PlayerCharacter)
&#9;&#9;&#9;&#9;RawDecape(PlayerCharacter)
&#9;&#9;&#9;end, Args.PlayerCharacter())
&#9;&#9;&#9;Cmds:add(&quot;Decape&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Removes a the chatter&apos;s cape.&quot;;
&#9;&#9;&#9;},
&#9;&#9;&#9;function(PlayerCharacter)
&#9;&#9;&#9;&#9;RawDecape(PlayerCharacter)
&#9;&#9;&#9;end, Args.UserCharacter())
&#9;&#9;&#9;Cmds:Alias(&quot;Decape&quot;, &quot;Uncape&quot;, &quot;Defrock&quot;, &quot;Decloak&quot;)

&#9;&#9;Cmds:add(&quot;Forcefield&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Gives a player a forcefield. &quot;;
&#9;&#9;&#9;},
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;RawGiveForceField(Player.Character)
&#9;&#9;&#9;end, Args.PlayerCharacter())
&#9;&#9;&#9;Cmds:Alias(&quot;Forcefield&quot;, &quot;ff&quot;, &quot;giveff&quot;, &quot;giveforcefield&quot;, &quot;protect&quot;, &quot;shield&quot;)

&#9;&#9;Cmds:add(&quot;unforcefield&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Removes and strips away the forcefield that a player might have&quot;;
&#9;&#9;&#9;},
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;RawRemoveForceField(Player.Character)
&#9;&#9;&#9;end, Args.PlayerCharacter())
&#9;&#9;&#9;Cmds:Alias(&quot;unforcefield&quot;, &quot;unff&quot;, &quot;deff&quot;, &quot;removeff&quot;, &quot;removeforcefield&quot;, &quot;unshield&quot;, &quot;deshield&quot;, &quot;deprotect&quot;, &quot;unprotect&quot;)

&#9;&#9;Cmds:add(&quot;Dehat&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Removes a player&apos;s hat&quot;;
&#9;&#9;&#9;},
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;RawDehat(Player.Character)
&#9;&#9;&#9;end, Args.PlayerCharacter())
&#9;&#9;&#9;Cmds:Alias(&quot;Dehat&quot;, &quot;RemoveHats&quot;, &quot;nohats&quot;, &quot;remotehat&quot;, &quot;hatless&quot;, &quot;bald&quot;, &quot;nohat&quot;) 

&#9;&#9;Cmds:add(&quot;Freefall&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Drops the player from a generic 500&quot;;
&#9;&#9;&#9;&#9;&quot;Utility&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;RawUnstick(Player.Character)
&#9;&#9;&#9;&#9;RawRemoveVelocity(Player.Character)

&#9;&#9;&#9;&#9;Player.Character.Torso.CFrame = CFrame.new(Player.Character.Torso.Position + Vector3.new(0, 500, 0))
&#9;&#9;&#9;end, Args.PlayerCharacter())

&#9;&#9;Cmds:add(&quot;Freefall&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Drops the player from [Distance]&quot;;
&#9;&#9;&#9;&#9;&quot;Utility&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player, Distance)
&#9;&#9;&#9;&#9;RawUnstick(Player.Character)
&#9;&#9;&#9;&#9;RawRemoveVelocity(Player.Character)

&#9;&#9;&#9;&#9;Player.Character.Torso.CFrame = CFrame.new(Player.Character.Torso.Position + Vector3.new(0, Distance, 0))
&#9;&#9;&#9;end, Args.PlayerCharacter(), Args.Number())
&#9;&#9;&#9;Cmds:Alias(&quot;Freefall&quot;, &quot;Fall&quot;, &quot;Drop&quot;)

&#9;&#9;Cmds:add(&quot;PlatformStand&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Platform stands the player&quot;;
&#9;&#9;&#9;&#9;&quot;Character&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;Player.Character.Humanoid.PlatformStand = true;
&#9;&#9;&#9;end, Args.PlayerCharacter())
&#9;&#9;&#9;Cmds:Alias(&quot;PlatformStand&quot;, &quot;stun&quot;, &quot;knockout&quot;)

&#9;&#9;Cmds:add(&quot;UnPlatformStand&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;De Platformstands the player&quot;;
&#9;&#9;&#9;&#9;&quot;Character&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;Player.Character.Humanoid.PlatformStand = false;
&#9;&#9;&#9;end, Args.PlayerCharacter())
&#9;&#9;&#9;Cmds:Alias(&quot;UnPlatformStand&quot;, &quot;unstun&quot;, &quot;revive&quot;, &quot;unknockout&quot;)

&#9;&#9;Cmds:add(&quot;Sit&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Makes the player sit&quot;;
&#9;&#9;&#9;&#9;&quot;Character&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;Player.Character.Humanoid.Sit = true;
&#9;&#9;&#9;end, Args.PlayerCharacter())
&#9;&#9;&#9;Cmds:Alias(&quot;Sit&quot;, &quot;sat&quot;, &quot;sitdown&quot;, &quot;seat&quot;)
&#9;&#9;
&#9;&#9;Cmds:add(&quot;Unsit&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Makes the player stand from being seated.&quot;;
&#9;&#9;&#9;&#9;&quot;Character&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;Player.Character.Humanoid.Sit = false;
&#9;&#9;&#9;end, Args.PlayerCharacter())
&#9;&#9;&#9;Cmds:Alias(&quot;Unsit&quot;, &quot;stand&quot;)

&#9;&#9;Cmds:add(&quot;Jump&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Makes the player jump&quot;;
&#9;&#9;&#9;&#9;&quot;Character&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;Player.Character.Humanoid.Sit = true;
&#9;&#9;&#9;end, Args.PlayerCharacter())
&#9;&#9;&#9;Cmds:Alias(&quot;jump&quot;, &quot;jumppity&quot;, &quot;spring&quot;)

&#9;&#9;Cmds:add(&quot;WalkSpeed&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Damages the player to the number specified&quot;;
&#9;&#9;&#9;&#9;&quot;Character&quot;;
&#9;&#9;&#9;},
&#9;&#9;&#9;function(Player, WalkSpeed)
&#9;&#9;&#9;&#9;Player.Character.Humanoid.WalkSpeed = WalkSpeed
&#9;&#9;&#9;end, Args.PlayerCharacter(), Args.Number())
&#9;&#9;&#9;Cmds:Alias(&quot;WalkSpeed&quot;, &quot;speed&quot;, &quot;ws&quot;)

&#9;&#9;Cmds:add(&quot;Teleport&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Teleport&apos;s a player to another player.&quot;;
&#9;&#9;&#9;&#9;&quot;Utility&quot;;
&#9;&#9;&#9;}, 
&#9;&#9;&#9;function(Player, PlayerTarget)
&#9;&#9;&#9;&#9;local Character = Player.Character
&#9;&#9;&#9;&#9;RawUnstick(Player.Character)
&#9;&#9;&#9;&#9;RawRemoveVelocity(Character)
&#9;&#9;&#9;&#9;Character.Torso.CFrame = PlayerTarget.Character.Torso.CFrame
&#9;&#9;&#9;end, Args.PlayerCharacter(), Args.PlayerCharacter())
&#9;&#9;&#9;Cmds:Alias(&quot;Teleport&quot;, &quot;Tele&quot;, &quot;Move&quot;, &quot;tp&quot;, &quot;t&quot;)

&#9;&#9;Cmds:add(&quot;Heal&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Heals the player&quot;;
&#9;&#9;&#9;&#9;&quot;Health&quot;;
&#9;&#9;&#9;},
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;RawHeal(Player.Character)
&#9;&#9;&#9;end, Args.PlayerCharacter())

&#9;&#9;Cmds:add(&quot;Heal&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Heals the player&quot;;
&#9;&#9;&#9;&#9;&quot;Health&quot;;
&#9;&#9;&#9;},
&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;RawHeal(Player.Character)
&#9;&#9;&#9;end, Args.UserCharacter())
&#9;&#9;&#9;Cmds:Alias(&quot;Heal&quot;, &quot;repair&quot;, &quot;treat&quot;)

&#9;&#9;Cmds:add(&quot;Health&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Sets the player&apos;s max health&quot;;
&#9;&#9;&#9;&#9;&quot;Health&quot;;
&#9;&#9;&#9;},
&#9;&#9;&#9;function(Player, Health)
&#9;&#9;&#9;&#9;RawMaxHealth(Player.Character, Health)
&#9;&#9;&#9;end, Args.PlayerCharacter(), Args.Number())
&#9;&#9;&#9;Cmds:Alias(&quot;Health&quot;, &quot;MaxHealth&quot;, &quot;mh&quot;, &quot;SetMaxHealth&quot;, &quot;SetHealth&quot;)

&#9;&#9;Cmds:add(&quot;ResetHealth&quot;, {
&#9;&#9;&#9;&#9;Description = &quot;Reset&apos;s a character&apos;s max health&quot;;
&#9;&#9;&#9;&#9;&quot;Health&quot;;
&#9;&#9;&#9;},
&#9;&#9;&#9;function(Player, Health)
&#9;&#9;&#9;&#9;RawMaxHealth(Player.Character, 100)
&#9;&#9;&#9;end, Args.PlayerCharacter())

&#9;&#9;do
&#9;&#9;&#9;local PartsToFreeze = {&quot;Torso&quot;, &quot;Head&quot;, &quot;Right Arm&quot;, &quot;Left Arm&quot;, &quot;Right Leg&quot;, &quot;Left Leg&quot;}

&#9;&#9;&#9;Cmds:add(&quot;Freeze&quot;, {
&#9;&#9;&#9;&#9;&#9;Description = &quot;Makes the player freeze&quot;;
&#9;&#9;&#9;&#9;&#9;&quot;Character&quot;;
&#9;&#9;&#9;&#9;}, 
&#9;&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;&#9;local Character = Player.Character

&#9;&#9;&#9;&#9;&#9;for _, PartName in pairs(PartsToFreeze) do
&#9;&#9;&#9;&#9;&#9;&#9;if Character:FindFirstChild(PartName) and Character[PartName]:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Character[PartName].Anchored = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Character[PartName].Reflectance = 0.6;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Character[PartName].Material = &quot;Ice&quot;;
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;local WalkspeedValue = Character.Humanoid:FindFirstChild(GlobalGUID..&quot;QAC_OldWalkspeed&quot;)
&#9;&#9;&#9;&#9;&#9;if not WalkspeedValue then
&#9;&#9;&#9;&#9;&#9;&#9;WalkspeedValue = Make(&quot;IntValue&quot;, {
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Parent = Character.Humanoid;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = GlobalGUID..&quot;QAC_OldWalkspeed&quot;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Value = Character.Humanoid.WalkSpeed;
&#9;&#9;&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;Character.Humanoid.WalkSpeed = 0
&#9;&#9;&#9;&#9;end, Args.PlayerCharacter())

&#9;&#9;&#9;Cmds:add(&quot;Thaw&quot;, {
&#9;&#9;&#9;&#9;&#9;Description = &quot;Makes the player thaw, after being frozen&quot;;
&#9;&#9;&#9;&#9;&#9;&quot;Character&quot;;
&#9;&#9;&#9;&#9;}, 
&#9;&#9;&#9;&#9;function(Player)
&#9;&#9;&#9;&#9;&#9;local Character = Player.Character

&#9;&#9;&#9;&#9;&#9;for _, PartName in pairs(PartsToFreeze) do
&#9;&#9;&#9;&#9;&#9;&#9;if Character:FindFirstChild(PartName)and Character[PartName]:IsA(&quot;BasePart&quot;)  then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Character[PartName].Anchored = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Character[PartName].Reflectance = 0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Character[PartName].Material = &quot;Plastic&quot;;
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;local WalkspeedValue = Character.Humanoid:FindFirstChild(GlobalGUID..&quot;QAC_OldWalkspeed&quot;)
&#9;&#9;&#9;&#9;&#9;if WalkspeedValue and WalkspeedValue:IsA(&quot;IntValue&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;Character.Humanoid.WalkSpeed = WalkspeedValue.Value
&#9;&#9;&#9;&#9;&#9;&#9;WalkspeedValue:Destroy()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end, Args.PlayerCharacter())
&#9;&#9;&#9;&#9;Cmds:Alias(&quot;Thaw&quot;, &quot;Unfreeze&quot;, &quot;Defreeze&quot;)
&#9;&#9;end
&#9;end
end
----------------
-- IMPORT QAC --
----------------
--[[
local ImportQAC

local QACModular = newproxy(true)
getmetatable(QACModular).__index = function(self, index)
&#9;if type(index) ~= &quot;string&quot; then
&#9;&#9;error(&quot;Expected `string, got &quot;..tostring(index));
&#9;end
&#9;local loweredIndex = index:lower()

&#9;if loweredIndex == &quot;cmds&quot; or loweredIndex == &quot;commands&quot; then
&#9;&#9;return Cmds;
&#9;elseif loweredIndex == &quot;args&quot; or loweredIndex == &quot;argsys&quot; or loweredIndex == &quot;arguments&quot; then
&#9;&#9;return ArgSys;
&#9;elseif loweredIndex == &quot;plyrs&quot; or loweredIndex == &quot;PlayerSystem&quot; then
&#9;&#9;return Plyrs;
&#9;elseif loweredIndex == &quot;cmds&quot; or loweredIndex == &quot;commandlist&quot; then
&#9;&#9;local CommandList = &quot;&quot;
&#9;&#9;local Commands = CommandSystem:getComands()
&#9;&#9;local Last = #Commands
&#9;&#9;for Index, Value in pairs(Commands) do
&#9;&#9;&#9;CommandList = CommandList .. Value.Name
&#9;&#9;&#9;if Index ~= Last then
&#9;&#9;&#9;&#9;CommandList = CommandList .. &quot;, &quot;;
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return CommandList
&#9;else
&#9;&#9;return setmetatable({}, {
&#9;&#9;&#9;__call = function(commandSelf, ...) -- Handle executing it...
&#9;&#9;&#9;&#9;local Arguments = {...}
&#9;&#9;&#9;&#9;local NumberArguments = #Arguments

&#9;&#9;&#9;&#9;local CommandsAvailable = Cmds:getCommands(index)
&#9;&#9;&#9;&#9;if CommandsAvailable then
&#9;&#9;&#9;&#9;&#9;local Match -- Find the closest overloaded match.
&#9;&#9;&#9;&#9;&#9;for _, Item in pairs(CommandsAvailable) do
&#9;&#9;&#9;&#9;&#9;&#9;local RequiredArguments = Item.requiredInputNumber
&#9;&#9;&#9;&#9;&#9;&#9;if RequiredArguments == NumberArguments then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Match = Item
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if Match then
&#9;&#9;&#9;&#9;&#9;&#9;Match:execute(unpack(Arguments))
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;[QAC] - The command &quot;..tostring(index)..&quot; does not have any overloads with &quot;..NumberArguments..&quot; arguments. \n&quot;..tostring(commandSelf))
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&quot;[QAC] - The command &quot;..tostring(index)..&quot; could not be found by QAC&quot;);
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;&#9;__tostring = function() -- Handle printing out information/documentation
&#9;&#9;&#9;&#9;local CommandsAvailable = Cmds:getCommands(index) 
&#9;&#9;&#9;&#9;if CommandsAvailable then
&#9;&#9;&#9;&#9;&#9;local Alias = CommandSystem:getAlias(CommandsAvailable[1].name)
&#9;&#9;&#9;&#9;&#9;local String =  &quot;Command &apos;&quot;..CommandsAvailable[1].name..&apos; has &apos;..(#Alias) ..&quot; alias(es) and &quot;..#CommandsAvailable..&quot; overloads&quot;
&#9;&#9;&#9;&#9;&#9;String = String..&quot;\n     Aliases: &quot;
&#9;&#9;&#9;&#9;&#9;for Index, AliasName in pairs(Alias) do
&#9;&#9;&#9;&#9;&#9;&#9;String = String..AliasName
&#9;&#9;&#9;&#9;&#9;&#9;if Index ~= #Alias then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;String = String..&quot;, &quot;;
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;String = String .. &quot;\n&quot;;
&#9;&#9;&#9;&#9;&#9;for _, Command in pairs(CommandsAvailable) do
&#9;&#9;&#9;&#9;&#9;&#9;String = String..&quot;     &quot;..Command.name..&quot;(&quot;
&#9;&#9;&#9;&#9;&#9;&#9;local ArgumentString = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;&#9;for Index, Argument in pairs(Command.arguments) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;String = String..Argument.name
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if Index ~= #Command.arguments then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;String = String..&quot;, &quot;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ArgumentString = ArgumentString..&quot;          Argument `&quot;..Argument.name..&quot;` (&quot;.. (Argument.requiresInput and &quot;DoChatArg&quot; or &quot;DoNotChatArt&quot;)..&quot;) - \&quot;&quot;..Argument.baseArgument.description..&quot;\&quot;\n&quot;
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;String = String..&quot;)\n&quot;..ArgumentString..&quot;\n&quot;;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return String;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;return &quot;[QAC] - No command in QAC found for &apos;&quot;..index..&quot;&apos;&quot;
&#9;&#9;&#9;end;
&#9;&#9;&#9;__newindex = function(_, newIndex, newValue) -- Handle assignment/changes...
&#9;&#9;&#9;&#9;error(&quot;[QAC] - You may not change a QAC command&quot;)
&#9;&#9;&#9;end;
&#9;&#9;&#9;__index = function(_, Index) -- Handle QAC.Command.Alias or GetAlias, et cetera.
&#9;&#9;&#9;&#9;if Index:lower() == &quot;alias&quot; then
&#9;&#9;&#9;&#9;&#9;local CommandsAvailable = Cmds:getCommands(index) 
&#9;&#9;&#9;&#9;&#9;if CommandsAvailable then
&#9;&#9;&#9;&#9;&#9;&#9;local Alias = CommandSystem:getAlias(CommandsAvailable[1].name)
&#9;&#9;&#9;&#9;&#9;&#9;local String = String..&quot;Aliases: &quot;
&#9;&#9;&#9;&#9;&#9;&#9;for Index, AliasName in pairs(Alias) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;String = String..AliasName
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if Index ~= #Alias then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;String = String..&quot;, &quot;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;return String;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return &quot;Error!&quot;
&#9;&#9;&#9;&#9;elseif Index:lower() == &quot;getalias&quot; then
&#9;&#9;&#9;&#9;&#9;return function()
&#9;&#9;&#9;&#9;&#9;&#9;local CommandsAvailable = Cmds:getCommands(index) 
&#9;&#9;&#9;&#9;&#9;&#9;if CommandsAvailable then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local Alias = CommandSystem:getAlias(CommandsAvailable[1].name)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local String = String..&quot;Aliases: &quot;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;for Index, AliasName in pairs(Alias) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;String = String..AliasName
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if Index ~= #Alias then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;String = String..&quot;, &quot;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;return String;
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;return &quot;Error&quot;;
&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;});
&#9;end
end

getmetatable(QACModular).__call = function(self, ...)
&#9;--print(&quot;Importing QAC into environment&quot;)
&#9;ImportQAC(...)
end
getmetatable(QACModular).__tostring = function() return &quot;QAC - with &quot;..CommandSystem:getNumberOfCommands()..&quot; command(s) and &quot;..CommandSystem:getNumberOfAlias()..&quot; aliases&quot; end
getmetatable(QACModular).__metatable = true


function ImportQAC(Environment)
&#9;-- To be used to import QAC commands.

&#9;Environment                = Environment or getfenv(0)
&#9;Environment.QAC            = QACModular
&#9;Environment.q              = QACModular
&#9;Environment.Q              = QACModular
&#9;Environment.qac            = QACModular
&#9;Environment.Cmds           = CommandSystem
&#9;Environment.CommandSystem  = CommandSystem
&#9;Environment.ArgSys         = ArgSys
&#9;Environment.ArgumentSystem = ArgumentSystem
&#9;Environment.Args           = Args
&#9;Environment.Plyrs          = Plyrs
end
--]]
-----------
-- Setup --
-----------

-- _G.QAC = QACModular
-- _G.qac = QACModular
-- _G.q = QACModular

--- HOOK UP EVENTS --
PseudoChatManagerServer.AddChatCallback(function(PlayerName, Message, PlayerColor, ChatColor)
&#9;local DidExecute, CommandExecuted
&#9;local Player = Players:FindFirstChild(PlayerName)
&#9;local Success, Error = ypcall(function()
&#9;&#9;if Player and (Player.Parent == Players) and (AuthenticationServiceServer.IsAuthorized(PlayerName)) then
&#9;&#9;&#9;-- print(&quot;QAC - Attempting to execute&quot;)
&#9;&#9;&#9;DidExecute, CommandExecuted = CommandSystem:executeCommandFromString(Message, Player)
&#9;&#9;-- else
&#9;&#9;-- &#9;print(&quot;QAC - Player not authorized to execute commands.&quot;)
&#9;&#9;end
&#9;end)
&#9;if Success then
&#9;&#9;if DidExecute and QACSettings.CommandsAreInvisibleOnPseudoChat then
&#9;&#9;&#9;PseudoChatManagerServer.AdminOutput(PlayerName .. &quot; - &apos;&quot; .. CommandExecuted.name ..&quot;&apos; : \&quot;&quot; .. Message ..&quot;\&quot;&quot;);
&#9;&#9;&#9;return true -- Don&apos;t count it as a chat!
&#9;&#9;else
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;else
&#9;&#9;PseudoChatManagerServer.AdminOutput(&quot;Error : &quot; .. Error)
&#9;&#9;return false
&#9;end
end)

print(&quot;QAC loaded with &quot;..CommandSystem:getNumberOfCommands()..&quot; command(s) and &quot;..CommandSystem:getNumberOfAlias()..&quot; aliases&quot;);

return NevermoreCommands;</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="Backpack" referent="RBX57">
				<Properties>
					<string name="Name">Camera</string>
				</Properties>
				<Item class="ModuleScript" referent="RBX58">
					<Properties>
						<string name="Name">CameraPlus</string>
						<ProtectedString name="Source">local ReplicatedStorage  = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine    = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary  = NevermoreEngine.LoadLibrary

local Easing = LoadCustomLibrary(&quot;Easing&quot;)
local qCFrame = LoadCustomLibrary(&quot;qCFrame&quot;)

--- Modified by Quenty
-- Removed metatable protection (Errored). Modified to have override. Modified to use qCFrame&apos;s better intepolation for CFrame
-- added callback to tweening
-- Slight changes to insure no errors
-- Other things

--[[
&#9;
&#9;
&#9;Camera Plus
&#9;http://sleitnick.github.io/CameraPlus/
&#9;
&#9;&#9;Version 1.0.7
&#9;&#9;March 25, 2014
&#9;&#9;Created by Crazyman32
&#9;&#9;
&#9;&#9;Release:&#9;April 3, 2014&#9;&#9;[v.1.0.5]
&#9;&#9;Update:&#9;&#9;APril 17, 2014&#9;&#9;[v.1.0.7]
&#9;&#9;
&#9;
&#9;Camera Plus is an API wrapper for the default Camera
&#9;object in ROBLOX to give additional support for
&#9;doing tween animations with the Workspace.CurrentCamera.
&#9;
&#9;I made this API because I got tired of always writing
&#9;custom camera cutscene systems for every new game I
&#9;made. It was time to set a standard for my code that
&#9;was unified! I had a lot of fun putting this together
&#9;and am happy to share it with you all. I hope to see
&#9;awesome camera cutscene animations spawn from how you
&#9;guys use this!
&#9;
&#9;----
&#9;This API uses Robert Penner&apos;s easing equations for
&#9;interpolation calculations. The licensing information
&#9;and other necessary credit is provided within the
&#9;&quot;Easing&quot; ModuleScript parented within this ModuleScript.
&#9;----
&#9;
&#9;Contact me on Twitter: @RBX_Crazyman32
&#9;
&#9;
&#9;------------------------------------------------------------------
&#9;
&#9;HOW TO USE
&#9;
&#9;
&#9;Please refer to my API Reference for CameraPlus:
&#9;
&#9;
&#9;&#9;&#9;http://sleitnick.github.io/CameraPlus/
&#9;&#9;&#9;
&#9;
--]]




-----------------------------------------------------
-- Constants

local CFRAME = CFrame.new

local CAMTYPE_SCRIPTABLE = Enum.CameraType.Scriptable

local CAMTYPE_CUSTOM = Enum.CameraType.Custom

local CLASS_NAME = &quot;CameraPlus&quot;

-----------------------------------------------------



-- local CameraPlus = {}
local API = {}
-- local MT = {}

CameraPlus = API

local function ReadOnly(tbl)
&#9;local t = {}
&#9;local mt = {}
&#9;mt.__metatable = true
&#9;mt.__index = tbl
&#9;mt.__newindex = function()
&#9;&#9;error(&quot;Cannot add to read-only table&quot;, 0)
&#9;end
&#9;setmetatable(t, mt)
&#9;return t
end


local function CFrameToPosAndFocus(cf, lookDistance)
&#9;local pos = cf.p
&#9;local foc = (pos + (cf.lookVector * (type(lookDistance) == &quot;number&quot; and lookDistance or 10)))
&#9;return pos, foc
end


local RenderWait do
&#9;local rs = game:GetService(&quot;RunService&quot;).RenderStepped
&#9;function RenderWait()
&#9;&#9;rs:wait()
&#9;end
end

local TweenNatures = {}
local function Tween(easingFunc, duration, callbackFunc, TweenType)
&#9;--- Left for flexible reasons, so CameraPlus may be used for any sort of tweening.

&#9;if TweenType then -- Override.
&#9;&#9;local LocalTweenId = TweenNatures[TweenType] and TweenNatures[TweenType] + 1 or 0
&#9;&#9;TweenNatures[TweenType] = LocalTweenId

&#9;&#9;local tick = tick
&#9;&#9;local start = tick()
&#9;&#9;local dur = 0
&#9;&#9;local ratio = 0
&#9;&#9;local RW = RenderWait
&#9;&#9;while dur &lt; duration and TweenNatures[TweenType] == LocalTweenId do
&#9;&#9;&#9;ratio = easingFunc(dur, 0, 1, duration)
&#9;&#9;&#9;dur = (tick() - start)
&#9;&#9;&#9;callbackFunc(ratio)
&#9;&#9;&#9;RW()
&#9;&#9;end
&#9;&#9;if TweenNatures[TweenType] == LocalTweenId then
&#9;&#9;&#9;callbackFunc(1)
&#9;&#9;end
&#9;else
&#9;&#9;local tick = tick
&#9;&#9;local start = tick()
&#9;&#9;local dur = 0
&#9;&#9;local ratio = 0
&#9;&#9;local RW = RenderWait
&#9;&#9;while (dur &lt; duration) do
&#9;&#9;&#9;ratio = easingFunc(dur, 0, 1, duration)
&#9;&#9;&#9;dur = (tick() - start)
&#9;&#9;&#9;callbackFunc(ratio)
&#9;&#9;&#9;RW()
&#9;&#9;end
&#9;&#9;callbackFunc(1)
&#9;end
end
API.GenericTween = Tween

local function StopTween(TweenType)
&#9;TweenNatures[TweenType] = TweenNatures[TweenType] and TweenNatures[TweenType] + 1 or 0
end
API.StopTween = StopTween

------------------------------------------------------------------------------------------------------------------------------
-- API:


-- local camera = game.Workspace.CurrentCamera
local lookAt = nil



API.Ease = (function()
&#9;--local Easing = require(script.Easing)
&#9;local In, Out, InOut = {}, {}, {}
&#9;for name,func in pairs(Easing) do&#9;-- &quot;Parse&quot; out the easing functions:
&#9;&#9;if (name == &quot;linear&quot;) then
&#9;&#9;&#9;In[&quot;Linear&quot;] = func
&#9;&#9;&#9;Out[&quot;Linear&quot;] = func
&#9;&#9;&#9;InOut[&quot;Linear&quot;] = func
&#9;&#9;else
&#9;&#9;&#9;local t,n = name:match(&quot;^(inOut)(.+)&quot;)
&#9;&#9;&#9;if (not t or not n) then t,n = name:match(&quot;^(in)(.+)&quot;) end
&#9;&#9;&#9;if (not t or not n) then t,n = name:match(&quot;^(out)(.+)&quot;) end
&#9;&#9;&#9;if (n) then
&#9;&#9;&#9;&#9;n = (n:sub(1, 1):upper() .. n:sub(2):lower())
&#9;&#9;&#9;end
&#9;&#9;&#9;if (t == &quot;inOut&quot;) then
&#9;&#9;&#9;&#9;InOut[n] = func
&#9;&#9;&#9;elseif (t == &quot;in&quot;) then
&#9;&#9;&#9;&#9;In[n] = func
&#9;&#9;&#9;elseif (t == &quot;out&quot;) then
&#9;&#9;&#9;&#9;Out[n] = func
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return ReadOnly {
&#9;&#9;In = ReadOnly(In);
&#9;&#9;Out = ReadOnly(Out);
&#9;&#9;InOut = ReadOnly(InOut);
&#9;}
end)();


-- Set the camera&apos;s position
function API:SetPosition(position)
&#9;
&#9;if (Workspace.CurrentCamera.CameraType == CAMTYPE_SCRIPTABLE) then
&#9;&#9;if (not lookAt) then
&#9;&#9;&#9;lookAt = (Workspace.CurrentCamera.CoordinateFrame.p + (Workspace.CurrentCamera.CoordinateFrame.lookVector * 5))
&#9;&#9;end
&#9;&#9;Workspace.CurrentCamera.CoordinateFrame = CFRAME(position, lookAt)
&#9;else
&#9;&#9;if (not lookAt) then
&#9;&#9;&#9;lookAt = Workspace.CurrentCamera.Focus.p
&#9;&#9;end
&#9;&#9;Workspace.CurrentCamera.CoordinateFrame = CFRAME(position)
&#9;&#9;Workspace.CurrentCamera.Focus = CFRAME(lookAt)
&#9;end
&#9;
end



-- Get the camera&apos;s position
function API:GetPosition()
&#9;return Workspace.CurrentCamera.CoordinateFrame.p
end



-- Set what the camera is looking at
function API:SetFocus(focus)
&#9;lookAt = focus
&#9;self:SetPosition(self:GetPosition())
end




-- Set the camera&apos;s position and what it is looking at
function API:SetView(position, focus)
&#9;lookAt = focus
&#9;self:SetPosition(position)
end



-- Set the camera&apos;s FieldOfView
function API:SetFOV(fov)
&#9;Workspace.CurrentCamera.FieldOfView = fov
end



-- Get the camera&apos;s FieldOfView
function API:GetFOV()
&#9;return Workspace.CurrentCamera.FieldOfView
end



-- Increment the camera&apos;s current FieldOfView
function API:IncrementFOV(deltaFov)
&#9;Workspace.CurrentCamera.FieldOfView = (Workspace.CurrentCamera.FieldOfView + deltaFov)
end



-- Set the camera&apos;s roll
-- OVERRIDE Camera:SetRoll
function API:SetRoll(roll)
&#9;camera:SetRoll(roll)
end



-- Get the camera&apos;s roll
-- OVERRIDE Camera:GetRoll
function API:GetRoll()
&#9;return camera:GetRoll()
end



-- Increment the camera&apos;s current roll
function API:IncrementRoll(deltaRoll)
&#9;camera:SetRoll(camera:GetRoll() + deltaRoll)
end



-- Tween the camera from one position to the next
function API:Tween(cframeStart, cframeEnd, duration, easingFunc, UserCallback)
&#9;Workspace.CurrentCamera.CameraType = CAMTYPE_SCRIPTABLE
&#9;-- local startPos, startLook = CFrameToPosAndFocus(cframeStart)
&#9;-- local endPos, endLook = CFrameToPosAndFocus(cframeEnd)
&#9;-- local curPos, curLook = startPos, startLook
&#9;if cframeStart ~= cframeEnd then
&#9;&#9;local Callback
&#9;&#9;if UserCallback then
&#9;&#9;&#9;function Callback(ratio)
&#9;&#9;&#9;&#9;Workspace.CurrentCamera.CoordinateFrame = qCFrame.SlerpCFrame(cframeStart, cframeEnd, ratio)
&#9;&#9;&#9;&#9;UserCallback(ratio)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;function Callback(ratio)
&#9;&#9;&#9;&#9;Workspace.CurrentCamera.CoordinateFrame = qCFrame.SlerpCFrame(cframeStart, cframeEnd, ratio)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;Tween(easingFunc, duration, Callback, &quot;CoordinateFrame&quot;)
&#9;else
&#9;&#9;print(&quot;[CameraPlus] - Start is end&quot;)
&#9;end
end



-- Tween the camera to the position from the current position
function API:TweenTo(cframeEnd, duration, easingFunc, callback)
&#9;Workspace.CurrentCamera.CameraType = CAMTYPE_SCRIPTABLE
&#9;self:Tween(Workspace.CurrentCamera.CoordinateFrame, cframeEnd, duration, easingFunc, callback)
end



-- Tween the camera from the current position back to the player
function API:TweenToPlayer(duration, easingFunc, callback)
&#9;local player = game.Players.LocalPlayer
&#9;local humanoid, walkSpeed = player.Character:FindFirstChild(&quot;Humanoid&quot;)
&#9;if (humanoid) then
&#9;&#9;walkSpeed = humanoid.WalkSpeed
&#9;&#9;humanoid.WalkSpeed = 0
&#9;end
&#9;local head = player.Character.Head
&#9;local cframeEnd = CFrame.new((head.Position - (head.CFrame.lookVector * 10)), head.Position)
&#9;self:TweenTo(cframeEnd, duration, easingFunc, callback)
&#9;
&#9;Workspace.CurrentCamera.CameraType = CAMTYPE_CUSTOM
&#9;Workspace.CurrentCamera.CameraSubject = player.Character
&#9;if (humanoid) then
&#9;&#9;humanoid.WalkSpeed = walkSpeed
&#9;end
end



-- Tween FieldOfView
function API:TweenFOV(startFov, endFov, duration, easingFunc, override)
&#9;local fov = startFov
&#9;local diffFov = (endFov - startFov)
&#9;local function Callback(ratio)
&#9;&#9;fov = (startFov + (diffFov * ratio))
&#9;&#9;Workspace.CurrentCamera.FieldOfView = fov
&#9;end
&#9;Tween(easingFunc, duration, Callback, &quot;FOV&quot;)
end



-- Tween to FieldOfView from current FieldOfView
function API:TweenToFOV(endFov, duration, easingFunc, override)
&#9;self:TweenFOV(Workspace.CurrentCamera.FieldOfView, endFov, duration, easingFunc, override)
end



-- Tween the camera&apos;s roll
function API:TweenRoll(startRoll, endRoll, duration, easingFunc, override)
&#9;Workspace.CurrentCamera.CameraType = CAMTYPE_SCRIPTABLE
&#9;local roll = startRoll
&#9;local diffRoll = (endRoll - startRoll)
&#9;local function Callback(ratio)
&#9;&#9;roll = (startRoll + (diffRoll * ratio))
&#9;&#9;camera:SetRoll(roll)
&#9;end
&#9;Tween(easingFunc, duration, Callback, &quot;Roll&quot;)
end



-- Tween the camera&apos;s roll from the current roll
function API:TweenToRoll(endRoll, duration, easingFunc, override)
&#9;self:TweenRoll(camera:GetRoll(), endRoll, duration, easingFunc, override)
end



-- Tween all parts of the camera
function API:TweenAll(cframeStart, cframeEnd, fovStart, fovEnd, rollStart, rollEnd, duration, easingFunc)
&#9;--- DOES NOT SUPPORT OVERRIDE

&#9;Workspace.CurrentCamera.CameraType = CAMTYPE_SCRIPTABLE
&#9;local startPos, startLook = CFrameToPosAndFocus(cframeStart)
&#9;local endPos, endLook = CFrameToPosAndFocus(cframeEnd)
&#9;local pos, look = startPos, startLook
&#9;local fov, fovDiff = fovStart, (fovEnd - fovStart)
&#9;local roll, rollDiff = rollStart, (rollEnd - rollStart)
&#9;local function Callback(ratio)
&#9;&#9;pos = startPos:lerp(endPos, ratio)
&#9;&#9;look = startLook:lerp(endLook, ratio)
&#9;&#9;fov = (fovStart + (fovDiff * ratio))
&#9;&#9;roll = (rollStart + (rollDiff * ratio))
&#9;&#9;Workspace.CurrentCamera.CoordinateFrame = CFRAME(pos, look)
&#9;&#9;Workspace.CurrentCamera.FieldOfView = fov
&#9;&#9;camera:SetRoll(roll)
&#9;end

&#9;Tween(easingFunc, duration, Callback)
end



-- Tween all parts of the camera from the current camera properties
function API:TweenToAll(cframeEnd, fovEnd, rollEnd, duration, easingFunc)
&#9;--- DOES NOT SUPPORT OVERRIDE

&#9;Workspace.CurrentCamera.CameraType = CAMTYPE_SCRIPTABLE
&#9;self:TweenAll(
&#9;&#9;Workspace.CurrentCamera.CoordinateFrame, &#9;cframeEnd,
&#9;&#9;Workspace.CurrentCamera.FieldOfView,&#9;&#9;&#9;fovEnd,
&#9;&#9;camera:GetRoll(),&#9;&#9;&#9;rollEnd,
&#9;&#9;duration,
&#9;&#9;easingFunc
&#9;)
end



--[[
-- OVERRIDE Camera:Interpolate
function API:Interpolate(endPos, endFocus, duration)
&#9;self:TweenTo(CFRAME(endPos, endFocus), duration, self.Ease.InOut.Sine)
end--]]


--[[
-- OVERRIDE Camera:IsA
function API:IsA(className)
&#9;return (className == CLASS_NAME or camera:IsA(className))
end--]]



------------------------------------------------------------------------------------------------------------------------------
-- MT:

-- Protects the API and hooks it onto the camera object, therefore
-- the API essentially appears to be an extention to the camera
-- object itself when used.

--[==[
MT.__metatable = true
MT.__index = function(t, k)
&#9;local value = (API[k] or camera[k])
&#9;return value
end
--[[]]
MT.__newindex = function(t, k, v)
&#9;if (API[k]) then
&#9;&#9;error(&quot;Cannot change CameraPlus API&quot;, 0)
&#9;else
&#9;&#9;camera[k] = v
&#9;end
end--]]
MT.__eq = function(t, other)
&#9;return (t == other or camera == other)
end
setmetatable(CameraPlus, MT)--]==]

------------------------------------------------------------------------------------------------------------------------------

return CameraPlus</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX59">
					<Properties>
						<string name="Name">Easing</string>
						<ProtectedString name="Source">--[[
&#9;NOTE FROM CRAZYMAN32:
&#9;
&#9;The below code was taken from a GitHub project (https://github.com/EmmanuelOga/easing).
&#9;I do not take credit for any of the code. It was derived from Robert Penner&apos;s easing equations.
&#9;
&#9;The only change made to the code was indentation (replaced space indentations with tabs through Sublime Text)
--]]






--
-- Adapted from
-- Tweener&apos;s easing functions (Penner&apos;s Easing Equations)
-- and http://code.google.com/p/tweener/ (jstweener javascript version)
--

--[[
Disclaimer for Robert Penner&apos;s Easing Equations license:

TERMS OF USE - EASING EQUATIONS

Open source under the BSD License.

Copyright &#194;&#169; 2001 Robert Penner
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

&#9;* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
&#9;* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
&#9;* Neither the name of the author nor the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
]]

-- For all easing functions:
-- t = elapsed time
-- b = begin
-- c = change == ending - beginning
-- d = duration (total time)

local pow = math.pow
local sin = math.sin
local cos = math.cos
local pi = math.pi
local sqrt = math.sqrt
local abs = math.abs
local asin  = math.asin

local function linear(t, b, c, d)
&#9;return c * t / d + b
end

local function inQuad(t, b, c, d)
&#9;t = t / d
&#9;return c * pow(t, 2) + b
end

local function outQuad(t, b, c, d)
&#9;t = t / d
&#9;return -c * t * (t - 2) + b
end

local function inOutQuad(t, b, c, d)
&#9;t = t / d * 2
&#9;if t &lt; 1 then
&#9;&#9;return c / 2 * pow(t, 2) + b
&#9;else
&#9;&#9;return -c / 2 * ((t - 1) * (t - 3) - 1) + b
&#9;end
end

local function outInQuad(t, b, c, d)
&#9;if t &lt; d / 2 then
&#9;&#9;return outQuad (t * 2, b, c / 2, d)
&#9;else
&#9;&#9;return inQuad((t * 2) - d, b + c / 2, c / 2, d)
&#9;end
end

local function inCubic (t, b, c, d)
&#9;t = t / d
&#9;return c * pow(t, 3) + b
end

local function outCubic(t, b, c, d)
&#9;t = t / d - 1
&#9;return c * (pow(t, 3) + 1) + b
end

local function inOutCubic(t, b, c, d)
&#9;t = t / d * 2
&#9;if t &lt; 1 then
&#9;&#9;return c / 2 * t * t * t + b
&#9;else
&#9;&#9;t = t - 2
&#9;&#9;return c / 2 * (t * t * t + 2) + b
&#9;end
end

local function outInCubic(t, b, c, d)
&#9;if t &lt; d / 2 then
&#9;&#9;return outCubic(t * 2, b, c / 2, d)
&#9;else
&#9;&#9;return inCubic((t * 2) - d, b + c / 2, c / 2, d)
&#9;end
end

local function inQuart(t, b, c, d)
&#9;t = t / d
&#9;return c * pow(t, 4) + b
end

local function outQuart(t, b, c, d)
&#9;t = t / d - 1
&#9;return -c * (pow(t, 4) - 1) + b
end

local function inOutQuart(t, b, c, d)
&#9;t = t / d * 2
&#9;if t &lt; 1 then
&#9;&#9;return c / 2 * pow(t, 4) + b
&#9;else
&#9;&#9;t = t - 2
&#9;&#9;return -c / 2 * (pow(t, 4) - 2) + b
&#9;end
end

local function outInQuart(t, b, c, d)
&#9;if t &lt; d / 2 then
&#9;&#9;return outQuart(t * 2, b, c / 2, d)
&#9;else
&#9;&#9;return inQuart((t * 2) - d, b + c / 2, c / 2, d)
&#9;end
end

local function inQuint(t, b, c, d)
&#9;t = t / d
&#9;return c * pow(t, 5) + b
end

local function outQuint(t, b, c, d)
&#9;t = t / d - 1
&#9;return c * (pow(t, 5) + 1) + b
end

local function inOutQuint(t, b, c, d)
&#9;t = t / d * 2
&#9;if t &lt; 1 then
&#9;&#9;return c / 2 * pow(t, 5) + b
&#9;else
&#9;&#9;t = t - 2
&#9;&#9;return c / 2 * (pow(t, 5) + 2) + b
&#9;end
end

local function outInQuint(t, b, c, d)
&#9;if t &lt; d / 2 then
&#9;&#9;return outQuint(t * 2, b, c / 2, d)
&#9;else
&#9;&#9;return inQuint((t * 2) - d, b + c / 2, c / 2, d)
&#9;end
end

local function inSine(t, b, c, d)
&#9;return -c * cos(t / d * (pi / 2)) + c + b
end

local function outSine(t, b, c, d)
&#9;return c * sin(t / d * (pi / 2)) + b
end

local function inOutSine(t, b, c, d)
&#9;return -c / 2 * (cos(pi * t / d) - 1) + b
end

local function outInSine(t, b, c, d)
&#9;if t &lt; d / 2 then
&#9;&#9;return outSine(t * 2, b, c / 2, d)
&#9;else
&#9;&#9;return inSine((t * 2) -d, b + c / 2, c / 2, d)
&#9;end
end

local function inExpo(t, b, c, d)
&#9;if t == 0 then
&#9;&#9;return b
&#9;else
&#9;&#9;return c * pow(2, 10 * (t / d - 1)) + b - c * 0.001
&#9;end
end

local function outExpo(t, b, c, d)
&#9;if t == d then
&#9;&#9;return b + c
&#9;else
&#9;&#9;return c * 1.001 * (-pow(2, -10 * t / d) + 1) + b
&#9;end
end

local function inOutExpo(t, b, c, d)
&#9;if t == 0 then return b end
&#9;if t == d then return b + c end
&#9;t = t / d * 2
&#9;if t &lt; 1 then
&#9;&#9;return c / 2 * pow(2, 10 * (t - 1)) + b - c * 0.0005
&#9;else
&#9;&#9;t = t - 1
&#9;&#9;return c / 2 * 1.0005 * (-pow(2, -10 * t) + 2) + b
&#9;end
end

local function outInExpo(t, b, c, d)
&#9;if t &lt; d / 2 then
&#9;&#9;return outExpo(t * 2, b, c / 2, d)
&#9;else
&#9;&#9;return inExpo((t * 2) - d, b + c / 2, c / 2, d)
&#9;end
end

local function inCirc(t, b, c, d)
&#9;t = t / d
&#9;return(-c * (sqrt(1 - pow(t, 2)) - 1) + b)
end

local function outCirc(t, b, c, d)
&#9;t = t / d - 1
&#9;return(c * sqrt(1 - pow(t, 2)) + b)
end

local function inOutCirc(t, b, c, d)
&#9;t = t / d * 2
&#9;if t &lt; 1 then
&#9;&#9;return -c / 2 * (sqrt(1 - t * t) - 1) + b
&#9;else
&#9;&#9;t = t - 2
&#9;&#9;return c / 2 * (sqrt(1 - t * t) + 1) + b
&#9;end
end

local function outInCirc(t, b, c, d)
&#9;if t &lt; d / 2 then
&#9;&#9;return outCirc(t * 2, b, c / 2, d)
&#9;else
&#9;&#9;return inCirc((t * 2) - d, b + c / 2, c / 2, d)
&#9;end
end

local function inElastic(t, b, c, d, a, p)
&#9;if t == 0 then return b end

&#9;t = t / d

&#9;if t == 1  then return b + c end

&#9;if not p then p = d * 0.3 end

&#9;local s

&#9;if not a or a &lt; abs(c) then
&#9;&#9;a = c
&#9;&#9;s = p / 4
&#9;else
&#9;&#9;s = p / (2 * pi) * asin(c/a)
&#9;end

&#9;t = t - 1

&#9;return -(a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b
end

-- a: amplitud
-- p: period
local function outElastic(t, b, c, d, a, p)
&#9;if t == 0 then return b end

&#9;t = t / d

&#9;if t == 1 then return b + c end

&#9;if not p then p = d * 0.3 end

&#9;local s

&#9;if not a or a &lt; abs(c) then
&#9;&#9;a = c
&#9;&#9;s = p / 4
&#9;else
&#9;&#9;s = p / (2 * pi) * asin(c/a)
&#9;end

&#9;return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p) + c + b
end

-- p = period
-- a = amplitud
local function inOutElastic(t, b, c, d, a, p)
&#9;if t == 0 then return b end

&#9;t = t / d * 2

&#9;if t == 2 then return b + c end

&#9;if not p then p = d * (0.3 * 1.5) end
&#9;if not a then a = 0 end

&#9;if not a or a &lt; abs(c) then
&#9;&#9;a = c
&#9;&#9;s = p / 4
&#9;else
&#9;&#9;s = p / (2 * pi) * asin(c / a)
&#9;end

&#9;if t &lt; 1 then
&#9;&#9;t = t - 1
&#9;&#9;return -0.5 * (a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b
&#9;else
&#9;&#9;t = t - 1
&#9;&#9;return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p ) * 0.5 + c + b
&#9;end
end

-- a: amplitud
-- p: period
local function outInElastic(t, b, c, d, a, p)
&#9;if t &lt; d / 2 then
&#9;&#9;return outElastic(t * 2, b, c / 2, d, a, p)
&#9;else
&#9;&#9;return inElastic((t * 2) - d, b + c / 2, c / 2, d, a, p)
&#9;end
end

local function inBack(t, b, c, d, s)
&#9;if not s then s = 1.70158 end
&#9;t = t / d
&#9;return c * t * t * ((s + 1) * t - s) + b
end

local function outBack(t, b, c, d, s)
&#9;if not s then s = 1.70158 end
&#9;t = t / d - 1
&#9;return c * (t * t * ((s + 1) * t + s) + 1) + b
end

local function inOutBack(t, b, c, d, s)
&#9;if not s then s = 1.70158 end
&#9;s = s * 1.525
&#9;t = t / d * 2
&#9;if t &lt; 1 then
&#9;&#9;return c / 2 * (t * t * ((s + 1) * t - s)) + b
&#9;else
&#9;&#9;t = t - 2
&#9;&#9;return c / 2 * (t * t * ((s + 1) * t + s) + 2) + b
&#9;end
end

local function outInBack(t, b, c, d, s)
&#9;if t &lt; d / 2 then
&#9;&#9;return outBack(t * 2, b, c / 2, d, s)
&#9;else
&#9;&#9;return inBack((t * 2) - d, b + c / 2, c / 2, d, s)
&#9;end
end

local function outBounce(t, b, c, d)
&#9;t = t / d
&#9;if t &lt; 1 / 2.75 then
&#9;&#9;return c * (7.5625 * t * t) + b
&#9;elseif t &lt; 2 / 2.75 then
&#9;&#9;t = t - (1.5 / 2.75)
&#9;&#9;return c * (7.5625 * t * t + 0.75) + b
&#9;elseif t &lt; 2.5 / 2.75 then
&#9;&#9;t = t - (2.25 / 2.75)
&#9;&#9;return c * (7.5625 * t * t + 0.9375) + b
&#9;else
&#9;&#9;t = t - (2.625 / 2.75)
&#9;&#9;return c * (7.5625 * t * t + 0.984375) + b
&#9;end
end

local function inBounce(t, b, c, d)
&#9;return c - outBounce(d - t, 0, c, d) + b
end

local function inOutBounce(t, b, c, d)
&#9;if t &lt; d / 2 then
&#9;&#9;return inBounce(t * 2, 0, c, d) * 0.5 + b
&#9;else
&#9;&#9;return outBounce(t * 2 - d, 0, c, d) * 0.5 + c * .5 + b
&#9;end
end

local function outInBounce(t, b, c, d)
&#9;if t &lt; d / 2 then
&#9;&#9;return outBounce(t * 2, b, c / 2, d)
&#9;else
&#9;&#9;return inBounce((t * 2) - d, b + c / 2, c / 2, d)
&#9;end
end

return {
&#9;linear = linear,
&#9;inQuad = inQuad,
&#9;outQuad = outQuad,
&#9;inOutQuad = inOutQuad,
&#9;outInQuad = outInQuad,
&#9;inCubic  = inCubic ,
&#9;outCubic = outCubic,
&#9;inOutCubic = inOutCubic,
&#9;outInCubic = outInCubic,
&#9;inQuart = inQuart,
&#9;outQuart = outQuart,
&#9;inOutQuart = inOutQuart,
&#9;outInQuart = outInQuart,
&#9;inQuint = inQuint,
&#9;outQuint = outQuint,
&#9;inOutQuint = inOutQuint,
&#9;outInQuint = outInQuint,
&#9;inSine = inSine,
&#9;outSine = outSine,
&#9;inOutSine = inOutSine,
&#9;outInSine = outInSine,
&#9;inExpo = inExpo,
&#9;outExpo = outExpo,
&#9;inOutExpo = inOutExpo,
&#9;outInExpo = outInExpo,
&#9;inCirc = inCirc,
&#9;outCirc = outCirc,
&#9;inOutCirc = inOutCirc,
&#9;outInCirc = outInCirc,
&#9;inElastic = inElastic,
&#9;outElastic = outElastic,
&#9;inOutElastic = inOutElastic,
&#9;outInElastic = outInElastic,
&#9;inBack = inBack,
&#9;outBack = outBack,
&#9;inOutBack = inOutBack,
&#9;outInBack = outInBack,
&#9;inBounce = inBounce,
&#9;outBounce = outBounce,
&#9;inOutBounce = inOutBounce,
&#9;outInBounce = outInBounce,
}</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX60">
					<Properties>
						<string name="Name">qCamera</string>
						<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)
local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&apos;qSystems&apos;)
local qCFrame           = LoadCustomLibrary(&apos;qCFrame&apos;)

qSystems:Import(getfenv(0))

local lib = {}

local function PointCamera(CoordinateFrame, Focus)
&#9;Workspace.CurrentCamera.Focus = Focus
&#9;Workspace.CurrentCamera.CoordinateFrame = CFrame.new(CoordinateFrame.p, Focus.p)
end
lib.PointCamera = PointCamera
lib.pointCamera = PointCamera

local function SetCurrentCameraToScriptable()
&#9;--[[local CoordinateFrame, Focus = Workspace.CurrentCamera.CoordinateFrame.p, Workspace.CurrentCamera.Focus
&#9;Workspace.CurrentCamera:Destroy()
&#9;wait(0)
&#9;while not Workspace.CurrentCamera do wait(0) end
&#9;Workspace.CurrentCamera.CameraType = &quot;Scriptable&quot;
&#9;Workspace.CurrentCamera.CoordinateFrame = CFrame.new(CoordinateFrame, Focus.p)
&#9;Workspace.CurrentCamera.Focus = Focus
&#9;return CoordinateFrame, Focus--]]

&#9;Workspace.CurrentCamera.CameraType = &quot;Scriptable&quot;;
end
lib.SetCurrentCameraToScriptable = SetCurrentCameraToScriptable
lib.setCurrentCameraToScriptable = SetCurrentCameraToScriptable
lib.SetCameraToScriptable = SetCurrentCameraToScriptable
lib.setCameraToScriptable = SetCurrentCameraToScriptable


local function ShakeCamera(c0,f0,intensity,durration,opposite)
&#9;local t = time()
&#9;local i = (intensity/2)
&#9;local i2 = i
&#9;while ((time()-t) &lt; durration) do
&#9;&#9;if (skip) then break end
&#9;&#9;if (opposite) then
&#9;&#9;&#9;i = (i2*((time()-t)/durration))
&#9;&#9;else
&#9;&#9;&#9;i = (i*(1-((time()-t)/durration)))
&#9;&#9;end
&#9;&#9;Workspace.CurrentCamera.CoordinateFrame = (c0*CFrame.new((-i+(math.random()*i)),(-i+(math.random()*i)),(-i+(math.random()*i))))
&#9;&#9;Workspace.CurrentCamera.Focus = (f0*CFrame.new((-i+(math.random()*i)),(-i+(math.random()*i)),(-i+(math.random()*i))))
&#9;&#9;wait(0)
&#9;end
&#9;Workspace.CurrentCamera.CoordinateFrame = c0
&#9;Workspace.CurrentCamera.Focus = f0
end

lib.ShakeCamera = ShakeCamera
lib.shakeCamera = ShakeCamera

local function SetPlayerControl()
&#9;if Players.LocalPlayer.Character then
&#9;&#9;Workspace.CurrentCamera.CameraSubject = Players.LocalPlayer.Character:FindFirstChild(&quot;Humanoid&quot;)
&#9;end
&#9;Workspace.CurrentCamera.CameraType = &quot;Custom&quot;
end
lib.SetPlayerControl = SetPlayerControl
lib.setPlayerControl = SetPlayerControl


local TweenCameraOverideId = 0
local OpeatingTweenCamera = false;

local function TweenCamera(CoordinateFrameTarget, FocusTarget, TimeToTween, Override, RollTarget, FieldOfViewTarget)
&#9;SetCurrentCameraToScriptable()
&#9;Spawn(function()
&#9;&#9;if Override and OpeatingTweenCamera then
&#9;&#9;&#9;--print(&quot;Camera Tween: Overriding operation&quot;);
&#9;&#9;&#9;TweenCameraOverideId = TweenCameraOverideId+1;
&#9;&#9;elseif OpeatingTweenCamera then
&#9;&#9;&#9;--print(&quot;Camera Tween: Did not override, old operation is continueing&quot;);
&#9;&#9;&#9;return false;
&#9;&#9;end
&#9;&#9;OpeatingTweenCamera = true;

&#9;&#9;FieldOfViewTarget = FieldOfViewTarget or Workspace.CurrentCamera.FieldOfView
&#9;&#9;RollTarget = RollTarget or Workspace.CurrentCamera:GetRoll()

&#9;&#9;local CurrentNumber = TweenCameraOverideId;
&#9;&#9;local OriginalRoll = Workspace.CurrentCamera:GetRoll()
&#9;&#9;local OriginalFieldOfView = Workspace.CurrentCamera.FieldOfView
&#9;&#9;local CoordinateFocusStart = Workspace.CurrentCamera.Focus.p
&#9;&#9;local CoordinateFrameStart = CFrame.new(Workspace.CurrentCamera.CoordinateFrame.p, CoordinateFocusStart)
&#9;&#9;local CoordinateFrameFinish = CFrame.new(CoordinateFrameTarget, FocusTarget)

&#9;&#9;local RepetitionIntervol = (1/(TimeToTween/wait(0)))
&#9;&#9;local Repetitions

&#9;&#9;for Index = 0, 1, RepetitionIntervol do
&#9;&#9;&#9;local SmoothIndex = math.sin((Index - 0.5) * math.pi)/2 + 0.5
&#9;&#9;&#9;local Focus = CoordinateFocusStart:lerp(FocusTarget, SmoothIndex)
&#9;&#9;&#9;Workspace.CurrentCamera.CoordinateFrame = qCFrame.SlerpCFrame(CoordinateFrameStart, CoordinateFrameFinish, SmoothIndex)
&#9;&#9;&#9;Workspace.CurrentCamera.Focus = CFrame.new(Focus)
&#9;&#9;&#9;Workspace.CurrentCamera:SetRoll(OriginalRoll + ((RollTarget - OriginalRoll) * SmoothIndex))
&#9;&#9;&#9;Workspace.CurrentCamera.FieldOfView = OriginalFieldOfView + ((FieldOfViewTarget - OriginalFieldOfView)) * SmoothIndex
&#9;&#9;&#9;wait(0)

&#9;&#9;&#9;if TweenCameraOverideId ~= CurrentNumber then
&#9;&#9;&#9;&#9;return false;
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;OpeatingTweenCamera = false;
&#9;&#9;PointCamera(CFrame.new(CoordinateFrameTarget), CFrame.new(FocusTarget))
&#9;&#9;Workspace.CurrentCamera:SetRoll(RollTarget)
&#9;&#9;Workspace.CurrentCamera.FieldOfView = FieldOfViewTarget
&#9;&#9;return true;
&#9;end)
end
lib.TweenCamera = TweenCamera
lib.tweenCamera = TweenCamera

local AdvanceRaycast = qCFrame.AdvanceRaycast

local MakeCameraSystem = Class(function(CameraSystem, Player)
&#9;local CurrentState
&#9;local States = {}

&#9;local IgnoreList = {}
&#9;setmetatable(IgnoreList, {__mode = &quot;k&quot;})

&#9;local function SetCurrentState(Name)
&#9;&#9;if States[Name] then
&#9;&#9;&#9;if CurrentState.OnStop then
&#9;&#9;&#9;&#9;CurrentState:OnStop(Player, Mouse, Camera)
&#9;&#9;&#9;end
&#9;&#9;&#9;CurrentState = States[Name]
&#9;&#9;&#9;if CurrentState.OnStart then
&#9;&#9;&#9;&#9;CurrentState:OnStart(Player, Mouse, Camera)
&#9;&#9;&#9;end
&#9;&#9;elseif Name == &quot;Custom&quot; then
&#9;&#9;&#9;CurrentState = nil
&#9;&#9;else
&#9;&#9;&#9;error(&quot;State &quot;..Name..&quot; does not exist&quot;)
&#9;&#9;end
&#9;end

&#9;do
&#9;&#9;local SquareRootOf3 = math.sqrt(3)

&#9;&#9;States.TopDown = {
&#9;&#9;&#9;Configuration = {
&#9;&#9;&#9;&#9;RotationGoal = 90;
&#9;&#9;&#9;&#9;RotationCurrent = 90;
&#9;&#9;&#9;&#9;Zoom = 10;
&#9;&#9;&#9;&#9;CurrentCoordinateFrame = Workspace.CurrentCamera.CoordinateFrame.p
&#9;&#9;&#9;};
&#9;&#9;&#9;RaycastIgnoreList = {Character, Camera};
&#9;&#9;&#9;Step = function(self, Player, Mouse, Camera)
&#9;&#9;&#9;&#9;if CheckCharacter(Player) then
&#9;&#9;&#9;&#9;&#9;local Configuration = self.Configuration
&#9;&#9;&#9;&#9;&#9;local Tilt = RoundNumber(Configuration.RotationGoal, 90)/90%4
&#9;&#9;&#9;&#9;&#9;local ZoomLevel = Configuration.Zoom + 10

&#9;&#9;&#9;&#9;&#9;Configuration.RotationCurrent = Configuration.RotationCurrent - (RotationCurrent - RotationGoal) * 0.2
&#9;&#9;&#9;&#9;&#9;local Inverse     = Configuration.RotationGoal &lt; 180 and 180 or -180
&#9;&#9;&#9;&#9;&#9;local PositionOne = Player.Character.Head.Position * Vector3.new(1, 0, 1);
&#9;&#9;&#9;&#9;&#9;local PositionTwo = PositionOne + Vector3.new((Mouse.X/Mouse.ViewSizeX - 0.5) * (Inverse/90), 0, (Mouse.Y/Mouse.ViewSizeY - 0.5) * (Inverse/90)) * Vector3.new(30, 0, 30)
&#9;&#9;&#9;&#9;&#9;local Distance    = -math.min((PositionOne - PositionTwo).magnitude, 80)/2
&#9;&#9;&#9;&#9;&#9;local MidPoint    = CFrame.new(PositionOne, PositionTwo) * CFrame.new(Tilt % 2 == 1 and Distance or 0, 0, Tilt % 2 == 0 and Distance or 0)
&#9;&#9;&#9;&#9;&#9;local CameraGoal  = MidPoint.p + Vector3.new(0, Player.Character.head.Position.Y + SquareRootOf3 * ZoomLevel * 0.5)
&#9;&#9;&#9;&#9;&#9;if Tilt == 1 then
&#9;&#9;&#9;&#9;&#9;&#9;CameraGoal = CameraGoal + Vector3.new(ZoomLevel * 0.5, 0, 0)
&#9;&#9;&#9;&#9;&#9;elseif Tilt == 3 then
&#9;&#9;&#9;&#9;&#9;&#9;CameraGoal = CameraGoal + Vector3.new(-ZoomLevel * 0.5, 0, 0)
&#9;&#9;&#9;&#9;&#9;elseif Tilt == 0 then
&#9;&#9;&#9;&#9;&#9;&#9;CameraGoal = CameraGoal + Vector3.new(0, 0, ZoomLevel * 0.5)
&#9;&#9;&#9;&#9;&#9;elseif Tilt == 2 then
&#9;&#9;&#9;&#9;&#9;&#9;CameraGoal = CameraGoal + Vector3.new(0, 0, -ZoomLevel * 0.5)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;local RayDestination = (CameraGoal - Character.Head.Position)
&#9;&#9;&#9;&#9;&#9;local Checker = Ray.new(Character.Head.Position, RayDestination)
&#9;&#9;&#9;&#9;&#9;local Hit, Position = AdvanceRaycast(Ray, self.RaycastIgnoreList, true, true)
&#9;&#9;&#9;&#9;&#9;if Hit and Position then
&#9;&#9;&#9;&#9;&#9;&#9;CameraGoal = CameraGoal - (RayDestination.unit * 1)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;Camera.CoordinateFrame = CFrame.new(Configuration.CurrentCoordinateFrame - (Configuration.CurrentCoordinateFrame - CameraGoal) * Vector3.new(0.2, 0.2, 0.2)) * CFrame.Angles(0, math.rad(Configuration.RotationCurrent), 0) * CFrame.Angles(math.rad(-60), 0, 0);
&#9;&#9;&#9;&#9;&#9;Configuration.CurrentCoordinateFrame = Camera.CoordinateFrame.p
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;print(&quot;[CameraSystem] - CharacterCheck failed, resetting to custom system.&quot;)
&#9;&#9;&#9;&#9;&#9;SetCurrentState(&quot;Custom&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;}
&#9;end

&#9;States.FirstPerson = {
&#9;&#9;OnStart = function(Player, Mouse, Camera)
&#9;&#9;&#9;Player.CameraMode = &quot;Classic&quot;;
&#9;&#9;&#9;Player.CameraMode = &quot;LockFirstPerson&quot;;
&#9;&#9;end;
&#9;&#9;OnStop = function(Player, Mouse, Camera)
&#9;&#9;&#9;Player.CameraMode = &quot;LockFirstPerson&quot;;
&#9;&#9;&#9;Player.CameraMode = &quot;Classic&quot;;
&#9;&#9;end;
&#9;}

&#9;CameraSystem.SetCurrentState = SetCurrentState

&#9;local function Step(Mouse)
&#9;&#9;if CurrentState and CurrentState.Step then
&#9;&#9;&#9;local Camera = Workspace.CurrentCamera
&#9;&#9;&#9;local CoordinateFrame, Focus = CurrentState:Step(Player, Mouse, Camera) -- Returns instead of setting directly to enable tweening.
&#9;&#9;&#9;if CoordinateFrame then
&#9;&#9;&#9;&#9;Camera.CoordinateFrame = CoordinateFrame
&#9;&#9;&#9;end
&#9;&#9;&#9;if Focus then
&#9;&#9;&#9;&#9;Camera.Focus = Focus
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;CameraSystem.Step = Step
end)

return lib</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="Backpack" referent="RBX61">
				<Properties>
					<string name="Name">qCFrame</string>
				</Properties>
				<Item class="ModuleScript" referent="RBX62">
					<Properties>
						<string name="Name">CFrameInterpolator</string>
						<ProtectedString name="Source">-- Optimized CFrame interpolator module ~ by Stravant
-- Based off of code by Treyreynolds posted on the Roblox Developer Forum

local fromAxisAngle = CFrame.fromAxisAngle
local components = CFrame.new().components
local inverse = CFrame.new().inverse
local v3 = Vector3.new
local acos = math.acos
local sqrt = math.sqrt
local invroot2 = 1/math.sqrt(2)

return function(c0, c1) -- (CFrame from, CFrame to) -&gt; (float theta, (float fraction -&gt; CFrame between))
&#9;-- The expanded matrix
&#9;local _, _, _, xx, yx, zx, 
&#9;               xy, yy, zy, 
&#9;               xz, yz, zz = components(inverse(c0)*c1)
&#9;
&#9;-- The cos-theta of the axisAngles from 
&#9;local cosTheta = (xx + yy + zz - 1)/2
&#9;
&#9;-- Rotation axis
&#9;local rotationAxis = v3(yz-zy, zx-xz, xy-yx)
&#9;
&#9;-- The position to tween through
&#9;local positionDelta = (c1.p - c0.p)
&#9;&#9;
&#9;-- Theta
&#9;local theta;&#9;&#9;&#9;
&#9;&#9;
&#9;-- Catch degenerate cases
&#9;if cosTheta &gt;= 0.999 then
&#9;&#9;-- Case same rotation, just return an interpolator over the positions
&#9;&#9;return 0, function(t)
&#9;&#9;&#9;return c0 + positionDelta*t
&#9;&#9;end&#9;
&#9;elseif cosTheta &lt;= -0.999 then
&#9;&#9;-- Case exactly opposite rotations, disambiguate
&#9;&#9;theta = math.pi
&#9;&#9;xx = (xx + 1) / 2
&#9;&#9;yy = (yy + 1) / 2
&#9;&#9;zz = (zz + 1) / 2
&#9;&#9;if xx &gt; yy and xx &gt; zz then
&#9;&#9;&#9;if xx &lt; 0.001 then
&#9;&#9;&#9;&#9;rotationAxis = v3(0, invroot2, invroot2)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;local x = sqrt(xx)
&#9;&#9;&#9;&#9;xy = (xy + yx) / 4
&#9;&#9;&#9;&#9;xz = (xz + zx) / 4
&#9;&#9;&#9;&#9;rotationAxis = v3(x, xy/x, xz/x)
&#9;&#9;&#9;end
&#9;&#9;elseif yy &gt; zz then
&#9;&#9;&#9;if yy &lt; 0.001 then
&#9;&#9;&#9;&#9;rotationAxis = v3(invroot2, 0, invroot2)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;local y = sqrt(yy)
&#9;&#9;&#9;&#9;xy = (xy + yx) / 4
&#9;&#9;&#9;&#9;yz = (yz + zy) / 4
&#9;&#9;&#9;&#9;rotationAxis = v3(xy/y, y, yz/y)
&#9;&#9;&#9;end&#9;
&#9;&#9;else
&#9;&#9;&#9;if zz &lt; 0.001 then
&#9;&#9;&#9;&#9;rotationAxis = v3(invroot2, invroot2, 0)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;local z = sqrt(zz)
&#9;&#9;&#9;&#9;xz = (xz + zx) / 4
&#9;&#9;&#9;&#9;yz = (yz + zy) / 4
&#9;&#9;&#9;&#9;rotationAxis = v3(xz/z, yz/z, z)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;-- Normal case, get theta from cosTheta
&#9;&#9;theta = acos(cosTheta)
&#9;end
&#9;
&#9;-- Return the interpolator
&#9;return theta, function(t)
&#9;&#9;return c0*fromAxisAngle(rotationAxis, theta*t) + positionDelta*t
&#9;end
end</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX63">
					<Properties>
						<string name="Name">PartGeometry</string>
						<ProtectedString name="Source">-- PartGeometry.lua
-- @author xLEGOx, modified by quenty
-- Gives out part geoemtry

-- From http://www.roblox.com/Stravant-MultiMove-item?id=166786055

local lib = {}


local function rightVector(cf)
    local _,_,_,r4,_,_,r7,_,_,r10,_,_ = cf:components()
    return Vector3.new(r4,r7,r10)
end

local function leftVector(cf)
    local _,_,_,r4,_,_,r7,_,_,r10,_,_ = cf:components()
    return Vector3.new(-r4,-r7,-r10)
end

local function topVector(cf)
    local _,_,_,_,r5,_,_,r8,_,_,r11,_ = cf:components()
    return Vector3.new(r5,r8,r11)
end

local function bottomVector(cf)
    local _,_,_,_,r5,_,_,r8,_,_,r11,_ = cf:components()
    return Vector3.new(-r5,-r8,-r11)
end

local function backVector(cf)
    local _,_,_,_,_,r6,_,_,r9,_,_,r12 = cf:components()
    return Vector3.new(r6,r9,r12)
end

local function frontVector(cf)
    local _,_,_,_,_,r6,_,_,r9,_,_,r12 = cf:components()
    return Vector3.new(-r6,-r9,-r12)
end


local function CFrameFromTopBack(at, top, back)
    local right = top:Cross(back)
    return CFrame.new(at.x, at.y, at.z,
                      right.x, top.x, back.x,
                      right.y, top.y, back.y,
                      right.z, top.z, back.z)
end

local function IsSmoothPart(part)
    return part:IsA(&apos;Part&apos;) and (part.Shape == Enum.PartType.Ball)
end

local function GetGeometry(part, hit, cframeOverride)
    local cf = cframeOverride or part.CFrame
    local pos = cf.p
    --
    local sx = part.Size.x/2
    local sy = part.Size.y/2
    local sz = part.Size.z/2
    --
    local xvec = rightVector(cf)
    local yvec = topVector(cf)
    local zvec = backVector(cf)
    --
    local verts, edges, faces;
    --
    local vertexMargin;
    --
    if part:IsA(&apos;Part&apos;) then
        if part.Shape == Enum.PartType.Block or part.Shape == Enum.PartType.Cylinder then
            --8 vertices
            verts = {
                pos +xvec*sx  +yvec*sy  +zvec*sz, --top 4
                pos +xvec*sx  +yvec*sy  -zvec*sz,
                pos -xvec*sx  +yvec*sy  +zvec*sz,
                pos -xvec*sx  +yvec*sy  -zvec*sz,
                --
                pos +xvec*sx  -yvec*sy  +zvec*sz, --bottom 4
                pos +xvec*sx  -yvec*sy  -zvec*sz,
                pos -xvec*sx  -yvec*sy  +zvec*sz,
                pos -xvec*sx  -yvec*sy  -zvec*sz,
            }
            --12 edges
            edges = {
                {verts[1], verts[2], math.min(2*sx, 2*sy)}, --top 4
                {verts[3], verts[4], math.min(2*sx, 2*sy)},
                {verts[1], verts[3], math.min(2*sy, 2*sz)},
                {verts[2], verts[4], math.min(2*sy, 2*sz)},
                --
                {verts[5], verts[6], math.min(2*sx, 2*sy)}, --bottom 4
                {verts[7], verts[8], math.min(2*sx, 2*sy)},
                {verts[5], verts[7], math.min(2*sy, 2*sz)},
                {verts[6], verts[8], math.min(2*sy, 2*sz)},
                --
                {verts[1], verts[5], math.min(2*sx, 2*sz)}, --verticals
                {verts[2], verts[6], math.min(2*sx, 2*sz)},
                {verts[3], verts[7], math.min(2*sx, 2*sz)},
                {verts[4], verts[8], math.min(2*sx, 2*sz)},
            }
            --6 faces

            --[[
                Apparently the first three entries are the X, Y, and Z of the normal of the face
                the 4th entry is a table of the verticies of said face. 
            ]]

            faces = {
                {verts[1],  xvec, zvec, {verts[1], verts[2], verts[6], verts[5]}}, --right
                {verts[3], -xvec, zvec, {verts[3], verts[4], verts[8], verts[7]}}, --left
                {verts[1],  yvec, xvec, {verts[1], verts[2], verts[4], verts[3]}}, --top
                {verts[5], -yvec, xvec, {verts[5], verts[6], verts[8], verts[7]}}, --bottom
                {verts[1],  zvec, xvec, {verts[1], verts[3], verts[7], verts[5]}}, --back
                {verts[2], -zvec, xvec, {verts[2], verts[4], verts[8], verts[6]}}, --front
            }
        elseif part.Shape == Enum.PartType.Ball then
            -- just have one face and vertex, at the hit pos
            verts = { hit }
            edges = {} --edge can be selected as the normal of the face if the user needs it
            local norm = (hit-pos).unit
            local norm2 = norm:Cross(Vector3.new(0,1,0)).unit
            faces = {
                {hit, norm, norm2, {}}
            }
 
        else
            assert(false, &quot;Bad Part Shape: `&quot;..tostring(part.Shape)..&quot;`&quot;)
        end
    elseif part:IsA(&apos;CornerWedgePart&apos;) then
        local slantVec1 = ( zvec*sy + yvec*sz).unit
        local slantVec2 = (-xvec*sy + yvec*sx).unit
        -- 5 verts
        verts = {
            pos +xvec*sx  +yvec*sy  -zvec*sz, --top 1
            --
            pos +xvec*sx  -yvec*sy  +zvec*sz, --bottom 4
            pos +xvec*sx  -yvec*sy  -zvec*sz,
            pos -xvec*sx  -yvec*sy  +zvec*sz,
            pos -xvec*sx  -yvec*sy  -zvec*sz,
        }
        -- 8 edges
        edges = {
            {verts[2], verts[3], 0}, -- bottom 4
            {verts[3], verts[5], 0},
            {verts[5], verts[4], 0},
            {verts[4], verts[1], 0},
            --
            {verts[1], verts[3], 0}, -- vertical
            --
            {verts[1], verts[2], 0}, -- side diagonals
            {verts[1], verts[5], 0},
            --
            {verts[1], verts[4], 0}, -- middle diagonal
        }
        -- 5 faces
        faces = {
            {verts[2], -yvec, xvec, {verts[2], verts[3], verts[5], verts[4]}}, -- bottom
            --
            {verts[1],  xvec, -yvec, {verts[1], verts[3], verts[2]}}, -- sides
            {verts[1], -zvec, -yvec, {verts[1], verts[3], verts[5]}},
            --
            {verts[1],  slantVec1, xvec, {verts[1], verts[2], verts[4]}}, -- tops
            {verts[1],  slantVec2, zvec, {verts[1], verts[5], verts[4]}},
        }
 
    elseif part:IsA(&apos;WedgePart&apos;) then
        local slantVec = (-zvec*sy + yvec*sz).unit
        --6 vertices
        verts = {
            pos +xvec*sx  +yvec*sy  +zvec*sz, --top 2
            pos -xvec*sx  +yvec*sy  +zvec*sz,
            --
            pos +xvec*sx  -yvec*sy  +zvec*sz, --bottom 4
            pos +xvec*sx  -yvec*sy  -zvec*sz,
            pos -xvec*sx  -yvec*sy  +zvec*sz,
            pos -xvec*sx  -yvec*sy  -zvec*sz,
        }
        --9 edges
        edges = {
            {verts[1], verts[2], math.min(2*sy, 2*sz)}, --top 1
            --
            {verts[1], verts[4], math.min(2*sy, 2*sz)}, --slanted 2
            {verts[2], verts[6], math.min(2*sy, 2*sz)},
            --
            {verts[3], verts[4], math.min(2*sx, 2*sy)}, --bottom 4
            {verts[5], verts[6], math.min(2*sx, 2*sy)},
            {verts[3], verts[5], math.min(2*sy, 2*sz)},
            {verts[4], verts[6], math.min(2*sy, 2*sz)},
            --
            {verts[1], verts[3], math.min(2*sx, 2*sz)}, --vertical 2
            {verts[2], verts[5], math.min(2*sx, 2*sz)},
        }
        --5 faces
        faces = {
            {verts[1],  xvec, zvec, {verts[1], verts[4], verts[3]}}, --right
            {verts[2], -xvec, zvec, {verts[2], verts[6], verts[5]}}, --left
            {verts[3], -yvec, xvec, {verts[3], verts[4], verts[6], verts[5]}}, --bottom
            {verts[1],  zvec, xvec, {verts[1], verts[2], verts[5], verts[3]}}, --back
            {verts[2], slantVec, slantVec:Cross(xvec), {verts[2], verts[1], verts[4], verts[6]}}, --slanted
        }
    elseif part:IsA(&apos;Terrain&apos;) then
        local cellPos = game.Workspace.Terrain:WorldToCellPreferSolid(hit)
        local mat, block, orient = game.Workspace.Terrain:GetCell(cellPos.x, cellPos.y, cellPos.z)
        local pos = game.Workspace.Terrain:CellCenterToWorld(cellPos.x, cellPos.y, cellPos.z)
        --
        vertexMargin = 4
        --
        local orientToNumberMap = {
            [Enum.CellOrientation.NegZ] = 0;
            [Enum.CellOrientation.X]    = 1;
            [Enum.CellOrientation.Z]    = 2;
            [Enum.CellOrientation.NegX] = 3;
        }
        --
        local xvec = CFrame.Angles(0, math.pi/2*(orientToNumberMap[orient]-1), 0).lookVector
        local yvec = Vector3.new(0, 1, 0)
        local zvec = xvec:Cross(yvec)
        --
        if block == Enum.CellBlock.Solid then
            --8 vertices
            verts = {
                pos +xvec*2  +yvec*2  +zvec*2, --top 4
                pos +xvec*2  +yvec*2  -zvec*2,
                pos -xvec*2  +yvec*2  +zvec*2,
                pos -xvec*2  +yvec*2  -zvec*2,
                --
                pos +xvec*2  -yvec*2  +zvec*2, --bottom 4
                pos +xvec*2  -yvec*2  -zvec*2,
                pos -xvec*2  -yvec*2  +zvec*2,
                pos -xvec*2  -yvec*2  -zvec*2,
            }
            --12 edges
            edges = {
                {verts[1], verts[2], 4}, --top 4
                {verts[3], verts[4], 4},
                {verts[1], verts[3], 4},
                {verts[2], verts[4], 4},
                --
                {verts[5], verts[6], 4}, --bottom 4
                {verts[7], verts[8], 4},
                {verts[5], verts[7], 4},
                {verts[6], verts[8], 4},
                --
                {verts[1], verts[5], 4}, --verticals
                {verts[2], verts[6], 4},
                {verts[3], verts[7], 4},
                {verts[4], verts[8], 4},
            }
            --6 faces
            faces = {
                {pos+xvec*2,  xvec, zvec, {verts[1], verts[2], verts[6], verts[5]}}, --right
                {pos-xvec*2, -xvec, zvec, {verts[3], verts[4], verts[8], verts[7]}}, --left
                {pos+yvec*2,  yvec, xvec, {verts[1], verts[2], verts[4], verts[3]}}, --top
                {pos-yvec*2, -yvec, xvec, {verts[5], verts[6], verts[8], verts[7]}}, --bottom
                {pos+zvec*2,  zvec, xvec, {verts[1], verts[3], verts[7], verts[5]}}, --back
                {pos-zvec*2, -zvec, xvec, {verts[2], verts[4], verts[8], verts[6]}}, --front
            }
 
        elseif block == Enum.CellBlock.VerticalWedge then
            --top wedge. Similar to wedgepart, but we need to flip the Z axis
            zvec = -zvec
            xvec = -xvec
            --
            local slantVec = (-zvec*2 + yvec*2).unit
            --6 vertices
            verts = {
                pos +xvec*2  +yvec*2  +zvec*2, --top 2
                pos -xvec*2  +yvec*2  +zvec*2,
                --
                pos +xvec*2  -yvec*2  +zvec*2, --bottom 4
                pos +xvec*2  -yvec*2  -zvec*2,
                pos -xvec*2  -yvec*2  +zvec*2,
                pos -xvec*2  -yvec*2  -zvec*2,
            }
            --9 edges
            edges = {
                {verts[1], verts[2], 4}, --top 1
                --
                {verts[1], verts[4], 4}, --slanted 2
                {verts[2], verts[6], 4},
                --
                {verts[3], verts[4], 4}, --bottom 4
                {verts[5], verts[6], 4},
                {verts[3], verts[5], 4},
                {verts[4], verts[6], 4},
                --
                {verts[1], verts[3], 4}, --vertical 2
                {verts[2], verts[5], 4},
            }
            --5 faces

            faces = {
                {pos+xvec*2,  xvec, zvec, {verts[1], verts[4], verts[3]}}, --right
                {pos-xvec*2, -xvec, zvec, {verts[2], verts[6], verts[5]}}, --left
                {pos-yvec*2, -yvec, xvec, {verts[3], verts[4], verts[6], verts[5]}}, --bottom
                {pos+zvec*2,  zvec, xvec, {verts[1], verts[2], verts[5], verts[3]}}, --back
                {pos, slantVec, slantVec:Cross(xvec), {verts[2], verts[1], verts[4], verts[6]}}, --slanted
            }
 
        elseif block == Enum.CellBlock.CornerWedge then
            --top corner wedge
            --4 verts
            verts = {
                pos +xvec*2  +yvec*2  -zvec*2, --top 1
                --
                pos +xvec*2  -yvec*2  -zvec*2, --bottom 3
                pos +xvec*2  -yvec*2  +zvec*2,
                pos -xvec*2  -yvec*2  -zvec*2,
            }
            --6 edges
            edges = {
                {verts[1], verts[2], 3},
                {verts[1], verts[3], 3},
                {verts[1], verts[4], 3},
                {verts[2], verts[3], 3},
                {verts[2], verts[4], 3},
                {verts[3], verts[4], 3},
            }
            local centerXZ = ((verts[3]+verts[4])/2 + verts[2])/2
            local slantCenter = Vector3.new(centerXZ.x, pos.y, centerXZ.z)
            local slantFaceDir = ((zvec-xvec).unit*2 + Vector3.new(0, math.sqrt(2), 0)).unit
            --4 faces
            faces = {
                {centerXZ, -yvec, xvec, {verts[2], verts[3], verts[4]}},
                {pos + xvec*2,  xvec, yvec, {verts[1], verts[2], verts[3]}},
                {pos - zvec*2, -zvec, yvec, {verts[1], verts[2], verts[4]}},
                {slantCenter, slantFaceDir, (xvec+zvec).unit, {verts[1], verts[3], verts[4]}},
            }
 
        elseif block == Enum.CellBlock.InverseCornerWedge then
            --block corner cut
            --7 vertices
            verts = {
                pos +xvec*2  +yvec*2  +zvec*2, --top 3
                pos +xvec*2  +yvec*2  -zvec*2,
                pos -xvec*2  +yvec*2  -zvec*2,
                --
                pos +xvec*2  -yvec*2  +zvec*2, --bottom 4
                pos +xvec*2  -yvec*2  -zvec*2,
                pos -xvec*2  -yvec*2  +zvec*2,
                pos -xvec*2  -yvec*2  -zvec*2,
            }
            --12 edges
            edges = {
                {verts[1], verts[2], 4}, --top 4
                {verts[2], verts[3], 4},
                --
                {verts[4], verts[5], 4}, --bottom 4
                {verts[6], verts[7], 4},
                {verts[4], verts[6], 4},
                {verts[5], verts[7], 4},
                --
                {verts[1], verts[4], 4}, --verticals
                {verts[2], verts[5], 4},
                {verts[3], verts[7], 4},
                --
                {verts[1], verts[3], 2.5}, --slants
                {verts[1], verts[6], 2.5},
                {verts[3], verts[6], 2.5},
            }
            --7 faces
            local centerXZ = ((verts[4]+verts[7])/2 + verts[6])/2
            local slantCenter = Vector3.new(centerXZ.x, pos.y, centerXZ.z)
            local slantFaceDir = ((zvec-xvec).unit*2 + Vector3.new(0, math.sqrt(2), 0)).unit
            faces = {
                {pos+xvec*2,  xvec, zvec, {verts[1], verts[2], verts[5], verts[4]} }, --right
                {pos-xvec*2, -xvec, zvec, {verts[3], verts[7], verts[6]}           }, --left
                {pos+yvec*2,  yvec, xvec, {verts[1], verts[2], verts[3]}           }, --top
                {pos-yvec*2, -yvec, xvec, {verts[4], verts[5], verts[7], verts[6]} }, --bottom
                {pos+zvec*2,  zvec, xvec, {verts[1], verts[6], verts[4]}           }, --back
                {pos-zvec*2, -zvec, xvec, {verts[2], verts[3], verts[7], verts[5]} }, --front
                {slantCenter, slantFaceDir, (xvec+zvec).unit, {verts[1], verts[3], verts[6]}}, --slant
            }
 
        elseif block == Enum.CellBlock.HorizontalWedge then
            --block side wedge
            --6 vertices
            verts = {
                pos +xvec*2  +yvec*2  +zvec*2, --top 4
                pos +xvec*2  +yvec*2  -zvec*2,
                pos -xvec*2  +yvec*2  -zvec*2,
                --
                pos +xvec*2  -yvec*2  +zvec*2, --bottom 4
                pos +xvec*2  -yvec*2  -zvec*2,
                pos -xvec*2  -yvec*2  -zvec*2,
            }
            --9 edges
            edges = {
                {verts[1], verts[2], 4}, --top 4
                {verts[2], verts[3], 4},
                --
                {verts[4], verts[5], 4}, --bottom 4
                {verts[5], verts[6], 4},
                --
                {verts[1], verts[4], 4}, --verticals
                {verts[2], verts[5], 4},
                {verts[3], verts[6], 4},
                --
                {verts[1], verts[3], 2.5}, --slants
                {verts[4], verts[6], 2.5},
            }
            --5 faces
            faces = {
                {pos+xvec*2,  xvec, zvec, {verts[1], verts[2], verts[5], verts[4]} }, --right
                {pos+yvec*2,  yvec, xvec, {verts[1], verts[2], verts[3]}           }, --top
                {pos-yvec*2, -yvec, xvec, {verts[4], verts[5], verts[6]}           }, --bottom
                {pos-zvec*2, -zvec, xvec, {verts[2], verts[3], verts[6], verts[5]} }, --front
                {pos, (zvec-xvec).unit, yvec, {verts[1], verts[3], verts[4], verts[6]}}, --slant
            }
 
        else
            assert(false, &quot;unreachable&quot;)
        end
    end
    --
    local geometry = {
        part = part;
        vertices = verts;
        edges = edges;
        faces = faces;
        vertexMargin = vertexMargin or math.min(sx, sy, sz)*2;
    }
    --
    local geomId = 0
    --
    for i, dat in pairs(faces) do
        geomId = geomId + 1
        dat.id = geomId
        dat.point = dat[1]
        dat.normal = dat[2]
        dat.direction = dat[3]
        dat.vertices = dat[4]
        dat.type = &apos;Face&apos;
        --avoid Event bug (if both keys + indicies are present keys are discarded when passing tables)
        dat[1], dat[2], dat[3], dat[4] = nil, nil, nil, nil
    end
    for i, dat in pairs(edges) do
        geomId = geomId + 1
        dat.id = geomId
        dat.a, dat.b = dat[1], dat[2]
        dat.direction = (dat.b-dat.a).unit
        dat.length = (dat.b-dat.a).magnitude
        dat.edgeMargin = dat[3]
        dat.type = &apos;Edge&apos;
        --avoid Event bug (if both keys + indicies are present keys are discarded when passing tables)
        dat[1], dat[2], dat[3] = nil, nil, nil
    end
    for i, dat in pairs(verts) do
        geomId = geomId + 1
        verts[i] = {
            position = dat;
            id = geomId;
            ignoreUnlessNeeded = IsSmoothPart(part);
            type = &apos;Vertex&apos;;
        }
    end
    --
    return geometry
end
lib.GetGeometry = GetGeometry

--[==[
local function otherNormals(dir)
    if math.abs(dir.X) &gt; 0 then
        return Vector3.new(0, 1, 0), Vector3.new(0, 0, 1)
    elseif math.abs(dir.Y) &gt; 0 then
        return Vector3.new(1, 0, 0), Vector3.new(0, 0, 1)
    else
        return Vector3.new(1, 0, 0), Vector3.new(0, 1, 0)
    end
end

local function extend(v, amount)
    return v.unit * (v.magnitude + amount) 
end

local function fillFace(parent, face, color, trans)
    local parts = {}
    local function fillTri(a, b, c)
        --[[       edg1
            A ------|------&gt;B  --.
            &apos;\      |      /      \
              \part1|part2/       |
               \   cut   /       / Direction edges point in:
           edg3 \       / edg2  /        (clockwise)
                 \     /      |/
                  \&lt;- /       &#194;&#175;&#194;&#175;
                   \ /
                    C
        --]]
        local ab, bc, ca = b-a, c-b, a-c
        local abm, bcm, cam = ab.magnitude, bc.magnitude, ca.magnitude
        local e1, e2, e3 = ca:Dot(ab)/(abm*abm), ab:Dot(bc)/(bcm*bcm), bc:Dot(ca)/(cam*cam)
        local edg1 = math.abs(0.5 + e1)
        local edg2 = math.abs(0.5 + e2)
        local edg3 = math.abs(0.5 + e3)
        -- Idea: Find the edge onto which the vertex opposite that
        -- edge has the projection closest to 1/2 of the way along that 
        -- edge. That is the edge thatwe want to split on in order to 
        -- avoid ending up with small &quot;sliver&quot; triangles with one very
        -- small dimension relative to the other one.
        if math.abs(e1) &gt; 0.0001 and math.abs(e2) &gt; 0.0001 and math.abs(e3) &gt; 0.0001 then
            if edg1 &lt; edg2 then
                if edg1 &lt; edg3 then
                    -- min is edg1: less than both
                    -- nothing to change
                else&#9;&#9;&#9;
                    -- min is edg3: edg3 &lt; edg1 &lt; edg2
                    -- &quot;rotate&quot; verts twice counterclockwise
                    a, b, c = c, a, b
                    ab, bc, ca = ca, ab, bc
                    abm = cam
                end
            else
                if edg2 &lt; edg3 then
                    -- min is edg2: less than both
                    -- &quot;rotate&quot; verts once counterclockwise
                    a, b, c = b, c, a
                    ab, bc, ca = bc, ca, ab
                    abm = bcm
                else
                    -- min is edg3: edg3 &lt; edg2 &lt; edg1
                    -- &quot;rotate&quot; verts twice counterclockwise
                    a, b, c = c, a, b
                    ab, bc, ca = ca, ab, bc
                    abm = cam
                end
            end
        else
            if math.abs(e1) &lt;= 0.0001 then
                -- nothing to do
            elseif math.abs(e2) &lt;= 0.0001 then
                -- use e2
                a, b, c = b, c, a
                ab, bc, ca = bc, ca, ab
                abm = bcm
            else
                -- use e3
                a, b, c = c, a, b
                ab, bc, ca = ca, ab, bc
                abm = cam
            end
        end
     
        --calculate lengths
        local len1 = -ca:Dot(ab)/abm
        local len2 = abm - len1
        local width = (ca + ab.unit*len1).magnitude
     
        --calculate &quot;base&quot; CFrame to pasition parts by
        local normal = ab:Cross(bc).unit
        local maincf = CFrameFromTopBack(a, normal, -ab.unit)

     &#9;local part1 = Instance.new(&apos;WedgePart&apos;)
     &#9;part1.TopSurface    = &apos;Smooth&apos;
     &#9;part1.BottomSurface = &apos;Smooth&apos;
     &#9;part1.FormFactor   = &apos;Custom&apos;
        part1.Anchored = true
        part1.Transparency = trans
        part1.BrickColor = color
        part1.CanCollide = false
        --
        local part2 = part1:Clone()
        part1.Archivable = false
        part2.Archivable = false

        --make parts
        local depth = 0.1
        if len1 &gt; 0.001 then
            if len1 &gt;= 0.2 and width &gt;= 0.2 and depth &gt;= 0.2 then
                part1.Size = Vector3.new(depth, width, len1)
            else
                part1.Size = Vector3.new(0.2, 0.2, 0.2)
                local mesh = Instance.new(&apos;SpecialMesh&apos;, part1)
                mesh.MeshType = &apos;Wedge&apos;
                mesh.Scale = Vector3.new(depth / 0.2, width / 0.2, len1 / 0.2)
            end
            part1.CFrame = maincf*CFrame.Angles(math.pi, 0, math.pi/2)*CFrame.new(0, width/2, len1/2)
            part1.Parent = parent
            table.insert(parts, part1)
        end
        --
        if len2 &gt; 0.001 then
            if len2 &gt;= 0.2 and width &gt;= 0.2 and depth &gt;= 0.2 then
                part2.Size = Vector3.new(depth, width, len2)
            else
                part2.Size = Vector3.new(0.2, 0.2, 0.2)
                local mesh = Instance.new(&apos;SpecialMesh&apos;, part2)
                mesh.MeshType = &apos;Wedge&apos;
                mesh.Scale = Vector3.new(depth / 0.2, width / 0.2, len2 / 0.2)
            end
            part2.CFrame = maincf*CFrame.Angles(math.pi, math.pi, -math.pi/2)*CFrame.new(0, width/2, -len1 - len2/2)
            part2.Parent = parent
            table.insert(parts, part2)
        end
    end
    for i = 2, #face.vertices - 1 do
        fillTri(face.vertices[1], face.vertices[i], face.vertices[i+1])
    end
    return parts
end

local function drawFace(parent, face, color, trans)
    local tb = {}
    --
    local function seg(size, cf)
&#9;&#9;local segment         = Instance.new(&apos;Part&apos;, parent)
&#9;&#9;segment.BrickColor    = color
&#9;&#9;segment.Anchored      = true
&#9;&#9;segment.Locked        = true
&#9;&#9;segment.Archivable    = false
&#9;&#9;segment.Transparency  = trans
&#9;&#9;segment.TopSurface    = &apos;Smooth&apos;
&#9;&#9;segment.BottomSurface = &apos;Smooth&apos;
&#9;&#9;segment.FormFactor    = &apos;Custom&apos;
&#9;&#9;segment.Size          = size
&#9;&#9;segment.CFrame        = cf
        table.insert(tb, segment)
    end
    --
    for i = 1, #face.vertices do
        local v1 = face.vertices[i]
        local v2;
        if i == #face.vertices then
            v2 = face.vertices[1]
        else
            v2 = face.vertices[i+1]
        end
        --
        seg(Vector3.new(0, 0, (v1-v2).magnitude), CFrameFromTopBack((v1+v2)/2, face.normal, (v1-v2).unit))
    end
    --
    return tb
end

local function getPoints(part)
    local hsize = part.Size / 2
    local cf = part.CFrame
    local geom = GetGeometry(part, Vector3.new())
    local points = {}
    for _, vert in pairs(geom.vertices) do
        table.insert(points, vert.position)
    end
    return points
end
--]==]
local function getNormal(face)
    return face.normal
end
lib.getNormal = getNormal

local function close(a, b)
    return (a - b).magnitude &lt; 0.001
end
lib.close = close
--[==[
local function unit2(x, y)
    local len = (x*x + y*y)^0.5
    return x/len, y/len
end

local function len2(x, y)
    return (x*x + y*y)^0.5
end

local function cross2(x, y, x2, y2)
    return x*y2 - y*x2
end

local function max3(a, b)
    return Vector3.new(math.max(a.X, b.X), math.max(a.Y, b.Y), math.max(a.Z, b.Z))
end
local function min3(a, b)
    return Vector3.new(math.min(a.X, b.X), math.min(a.Y, b.Y), math.min(a.Z, b.Z))
end

local function getSelectVert(face)
    local vert = nil
    local bestDist = math.huge
    for _, v in pairs(face.vertices) do
        local dist = (v - face.click).magnitude
        if dist &lt; bestDist then
            bestDist = dist
            vert = v
        end
    end
    return vert
end
--]==]


return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX64">
					<Properties>
						<string name="Name">qCFrame</string>
						<ProtectedString name="Source">local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local NevermoreEngine   = require(ReplicatedStorage:WaitForChild(&quot;NevermoreEngine&quot;))
local LoadCustomLibrary = NevermoreEngine.LoadLibrary

local qSystems          = LoadCustomLibrary(&quot;qSystems&quot;)
local qInstance         = LoadCustomLibrary(&quot;qInstance&quot;)

qSystems:Import(getfenv(0));

local lib = {}

--[[
local function RecurseGetBoundingBox(object,sides)
&#9;-- Credit to Anaminus, I have a general understanding on how this works. Basically, 
&#9;-- It would appear it loops through each part, and finds that part&apos;s bounding box.  
&#9;-- It then expands the &quot;global&quot; bounding box to the correct size. 

&#9;-- I think. Anyway, it finds the bounding box of the object in question.

&#9;if object:IsA(&quot;BasePart&quot;) then
&#9;&#9;local mod = object.Size/2
&#9;&#9;local rot = object.CFrame
&#9;&#9;for i = 1,#bb_points do
&#9;&#9;&#9;local point = rot*CFrame.new(mod*bb_points[i]).p
&#9;&#9;&#9;if point.x &gt; sides[1] then sides[1] = point.x end
&#9;&#9;&#9;if point.x &lt; sides[2] then sides[2] = point.x end
&#9;&#9;&#9;if point.y &gt; sides[3] then sides[3] = point.y end
&#9;&#9;&#9;if point.y &lt; sides[4] then sides[4] = point.y end
&#9;&#9;&#9;if point.z &gt; sides[5] then sides[5] = point.z end
&#9;&#9;&#9;if point.z &lt; sides[6] then sides[6] = point.z end
&#9;&#9;end
&#9;&#9;-- if parts then parts[#parts + 1] = object end
&#9;end
&#9;local children = object:GetChildren()
&#9;for i = 1,#children do
&#9;&#9;RecurseGetBoundingBox(children[i],sides,parts)
&#9;end
end

local function GetBoundingBox(objects,return_parts)
&#9;local sides = {-math.huge;math.huge;-math.huge;math.huge;-math.huge;math.huge}
&#9;local parts
&#9;if return_parts then
&#9;&#9;parts = {}
&#9;end
&#9;for i = 1,#objects do
&#9;&#9;RecurseGetBoundingBox(objects[i],sides,parts)
&#9;end
&#9;return
&#9;&#9;Vector3.new(sides[1]-sides[2],sides[3]-sides[4],sides[5]-sides[6]),
&#9;&#9;Vector3.new((sides[1]+sides[2])/2,(sides[3]+sides[4])/2,(sides[5]+sides[6])/2),
&#9;&#9;parts
end
lib.GetBoundingBox = GetBoundingBox
lib.getBoundingBox = GetBoundingBox--]]

local BouncingBoxPoints = { -- Bouding box posiitions. 
&#9;Vector3.new(-1,-1,-1);
&#9;Vector3.new( 1,-1,-1);
&#9;Vector3.new(-1, 1,-1);
&#9;Vector3.new( 1, 1,-1);
&#9;Vector3.new(-1,-1, 1);
&#9;Vector3.new( 1,-1, 1);
&#9;Vector3.new(-1, 1, 1);
&#9;Vector3.new( 1, 1, 1);
}

local function GetBoundingBox(Objects)
&#9;local Sides = {-math.huge;math.huge;-math.huge;math.huge;-math.huge;math.huge}

&#9;for _, BasePart in pairs(Objects) do
&#9;&#9;local HalfSize = BasePart.Size/2
&#9;&#9;local Rotation = BasePart.CFrame

&#9;&#9;for _, BoundingBoxPoint in pairs(BouncingBoxPoints) do
&#9;&#9;&#9;local Point = Rotation*CFrame.new(HalfSize*BoundingBoxPoint).p

&#9;&#9;&#9;if Point.x &gt; Sides[1] then Sides[1] = Point.x end
&#9;&#9;&#9;if Point.x &lt; Sides[2] then Sides[2] = Point.x end
&#9;&#9;&#9;if Point.y &gt; Sides[3] then Sides[3] = Point.y end
&#9;&#9;&#9;if Point.y &lt; Sides[4] then Sides[4] = Point.y end
&#9;&#9;&#9;if Point.z &gt; Sides[5] then Sides[5] = Point.z end
&#9;&#9;&#9;if Point.z &lt; Sides[6] then Sides[6] = Point.z end
&#9;&#9;end
&#9;end

&#9;-- Size, Position
&#9;return Vector3.new(Sides[1]-Sides[2],Sides[3]-Sides[4],Sides[5]-Sides[6]), 
&#9;       Vector3.new((Sides[1]+Sides[2])/2,(Sides[3]+Sides[4])/2,(Sides[5]+Sides[6])/2)
end
lib.GetBoundingBox = GetBoundingBox

local function QuaternionFromCFrame(cf)
&#9;local mx,  my,  mz,
&#9;      m00, m01, m02,
&#9;      m10, m11, m12,
&#9;      m20, m21, m22 = cf:components()
&#9;local trace = m00 + m11 + m22
&#9;if trace &gt; 0 then
&#9;&#9;local s = math.sqrt(1 + trace)
&#9;&#9;local recip = 0.5/s
&#9;&#9;return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5
&#9;else
&#9;&#9;local i = 0
&#9;&#9;if m11 &gt; m00 then i = 1 end
&#9;&#9;if m22 &gt; (i == 0 and m00 or m11) then i = 2 end
&#9;&#9;if i == 0 then
&#9;&#9;&#9;local s = math.sqrt(m00-m11-m22+1)
&#9;&#9;&#9;local recip = 0.5/s
&#9;&#9;&#9;return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip
&#9;&#9;elseif i == 1 then
&#9;&#9;&#9;local s = math.sqrt(m11-m22-m00+1)
&#9;&#9;&#9;local recip = 0.5/s
&#9;&#9;&#9;return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip
&#9;&#9;elseif i == 2 then
&#9;&#9;&#9;local s = math.sqrt(m22-m00-m11+1)
&#9;&#9;&#9;local recip = 0.5/s
&#9;&#9;&#9;return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip
&#9;&#9;end
&#9;end
end
lib.QuaternionFromCFrame = QuaternionFromCFrame;
lib.quaternionFromCFrame = QuaternionFromCFrame;

local function QuaternionToCFrame(px, py, pz, x, y, z, w)
&#9;-- return CFrame.new(x, py, pz, x, y, z, w)
&#9;
&#9;---[[
&#9;local xs, ys, zs = x + x, y + y, z + z
&#9;local wx, wy, wz = w*xs, w*ys, w*zs
&#9;--
&#9;local xx = x*xs
&#9;local xy = x*ys
&#9;local xz = x*zs
&#9;local yy = y*ys
&#9;local yz = y*zs
&#9;local zz = z*zs
&#9;--
&#9;return CFrame.new(px,        py,        pz,
&#9;                  1-(yy+zz), xy - wz,   xz + wy,
&#9;                  xy + wz,   1-(xx+zz), yz - wx,
&#9;                  xz - wy,   yz + wx,   1-(xx+yy))--]]
end
lib.QuaternionToCFrame = QuaternionToCFrame;
lib.quaternionToCFrame = QuaternionToCFrame;


local function QuaternionSlerp(a, b, t)
&#9;local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4]
&#9;local startInterp, finishInterp;
&#9;if cosTheta &gt;= 0.0001 then
&#9;&#9;if (1 - cosTheta) &gt; 0.0001 then
&#9;&#9;&#9;local theta = math.acos(cosTheta)
&#9;&#9;&#9;local invSinTheta = 1/math.sin(theta)
&#9;&#9;&#9;startInterp = math.sin((1-t)*theta)*invSinTheta
&#9;&#9;&#9;finishInterp = math.sin(t*theta)*invSinTheta 
&#9;&#9;else
&#9;&#9;&#9;startInterp = 1-t
&#9;&#9;&#9;finishInterp = t
&#9;&#9;end
&#9;else
&#9;&#9;if (1+cosTheta) &gt; 0.0001 then
&#9;&#9;&#9;local theta = math.acos(-cosTheta)
&#9;&#9;&#9;local invSinTheta = 1/math.sin(theta)
&#9;&#9;&#9;startInterp = math.sin((t-1)*theta)*invSinTheta
&#9;&#9;&#9;finishInterp = math.sin(t*theta)*invSinTheta
&#9;&#9;else
&#9;&#9;&#9;startInterp = t-1
&#9;&#9;&#9;finishInterp = t
&#9;&#9;end
&#9;end
&#9;return a[1]*startInterp + b[1]*finishInterp,
&#9;       a[2]*startInterp + b[2]*finishInterp,
&#9;       a[3]*startInterp + b[3]*finishInterp,
&#9;       a[4]*startInterp + b[4]*finishInterp&#9;       
end
lib.QuaternionSlerp = QuaternionSlerp;
lib.quaternionSlerp = QuaternionSlerp;
--]==]

local function TweenPart(part, a, b, length)
&#9;local qa = {QuaternionFromCFrame(a)}
&#9;local qb = {QuaternionFromCFrame(b)}
&#9;local ax, ay, az = a.x, a.y, a.z
&#9;local bx, by, bz = b.x, b.y, b.z
&#9;--
&#9;local c = 0
&#9;local tot = 0
&#9;--
&#9;local startTime = tick()
&#9;while true do
&#9;&#9;wait()
&#9;&#9;local t = (tick()-startTime)/length
&#9;&#9;local _t = 1-t
&#9;&#9;if t &gt; 1 then break end
&#9;&#9;local startT = tick()
&#9;&#9;local cf = QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,
&#9;&#9;&#9;                             QuaternionSlerp(qa, qb, t))
&#9;&#9;tot = tot+(tick()-startT)
&#9;&#9;c = c + 1
&#9;&#9;part.CFrame = cf
&#9;end
&#9;--print(&quot;Average Cost Per Slerp+ToCFrame:&quot;, string.format(&quot;%.4fms&quot;, tot/c*1000))
end
lib.TweenPart = TweenPart;
lib.tweenPart = TweenPart;


local function SlerpCFrame(a, b, scale)
&#9;-- Same thing as lerp, but with rotation, scale is mapped between 0 and 1... 

&#9;local qa = {QuaternionFromCFrame(a)}
&#9;local qb = {QuaternionFromCFrame(b)}
&#9;local ax, ay, az = a.x, a.y, a.z
&#9;local bx, by, bz = b.x, b.y, b.z


&#9;local _scale = 1-scale;
&#9;--print(scale, _scale)
&#9;return QuaternionToCFrame(_scale * ax + scale*bx, _scale*ay + scale*by, _scale*az + scale*bz,
&#9;                                   QuaternionSlerp(qa, qb, scale))
end
lib.QuaternionSlerpCFrame = SlerpCFrame;
lib.quaternionSlerpCFrame = SlerpCFrame;

lib.SlerpCFrame = SlerpCFrame;
lib.slerpCFrame = SlerpCFrame;

do
&#9;local v3 = Vector3.new
&#9;local acos = math.acos
&#9;local components = CFrame.new().components
&#9;local inverse = CFrame.new().inverse
&#9;local fromAxisAngle = CFrame.fromAxisAngle
&#9;local abs = math.abs

&#9;local function AxisAngleInterpolate(c0,c1,t)--CFrame0,CFrame1,Tween
&#9;&#9;local _,_,_,xx,yx,zx,xy,yy,zy,xz,yz,zz=components(inverse(c0)*c1)
&#9;&#9;local c,p=(xx+yy+zz-1)/2,(c1.p-c0.p)*t
&#9;&#9;return c0*fromAxisAngle(abs(c)&lt;0.99999 and v3(yz-zy,zx-xz,xy-yx) or v3(0,1,0),acos(c&gt;1 and 1 or c&lt;-1 and -1 or c)*t)+p
&#9;end

&#9;lib.AxisAngleInterpolate = AxisAngleInterpolate
&#9;lib.axisAngleInterpolate = AxisAngleInterpolate

&#9;lib.FastSlerp = AxisAngleInterpolate
&#9;lib.fastSlerp = AxisAngleInterpolate

end

local toObjectSpace = CFrame.new().toObjectSpace
local toWorldSpace  = CFrame.new().toWorldSpace

local function TransformModel(Objects, Center, NewLocation)
&#9;--- MoveModel

&#9;-- Transforms a group of bricks (Objects) relative to Center to the NewLocation CFrame (NewLocation).  
&#9;-- @param Objects is a table of all the ROBLOX parts. It needs to know the parts it&apos;s moving. 
&#9;-- @param Center CFrame, Center is the current center of the model. This will be moved to &quot;NewLocation&quot;, and all the other parts will follow, relative to Center
&#9;-- @param NewLocation CFrame, The new location to move it to

&#9;-- NewLocation is the new center of the model.


&#9;for _, BasePart in pairs(Objects) do
&#9;&#9;BasePart.CFrame = toWorldSpace(NewLocation, toObjectSpace(Center, BasePart.CFrame))
&#9;end
end
lib.TransformModel = TransformModel
lib.transformModel = TransformModel

local function MakeModelTransformer(Objects, Center)
&#9;--- Function factory. Returns a function that will transform all Objects (in the table sent) to the new position, relative to center
&#9;-- @param Objects the objects to transform, should be an an array. Should only be BaseParts. Should be nonempty
&#9;-- @param Center CFrame, the center of the objects. Suggested that it is either the model&apos;s GetPrimaryPartCFrame() or one of the Object&apos;s CFrame.
&#9;-- @return The transformer function

&#9;-- The model is transformed so the &quot;Center&quot;&apos;s CFrame is now the new NewLocation. It respects rotation.
&#9;-- An example would be the &quot;Seat&quot; of a car. If you transform the &quot;Seat&quot; to be the CFrame of a Player&apos;s Torso, the seat will be moved
&#9;-- to the new location, and the rest of the car will follow, that is to say, it will move relative to the cframe.

&#9;-- If relative positions change relative to the center, and these new changes are to be respected, the transformer must be reconstructed.

&#9;local RelativePositions = {}

&#9;for _, Part in pairs(Objects) do
&#9;&#9;RelativePositions[Part] = toObjectSpace(Center, Part.CFrame)
&#9;end
&#9;Objects = nil

&#9;return function(NewLocation)
&#9;&#9;--- Transforms the model to the NewLocation
&#9;&#9;-- @param NewLocation A new CFrame to transform the model to.

&#9;&#9;for Part, Position in pairs(RelativePositions) do
&#9;&#9;&#9;Part.CFrame = toWorldSpace(NewLocation, Position)
&#9;&#9;end
&#9;end
end
lib.MakeModelTransformer = MakeModelTransformer
lib.makeModelTransformer = MakeModelTransformer

local pointToObjectSpace = CFrame.new().pointToObjectSpace
lib.pointToObjectSpace = pointToObjectSpace
lib.PointToObjectSpace = pointToObjectSpace

local function PointInsidePart(Part, Point)
&#9;--- Return&apos;s whether a point is inside of a part.
&#9;-- @param Part The part to check. May also be a table with a .Size and .CFrame value in it.
&#9;
&#9;local PartSize = Part.Size/2
&#9;local RelativePosition = Part.CFrame:pointToObjectSpace(Point)
&#9;--print(RelativePosition, PartSize)
&#9;if not (RelativePosition.X &gt;= -PartSize.X and RelativePosition.X &lt;= PartSize.X) then
&#9;&#9;return false
&#9;elseif not (RelativePosition.Y &gt;= -PartSize.Y and RelativePosition.Y &lt;= PartSize.Y) then
&#9;&#9;return false
&#9;elseif not (RelativePosition.Z &gt;= -PartSize.Z and RelativePosition.Z &lt;= PartSize.Z) then
&#9;&#9;return false
&#9;end

&#9;return true&#9;
end
lib.PointInsidePart = PointInsidePart
lib.pointInsidePart = PointInsidePart

local FindPartOnRayWithIgnoreList = Workspace.FindPartOnRayWithIgnoreList

local function AdvanceRaycast(RayTrace, IgnoreList, IgnoreInvisible, IgnoreCanCollideFalse, TerrainCellsAreCubes, MaximumCastCount)
&#9;local ContinueCasting = true;
&#9;local CastCount = 0

&#9;local function CastAttempt(NewRayTrace)
&#9;&#9;if CastCount &gt; MaximumCastCount then
&#9;&#9;&#9;return
&#9;&#9;else
&#9;&#9;&#9;CastCount = CastCount + 1
&#9;&#9;end

&#9;&#9;local Object, Position = FindPartOnRayWithIgnoreList(Workspace, NewRayTrace, IgnoreList, TerrainCellsAreCubes)

&#9;&#9;if Object and Position then
&#9;&#9;&#9;if IgnoreCanCollideFalse and Object.CanCollide == false then
&#9;&#9;&#9;&#9;IgnoreList[#IgnoreList+1] = Object
&#9;&#9;&#9;&#9;CastCount = CastCount + 1
&#9;&#9;&#9;&#9;return CastAttempt(NewRayTrace)
&#9;&#9;&#9;elseif IgnoreInvisible and Object.Transparency &gt;= 1 then
&#9;&#9;&#9;&#9;IgnoreList[#IgnoreList+1] = Object
&#9;&#9;&#9;&#9;CastCount = CastCount + 1
&#9;&#9;&#9;&#9;return CastAttempt(NewRayTrace)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;return Object, Position
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end

&#9;local DirectionUnit = RayTrace.Direction.unit
&#9;local Magnitude = RayTrace.Direction.magnitude
&#9;local CastedMagnitude = 0

&#9;while CastedMagnitude &lt; Magnitude do
&#9;&#9;local ToCastMagnitude = Magnitude - CastedMagnitude + 1

&#9;&#9;if ToCastMagnitude &gt; 999 then
&#9;&#9;&#9;ToCastMagnitude = 999
&#9;&#9;end

&#9;&#9;local NewRayTrace = Ray.new(RayTrace.Origin, DirectionUnit * ToCastMagnitude)
&#9;&#9;local Object, Position = CastAttempt(NewRayTrace)

&#9;&#9;if Object then
&#9;&#9;&#9;return Object, Position
&#9;&#9;end

&#9;&#9;CastedMagnitude = CastedMagnitude + ToCastMagnitude

&#9;&#9;if CastCount &gt; MaximumCastCount then
&#9;&#9;&#9;--print(&quot;[AdvanceRaycast] - Reached maximum cast count @ &quot; .. CastCount)
&#9;&#9;&#9;return nil
&#9;&#9;end
&#9;end

end

--[[
local function AdvanceRaycast(Ray, IgnoreList, IgnoreInvisible, IgnoreCollisions, TerrainCellsAreCubes, MaximumDepth)
&#9;-- Abuses raycasing to force ignoring of invisible and collision parts.
&#9;-- @param MaximumDepth The max iterations possible.

&#9;-- IgnoreList should be a metatable __mode = &quot;k&quot;
&#9;MaximumDepth = MaximumDepth and MaximumDepth - 1 or 10

&#9;-- print(&quot;Advance raycast @ &quot; .. MaximumDepth)
&#9;local Object, Position = FindPartOnRayWithIgnoreList(Workspace, Ray, IgnoreList, TerrainCellsAreCubes)
&#9;if not Object or ((Object.CanCollide == IgnoreCollisions or not IgnoreCollisions) and (Object.Transparency &lt; 1 or not IgnoreInvisible)) then
&#9;&#9;return Object, Position
&#9;elseif MaximumDepth &gt; 0 then
&#9;&#9;IgnoreList[#IgnoreList + 1] = Object
&#9;&#9;return AdvanceRaycast(Ray, IgnoreList, IgnoreInvisible, IgnoreCollisions, TerrainCellsAreCubes, MaximumDepth)
&#9;else
&#9;&#9;return nil, nil
&#9;end
end--]]
lib.AdvanceRaycast = AdvanceRaycast
lib.advanceRaycast = AdvanceRaycast

local function WeldTogether(Part0, Part1, JointType, WeldParent)
&#9;--- Weld&apos;s 2 parts together
&#9;-- @param Part0 The first part
&#9;-- @param Part1 The second part (Dependent part most of the time).
&#9;-- @param [JointType] The type of joint. Defaults to weld.
&#9;-- @param [WeldParent] Parent of the weld, Defaults to Part0 (so GC is better).
&#9;-- @return The weld created.

&#9;JointType = JointType or &quot;Weld&quot;

&#9;local NewWeld = Make(JointType, {
&#9;&#9;Part0  = Part0;
&#9;&#9;Part1  = Part1;
&#9;&#9;C0     = CFrame.new();--Part0.CFrame:inverse();
&#9;&#9;C1     = Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
&#9;&#9;Parent = WeldParent or Part0;
&#9;})

&#9;return NewWeld
end
lib.WeldTogether = WeldTogether
lib.WeldTogether = WeldTogether

local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
&#9;-- @param Parts The Parts to weld. Should be anchored to prevent really horrible results.
&#9;-- @param MainPart The part to weld the model to (can be in the model).
&#9;-- @param [JointType] The type of joint. Defaults to weld. 
&#9;-- @parm DoNotUnanchor Boolean, if true, will not unachor the model after cmopletion.

&#9;for _, Part in pairs(Parts) do
&#9;&#9;if Part ~= MainPart then
&#9;&#9;&#9;WeldTogether(MainPart, Part, JointType, MainPart)
&#9;&#9;end
&#9;end

&#9;if not DoNotUnanchor then
&#9;&#9;for _, Part in pairs(Parts) do
&#9;&#9;&#9;Part.Anchored = false
&#9;&#9;end
&#9;&#9;MainPart.Anchored = false
&#9;end
end
lib.WeldParts = WeldParts
lib.weldParts = WeldParts

local function GetSurfaceNormal(Part, Vector)
&#9;--[[
&#9;&#9;CirrusGeometry.getSurfaceNormal(part, point)
&#9;&#9;Returns unit vector of the surface normal given a point on the surface of part
&#9;--]]

&#9;local Percent = Part.CFrame:toObjectSpace(CFrame.new(Vector)).p / ((Part.Size  - Vector3.new(0.02, 0.02, 0.02))/ 2)
&#9;local ab      = Vector3.new(math.abs(Percent.X), math.abs(Percent.Y), math.abs(Percent.Z))
&#9;local normal  = Vector3.new(0, 1, 0)

&#9;if Part:IsA(&quot;Part&quot;) and (Part.Shape == Enum.PartType.Ball or Part.Shape == Enum.PartType.Cylinder) then
&#9;&#9;normal = (Vector - Part.Position).unit
&#9;elseif Part:IsA(&quot;WedgePart&quot;) and ((Percent.Y &gt; 0) or (Percent.Z &lt; 0)) and ab.X &lt; 1 and ab.Y &lt; 1 and ab.Z &lt; 1 then
&#9;&#9;normal = CFrame.new(Part.Position, (Part.CFrame * CFrame.new(0,Part.Size.Z,-Part.Size.Y)).p).lookVector
&#9;elseif math.abs(Percent.X) &gt; math.abs(Percent.Y) and math.abs(Percent.X) &gt; math.abs(Percent.Z) then
&#9;&#9;normal = lib.vecRight(Part.CFrame) * Percent.X/math.abs(Percent.X)
&#9;elseif math.abs(Percent.Y) &gt;= math.abs(Percent.X) and math.abs(Percent.Y) &gt;= math.abs(Percent.Z) then
&#9;&#9;normal = lib.vecUp(Part.CFrame) * Percent.Y/math.abs(Percent.Y)
&#9;elseif math.abs(Percent.Z) &gt; math.abs(Percent.X) and math.abs(Percent.Z) &gt; math.abs(Percent.Y) then
&#9;&#9;normal = lib.vecForwards(Part.CFrame) * -Percent.Z/math.abs(Percent.Z)
&#9;end
&#9;return normal
end

--[[
You can think of a CFrame as a set of the lookVectors of 3 of the faces of a part.

Really all I do is:
-Take one of the two directions that _isn&apos;t_ &quot;up&quot; from the current CFrame
-Construct a new direction that removes all of that direction&apos;s y component, and normalizes the direction to a new unit vector.
-Constructs a CFrame from that vector and the &quot;up&quot; vector (the third vector can be found from the other two).

~ Stravant
http://www.roblox.com/Forum/ShowPost.aspx?PostID=78453245
]]


local function GetRightVector(CFrameValue)
&#9;--- Get&apos;s the right vector of a CFrame Value
&#9;-- @param CFrameValue A CFrame, of which the vector will be retrieved
&#9;-- @return The right vector of the CFrame

&#9;local _,_,_,r4,_,_,r7,_,_,r10,_,_ = CFrameValue:components()
&#9;return Vector3.new(r4,r7,r10)
end
lib.GetRightVector = GetRightVector
lib.getRightVector = GetRightVector

local function GetLeftVector(CFrameValue)
&#9;--- Get&apos;s the left vector of a CFrame Value
&#9;-- @param CFrameValue A CFrame, of which the vector will be retrieved
&#9;-- @return The left vector of the CFrame

&#9;local _,_,_,r4,_,_,r7,_,_,r10,_,_ = CFrameValue:components()
&#9;return Vector3.new(-r4,-r7,-r10)
end
lib.GetLeftVector = GetLeftVector
lib.getLeftVector = GetLeftVector

local function GetTopVector(CFrameValue)
&#9;--- Get&apos;s the top vector of a CFrame Value
&#9;-- @param CFrameValue A CFrame, of which the vector will be retrieved
&#9;-- @return The top vector of the CFrame

&#9;local _,_,_,_,r5,_,_,r8,_,_,r11,_ = CFrameValue:components()
&#9;return Vector3.new(r5,r8,r11)
end
lib.GetTopVector = GetTopVector
lib.getTopVector = GetTopVector

local function GetBottomVector(CFrameValue)
&#9;--- Get&apos;s the bottom vector of a CFrame Value
&#9;-- @param CFrameValue A CFrame, of which the vector will be retrieved
&#9;-- @return The bottom vector of the CFrame

&#9;local _,_,_,_,r5,_,_,r8,_,_,r11,_ = CFrameValue:components()
&#9;return Vector3.new(-r5,-r8,-r11)
end
lib.GetBottomVector = GetBottomVector
lib.getBottomVector = GetBottomVector

local function GetBackVector(CFrameValue)
&#9;--- Get&apos;s the back vector of a CFrame Value
&#9;-- @param CFrameValue A CFrame, of which the vector will be retrieved
&#9;-- @return The back vector of the CFrame

&#9;local _,_,_,_,_,r6,_,_,r9,_,_,r12 = CFrameValue:components()
&#9;return Vector3.new(r6,r9,r12)
end
lib.GetBackVector = GetBackVector
lib.getBackVector = GetBackVector

local function GetFrontVector(CFrameValue)
&#9;--- Get&apos;s the front vector of a CFrame Value
&#9;-- @param CFrameValue A CFrame, of which the vector will be retrieved
&#9;-- @return The front vector of the CFrame

&#9;local _,_,_,_,_,r6,_,_,r9,_,_,r12 = CFrameValue:components()
&#9;return Vector3.new(-r6,-r9,-r12)
end
lib.GetFrontVector = GetFrontVector
lib.getFrontVector = GetFrontVector

local function GetCFrameFromTopBack(CFrameAt, Top, Back)
&#9;--- Get&apos;s the CFrame fromt he &quot;top back&quot; vector. or something

&#9;local Right = Top:Cross(Back) -- Get&apos;s the &quot;right&quot; cframe lookvector.
&#9;return CFrame.new(CFrameAt.x, CFrameAt.y, CFrameAt.z,
&#9;&#9;Right.x, Top.x, Back.x,
&#9;&#9;Right.y, Top.y, Back.y,
&#9;&#9;Right.z, Top.z, Back.z
&#9;)
end
lib.GetCFrameFromTopBack = GetCFrameFromTopBack
lib.getCFrameFromTopBack = GetCFrameFromTopBack

local function GetRotationInXZPlane(CFrameValue)
&#9;--- Get&apos;s the rotation in the XZ plane (global).

&#9;local Back = GetBackVector(CFrameValue)
&#9;return GetCFrameFromTopBack(CFrameValue.p, 
&#9;&#9;Vector3.new(0,1,0), -- Top lookVector (straight up)
&#9;&#9;Vector3.new(Back.x, 0, Back.z).unit -- Right facing direction (removed Y axis.)
&#9;)
end
lib.GetRotationInXZPlane = GetRotationInXZPlane
lib.getRotationInXZPlane = GetRotationInXZPlane

local function FindFaceFromCoord(Size, RelativePosition)
&#9;--- Find&apos;s a faces coordanate given it&apos;s size and RelativePosition.

&#9;local pa, pb = -Size/2, Size/2
&#9;local dx = math.min(math.abs(RelativePosition.x - pa.x), math.abs(RelativePosition.x - pb.x))
&#9;local dy = math.min(math.abs(RelativePosition.y - pa.y), math.abs(RelativePosition.y - pb.y))
&#9;local dz = math.min(math.abs(RelativePosition.z - pa.z), math.abs(RelativePosition.z - pb.z))
&#9;--
&#9;if dx &lt; dy and dx &lt; dz then
&#9;&#9;if math.abs(RelativePosition.x - pa.x) &lt; math.abs(RelativePosition.x - pb.x) then
&#9;&#9;&#9;return Enum.NormalId.Left --&apos;Left&apos;
&#9;&#9;else
&#9;&#9;&#9;return Enum.NormalId.Right --&apos;Right&apos;
&#9;&#9;end
&#9;elseif dy &lt; dx and dy &lt; dz then
&#9;&#9;if math.abs(RelativePosition.y - pa.y) &lt; math.abs(RelativePosition.y - pb.y) then
&#9;&#9;&#9;return Enum.NormalId.Bottom --&apos;Bottom&apos;
&#9;&#9;else
&#9;&#9;&#9;return Enum.NormalId.Top --&apos;Top&apos;
&#9;&#9;end
&#9;elseif dz &lt; dx and dz &lt; dy then
&#9;&#9;if math.abs(RelativePosition.z - pa.z) &lt; math.abs(RelativePosition.z - pb.z) then
&#9;&#9;&#9;return Enum.NormalId.Front --&apos;Front&apos;
&#9;&#9;else
&#9;&#9;&#9;return Enum.NormalId.Back --&apos;Back&apos;
&#9;&#9;end&#9;
&#9;end 
end
lib.FindFaceFromCoord = FindFaceFromCoord
lib.findFaceFromCoord = FindFaceFromCoord

--[[ EXAMPLE

local function CreateScorch(part, hit)
&#9;local scorch = Modify(Instance.new(&quot;Part&quot;), {
&#9;&#9;Name         = &apos;SpotWeld_Scorch&apos;;
&#9;&#9;FormFactor   = &apos;Custom&apos;;
&#9;&#9;CanCollide   = false;
&#9;&#9;Anchored     = true;
&#9;&#9;Size         = Vector3.new(2, 0.1, 2);
&#9;&#9;Transparency = 1;
&#9;&#9;Modify(Instance.new(&quot;Decal&quot;), {
&#9;&#9;&#9;Face    = &apos;Top&apos;,
&#9;&#9;&#9;Texture = &apos;http://www.roblox.com/asset/?id=22915150&apos;,
&#9;&#9;&#9;Shiny   = 0,
&#9;&#9;});
&#9;});

&#9;scorch.Parent = BulletHolder;
&#9;local hitFace = FindFaceFromCoord(part.Size, part.CFrame:toObjectSpace(CFrame.new(hit)))
&#9;local dir = (part.CFrame-part.Position)*Vector3.FromNormalId(hitFace)
&#9;if part:IsA(&apos;Terrain&apos;) then
&#9;&#9;scorch.CFrame = CFrame.new(hit)
&#9;else
&#9;&#9;scorch.CFrame = CFrame.new(hit, hit+dir)*CFrame.Angles(-math.pi/2, 0, 0)
&#9;end

&#9;game.Debris:AddItem(scorch, 15)
end
--]]

local function GetCFramePitch(Angle)
&#9;-- returns CFrame.Angles(Angle, 0, 0) 

&#9;return CFrame.Angles(Angle, 0, 0)
end
lib.GetCFramePitch = GetCFramePitch
lib.getCFramePitch = GetCFramePitch

local function GetCFrameYaw(Angle)
&#9;-- returns CFrame.Angles(0, Angle, 0) 

&#9;return CFrame.Angles(0, Angle, 0)
end
lib.GetCFrameYaw = GetCFrameYaw
lib.getCFrameYaw = GetCFrameYaw

local function GetCFrameRoll(Angle)
&#9;-- returns CFrame.Angles(0, 0, Angle) 

&#9;return CFrame.Angles(0, 0, Angle)
end
lib.GetCFrameRoll = GetCFrameRoll
lib.getCFrameRoll = GetCFrameRoll

local function GetPitchFromLookVector(Vector)
&#9;-- Returns pitch of a Vector

&#9;return -math.asin(vec.Y) + math.pi/2
end
lib.GetPitchFromLookVector = GetPitchFromLookVector
lib.getPitchFromLookVector = GetPitchFromLookVector

local function GetYawFromLookVector(Vector)
&#9;-- Returns yaw of a Vector

&#9;return -math.atan2(vec.Z, vec.X) - math.pi/2
end
lib.GetYawFromLookVector = GetYawFromLookVector
lib.getYawFromLookVector = GetYawFromLookVector

local function GetRollFromCFrame(CFrameValue)
&#9;-- Returns roll of a CFrame

&#9;local RollDifferance = CFrame.new(CFrameValue.p, CFrameValue.p + CFrameValue.lookVector):toObjectSpace(CFrameValue)
&#9;local Vector = GetRightVector(RollDifferance)

&#9;return math.atan2(Vector.Y, Vector.X)
end
lib.GetRollFromCFrame = GetRollFromCFrame
lib.getRollFromCFrame = GetRollFromCFrame

local function DrawRay(Ray, Color, Parent)
&#9;--- Draw&apos;s a ray out (for debugging)
&#9;-- Credit to Cirrus for initial code.

&#9;Parent = Parent or Workspace

&#9;local NewPart = Instance.new(&quot;Part&quot;, Parent)

&#9;NewPart.FormFactor = &quot;Custom&quot;
&#9;NewPart.Size       = Vector3.new(0.2, Ray.Direction.magnitude, 0.2)

&#9;local Center = Ray.Origin + Ray.Direction/2
&#9;-- lib.DrawPoint(Ray.Origin).Name = &quot;origin&quot;
&#9;-- lib.DrawPoint(Center).Name = &quot;Center&quot;
&#9;-- lib.DrawPoint(Ray.Origin + Ray.Direction).Name = &quot;Destination&quot;

&#9;NewPart.CFrame     = CFrame.new(Center, Ray.Origin + Ray.Direction) * CFrame.Angles(math.pi/2, 0, 0) --* GetCFramePitch(math.pi/2)
&#9;NewPart.Anchored   = true
&#9;NewPart.CanCollide = false
&#9;NewPart.Transparency = 0.5
&#9;NewPart.BrickColor = Color or BrickColor.new(&quot;Bright red&quot;)

&#9;Instance.new(&quot;SpecialMesh&quot;, NewPart)

&#9;return NewPart
end
lib.DrawRay = DrawRay
lib.drawRay = DrawRay

local function DrawPoint(Position, Color, Parent)
&#9;--- FOR DEBUGGING

&#9;local NewDraw = Make(&quot;Part&quot;, {
&#9;&#9;Parent        = Parent or Workspace;
&#9;&#9;Size          = Vector3.new(1, 1, 1);
&#9;&#9;Transparency  = 0.5;
&#9;&#9;BrickColor    = Color or BrickColor.new(&quot;Bright red&quot;);
&#9;&#9;Name          = &quot;PointRender&quot;;
&#9;&#9;Archivable    = false;
&#9;&#9;Anchored      = true;
&#9;&#9;CanCollide    = false;
&#9;&#9;TopSurface    = &quot;Smooth&quot;;
&#9;&#9;BottomSurface = &quot;Smooth&quot;;
&#9;&#9;Shape         = &quot;Ball&quot;;
&#9;})
&#9;NewDraw.CFrame = CFrame.new(Position);

&#9;return NewDraw
end
lib.DrawPoint = DrawPoint
lib.drawPoint = DrawPoint

local function GetSlopeRelativeToGravity(Part, Position)
&#9;--- Return&apos;s the slope of the surface a character is walking upon.
&#9;-- @param Part The part the ray found
&#9;-- @param Position A vector on the Part&apos;s surface, probably the one the ray found
&#9;-- @return The Angle, in radians, that was calculated.
&#9;-- &#9;&#9;0 radians should be level
&#9;--&#9;&#9;math.pi/2 radians should be straight up and down?
&#9;-- If it&apos;s past that, I&apos;m not sure how it happened.

&#9;local Face = FindFaceFromCoord(Part.Size, Part.CFrame:toObjectSpace(CFrame.new(Position)))
&#9;if Face then
&#9;&#9;local SlopeDirection = ((Part.CFrame - Part.Position) * Vector3.FromNormalId(Face)).unit

&#9;&#9;local GravityVector = Vector3.new(0, -1, 0)

&#9;&#9;local Angle = math.acos(SlopeDirection:Dot(GravityVector)) -- Would divide by magnitude * magnitude, but it&apos;s 1.
&#9;&#9;return math.abs((Angle - math.pi))
&#9;else
&#9;&#9;print(&quot;[GetSlopeRelativeToGravity] No face found&quot;)
&#9;&#9;return nil
&#9;end
end
lib.GetSlopeRelativeToGravity = GetSlopeRelativeToGravity
lib.getSlopeRelativeToGravity = GetSlopeRelativeToGravity

local function GetSlopeRelativeToVector(Part, Position, Vector)
&#9;--- Return&apos;s the slope of the surface a character is walking upon relative to their direction.
&#9;-- @param Part The part the ray found
&#9;-- @param Position A vector on the Part&apos;s surface, probably the one the ray found
&#9;-- @return The Angle, in radians, that was calculated.
&#9;-- &#9;&#9;0 radians should be level
&#9;--&#9;&#9;math.pi/2 radians should be straight up and down?
&#9;-- If it&apos;s past that, I&apos;m not sure how it happened.

&#9;local Face = FindFaceFromCoord(Part.Size, Part.CFrame:toObjectSpace(CFrame.new(Position)))
&#9;if Face then
&#9;&#9;local SlopeDirection = ((Part.CFrame - Part.Position) * Vector3.FromNormalId(Face)).unit

&#9;&#9;local Angle = math.acos(SlopeDirection:Dot(Vector)) -- Would divide by magnitude * magnitude, but it&apos;s 1.
&#9;&#9;return math.abs((Angle - math.pi))
&#9;else
&#9;&#9;print(&quot;[GetSlopeRelativeToGravity] No face found&quot;)
&#9;&#9;return nil
&#9;end
end
lib.GetSlopeRelativeToVector = GetSlopeRelativeToVector
lib.getSlopeRelativeToVector = GetSlopeRelativeToVector

local function LookCFrame(c,v,t)
&#9;--- TREY REYNOLDS FOR ALL THE THINGZ

&#9;--- Creates a new CFrame based upon another CFrame, a Vector to look at, and a time (t) to scale [0, 1]
&#9;-- &quot;perfect rotation&quot;

&#9;-- @param c The CFrame (base)
&#9;-- @param v The vector to look at. Target.
&#9;-- @param t The spherical interpolation between c and v (target).

&#9;local t,v=t and t/2 or 0.5,(c:inverse()*v).unit
&#9;local an=math.abs(v.z)&lt;1 and math.acos(-v.z)
&#9;local l=an and (math.sin(t*an)*v-Vector3.new(0,0,math.sin((1-t)*an)))/math.sin(an)
&#9;return l and c*CFrame.new(0,0,0,l.y,-l.x,0,-l.z) or c
end
lib.LookCFrame = LookCFrame

--[[
local function RawVectorClosestPointOnRayAToRayB(aox,aoy,aoz,adx,ady,adz,box,boy,boz,bdx,bdy,bdz)--AOrigin x,y,z,ADirection x,y,z,BOrigin x,y,z,BDirection x,y,z
&#9;-- Trey Reynolds. Finds the closest point on RayA to RayB

&#9;-- Untested. Mostly. Should work according to trey, tested once. 


&#9;local bda,bdb=bdx*adx+bdy*ady+bdz*adz,bdx*bdx+bdy*bdy+bdz*bdz--BDirectionDotADirection,BDirectionDotBDirection
&#9;local nx,ny,nz=bda*bdx-bdb*adx,bda*bdy-bdb*ady,bda*bdz-bdb*adz--Normal x,y,z
&#9;local d=((aox-box)*nx+(aoy-boy)*ny+(aoz-boz)*nz)/(adx*nx+ady*ny+adz*nz)--Distance
&#9;return aox-d*adx,aoy-d*ady,aoz-d*adz
end

local function VectorClosestPointOnRayAToRayB(RayA, RayB)
&#9;local OriginA, DirectionA = RayA.Origin, Direction
&#9;local OriginB, DirectionB = RayB.Origin, Direction

&#9;return Vector3.new(RawVectorClosestPointOnRayAToRayB(
&#9;&#9;OriginA.x, OriginA.y, OriginA.z,
&#9;&#9;DirectionA.x, DirectionA.y, DirectionA.z,
&#9;&#9;OriginB.x, OriginB.y, OriginB.z,
&#9;&#9;DirectionB.x, DirectionB.y, DirectionB.z
&#9;))
end--]]

do
&#9;local Dot = Vector3.new().Dot
&#9;
&#9;local function VectorClosestPointOnRayAToRayB(ao,ad,bo,bd)
&#9;&#9;local n=Dot(bd,ad)*bd-Dot(bd,bd)*ad
&#9;&#9;return ao-Dot(ao-bo,n)/Dot(ad,n)*ad
&#9;end


&#9;lib.VectorClosestPointOnRayAToRayB = VectorClosestPointOnRayAToRayB
end

return lib</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX65">
					<Properties>
						<string name="Name">Quaternion</string>
						<ProtectedString name="Source">-- Quaternion.lua

--By xXxMoNkEyMaNxXx
-- Modified by Quenty

--[[
God, grant me the serenity to accept the things I cannot change,
The courage to change the things I can,
And wisdom to know the difference.

I cannot change most of this.
]]
local next     = next
local tick     = tick
local type     = type
local print    = print
local select   = select
local tostring = tostring

local pi       = math.pi
local tau      = 2*pi
local abs      = math.abs
local cos,sin  = math.cos,math.sin
local sqrt     = math.sqrt
local atan2    = math.atan2
local max      = math.max

local vec3     = Vector3.new
local CF       = CFrame.new

local iv       = vec3()
local iq       = {1,0,0,0}

local lib = {}

local function BezierPosition(x0,x1,v0,v1,t)
&#9;local T=1-t
&#9;return x0*T*T*T+(3*x0+v0)*t*T*T+(3*x1-v1)*t*t*T+x1*t*t*t
end
local function BezierVelocity(x0,x1,v0,v1,t)
&#9;local T=1-t
&#9;return v0*T*T+2*(3*(x1-x0)-(v1+v0))*t*T+v1*t*t
end

local function Qmul(q1,q2) -- Multiply
&#9;local w1,x1,y1,z1,w2,x2,y2,z2=q1[1],q1[2],q1[3],q1[4],q2[1],q2[2],q2[3],q2[4]
&#9;return {w1*w2-x1*x2-y1*y2-z1*z2,w1*x2+x1*w2+y1*z2-z1*y2,w1*y2-x1*z2+y1*w2+z1*x2,w1*z2+x1*y2-y1*x2+z1*w2}
end

local function Qinv(q)--Inverse. (q^-1)
&#9;local w,x,y,z=q[1],q[2],q[3],q[4]
&#9;local m=w*w+x*x+y*y+z*z
&#9;if m&gt;0 then
&#9;&#9;return {w/m,-x/m,-y/m,-z/m}
&#9;else
&#9;&#9;return {0,0,0,0}
&#9;end
end

local function Qpow(q,exponent,choice)
&#9;choice=choice or 0
&#9;local w,x,y,z=q[1],q[2],q[3],q[4]
&#9;local vv=x*x+y*y+z*z
&#9;if vv&gt;0 then
&#9;&#9;--Convert to polar form and exponentiate (all in one go)
&#9;&#9;local v=sqrt(vv)
&#9;&#9;local m=(w*w+vv)^(0.5*exponent)
&#9;&#9;local theta=exponent*(atan2(v,w)+tau*choice)--swag
&#9;&#9;local s=m*sin(theta)/v
&#9;&#9;return {m*cos(theta),x*s,y*s,z*s}
&#9;else--This is a regular number.  srs.  lol.
&#9;&#9;if w&lt;0 then--Quaternions, umad? u dun fool me nub
&#9;&#9;&#9;local m=(-w)^exponent
&#9;&#9;&#9;local s=m*sin(pi*exponent)*sqrt(3)/3
&#9;&#9;&#9;return {m*cos(pi*exponent),s,s,s}
&#9;&#9;else
&#9;&#9;&#9;return {w^exponent,0,0,0}
&#9;&#9;end
&#9;end
end

local function QuaternionFromCFrame(cf)
&#9;local mx,my,mz,m00,m01,m02,m10,m11,m12,m20,m21,m22=cf:components()
&#9;local trace=m00+m11+m22
&#9;if trace&gt;0 then
&#9;&#9;local s=sqrt(1+trace)
&#9;&#9;local recip=0.5/s
&#9;&#9;return s*0.5,(m21-m12)*recip,(m02-m20)*recip,(m10-m01)*recip
&#9;else
&#9;&#9;local big=max(m00,m11,m22)
&#9;&#9;if big==m00 then
&#9;&#9;&#9;local s=sqrt(1+m00-m11-m22)
&#9;&#9;&#9;local recip=0.5/s
&#9;&#9;&#9;return (m21-m12)*recip,0.5*s,(m10+m01)*recip,(m02+m20)*recip
&#9;&#9;elseif big==m11 then
&#9;&#9;&#9;local s=sqrt(1-m00+m11-m22)
&#9;&#9;&#9;local recip=0.5/s
&#9;&#9;&#9;return (m02-m20)*recip,(m10+m01)*recip,0.5*s,(m21+m12)*recip
&#9;&#9;elseif big==m22 then
&#9;&#9;&#9;local s=sqrt(1-m00-m11+m22)
&#9;&#9;&#9;local recip=0.5/s
&#9;&#9;&#9;return (m10-m01)*recip,(m02+m20)*recip,(m21+m12)*recip,0.5*s
&#9;&#9;end
&#9;end
end

local function SlerpQuaternions(q0, q1, t)
&#9;return Qmul(q0, Qpow(Qmul(q1, Qinv(q0)), t))
end

local function QuaternionToCFrame(q)
&#9;local w,x,y,z=q[1],q[2],q[3],q[4]
&#9;local xs,ys,zs=x+x,y+y,z+z
&#9;local wx,wy,wz=w*xs,w*ys,w*zs
&#9;local xx,xy,xz,yy,yz,zz=x*xs,x*ys,x*zs,y*ys,y*zs,z*zs
&#9;return 1-(yy+zz),xy-wz,xz+wy,xy+wz,1-(xx+zz),yz-wx,xz-wy,yz+wx,1-(xx+yy)
end

local function BezierRotation(q0,q1,w0,w1,t)
&#9;local _30,_31,_32,_33=q0,Qmul(q0,w0),Qmul(q1,Qinv(w1)),q1
&#9;local _20,_21,_22=Qmul(_30,Qpow(Qmul(Qinv(_30),_31),t)),Qmul(_31,Qpow(Qmul(Qinv(_31),_32),t)),Qmul(_32,Qpow(Qmul(Qinv(_32),_33),t))
&#9;local _10,_11=Qmul(_20,Qpow(Qmul(Qinv(_20),_21),t)),Qmul(_21,Qpow(Qmul(Qinv(_21),_22),t))
&#9;local _00=Qmul(_10,Qpow(Qmul(Qinv(_10),_11),t))
&#9;return _00
end
local function BezierAngularV(q0,q1,w0,w1,t)
&#9;local _30,_31,_32,_33=q0,Qmul(q0,w0),Qmul(q1,Qinv(w1)),q1
&#9;local _20,_21,_22=Qmul(Qinv(_30),_31),Qmul(Qinv(_31),_32),Qmul(Qinv(_32),_33)
&#9;local _10,_11=Qmul(_20,Qpow(Qmul(Qinv(_20),_21),t)),Qmul(_21,Qpow(Qmul(Qinv(_21),_22),t))
&#9;local _00=Qmul(_10,Qpow(Qmul(Qinv(_10),_11),t))
&#9;return _00
end

--Regular tweening
local TweenData={}
local Tweens=setmetatable({},{
&#9;__index=function(self,i)
&#9;&#9;local data=TweenData[i]
&#9;&#9;if data then
&#9;&#9;&#9;local timeNow,t0,t1=tick(),data.t0,data.t1
&#9;&#9;&#9;if timeNow&gt;t0 and timeNow&lt;t1 then
&#9;&#9;&#9;&#9;return BezierPosition(data.x0,data.x1,data.v0,data.v1,(timeNow-t0)/(t1-t0))
&#9;&#9;&#9;elseif timeNow&gt;=t1 then
&#9;&#9;&#9;&#9;return data.x1
&#9;&#9;&#9;elseif timeNow&lt;=t0 then--Whatever.
&#9;&#9;&#9;&#9;return data.x0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end,
&#9;__newindex=function(self,i,v)
&#9;&#9;local data=TweenData[i]
&#9;&#9;if data then
&#9;&#9;&#9;local timeNow,t0,t1,x0,x1,v0,v1=tick(),data.t0,data.t1
&#9;&#9;&#9;if timeNow&gt;t0 and timeNow&lt;t1 then
&#9;&#9;&#9;&#9;local dt=t1-t0
&#9;&#9;&#9;&#9;local t=(timeNow-t0)/dt
&#9;&#9;&#9;&#9;x0,x1,v0,v1=BezierPosition(data.x0,data.x1,data.v0,data.v1,t),v,BezierVelocity(data.x0,data.x1,data.v0,data.v1,t)/dt,v*0
&#9;&#9;&#9;elseif timeNow&gt;=t1 then
&#9;&#9;&#9;&#9;x0,x1,v0,v1=data.x1,v,v*0,v*0
&#9;&#9;&#9;elseif timeNow&lt;=t0 then
&#9;&#9;&#9;&#9;x0,x1,v0,v1=data.x0,v,v*0,v*0
&#9;&#9;&#9;end
&#9;&#9;&#9;local dt,time=1,data.time
&#9;&#9;&#9;local timeType=type(time)
&#9;&#9;&#9;if timeType==&quot;number&quot; then
&#9;&#9;&#9;&#9;dt=time
&#9;&#9;&#9;elseif timeType==&quot;function&quot; then
&#9;&#9;&#9;&#9;dt=time(x0,x1,v0,v1)
&#9;&#9;&#9;end
&#9;&#9;&#9;data.x0,data.x1,data.v0,data.v1,data.t0,data.t1,data.tweening=x0,x1,dt*v0,dt*v1,timeNow,timeNow+dt,true
&#9;&#9;else
&#9;&#9;&#9;print(&quot;A value named &quot;..tostring(i)..&quot; has not yet been created.&quot;)
&#9;&#9;end
&#9;end,
})
lib.Tweens = Tweens

--Quaternion tweening
local QuaternionTweenData={}
local QuaternionTweens=setmetatable({},{
&#9;__index=function(self,i)
&#9;&#9;local data=QuaternionTweenData[i]
&#9;&#9;if data then
&#9;&#9;&#9;local timeNow,t0,t1=tick(),data.t0,data.t1
&#9;&#9;&#9;if timeNow&gt;t0 and timeNow&lt;t1 then
&#9;&#9;&#9;&#9;return BezierRotation(data.q0,data.q1,data.w0,data.w1,(timeNow-t0)/(t1-t0))
&#9;&#9;&#9;elseif timeNow&gt;=t1 then
&#9;&#9;&#9;&#9;return data.q1
&#9;&#9;&#9;elseif timeNow&lt;=t0 then--Whatever.
&#9;&#9;&#9;&#9;return data.q0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end,
&#9;__newindex=function(self,i,v)
&#9;&#9;local data=QuaternionTweenData[i]
&#9;&#9;if data then
&#9;&#9;&#9;local timeNow,t0,t1,q0,q1,w0,w1=tick(),data.t0,data.t1
&#9;&#9;&#9;if timeNow&gt;t0 and timeNow&lt;t1 then
&#9;&#9;&#9;&#9;local dt=t1-t0
&#9;&#9;&#9;&#9;local t=(timeNow-t0)/dt
&#9;&#9;&#9;&#9;q0,q1,w0,w1=BezierRotation(data.q0,data.q1,data.w0,data.w1,t),v,Qpow(BezierAngularV(data.q0,data.q1,data.w0,data.w1,t),1/dt),iq
&#9;&#9;&#9;elseif timeNow&gt;=t1 then
&#9;&#9;&#9;&#9;q0,q1,w0,w1=data.q1,v,iq,iq
&#9;&#9;&#9;elseif timeNow&lt;=t0 then
&#9;&#9;&#9;&#9;q0,q1,w0,w1=data.q0,v,iq,iq
&#9;&#9;&#9;end
&#9;&#9;&#9;if data.autoChoose then
&#9;&#9;&#9;&#9;if q0[1]*q1[1]+q0[2]*q1[2]+q0[3]*q1[3]+q0[4]*q1[4]&lt;0 then
&#9;&#9;&#9;&#9;&#9;q1={-q1[1],-q1[2],-q1[3],-q1[4]}
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;local dt,time=1,data.time
&#9;&#9;&#9;local timeType=type(time)
&#9;&#9;&#9;if timeType==&quot;number&quot; then
&#9;&#9;&#9;&#9;dt=time
&#9;&#9;&#9;elseif timeType==&quot;function&quot; then
&#9;&#9;&#9;&#9;dt=time(q0,q1,w0,w1)
&#9;&#9;&#9;end
&#9;&#9;&#9;data.q0,data.q1,data.w0,data.w1,data.t0,data.t1,data.tweening=q0,q1,Qpow(w0,dt),Qpow(w1,dt),timeNow,timeNow+dt,true
&#9;&#9;else
&#9;&#9;&#9;print(&quot;A value named &quot;..tostring(i)..&quot; has not yet been created.&quot;)
&#9;&#9;end
&#9;end,
})
lib.QuaternionTweens = QuaternionTweens

--CFrame tweening
local CFrameTweenData={}
local CFrameTweens=setmetatable({},{
&#9;__index=function(self,i)
&#9;&#9;local data=CFrameTweenData[i]
&#9;&#9;if data then
&#9;&#9;&#9;local timeNow,t0,t1=tick(),data.t0,data.t1
&#9;&#9;&#9;if timeNow&gt;t0 and timeNow&lt;t1 then
&#9;&#9;&#9;&#9;local t=(timeNow-t0)/(t1-t0)
&#9;&#9;&#9;&#9;local p=BezierPosition(data.x0,data.x1,data.v0,data.v1,t)
&#9;&#9;&#9;&#9;return CF(p.x,p.y,p.z,QuaternionToCFrame(BezierRotation(data.q0,data.q1,data.w0,data.w1,t)))
&#9;&#9;&#9;elseif timeNow&gt;=t1 then
&#9;&#9;&#9;&#9;return data.c1
&#9;&#9;&#9;elseif timeNow&lt;=t0 then--Whatever.
&#9;&#9;&#9;&#9;return data.c0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end,
&#9;__newindex=function(self,i,v)
&#9;&#9;local data=CFrameTweenData[i]
&#9;&#9;if data then
&#9;&#9;&#9;local timeNow,t0,t1,x0,x1,v0,v1,q0,q1,w0,w1=tick(),data.t0,data.t1
&#9;&#9;&#9;if timeNow&gt;t0 and timeNow&lt;t1 then
&#9;&#9;&#9;&#9;local dt=t1-t0
&#9;&#9;&#9;&#9;local t=(timeNow-t0)/dt
&#9;&#9;&#9;&#9;x0,x1,v0,v1,q0,q1,w0,w1=BezierPosition(data.x0,data.x1,data.v0,data.v1,t),v.p,BezierVelocity(data.x0,data.x1,data.v0,data.v1,t)/dt,iv,BezierRotation(data.q0,data.q1,data.w0,data.w1,t),{QuaternionFromCFrame(v)},Qpow(BezierAngularV(data.q0,data.q1,data.w0,data.w1,t),1/dt),iq
&#9;&#9;&#9;elseif timeNow&gt;=t1 then
&#9;&#9;&#9;&#9;x0,x1,v0,v1,q0,q1,w0,w1=data.x1,v.p,iv,iv,data.q1,{QuaternionFromCFrame(v)},iq,iq
&#9;&#9;&#9;elseif timeNow&lt;=t0 then
&#9;&#9;&#9;&#9;x0,x1,v0,v1,q0,q1,w0,w1=data.x0,v.p,iv,iv,data.q0,{QuaternionFromCFrame(v)},iq,iq
&#9;&#9;&#9;end
&#9;&#9;&#9;local a1,b1,c1,d1,a2,b2,c2,d2=q0[1]-q1[1],q0[2]-q1[2],q0[3]-q1[3],q0[4]-q1[4],q0[1]+q1[1],q0[2]+q1[2],q0[3]+q1[3],q0[4]+q1[4]
&#9;&#9;&#9;if a1*a1+b1*b1+c1*c1+d1*d1&gt;a2*a2+b2*b2+c2*c2+d2*d2 then
&#9;&#9;&#9;&#9;q1={-q1[1],-q1[2],-q1[3],-q1[4]}
&#9;&#9;&#9;end
&#9;&#9;&#9;local c0=CF(x0.x,x0.y,x0.z,QuaternionToCFrame(q0))
&#9;&#9;&#9;local dt,time=1,data.time
&#9;&#9;&#9;local timeType=type(time)
&#9;&#9;&#9;if timeType==&quot;number&quot; then
&#9;&#9;&#9;&#9;dt=time
&#9;&#9;&#9;elseif timeType==&quot;function&quot; then
&#9;&#9;&#9;&#9;dt=time(c0,v,x0,x1,v0,v1,q0,q1,w0,w1)--lol
&#9;&#9;&#9;end
&#9;&#9;&#9;data.c0,data.c1,data.x0,data.x1,data.v0,data.v1,data.q0,data.q1,data.w0,data.w1,data.t0,data.t1,data.tweening=c0,v,x0,x1,v0*dt,v1*dt,q0,q1,Qpow(w0,dt),Qpow(w1,dt),timeNow,timeNow+dt,true
&#9;&#9;else
&#9;&#9;&#9;print(&quot;A value named &quot;..tostring(i)..&quot; has not yet been created.&quot;)
&#9;&#9;end
&#9;end,
})
lib.CFrameTweens = CFrameTweens

local function updateTweens(timeNow)
&#9;for i,data in next,TweenData do
&#9;&#9;local f,t0,t1=data.update,data.t0,data.t1
&#9;&#9;if f then
&#9;&#9;&#9;if data.tweening then
&#9;&#9;&#9;&#9;if timeNow&gt;t0 and timeNow&lt;t1 then
&#9;&#9;&#9;&#9;&#9;f(BezierPosition(data.x0,data.x1,data.v0,data.v1,(timeNow-t0)/(t1-t0)))
&#9;&#9;&#9;&#9;elseif timeNow&gt;=t1 then
&#9;&#9;&#9;&#9;&#9;f(data.x1)
&#9;&#9;&#9;&#9;&#9;data.tweening=false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;elseif timeNow&lt;=t0 then
&#9;&#9;&#9;&#9;data.tweening=true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end
lib.updateTweens = updateTweens

local function updateQuaternionTweens(timeNow)
&#9;for i,data in next,QuaternionTweenData do
&#9;&#9;local f,t0,t1=data.update,data.t0,data.t1
&#9;&#9;if f then
&#9;&#9;&#9;if data.tweening then
&#9;&#9;&#9;&#9;if timeNow&gt;t0 and timeNow&lt;t1 then
&#9;&#9;&#9;&#9;&#9;f(BezierRotation(data.q0,data.q1,data.w0,data.w1,(timeNow-t0)/(t1-t0)))
&#9;&#9;&#9;&#9;elseif timeNow&gt;=t1 then
&#9;&#9;&#9;&#9;&#9;f(data.q1)
&#9;&#9;&#9;&#9;&#9;data.tweening=false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;elseif timeNow&lt;=t0 then
&#9;&#9;&#9;&#9;data.tweening=true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end
lib.updateQuaternionTweens = updateQuaternionTweens

local function updateCFrameTweens(timeNow)
&#9;for i,data in next,CFrameTweenData do
&#9;&#9;local f,t0,t1=data.update,data.t0,data.t1
&#9;&#9;if f then
&#9;&#9;&#9;if data.tweening then
&#9;&#9;&#9;&#9;if timeNow&gt;t0 and timeNow&lt;t1 then
&#9;&#9;&#9;&#9;&#9;local t=(timeNow-t0)/(t1-t0)
&#9;&#9;&#9;&#9;&#9;local p=BezierPosition(data.x0,data.x1,data.v0,data.v1,t)
&#9;&#9;&#9;&#9;&#9;f(CF(p.x,p.y,p.z,QuaternionToCFrame(BezierRotation(data.q0,data.q1,data.w0,data.w1,t))))
&#9;&#9;&#9;&#9;elseif timeNow&gt;=t1 then
&#9;&#9;&#9;&#9;&#9;f(data.c1)
&#9;&#9;&#9;&#9;&#9;data.tweening=false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;elseif timeNow&lt;=t0 then
&#9;&#9;&#9;&#9;data.tweening=true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end
lib.updateCFrameTweens = updateCFrameTweens

local function newTween(name,value,updateFunction,time)
&#9;TweenData[name]={x0=value,x1=value,v0=value*0,v1=value*0,t0=0,t1=tick(),time=time or 1,update=updateFunction,tweening=false}
&#9;if updateFunction then
&#9;&#9;updateFunction(value)--Just in case c:
&#9;end
end
lib.newTween = newTween

local function newQuaternionTween(name,value,updateFunction,time,autoChoose)
&#9;QuaternionTweenData[name]={q0=value,q1=value,w0=iq,w1=iq,t0=0,t1=tick(),time=time or 1,update=updateFunction,tweening=false,autoChoose=autoChoose==nil or autoChoose}
&#9;if updateFunction then
&#9;&#9;updateFunction(value)--Just in case c:
&#9;end
end
lib.newQuaternionTween = newQuaternionTween

local function newCFrameTween(name,value,updateFunction,time)
&#9;local q={QuaternionFromCFrame(value)}
&#9;CFrameTweenData[name]={c0=value,c1=value,x0=value.p,x1=value.p,v0=iv,v1=iv,q0=q,q1=q,w0=iq,w1=iq,t0=0,t1=tick(),time=time or 1,update=updateFunction,tweening=false}
&#9;if updateFunction then
&#9;&#9;updateFunction(value)--Just in case c:
&#9;end
end
lib.newCFrameTween = newCFrameTween

return lib
-- return {Tweens=Tweens,QuaternionTweens=QuaternionTweens,CFrameTweens=CFrameTweens,updateTweens=updateTweens,updateQuaternionTweens=updateQuaternionTweens,updateCFrameTweens=updateCFrameTweens,newTween=newTween,newQuaternionTween=newQuaternionTween,newCFrameTween=newCFrameTween}
</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX66">
					<Properties>
						<string name="Name">SurfaceNormal</string>
						<ProtectedString name="Source">--By xXxMoNkEyMaNxXx
-- Modified by Quenty

local lib = {}

-- SurfaceNormal.lua

--By xXxMoNkEyMaNxXx
local sqrt=math.sqrt

local Terrain=workspace.Terrain
local GetCell=Terrain.GetCell
local CellCenterToWorld=Terrain.CellCenterToWorld
local WorldToCellPreferSolid=Terrain.WorldToCellPreferSolid

local vec3=Vector3.new
local IdentityVector=vec3()
local dot=IdentityVector.Dot
local cross=IdentityVector.Cross

local mat3=CFrame.new
local IdentityCFrame=mat3()
local ptos=IdentityCFrame.pointToObjectSpace
local vtws=IdentityCFrame.vectorToWorldSpace

--Part geometry data
local UnitaryConvexPlaneMeshes={--I realized that I could make each component of the normal vector dependent on every component of the size using matrices (genius!)
&#9;WedgePart={{vec3(0,-1,0),vec3(0,-0.5,0)},{vec3(0,0,1),vec3(0,0,0.5)},{mat3(0,0,0, 0,0,0, 0,0,1, 0,-1,0),vec3(0,0,0)},{vec3(1,0,0),vec3(0.5,0,0)},{vec3(-1,0,0),vec3(-0.5,0,0)}},
&#9;CornerWedgePart={{vec3(0,-1,0),vec3(0,-0.5,0)},{vec3(1,0,0),vec3(0.5,0,0)},{vec3(0,0,-1),vec3(0,0,-0.5)},{mat3(0,0,0, 0,-1,0, 1,0,0, 0,0,0),vec3(0,0,0)},{mat3(0,0,0, 0,0,0, 0,0,1, 0,1,0),vec3(0,0,0)}},
&#9;Part={{vec3(1,0,0),vec3(0.5,0,0)},{vec3(0,1,0),vec3(0,0.5,0)},{vec3(0,0,1),vec3(0,0,0.5)},{vec3(-1,0,0),vec3(-0.5,0,0)},{vec3(0,-1,0),vec3(0,-0.5,0)},{vec3(0,0,-1),vec3(0,0,-0.5)}}
}

--Terrain geometry data
local TerrainCellSize=vec3(4,4,4)--Support arbitrary stuff BECAUSE I CAN
local TerrainCellOrientations={
&#9;[0]=mat3(0,0,0, 1,0,0, 0,1,0, 0,0,1),
&#9;mat3(0,0,0, 0,0,1, 0,1,0, -1,0,0),
&#9;mat3(0,0,0, -1,0,0, 0,1,0, 0,0,-1),
&#9;mat3(0,0,0, 0,0,-1, 0,1,0, 1,0,0)
}
local TerrainCellBlockUnitaryConvexPlaneMeshes={
&#9;[0]={{vec3(1,0,0),vec3(0.5,0,0)},{vec3(0,1,0),vec3(0,0.5,0)},{vec3(0,0,1),vec3(0,0,0.5)},{vec3(-1,0,0),vec3(-0.5,0,0)},{vec3(0,-1,0),vec3(0,-0.5,0)},{vec3(0,0,-1),vec3(0,0,-0.5)}},
&#9;{{vec3(1,0,0),vec3(0.5,0,0)},{vec3(-1,0,0),vec3(-0.5,0,0)},{vec3(0,-1,0),vec3(0,-0.5,0)},{vec3(0,0,-1),vec3(0,0,-0.5)},{mat3(0,0,0, 0,0,0, 0,0,1, 0,1,0),vec3(0,0,0)}},
&#9;{{vec3(1,0,0),vec3(0.5,0,0)},{vec3(0,-1,0),vec3(0,-0.5,0)},{vec3(0,0,-1),vec3(0,0,-0.5)},{mat3(0,0,0, 0,-1,-1, 1,0,1, 1,1,0),vec3(0.5,-0.5,-0.5)/3}},
&#9;{{vec3(1,0,0),vec3(0.5,0,0)},{vec3(0,1,0),vec3(0,0.5,0)},{vec3(0,0,1),vec3(0,0,0.5)},{vec3(-1,0,0),vec3(-0.5,0,0)},{vec3(0,-1,0),vec3(0,-0.5,0)},{vec3(0,0,-1),vec3(0,0,-0.5)},{mat3(0,0,0, 0,-1,-1, 1,0,1, 1,1,0),vec3(-0.5,0.5,0.5)/3}},
&#9;{{vec3(1,0,0),vec3(0.5,0,0)},{vec3(0,1,0),vec3(0,0.5,0)},{vec3(0,-1,0),vec3(0,-0.5,0)},{vec3(0,0,-1),vec3(0,0,-0.5)},{mat3(0,0,0, 0,0,-1, 0,0,0, 1,0,0),vec3(0,0,0)}}
}

--Returns:
--Index of closest plane to p
local function ClosestNormalVector(p,planes)
&#9;local best_d=-math.huge
&#9;local best_i
&#9;for i=1,#planes do
&#9;&#9;local plane=planes[i]
&#9;&#9;local d=dot(plane[1],p-plane[2])
&#9;&#9;if d&gt;best_d then
&#9;&#9;&#9;best_i,best_d=i,d
&#9;&#9;end
&#9;end
&#9;return best_i
end
lib.ClosestNormalVector = ClosestNormalVector

--Returns:
--ConvexPlaneMesh in local coordinates
--CFrame that can be used to convert to world coordinates
--Scale that was used (not sure how it could be useful to return it)
local function ConvexPlaneMesh(part,point)
&#9;local UCPM
&#9;local partCFrame,partSize=part.CFrame,part.Size
&#9;if part.ClassName==&quot;Terrain&quot; then
&#9;&#9;local CellGridLocation=WorldToCellPreferSolid(part,vec3(point.x,point.y-1e-5,point.z))--Ugly floating point fix.  Alternatively, one could check the distance to the surrounding cells&apos; CPM, and use the closest one, but I don&apos;t feel like it.
&#9;&#9;local CellMaterial,CellBlock,CellOrientation=GetCell(part,CellGridLocation.x,CellGridLocation.y,CellGridLocation.z)
&#9;&#9;UCPM=TerrainCellBlockUnitaryConvexPlaneMeshes[CellBlock.Value]
&#9;&#9;partCFrame=TerrainCellOrientations[CellOrientation.Value]+CellCenterToWorld(part,CellGridLocation.x,CellGridLocation.y,CellGridLocation.z)
&#9;&#9;partSize=TerrainCellSize
&#9;else
&#9;&#9;UCPM=UnitaryConvexPlaneMeshes[part.ClassName] or UnitaryConvexPlaneMeshes.Part--Trusses, SpawnLocations, etc.
&#9;end
&#9;local CPM={}
&#9;for i=1,#UCPM do
&#9;&#9;local plane=UCPM[i]
&#9;&#9;CPM[i]={(plane[1]*partSize).unit,plane[2]*partSize}
&#9;end
&#9;return CPM,partCFrame,partSize
end
lib.ConvexPlaneMesh = ConvexPlaneMesh


local function NormalVector(part,point)
&#9;if part.ClassName==&quot;Part&quot; and (part.Shape==Enum.PartType.Ball or part.Shape==Enum.PartType.Cylinder) then
&#9;&#9;return vtws(part.CFrame,ptos(part.CFrame,point).unit)--A bit simpler than the other ones.  Just a bit.
&#9;--[[
&#9;elseif part.ClassName==&quot;Part&quot; and part.Shape==Enum.PartType.Cylinder then
&#9;&#9;local Point=ptos(part.CFrame,point)
&#9;&#9;if Point.x*Point.x&gt;Point.y*Point.y+Point.z*Point.z then
&#9;&#9;&#9;return vtws(part.CFrame,Vector3.new(Point.x&lt;0 and -1 or 1,0,0))
&#9;&#9;else
&#9;&#9;&#9;return vtws(part.CFrame,(Point*Vector3.new(0,1,1)).unit)
&#9;&#9;end
&#9;--]]
&#9;else
&#9;&#9;local CPM,partCFrame=ConvexPlaneMesh(part,point)
&#9;&#9;local PlaneIndex=ClosestNormalVector(ptos(partCFrame,point),CPM)
&#9;&#9;if PlaneIndex then
&#9;&#9;&#9;return vtws(partCFrame,CPM[PlaneIndex][1])
&#9;&#9;else
&#9;&#9;&#9;return IdentityVector--Dead code unless the tables are tampered with
&#9;&#9;end
&#9;end
end
lib.NormalVector = NormalVector

--Returns:
--Closest point on planes to p
--Distance to planes from p (p is inside if this is negative)
--Index of closest plane to p
local function ClosestPointOnCPM(p,planes)
&#9;local best_d=-math.huge
&#9;local best_i
&#9;local AboveCount=0
&#9;local AbovePlanes={}
&#9;local PlaneIndices={}
&#9;local DistanceAbove={}
&#9;local ConstrainedPoints={}
&#9;for i=1,#planes do
&#9;&#9;local plane=planes[i]
&#9;&#9;local n=plane[1]
&#9;&#9;local d=dot(n,p-plane[2])
&#9;&#9;if d&gt;best_d then
&#9;&#9;&#9;best_i,best_d=i,d
&#9;&#9;end
&#9;&#9;if d&gt;0 then
&#9;&#9;&#9;AboveCount=AboveCount+1
&#9;&#9;&#9;AbovePlanes[AboveCount]=plane
&#9;&#9;&#9;PlaneIndices[AboveCount]=i
&#9;&#9;&#9;DistanceAbove[AboveCount]=d
&#9;&#9;&#9;ConstrainedPoints[AboveCount]=p-n*d
&#9;&#9;end
&#9;end
&#9;if #AbovePlanes&gt;0 then
&#9;&#9;local SortedData={}--Plane index and DistanceAbove sorted by distance above from greatest to least
&#9;&#9;for i1=1,AboveCount do
&#9;&#9;&#9;local ConstrainedPoint=ConstrainedPoints[i1]
&#9;&#9;&#9;local IsOnPlane=true
&#9;&#9;&#9;for i2=1,AboveCount do
&#9;&#9;&#9;&#9;if i1~=i2 then
&#9;&#9;&#9;&#9;&#9;local plane=AbovePlanes[i2]
&#9;&#9;&#9;&#9;&#9;if dot(plane[1],ConstrainedPoint-plane[2])&gt;0 then
&#9;&#9;&#9;&#9;&#9;&#9;IsOnPlane=false
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;local d=DistanceAbove[i1]
&#9;&#9;&#9;if IsOnPlane then
&#9;&#9;&#9;&#9;return ConstrainedPoint,d,PlaneIndices[i1]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;local Unsorted=true
&#9;&#9;&#9;&#9;for i=#SortedData,1,-1 do
&#9;&#9;&#9;&#9;&#9;local Data=SortedData[i]
&#9;&#9;&#9;&#9;&#9;if d&gt;Data[2] then
&#9;&#9;&#9;&#9;&#9;&#9;if i&lt;3 then --Only keep the top 3
&#9;&#9;&#9;&#9;&#9;&#9;&#9;SortedData[i+1]=Data
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;Unsorted=false
&#9;&#9;&#9;&#9;&#9;&#9;SortedData[i+1]={PlaneIndices[i1],d}
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if Unsorted then
&#9;&#9;&#9;&#9;&#9;SortedData[1]={PlaneIndices[i1],d}
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #SortedData==2 then
&#9;&#9;&#9;local Data1,Data2=SortedData[1],SortedData[2]
&#9;&#9;&#9;local plane1,plane2=planes[Data1[1]],planes[Data2[1]]
&#9;&#9;&#9;local n1,n2=plane1[1],plane2[1]
&#9;&#9;&#9;local d1,d2=Data1[2],Data2[2]
&#9;&#9;&#9;--Closest point to p on the intersection of the 2 planes
&#9;&#9;&#9;local w=dot(n1,n2)
&#9;&#9;&#9;local n3=cross(n1,n2)--Appears to not need to be unit length
&#9;&#9;&#9;--local ClosestPoint=(dot(n1,plane1[2])*cross(n2,n3)+dot(n2,plane2[2])*cross(n3,n1)+dot(n3,p)*n3)/(n1.x*n2.y*n3.z-n1.x*n3.y*n2.z-n2.x*n1.y*n3.z+n2.x*n3.y*n1.z+n3.x*n1.y*n2.z-n3.x*n2.y*n1.z)
&#9;&#9;&#9;--return ClosestPoint,(p-ClosestPoint).magnitude,Data1[1]
&#9;&#9;&#9;--Using geometry and triple product simplifications...
&#9;&#9;&#9;return (dot(n1,plane1[2])*(n1-n2*w)+dot(n2,plane2[2])*(n2-n1*w)+dot(n3,p)*n3)/dot(n3,n3),sqrt((d1*d1+d2*d2-2*w*d1*d2)/(1-w*w)),Data1[1]
&#9;&#9;elseif #SortedData==3 then
&#9;&#9;&#9;local Data1,Data2,Data3=SortedData[1],SortedData[2],SortedData[3]
&#9;&#9;&#9;local plane1,plane2,plane3=planes[Data1[1]],planes[Data2[1]],planes[Data3[1]]
&#9;&#9;&#9;local n1,n2,n3=plane1[1],plane2[1],plane3[1]
&#9;&#9;&#9;--The intersection of the 3 planes is the closest point
&#9;&#9;&#9;local ClosestPoint=(dot(n1,plane1[2])*cross(n2,n3)+dot(n2,plane2[2])*cross(n3,n1)+dot(n3,plane3[2])*cross(n1,n2))/(n1.x*n2.y*n3.z-n1.x*n3.y*n2.z-n2.x*n1.y*n3.z+n2.x*n3.y*n1.z+n3.x*n1.y*n2.z-n3.x*n2.y*n1.z) --determinant pls. I didn&apos;t want to choose between dot(n1,cross(n2,n3)) and the other cyclic equivalents...
&#9;&#9;&#9;return ClosestPoint,(p-ClosestPoint).magnitude,Data1[1]
&#9;&#9;else
&#9;&#9;&#9;print&apos;This should never run&apos;
&#9;&#9;&#9;return p-planes[SortedData[1][1]]*SortedData[1][2],SortedData[1][2],SortedData[1][1]
&#9;&#9;end
&#9;else
&#9;&#9;return p-planes[best_i][1]*best_d,best_d,best_i
&#9;end
end

local function GetSurfaceIdFromNormalRelativeToCFrame(RotMatrix, SurfaceNormal)
&#9;--- Basically, used to get a surfacenormal Id given the RotMatrix and a SurfaceNormal from the RotMatrix. 

&#9;-- May be super picky. SurfaceNormal must be exact, and a unit value.
&#9;-- Also returns the direction (Positive or negative).

&#9;local X, Y, Z, RightX, UpX, BackX, 
&#9;               RightY, UpY, BackY, 
&#9;               RightZ, UpZ, BackZ = RotMatrix:components()
&#9;
&#9;local RightVector = Vector3.new(RightX, RightY, RightZ)
&#9;local LeftVector = -RightVector
&#9;local UpVector = Vector3.new(UpX, UpY, UpZ)
&#9;local DownVector = -UpVector
&#9;local BackVector = Vector3.new(BackX, BackY, BackZ)
&#9;local FrontVector = -BackVector

&#9;if RightVector == SurfaceNormal then
&#9;&#9;return Enum.NormalId.Right, 1
&#9;elseif LeftVector == SurfaceNormal then
&#9;&#9;return Enum.NormalId.Left, -1
&#9;elseif UpVector == SurfaceNormal then
&#9;&#9;return Enum.NormalId.Top, 1
&#9;elseif DownVector == SurfaceNormal then
&#9;&#9;return Enum.NormalId.Bottom, -1
&#9;elseif BackVector == SurfaceNormal then
&#9;&#9;return Enum.NormalId.Back, 1
&#9;elseif FrontVector == SurfaceNormal then
&#9;&#9;return Enum.NormalId.Front, -1
&#9;else
&#9;&#9;return nil
&#9;end
end
lib.GetSurfaceIdFromNormalRelativeToCFrame = GetSurfaceIdFromNormalRelativeToCFrame



--Returns:
--Closest point on part to point
--Distance to that point (point to surface)
--Normal at that point (should give the same result as NormalVector(part,point))
--Plane definition {Normal, PointOnPlane}  (Which could be reconstructed based upon data)
local function ClosestPointOnPart(part,point) --Will not work correctly with terrain in most cases due to its complexity, feel free to make it slower.
&#9;if part.ClassName==&quot;Part&quot; and (part.Shape==Enum.PartType.Ball or part.Shape==Enum.PartType.Cylinder) then
&#9;&#9;--I was going to find the closest point on an ellipsoid just for the hell of it, but it turns out you need to find the roots of a degree 6 polynomial...
&#9;&#9;local Normal=ptos(part.CFrame,point).unit --Why not
&#9;&#9;local ClosestPoint=part.CFrame*(Normal*part.Size) --lolhack umad
&#9;&#9;return ClosestPoint, (point-ClosestPoint).magnitude, vtws(part.CFrame,Normal), {Normal, ClosestPoint}
&#9;else
&#9;&#9;local CPM,partCFrame=ConvexPlaneMesh(part,point)
&#9;&#9;local ClosestPoint,DistanceToPoint,PlaneIndex=ClosestPointOnCPM(ptos(partCFrame,point),CPM)
&#9;&#9;return partCFrame*ClosestPoint,DistanceToPoint,vtws(partCFrame,CPM[PlaneIndex][1]), CPM[PlaneIndex]
&#9;end
end
lib.ClosestPointOnPart = ClosestPointOnPart


local function Coplanar(PlaneOne, PlaneTwo)
&#9;--[[
&#9;&#9;abs(n1:Dot(p2-p1))&lt;spaghetti
&#9;[6:11:04 PM] Rhys: and abs(n2:Dot(p1-p2))&lt;spaghetti
&#9;[6:11:12 PM] Rhys: means the planes are about the same
&#9;[6:11:15 PM] Rhys: within spaghetti
&#9;[6:11:28 PM | Edited 6:11:34 PM] Rhys: where the two planes are {n1,p1} and {n2,p2}
&#9;]]

end
--[[
local Terrain=workspace.Terrain
local GetCell=Terrain.GetCell
local CellCenterToWorld=Terrain.CellCenterToWorld
local WorldToCellPreferSolid=Terrain.WorldToCellPreferSolid
 
local vec3=Vector3.new
local IdentityVector=vec3()
local dot=IdentityVector.Dot
local cross=IdentityVector.Cross
 
local mat3=CFrame.new
local IdentityCFrame=mat3()
local ptos=IdentityCFrame.pointToObjectSpace
local vtws=IdentityCFrame.vectorToWorldSpace
 
--Returns:
--Index of closest plane to p
--Distance to surface from p
local function ClosestNormalVector(p,planes)
&#9;local best_d=-math.huge
&#9;local best_i
&#9;for i=1,#planes do
&#9;&#9;local plane=planes[i]
&#9;&#9;local d=dot(plane[1],p-plane[2])
&#9;&#9;if d&gt;best_d then
&#9;&#9;&#9;best_i,best_d=i,d
&#9;&#9;end
&#9;end
&#9;return best_i,best_d
end
 
--Part geometry data
local UnitaryConvexPlaneMeshes={--I realized that I could make each component of the normal vector dependent on every component of the size using matrices (genius!)
&#9;WedgePart={{vec3(0,-1,0),vec3(0,-0.5,0)},{vec3(0,0,1),vec3(0,0,0.5)},{mat3(0,0,0, 0,0,0, 0,0,1, 0,-1,0),vec3(0,0,0)},{vec3(1,0,0),vec3(0.5,0,0)},{vec3(-1,0,0),vec3(-0.5,0,0)}},
&#9;CornerWedgePart={{vec3(0,-1,0),vec3(0,-0.5,0)},{vec3(1,0,0),vec3(0.5,0,0)},{vec3(0,0,-1),vec3(0,0,-0.5)},{mat3(0,0,0, 0,-1,0, 1,0,0, 0,0,0),vec3(0,0,0)},{mat3(0,0,0, 0,0,0, 0,0,1, 0,1,0),vec3(0,0,0)}},
&#9;Part={{vec3(1,0,0),vec3(0.5,0,0)},{vec3(0,1,0),vec3(0,0.5,0)},{vec3(0,0,1),vec3(0,0,0.5)},{vec3(-1,0,0),vec3(-0.5,0,0)},{vec3(0,-1,0),vec3(0,-0.5,0)},{vec3(0,0,-1),vec3(0,0,-0.5)}}
}
 
--Terrain geometry data
local TerrainCellSize=vec3(4,4,4)--Support arbitrary stuff BECAUSE I CAN
local TerrainCellOrientations={
&#9;[0]=mat3(0,0,0, 1,0,0, 0,1,0, 0,0,1),
&#9;mat3(0,0,0, 0,0,1, 0,1,0, -1,0,0),
&#9;mat3(0,0,0, -1,0,0, 0,1,0, 0,0,-1),
&#9;mat3(0,0,0, 0,0,-1, 0,1,0, 1,0,0)
}
local TerrainCellBlockUnitaryConvexPlaneMeshes={
&#9;[0]={{vec3(1,0,0),vec3(0.5,0,0)},{vec3(0,1,0),vec3(0,0.5,0)},{vec3(0,0,1),vec3(0,0,0.5)},{vec3(-1,0,0),vec3(-0.5,0,0)},{vec3(0,-1,0),vec3(0,-0.5,0)},{vec3(0,0,-1),vec3(0,0,-0.5)}},
&#9;{{vec3(1,0,0),vec3(0.5,0,0)},{vec3(-1,0,0),vec3(-0.5,0,0)},{vec3(0,-1,0),vec3(0,-0.5,0)},{vec3(0,0,-1),vec3(0,0,-0.5)},{mat3(0,0,0, 0,0,0, 0,0,1, 0,1,0),vec3(0,0,0)}},
&#9;{{vec3(1,0,0),vec3(0.5,0,0)},{vec3(0,-1,0),vec3(0,-0.5,0)},{vec3(0,0,-1),vec3(0,0,-0.5)},{mat3(0,0,0, 0,-1,-1, 1,0,1, 1,1,0),vec3(0.5,-0.5,-0.5)/3}},
&#9;{{vec3(1,0,0),vec3(0.5,0,0)},{vec3(0,1,0),vec3(0,0.5,0)},{vec3(0,0,1),vec3(0,0,0.5)},{vec3(-1,0,0),vec3(-0.5,0,0)},{vec3(0,-1,0),vec3(0,-0.5,0)},{vec3(0,0,-1),vec3(0,0,-0.5)},{mat3(0,0,0, 0,-1,-1, 1,0,1, 1,1,0),vec3(-0.5,0.5,0.5)/3}},
&#9;{{vec3(1,0,0),vec3(0.5,0,0)},{vec3(0,1,0),vec3(0,0.5,0)},{vec3(0,-1,0),vec3(0,-0.5,0)},{vec3(0,0,-1),vec3(0,0,-0.5)},{mat3(0,0,0, 0,0,-1, 0,0,0, 1,0,0),vec3(0,0,0)}}
}
 
local function NormalVector(part, point)
&#9;--- Returns a unit vector3 of the surface normal
&#9;-- @param Part the part to check
&#9;-- @param point the Point that was hit on the part (probably raycast)
&#9;-- @return The surface normal 

&#9;if part.ClassName==&quot;Part&quot; and (part.Shape==Enum.PartType.Ball or part.Shape==Enum.PartType.Cylinder) then
&#9;&#9;return vtws(part.CFrame,ptos(part.CFrame,point).unit) --A bit simpler than the other ones.  Just a bit.
&#9;else
&#9;&#9;local partCFrame,partSize=part.CFrame,part.Size
&#9;&#9;local UCPM
&#9;&#9;if part.ClassName==&quot;Terrain&quot; then
&#9;&#9;&#9;local CellGridLocation=WorldToCellPreferSolid(part,vec3(point.x,point.y-1e-5,point.z))--Ugly floating point fix.  Alternatively, one could check the distance to the surrounding cells&apos; CPM, and use the closest one, but I don&apos;t feel like it.
&#9;&#9;&#9;local CellMaterial,CellBlock,CellOrientation=GetCell(part,CellGridLocation.x,CellGridLocation.y,CellGridLocation.z)
&#9;&#9;&#9;partCFrame=TerrainCellOrientations[CellOrientation.Value]+CellCenterToWorld(part,CellGridLocation.x,CellGridLocation.y,CellGridLocation.z)
&#9;&#9;&#9;partSize=TerrainCellSize
&#9;&#9;&#9;UCPM=TerrainCellBlockUnitaryConvexPlaneMeshes[CellBlock.Value]
&#9;&#9;else
&#9;&#9;&#9;UCPM=UnitaryConvexPlaneMeshes[part.ClassName] or UnitaryConvexPlaneMeshes.Part--Trusses, SpawnLocations, etc.
&#9;&#9;end
&#9;&#9;local CPM={}
&#9;&#9;for i=1,#UCPM do
&#9;&#9;&#9;local plane=UCPM[i]
&#9;&#9;&#9;CPM[i]={(plane[1]*partSize).unit,plane[2]*partSize}
&#9;&#9;end
&#9;&#9;local PlaneIndex,DistanceToSurface=ClosestNormalVector(ptos(partCFrame,point),CPM)
&#9;&#9;if PlaneIndex then
&#9;&#9;&#9;return vtws(partCFrame,CPM[PlaneIndex][1])
&#9;&#9;else
&#9;&#9;&#9;return IdentityVector--Dead code unless the tables are tampered with
&#9;&#9;end
&#9;end
end
lib.NormalVector = NormalVector
--]]
return lib</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="Backpack" referent="RBX67">
				<Properties>
					<string name="Name">Utility</string>
				</Properties>
				<Item class="ModuleScript" referent="RBX68">
					<Properties>
						<string name="Name">ExperienceCalculator</string>
						<ProtectedString name="Source">local ExperienceCalculator = {}
local ExperienceFactor = 200

local function GetLevelFromExperience(Experience)
&#9;-- http://stackoverflow.com/questions/6954874/php-game-formula-to-calculate-a-level-based-on-exp
&#9;
&#9;return math.floor((ExperienceFactor + math.sqrt(ExperienceFactor * ExperienceFactor - 4 * ExperienceFactor * (-Experience)))/ (2 * ExperienceFactor))
end
ExperienceCalculator.GetLevelFromExperience = GetLevelFromExperience

local function GetExperienceForNextLevel(CurrentExperience)
&#9;if CurrentExperience - 1 == CurrentExperience then -- Math.huge
&#9;&#9;return 0
&#9;end
&#9;
&#9;local NextLevel = GetLevelFromExperience(CurrentExperience)+1
&#9;local ExperienceRequired = ExperienceFactor*(NextLevel*(1+NextLevel))

&#9;return ExperienceRequired - CurrentExperience
end
ExperienceCalculator.GetExperienceForNextLevel = GetExperienceForNextLevel

return ExperienceCalculator</ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX69">
					<Properties>
						<string name="Name">qTime</string>
						<ProtectedString name="Source">-- qTime.lua
-- Library handles time based parsing / operations. Untested. Based off of PHP.

-- @author Quenty
-- Last modified February 1st, 2014

local lib = {}

--- STATIC DATA ---
local MonthNames         = {&quot;January&quot;; &quot;February&quot;; &quot;March&quot;; &quot;April&quot;; &quot;May&quot;; &quot;June&quot;; &quot;July&quot;; &quot;August&quot;; &quot;September&quot;; &quot;October&quot;; &quot;November&quot;; &quot;December&quot;;}
local MonthNamesShort    = {&quot;Jan&quot;;     &quot;Feb&quot;;      &quot;Mar&quot;;   &quot;Apr&quot;;   &quot;May&quot;; &quot;Jun&quot;;  &quot;Jul&quot;;  &quot;Aug&quot;;    &quot;Sep&quot;;       &quot;Oct&quot;;     &quot;Nov&quot;;      &quot;Dec&quot;;}
local DaysInMonth        = { 31;        28;         31;      30;      31;    30;     31;     31;       30;          31; 30; 31} -- Before reading this table, call FixLeapYear(Year)
local DaysOfTheWeek      = {&quot;Sunday&quot;; &quot;Monday&quot;; &quot;Tuesday&quot;; &quot;Wednesday&quot;; &quot;Thursday&quot;; &quot;Friday&quot;; &quot;Saturday&quot;;}
local DaysOfTheWeekShort = {&quot;Sun&quot;;    &quot;Mon&quot;;    &quot;Tues&quot;;    &quot;Weds&quot;;      &quot;Thurs&quot;;    &quot;Fri&quot;;    &quot;Sat&quot;;}

-- UTILITY --

local function FixLeapYear(Year)
&#9;--- Fixes The DaysInMonth table, given a year. 

&#9;if Year % 4 == 0 then
&#9;&#9;DaysInMonth[2] = 29;
&#9;else
&#9;&#9;DaysInMonth[2] = 28;
&#9;end
end

--- LIBRARY ---

function lib.GetSecond(CurrentTime)
&#9;local TSec = CurrentTime % 86400
&#9;local CurrentSecond = math.floor(TSec%60)

&#9;return CurrentSecond;
end

function lib.GetMinute(CurrentTime)
&#9;local TSec = CurrentTime % 86400
&#9;local CurrentMinute = math.floor((TSec/60)%60)
&#9;return CurrentMinute;
end

function lib.GetHour(CurrentTime)
&#9;local TSec = CurrentTime % 86400
&#9;local CurrentHour = math.floor((TSec/60/60)%24)
&#9;return CurrentHour;
end

function lib.GetDay(CurrentTime)
&#9;local CurrentDay = math.ceil(CurrentTime/60/60/24%365.25)
&#9;return CurrentDay;
end

function lib.GetYear(CurrentTime) 
&#9;local CurrentYear = math.floor(CurrentTime/60/60/24/365.25+1970)

&#9;return CurrentYear
end

function lib.GetYearShort(CurrentTime)
&#9;local Year = lib.GetYear(CurrentTime);
&#9;return Year % 100
end

function lib.GetYearShortFormatted(CurrentTime) 
&#9;local ShortYear = lib.GetYearShort(CurrentTime);
&#9;if ShortYear &lt; 10 then
&#9;&#9;ShortYear = &quot;0&quot;..ShortYear
&#9;end
&#9;return ShortYear
end

function lib.GetMonth(CurrentTime)
&#9;local Year = lib.GetYear(CurrentTime)
&#9;local Day = lib.GetDay(CurrentTime)
&#9;local Month;
&#9;
&#9;FixLeapYear(Year)
&#9;
&#9;for Index=1, #DaysInMonth do
&#9;&#9;if Day &gt; DaysInMonth[Index] then
&#9;&#9;&#9;Day = Day - DaysInMonth[Index]
&#9;&#9;else
&#9;&#9;&#9;return Index
&#9;&#9;end
&#9;end
end

function lib.GetFormattedMonth(CurrentTime)
&#9;local Month = lib.GetMonth(CurrentTime);
&#9;if Month &lt; 10 then
&#9;&#9;Month = &quot;0&quot;..Month;
&#9;end
&#9;
&#9;return Month;
end

function lib.GetDayOfTheMonth(CurrentTime)
&#9;local Year = lib.GetYear(CurrentTime)
&#9;local Day = lib.GetDay(CurrentTime)
&#9;local DayOfTheMonth;
&#9;
&#9;FixLeapYear(Year)

&#9;for Index=1, #DaysInMonth do
&#9;&#9;if Day &gt; DaysInMonth[Index] then
&#9;&#9;&#9;Day = Day - DaysInMonth[Index]
&#9;&#9;else
&#9;&#9;&#9;return Day
&#9;&#9;end
&#9;end
end

function lib.GetFormattedDayOfTheMonth(CurrentTime)
&#9;local DayOfTheMonth = lib.GetDayOfTheMonth(CurrentTime);
&#9;
&#9;if DayOfTheMonth &lt; 10 then
&#9;&#9;DayOfTheMonth = &quot;0&quot;..DayOfTheMonth;
&#9;end
&#9;
&#9;return DayOfTheMonth;
end

function lib.GetMonthName(CurrentTime)
&#9;return MonthNames[lib.GetMonth(CurrentTime)]
end

function lib.GetMonthNameShort(CurrentTime)
&#9;return MonthNamesShort[lib.GetMonth(CurrentTime)]
end

function lib.GetJulianDate(CurrentTime)
&#9;local Month = lib.GetMonth(CurrentTime)
&#9;local Year = lib.GetYear(CurrentTime)
&#9;local Day = lib.GetDay(CurrentTime)
&#9;
&#9;local A = (14-Month) / 12
&#9;local Y = Year + 4800 - A
&#9;local M = Month + 12 * A - 3
&#9;
&#9;JulianDay = Day + ((153 * M + 2) / 5) + 365 * Y + (Y/4) - (Y/100) + (Y/400) - 32045
&#9;
&#9;--[[local JulianDay = (Day 
&#9;+ ((153 * (Month + 12 * ((14 - Month) / 12 ) - 3) + 2) / 5)
&#9;+ (365 * (Year + 4800 - ((14 - Month) / 12)))
&#9;+ ((Year + 4800 - ((14 - Month) / 12)) / 4)
&#9;+ ((Year + 4800 - ((14 - Month) / 12)) / 100)
&#9;+ ((Year + 4800 - ((14 - Month) / 12)) / 400)
&#9;- 32045);--]]

&#9;return JulianDay
end

function lib.GetDayOfTheWeek(CurrentTime)
&#9;
&#9;local JulianTime = lib.GetJulianDate(CurrentTime);
&#9;
&#9;return math.floor(JulianTime) % 7
end

function lib.GetDayOfTheWeekName(CurrentTime)
&#9;local DayOfTheWeek = lib.GetDayOfTheWeek(CurrentTime)
&#9;local Name = DaysOfTheWeek[DayOfTheWeek]
&#9;
&#9;return Name
end

function lib.GetDayOfTheWeekNameShort(CurrentTime) 
&#9;local DayOfTheWeek = lib.GetDayOfTheWeek(CurrentTime)
&#9;local Name = DaysOfTheWeekShort[DayOfTheWeek] 
&#9;
&#9;return Name
end

function lib.GetOrdinalOfNumber(Number) -- Returns st, nd (Like 1st, 2nd)
&#9;local TenRemainder = Number % 10;
&#9;local HundredRemainder = Number % 100
&#9;
&#9;if HundredRemainder &gt;= 10 and HundredRemainder &lt;= 20 then
&#9;&#9;return &quot;th&quot;;
&#9;end
&#9;
&#9;if TenRemainder == 1 then
&#9;&#9;return &quot;st&quot;;
&#9;elseif TenRemainder == 2 then
&#9;&#9;return &quot;nd&quot;;
&#9;elseif TenRemainder == 3 then
&#9;&#9;return &quot;rd&quot;;
&#9;else
&#9;&#9;return &quot;th&quot;;
&#9;end
end

function lib.GetDayOfTheMonthOrdinal(CurrentTime)
&#9;local DayOfTheMonth = lib.GetDayOfTheMonth(CurrentTime)

&#9;return lib.GetOrdinalOfNumber(DayOfTheMonth);
end

function lib.GetFormattedSecond(CurrentTime)
&#9;local CurrentSecond = lib.GetSecond(CurrentTime)
&#9;if CurrentSecond &lt; 10 then
&#9;&#9;CurrentSecond = &quot;0&quot;..CurrentSecond
&#9;end
&#9;return CurrentSecond
end

function lib.GetFormattedMinute(CurrentTime)
&#9;local CurrentMinute = lib.GetMinute(CurrentTime)

&#9;if CurrentMinute &lt; 10 then
&#9;&#9;CurrentMinute = &quot;0&quot;.. CurrentMinute
&#9;end

&#9;return CurrentMinute
end

function lib.GetRegularHour(CurrentTime)
&#9;local CurrentHour = lib.GetHour(CurrentTime)

&#9;if CurrentHour &gt; 12 then
&#9;&#9;CurrentHour = CurrentHour - 12
&#9;end

&#9;return CurrentHour
end

function lib.GetHourFormatted(CurrentTime)
&#9;local CurrentHour = lib.GetHour(CurrentTime)

&#9;if CurrentHour &lt; 10 then
&#9;&#9;CurrentHour = &quot;0&quot;..CurrentHour;
&#9;end

&#9;return CurrentHour
end

function lib.GetRegularHourFormatted(CurrentTime)
&#9;local CurrentHour = lib.GetRegularHour(CurrentTime)

&#9;if CurrentHour &lt; 10 then
&#9;&#9;CurrentHour = &quot;0&quot;..CurrentHour
&#9;end

&#9;return CurrentHour;
end

function lib.GetamOrpm(CurrentTime)
&#9;local CurrentHour = lib.GetHour(CurrentTime)

&#9;if CurrentHour &gt; 12 then
&#9;&#9;return &quot;pm&quot;;
&#9;else
&#9;&#9;return &quot;am&quot;;
&#9;end
end

function lib.GetAMorPM(CurrentTime)
&#9;local CurrentHour = lib.GetHour(CurrentTime)

&#9;if CurrentHour &gt; 12 then
&#9;&#9;return &quot;PM&quot;;
&#9;else
&#9;&#9;return &quot;AM&quot;;
&#9;end
end

function lib.GetMilitaryHour(CurrentTime)
&#9;local CurrentHour = lib.GetHour(CurrentTime)

&#9;if CurrentHour &lt; 10 then
&#9;&#9;CurrentHour = &quot;0&quot;..CurrentHour
&#9;end
end

function lib.LeapYear(CurrentTime)
&#9;local Year = lib.GetYear(CurrentTime);

&#9;if Year % 4 == 0 then
&#9;&#9;return 1
&#9;else
&#9;&#9;return 0
&#9;end
end

function lib.GetDaysInMonth(CurrentTime)
&#9;local Month = lib.GetMonth(CurrentTime);
&#9;local Year = lib.GetYear(CurrentTime);

&#9;FixLeapYear(Year)

&#9;return DaysInMonth[Month]
end

local FormatStrings = {
&#9;d = lib.GetFormattedDayOfTheMonth;
&#9;D = lib.GetDayOfTheWeekNameShort;
&#9;j = lib.GetDayOfTheMonth;
&#9;l = lib.GetDayOfTheWeekName;
&#9;N = lib.GetDayOfTheWeek;
&#9;S = lib.GetDayOfTheMonthOrdinal;
&#9;W = lib.GetDayOfTheWeek;
&#9;Z = lib.GetDay;

&#9;--W -- Mmm.. Idk. 
&#9;
&#9;F = lib.GetMonthName;
&#9;m = lib.GetFormattedMonth;
&#9;M = lib.GetMonthNameShort;
&#9;n = lib.GetMonth;
&#9;t = lib.GetDaysInMonth;
&#9;
&#9;L = lib.LeapYear;
&#9;o = lib.GetYear;
&#9;Y = lib.GetYear; -- Screw ISO-8610, it confuses me.
&#9;y = lib.GetYearShortFormatted;
&#9;
&#9;a = lib.GetamOrpm;
&#9;A = lib.GetAMorPM;
&#9;--B -- No one uses it
&#9;g = lib.GetRegularHour;
&#9;G = lib.GetHour;
&#9;h = lib.GetRegularHourFormatted;
&#9;H = lib.GetHourFormatted;
&#9;i = lib.GetFormattedMinute;
&#9;s = lib.GetFormattedSecond;
&#9;
&#9;X = lib.GetJulianDate; -- For testing purposes.
&#9;
&#9;--e -- No way to get Time Zones
&#9;-- I -- Daylight saving time should be added later.
&#9;-- O -- No way to get Time Zones
&#9;-- P -- No way to get Time Zones
&#9;-- T -- No way to get Time Zones
&#9;-- Z -- No way to get Time Zones
&#9;
&#9;-- c -- ISO 8601
&#9;-- r -- No need for formatted dates
&#9;U = time;
}

local MatchString = &quot;[&quot;

for Index, Value in pairs(FormatStrings) do
&#9;MatchString = MatchString..Index
end

MatchString = MatchString..&quot;]&quot;;

function lib.GetFormatedTime(Format, CurrentTime)
&#9;CurrentTime = CurrentTime or tick();
&#9;
&#9;local ReturnString = Format;
&#9;local FormatsRequired = {}
&#9;
&#9;for NewFormat in string.gmatch(Format, MatchString) do
&#9;&#9;FormatsRequired[#FormatsRequired+1] = NewFormat
&#9;end
&#9;
&#9;for _, FormatType in pairs(FormatsRequired) do
&#9;&#9;ReturnString = ReturnString:gsub(FormatType, FormatType:rep(3))
&#9;end
&#9;
&#9;for _, FormatType in pairs(FormatsRequired) do
&#9;&#9;local Replacement = FormatStrings[FormatType](CurrentTime)
&#9;&#9;ReturnString = ReturnString:gsub(FormatType:rep(3), Replacement)
&#9;end
&#9;
&#9;return ReturnString;
end

return lib</ProtectedString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Backpack" referent="RBX70">
			<Properties>
				<string name="Name">App</string>
			</Properties>
			<Item class="ModuleScript" referent="RBX71">
				<Properties>
					<string name="Name">NevermoreEngine</string>
					<ProtectedString name="Source">-- see readme.md
-- @author Quenty

--[[


Update August 16th, 2014
- Any module with the name &quot;Server&quot; in it is not replicated, to prevent people from stealing
  nevermore&apos;s complete source. 


]]

local NevermoreEngine     = {}
local Players             = game:GetService(&quot;Players&quot;)
local ReplicatedStorage   = game:GetService(&quot;ReplicatedStorage&quot;)
local MarketplaceService  = game:GetService(&quot;MarketplaceService&quot;)
local TestService         = game:GetService(&quot;TestService&quot;)
local StarterGui          = game:GetService(&quot;StarterGui&quot;)

local RbxUtility = LoadLibrary(&quot;RbxUtility&quot;)


local ServerStorage      
local ServerScriptService

local Configuration = {&#9;
&#9;Blacklist              = &quot;&quot;; -- Ban list
&#9;ClientName             = &quot;NevermoreClient&quot;;
&#9;CustomCharacters       = false; -- When enabled, allows the client to set Player.Character itself.
&#9;IsClient               = script.Parent ~= nil;
&#9;ReplicatedPackageName  = &quot;NevermoreResources&quot;;
&#9;SoloTestMode           = (game:FindService(&quot;NetworkServer&quot;) == nil and game.PlaceId == 0); -- Are we testing in solo test mode?
&#9;SplashScreen           = true; -- Should a splashscreen be rendered?
&#9;CharacterRespawnTime   = 0.5; -- How long does it take for characters to respawn? Only kept updated on the server-side.
&#9;DataSteamName          = &quot;NevermoreDataStream&quot;;
&#9;NevermoreRequestPrefix = &quot;NevermoreEngineRequest&quot;; -- For network requests, what should it prefix it as?
&#9;EnableFiltering        = false; -- Set Workspace.FilteringEnabled
&#9;ResetPlayerGuiOnSpawn  = false; -- Set StarterGui.ResetPlayerGuiOnSpawn --- NOTE the client script must reparent itself to the PlayerGui
}
Configuration.IsServer = not Configuration.IsClient


-- DO CONFIGURATION STUFF --
if Configuration.EnableFiltering or Workspace.FilteringEnabled then
&#9;Workspace.FilteringEnabled = true
&#9;print(&quot;**** Workspace.FilteringEnabled is enabled&quot;)
end

if not Configuration.ResetPlayerGuiOnSpawn or not StarterGui.ResetPlayerGuiOnSpawn then
&#9;print(&quot;**** StarterGui.ResetPlayerGuiOnSpawn is disabled. No GUI reload mode enabled. &quot;)
&#9;StarterGui.ResetPlayerGuiOnSpawn = false
end

-- SETUP HEADER --
if Configuration.SoloTestMode then
&#9;Configuration.PrintHeader = &quot;[NevermoreEngineSolo] - &quot;
else
&#9;-- print(game:FindService(&quot;NetworkServer&quot;) == nil, game.PlaceId == 0)
&#9;if Configuration.IsServer then
&#9;&#9;Configuration.PrintHeader = &quot;[NevermoreEngine] - &quot;
&#9;else
&#9;&#9;Configuration.PrintHeader = &quot;[NevermoreEngineLocal] - &quot;
&#9;end
end

-- SET AUTOLOADING TO FALSE.
Players.CharacterAutoLoads = false;

-- GET STORAGE UNITS
if not Configuration.IsClient then
&#9;ServerStorage       = game:GetService(&quot;ServerStorage&quot;)
&#9;ServerScriptService = game:GetService(&quot;ServerScriptService&quot;)
end

-- DEBUG -- 
-- print(&quot;script.Parent == &quot; .. tostring(script.Parent))
-- print(Configuration.PrintHeader .. &quot;Nevermore is Loadingg.&quot;)

-----------------------
-- UTILITY FUNCTIONS --
-----------------------

local function WaitForChild(Parent, Name)
&#9;--- Yields until a child is added. Warns after 5 seconds of yield.
&#9;-- @param Parent The parent to wait for the child of
&#9;-- @param Name The name of the child
&#9;-- @return The child found

&#9;local Child = Parent:FindFirstChild(Name)
&#9;local StartTime = tick()
&#9;local Warned = false;
&#9;while not Child do
&#9;&#9;wait(0)
&#9;&#9;Child = Parent:FindFirstChild(Name)
&#9;&#9;if not Warned and StartTime + 5 &lt;= tick() then
&#9;&#9;&#9;Warned = true;
&#9;&#9;&#9;warn(Configuration.PrintHeader .. &quot; &quot; .. Name .. &quot; has not replicated after 5 seconds, may not be able to execute Nevermore.&quot;)
&#9;&#9;end
&#9;end
&#9;return Child
end

local function pack(...)
&#9;--- Packs a tuple into a table and returns it
&#9;-- @return The packed tuple

&#9;return {...}
end

------------------------------
-- Load Dependent Resources --
------------------------------
local NevermoreContainer, ModulesContainer, ApplicationContainer, ReplicatedPackage, DataStreamContainer, EventStreamContainer
do
&#9;local function LoadResource(Parent, ResourceName)
&#9;&#9;--- Loads a resource or errors. Makes sure that a resource is available.
&#9;&#9;-- @param Parent The parent of the resource to load
&#9;&#9;-- @param ResourceName The name of the resource attempting to load

&#9;&#9;local Resource = Parent:FindFirstChild(ResourceName)
&#9;&#9;if not Resource then
&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;Failed to load required resource &apos;&quot; .. ResourceName .. &quot;&apos;, expected at &apos;&quot; .. Parent:GetFullName() .. &quot;&apos;&quot;, 2)
&#9;&#9;&#9;return nil
&#9;&#9;else
&#9;&#9;&#9;return Resource
&#9;&#9;end
&#9;end

&#9;if Configuration.IsServer then
&#9;&#9;-- Load Resources --

&#9;&#9;NevermoreContainer          = LoadResource(ServerScriptService, &quot;Nevermore&quot;)
&#9;&#9;ModulesContainer            = LoadResource(NevermoreContainer, &quot;Modules&quot;)
&#9;&#9;ApplicationContainer        = LoadResource(NevermoreContainer, &quot;App&quot;)

&#9;&#9;-- Create the replicated package --
&#9;&#9;ReplicatedPackage = ReplicatedStorage:FindFirstChild(Configuration.ReplicatedPackageName)
&#9;&#9;if not ReplicatedPackage then
&#9;&#9;&#9;ReplicatedPackage            = Instance.new(&quot;Backpack&quot;)
&#9;&#9;&#9;ReplicatedPackage.Name       = Configuration.ReplicatedPackageName
&#9;&#9;&#9;ReplicatedPackage.Parent     = ReplicatedStorage
&#9;&#9;&#9;ReplicatedPackage.Archivable = false;&#9;&#9;
&#9;&#9;end
&#9;&#9;ReplicatedPackage:ClearAllChildren()

&#9;&#9;DataStreamContainer = ReplicatedPackage:FindFirstChild(&quot;DataStreamContainer&quot;)
&#9;&#9;if not DataStreamContainer then
&#9;&#9;&#9;DataStreamContainer            = Instance.new(&quot;Backpack&quot;)
&#9;&#9;&#9;DataStreamContainer.Name       = &quot;DataStreamContainer&quot;
&#9;&#9;&#9;DataStreamContainer.Parent     = ReplicatedPackage
&#9;&#9;&#9;DataStreamContainer.Archivable = false;
&#9;&#9;end

&#9;&#9;EventStreamContainer = ReplicatedPackage:FindFirstChild(&quot;EventStreamContainer&quot;)
&#9;&#9;if not EventStreamContainer then
&#9;&#9;&#9;EventStreamContainer            = Instance.new(&quot;Backpack&quot;)
&#9;&#9;&#9;EventStreamContainer.Name       = &quot;EventStreamContainer&quot;
&#9;&#9;&#9;EventStreamContainer.Parent     = ReplicatedPackage
&#9;&#9;&#9;EventStreamContainer.Archivable = false;
&#9;&#9;end
&#9;
&#9;&#9;DataStreamContainer:ClearAllChildren()&#9;&#9;
&#9;else
&#9;&#9;-- Handle replication for clients

&#9;&#9;-- Load Resource Package --
&#9;&#9;ReplicatedPackage    = WaitForChild(ReplicatedStorage, Configuration.ReplicatedPackageName)
&#9;&#9;DataStreamContainer  = WaitForChild(ReplicatedPackage, &quot;DataStreamContainer&quot;)
&#9;&#9;EventStreamContainer = WaitForChild(ReplicatedPackage, &quot;EventStreamContainer&quot;)
&#9;end
end

--print(Configuration.PrintHeader .. &quot;Loaded dependent resources module&quot;)
------------------------
-- RESOURCE MANAGMENT --
------------------------
local NetworkingRemoteFunction
local ResouceManager = {} do
&#9;--- Handles resource loading and replication
&#9;local ResourceCache = {}
&#9;local MainResourcesServer, MainResourcesClient

&#9;if Configuration.IsServer then
&#9;&#9;MainResourcesServer = {} -- Resources to load.
&#9;&#9;MainResourcesClient = {}
&#9;else
&#9;&#9;MainResourcesClient = {}
&#9;end

&#9;local function GetDataStreamObject(Name, Parent)
&#9;&#9;--- Products a new DataStream object if it doesn&apos;t already exist, otherwise
&#9;&#9;--  return&apos;s the current datastream.
&#9;&#9;-- @param Name The Name of the DataStream
&#9;&#9;-- @param [Parent] The parent to add to

&#9;&#9;Parent = Parent or DataStreamContainer

&#9;&#9;local DataStreamObject = Parent:FindFirstChild(Name)
&#9;&#9;if not DataStreamObject then
&#9;&#9;&#9;if Configuration.IsServer then
&#9;&#9;&#9;&#9;DataStreamObject            = Instance.new(&quot;RemoteFunction&quot;)
&#9;&#9;&#9;&#9;DataStreamObject.Name       = Name;
&#9;&#9;&#9;&#9;DataStreamObject.Archivable = false;
&#9;&#9;&#9;&#9;DataStreamObject.Parent     = Parent
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;DataStreamObject = WaitForChild(Parent, Name) -- Client side, we must wait.&apos;
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return DataStreamObject
&#9;end
&#9;ResouceManager.GetDataStreamObject = GetDataStreamObject

&#9;local function GetEventStreamObject(Name, Parent)
&#9;&#9;--- Products a new EventStream object if it doesn&apos;t already exist, otherwise
&#9;&#9;--  return&apos;s the current datastream. 
&#9;&#9;-- @param Name The Name of the EventStream
&#9;&#9;-- @param [Parent] The parent to add to

&#9;&#9;Parent = Parent or EventStreamContainer

&#9;&#9;local DataStreamObject = Parent:FindFirstChild(Name)
&#9;&#9;if not DataStreamObject then
&#9;&#9;&#9;if Configuration.IsServer then
&#9;&#9;&#9;&#9;DataStreamObject            = Instance.new(&quot;RemoteEvent&quot;)
&#9;&#9;&#9;&#9;DataStreamObject.Name       = Name;
&#9;&#9;&#9;&#9;DataStreamObject.Archivable = false;
&#9;&#9;&#9;&#9;DataStreamObject.Parent     = Parent
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;DataStreamObject = WaitForChild(Parent, Name) -- Client side, we must wait.
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return DataStreamObject
&#9;end
&#9;ResouceManager.GetEventStreamObject = GetEventStreamObject

&#9;if Configuration.IsClient then
&#9;&#9;NetworkingRemoteFunction = WaitForChild(DataStreamContainer, Configuration.DataSteamName)
&#9;else
&#9;&#9;NetworkingRemoteFunction = GetDataStreamObject(Configuration.DataSteamName, DataStreamContainer)
&#9;end

&#9;local function IsMainResource(Item)
&#9;&#9;--- Finds out if an Item is considered a MainResource
&#9;&#9;-- @return Boolean is a main resource

&#9;&#9;if Item:IsA(&quot;Script&quot;) then
&#9;&#9;&#9;if not Item.Disabled then
&#9;&#9;&#9;&#9;-- If an item is not disabled, then it&apos;s disabled, but yell at 
&#9;&#9;&#9;&#9;-- the user.

&#9;&#9;&#9;&#9;if Item.Name:lower():match(&quot;\.main$&quot;) == nil then
&#9;&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. Item:GetFullName() .. &quot; is not disabled, and does not end with .Main.&quot;)
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;&#9;return Item.Name:lower():match(&quot;\.main$&quot;) ~= nil -- Check to see if it ends
&#9;&#9;&#9;                                                  -- in .main, ignoring caps
&#9;&#9;else
&#9;&#9;&#9;return false;
&#9;&#9;end
&#9;end

&#9;local function GetLoadablesForServer()
&#9;&#9;--- Get&apos;s the loadable items for the server, that should be insta-ran
&#9;&#9;-- @return A table full of the resources to be loaded

&#9;&#9;return MainResourcesServer
&#9;end
&#9;ResouceManager.GetLoadablesForServer = GetLoadablesForServer

&#9;local function GetLoadablesForClient()
&#9;&#9;--- Get&apos;s the loadable items for the Client, that should be insta-ran
&#9;&#9;-- @return A table full of the resources to be loaded
&#9;&#9;
&#9;&#9;return MainResourcesClient
&#9;end
&#9;ResouceManager.GetLoadablesForClient = GetLoadablesForClient

&#9;local PopulateResourceCache
&#9;if Configuration.IsClient then
&#9;&#9;function PopulateResourceCache()
&#9;&#9;&#9;--- Populates the resource cache. For the client.
&#9;&#9;&#9;-- Should only be called once. Used internally. 

&#9;&#9;&#9;local Populate
&#9;&#9;&#9;function Populate(Parent)
&#9;&#9;&#9;&#9;for _, Item in pairs(Parent:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;if (Item:IsA(&quot;LocalScript&quot;) or Item:IsA(&quot;ModuleScript&quot;)) then

&#9;&#9;&#9;&#9;&#9;&#9;ResourceCache[Item.Name] = Item;

&#9;&#9;&#9;&#9;&#9;&#9;if IsMainResource(Item) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;MainResourcesClient[#MainResourcesClient+1] = Item;
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;Populate(Item)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;Populate(ReplicatedPackage)
&#9;&#9;end
&#9;else -- Configuration.IsServer then
&#9;&#9;function PopulateResourceCache()
&#9;&#9;&#9;--- Populates the resource cache. For the server. Also populates
&#9;&#9;&#9;-- the replication cache. Used internally. 
&#9;&#9;&#9;-- Should be called once. 

&#9;&#9;&#9;--[[local NevermoreModule = script:Clone()
&#9;&#9;&#9;NevermoreModule.Archivable = false;
&#9;&#9;&#9;NevermoreModule.Parent = ReplicatedStorage--]]

&#9;&#9;&#9;local function Populate(Parent)
&#9;&#9;&#9;&#9;for _, Item in pairs(Parent:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;if Item:IsA(&quot;Script&quot;) or Item:IsA(&quot;ModuleScript&quot;) then -- Will catch LocalScripts as they inherit from script
&#9;&#9;&#9;&#9;&#9;&#9;if ResourceCache[Item.Name] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;There are two Resources called &apos;&quot; .. Item:GetFullName() ..&quot;&apos;. Nevermore failed to populate the cache..&quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if Item:IsA(&quot;LocalScript&quot;) or Item:IsA(&quot;ModuleScript&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- Clone the item into the replication packet for
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- replication. However, we do not clone server scripts.

&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local ItemClone
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if not (Item:IsA(&quot;ModuleScript&quot;) and Item.Name:lower():find(&quot;server&quot;)) then -- Don&apos;t clone scripts with the name &quot;server&quot; in it.
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ItemClone      = Item:Clone()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ItemClone.Archivable = false;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ItemClone.Parent     = ReplicatedPackage
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;Not cloning resource &apos;&quot; .. Item.Name ..&quot;&apos; as it is server only.&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if Item:IsA(&quot;ModuleScript&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ResourceCache[Item.Name] = ItemClone or Item;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;elseif IsMainResource(Item) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;MainResourcesClient[#MainResourcesClient+1] = Item
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else -- Do not replicate local scripts
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if IsMainResource(Item) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;MainResourcesServer[#MainResourcesServer+1] = Item
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ResourceCache[Item.Name] = Item&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;Populate(Item)
&#9;&#9;&#9;&#9;&#9;&#9;--error(Configuration.PrintHeader .. &quot;The resource &apos;&quot; .. Item:GetFullName() ..&quot;&apos; is not a LocalScript, Script, or ModuleScript, and cannot be included. Nevermore failed to populate the cache..&quot;, 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;Populate(ModulesContainer)
&#9;&#9;end
&#9;end
&#9;ResouceManager.PopulateResourceCache = PopulateResourceCache

&#9;local function GetResource(ResourceName)
&#9;&#9;--- This script will load another script, module script, et cetera, if it is 
&#9;&#9;--  available.  It will return the resource in question.
&#9;&#9;-- @param ResourceName The name of the resource 
&#9;&#9;-- @return The found resource

&#9;&#9;local ResourceFound = ResourceCache[ResourceName]

&#9;&#9;if ResourceFound then
&#9;&#9;&#9;return ResourceFound
&#9;&#9;else
&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;The resource &apos;&quot; .. ResourceName .. &quot;&apos; does not exist, cannot load&quot;, 2)
&#9;&#9;end
&#9;end
&#9;ResouceManager.GetResource = GetResource

&#9;local function LoadScript(ScriptName)
&#9;&#9;--- Runs a script, and can be called multiple times if the script is not
&#9;&#9;--  a modular script. 
&#9;&#9;-- @param ScriptName The name of the script to load.
&#9;&#9;
&#9;&#9;local ScriptToLoad = GetResource(ScriptName)
&#9;&#9;if ScriptToLoad and ScriptToLoad:IsA(&quot;Script&quot;) then
&#9;&#9;&#9;local NewScript = ScriptToLoad:Clone()
&#9;&#9;&#9;NewScript.Disabled = true;

&#9;&#9;&#9;--[[if Configuration.SoloTestMode then
&#9;&#9;&#9;&#9;if NewScript:IsA(&quot;LocalScript&quot;) then
&#9;&#9;&#9;&#9;&#9;NewScript.Parent = Players.LocalPlayer:FindFirstChild(&quot;PlayerGui&quot;)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;NewScript.Parent = script;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;NewScript.Parent = script;
&#9;&#9;&#9;end--]]
&#9;&#9;&#9;if Configuration.IsServer then
&#9;&#9;&#9;&#9;NewScript.Parent = NevermoreContainer;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;NewScript.Parent = Players.LocalPlayer:FindFirstChild(&quot;Backpack&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;wait(0)
&#9;&#9;&#9;&#9;NewScript.Disabled = false;
&#9;&#9;&#9;end)
&#9;&#9;else
&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;The script &apos;&quot; .. ScriptName .. &quot;&apos; is a &apos;&quot;.. (ScriptToLoad and ScriptToLoad.ClassName or &quot;nil value&quot;) .. &quot;&apos; and cannot be loaded&quot;, 2)
&#9;&#9;end
&#9;end
&#9;ResouceManager.LoadScript = LoadScript

&#9;if Configuration.IsServer then
&#9;&#9;local function LoadScriptOnClient(Script, Client)
&#9;&#9;&#9;--- Runs a script on the client. Used internally.
&#9;&#9;&#9;-- @param Script The script to load. Should be a script object
&#9;&#9;&#9;-- @param Client The client to run the script on. Should be a Player
&#9;&#9;&#9;--               object

&#9;&#9;&#9;if Script and Script:IsA(&quot;LocalScript&quot;) then
&#9;&#9;&#9;&#9;local NewScript = Script:Clone()
&#9;&#9;&#9;&#9;NewScript.Disabled = true;
&#9;&#9;&#9;&#9;NewScript.Parent = Client:FindFirstChild(&quot;Backpack&quot;)

&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;wait(0)
&#9;&#9;&#9;&#9;&#9;NewScript.Disabled = false;
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;The script &apos;&quot; .. tostring(Script) .. &quot;&apos; is a &apos;&quot; .. (Script and Script.ClassName or &quot;nil value&quot;) .. &quot;&apos; and cannot be loaded&quot;, 2)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;ResouceManager.LoadScriptOnClient = LoadScriptOnClient

&#9;&#9;local function ExecuteExecutables()
&#9;&#9;&#9;--- Executes all the executable scripts on the server.

&#9;&#9;&#9;for _, Item in pairs(GetLoadablesForServer()) do
&#9;&#9;&#9;&#9;LoadScript(Item.Name)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;ResouceManager.ExecuteExecutables = ExecuteExecutables
&#9;end

&#9;local NativeImports

&#9;local function ImportLibrary(LibraryDefinition, Environment, Prefix)
&#9;&#9;--- Imports a library into a given environment, potentially adding a PreFix 
&#9;&#9;--  into any of the values of the library,
&#9;&#9;--  incase that&apos;s wanted. :)
&#9;&#9;-- @param LibraryDefinition Table, the libraries definition
&#9;&#9;-- @param Environment Another table, probably received by getfenv() in Lua 5.1, and __ENV in Lua 5.2
&#9;&#9;-- @Param [Prefix] Optional string that will be prefixed to each function imported into the environment.

&#9;&#9;if type(LibraryDefinition) ~= &quot;table&quot; then
&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;The LibraryDefinition argument must be a table, got &apos;&quot; .. tostring(LibraryDefinition) .. &quot;&apos;&quot;, 2)
&#9;&#9;elseif type(Environment) ~= &quot;table&quot; then
&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;The Environment argument must be a table, got &apos;&quot; .. tostring(Environment) .. &quot;&apos;&quot;, 2)
&#9;&#9;else
&#9;&#9;&#9;Prefix = Prefix or &quot;&quot;;

&#9;&#9;&#9;for Name, Value in pairs(LibraryDefinition) do
&#9;&#9;&#9;&#9;if Environment[Prefix .. Name] == nil and not NativeImports[Name] then
&#9;&#9;&#9;&#9;&#9;Environment[Prefix .. Name] = LibraryDefinition[Name]
&#9;&#9;&#9;&#9;elseif not NativeImports[Name] then
&#9;&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;Failed to import function &apos;&quot; .. (Prefix .. Name) .. &quot;&apos; as it already exists in the environment&quot;, 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;ResouceManager.ImportLibrary = ImportLibrary

&#9;-- List of functions to import into each library. In this case, only the 
&#9;-- environmental import functions and added to each library. 
&#9;NativeImports = {
&#9;&#9;import = ImportLibrary;
&#9;&#9;Import = ImportLibrary;
&#9;}

&#9;local function LoadLibrary(LibraryName)
&#9;&#9;--- Load&apos;s a modular script and packages it as a library. 
&#9;&#9;-- @param LibraryName A string of the resource that ist the LibraryName

&#9;&#9;-- print(Configuration.PrintHeader .. &quot;Loading Library &quot; .. LibraryName)

&#9;&#9;local ModularScript = GetResource(LibraryName)

&#9;&#9;if ModularScript then
&#9;&#9;&#9;if ModularScript:IsA(&quot;ModuleScript&quot;) then
&#9;&#9;&#9;&#9;-- print(Configuration.PrintHeader .. &quot;Loading Library &quot; .. ModularScript:GetFullName())
&#9;&#9;&#9;&#9;local LibraryDefinition = require(ModularScript)

&#9;&#9;&#9;&#9;if type(LibraryDefinition) == &quot;table&quot; then
&#9;&#9;&#9;&#9;&#9;-- Import native definitions
&#9;&#9;&#9;&#9;&#9;for Name, Value in pairs(NativeImports) do
&#9;&#9;&#9;&#9;&#9;&#9;if LibraryDefinition[Name] == nil then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;LibraryDefinition[Name] = Value
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot; Library &apos;&quot; .. LibraryName .. &quot;&apos; did not return a table, returned a &apos;&quot; .. type(LibraryDefinition) .. &quot;&apos; value, &apos;&quot; .. tostring(LibraryDefinition) .. &quot;&apos;&quot;)
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;return LibraryDefinition
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot; The resource &quot; .. LibraryName 
&#9;&#9;&#9;&#9;&#9;.. &quot; is not a ModularScript, as expected, it is a &quot; 
&#9;&#9;&#9;&#9;&#9;.. ModularScript.ClassName, 2
&#9;&#9;&#9;&#9;)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot; Could not identify a library known as &apos;&quot; .. LibraryName .. &quot;&apos;&quot;, 2)
&#9;&#9;end
&#9;end
&#9;ResouceManager.LoadLibrary = LoadLibrary
end

--print(Configuration.PrintHeader .. &quot;Loaded resource manager module&quot;)

-----------------------------
-- NETWORKING STREAM SETUP --
-----------------------------
local Network = {} -- API goes in here
--[[
Contains the following API:

Network.GetDataStream
Network.GetDataStream

--]]
do
&#9;--- Handles networking and PlayerLoading
&#9;local DataStreamMain
&#9;local GetDataStream
&#9;local DataStreamCache = {}
&#9;-- setmetatable(DataStreamCache, {__mode = &quot;v&quot;});

&#9;local function GetCachedDataStream(RemoteFunction)
&#9;&#9;--- Creates a datastream filter that will take requests and 
&#9;&#9;--  filter them out. 
&#9;&#9;-- @param RemoteFunction A remote function to connect to

&#9;&#9;-- Execute on the server:
&#9;&#9;--- Execute ( Player Client , [...] )
&#9;&#9;-- Execute on the client:
&#9;&#9;--- Execute ( [...] )
&#9;&#9;if DataStreamCache[RemoteFunction] then
&#9;&#9;&#9;if Configuration.IsClient then
&#9;&#9;&#9;&#9;DataStreamCache[RemoteFunction].ReloadConnection()
&#9;&#9;&#9;end
&#9;&#9;&#9;return DataStreamCache[RemoteFunction]
&#9;&#9;else
&#9;&#9;&#9;local DataStream = {}
&#9;&#9;&#9;local RequestTagDatabase = {}

&#9;&#9;&#9;-- Set request handling, for solo test mode. The problem here is that Server and Client scripts share the same
&#9;&#9;&#9;-- code base, because both load the same engine in replicated storage. 
&#9;&#9;&#9;local function Send(...)
&#9;&#9;&#9;&#9;-- print(Configuration.PrintHeader .. &quot; Sending SoloTestMode&quot;)
&#9;&#9;&#9;&#9;-- print(...)

&#9;&#9;&#9;&#9;local Arguments = {...}
&#9;&#9;&#9;&#9;local PossibleClient = Arguments[1]
&#9;&#9;&#9;&#9;if PossibleClient and type(PossibleClient) == &quot;userdata&quot; and PossibleClient:IsA(&quot;Player&quot;) then
&#9;&#9;&#9;&#9;&#9;local Request = Arguments[2]
&#9;&#9;&#9;&#9;&#9;if type(Request) == &quot;string&quot; then 
&#9;&#9;&#9;&#9;&#9;&#9;local OtherArguments = {}
&#9;&#9;&#9;&#9;&#9;&#9;for Index=3, #Arguments do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;OtherArguments[#OtherArguments+1] = Arguments[Index]
&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;return RemoteFunction:InvokeClient(PossibleClient, Request:lower(), unpack(OtherArguments))
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request) .. &quot;&apos; received. Resolved into &apos;&quot; .. tostring(Request) .. &quot;&apos;&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;return nil
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;elseif type(PossibleClient) == &quot;string&quot; then
&#9;&#9;&#9;&#9;&#9;local Request = PossibleClient

&#9;&#9;&#9;&#9;&#9;if type(Request) == &quot;string&quot; then 
&#9;&#9;&#9;&#9;&#9;&#9;local OtherArguments = {}
&#9;&#9;&#9;&#9;&#9;&#9;for Index=2, #Arguments do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;OtherArguments[#OtherArguments+1] = Arguments[Index]
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;-- print(&quot;Invoke server&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;return RemoteFunction:InvokeServer(Request:lower(), unpack(OtherArguments))
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request) .. &quot;&apos; received. Resolved into &apos;&quot; .. tostring(Request) .. &quot;&apos;&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;return nil
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request))
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;local function SpawnSend(...)
&#9;&#9;&#9;&#9;--- Sends the data, but doesn&apos;t wait for a response or return one. 

&#9;&#9;&#9;&#9;local Data = {...}
&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;Send(unpack(Data))
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end

&#9;&#9;&#9;if Configuration.IsServer or Configuration.SoloTestMode then
&#9;&#9;&#9;&#9;function RemoteFunction.OnServerInvoke(Client, Request, ...)
&#9;&#9;&#9;&#9;&#9;--- Handles incoming requests
&#9;&#9;&#9;&#9;&#9;-- @param Client The client the request is being sent to
&#9;&#9;&#9;&#9;&#9;-- @param Request The request string that is being sent
&#9;&#9;&#9;&#9;&#9;-- @param [...] The extra parameters of the request
&#9;&#9;&#9;&#9;&#9;-- @return The results, if successfully executed

&#9;&#9;&#9;&#9;&#9;if type(Request) == &quot;string&quot; then 
&#9;&#9;&#9;&#9;&#9;&#9;-- print(Configuration.PrintHeader .. &quot;Server request received&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;-- print(...)

&#9;&#9;&#9;&#9;&#9;&#9;if Client == nil then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if Configuration.SoloTestMode then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Client = Players.LocalPlayer
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;No client provided&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;local RequestExecuter = RequestTagDatabase[Request:lower()]
&#9;&#9;&#9;&#9;&#9;&#9;local RequestArguments = {...}
&#9;&#9;&#9;&#9;&#9;&#9;if RequestExecuter then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--[[local Results
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Results = pack(RequestExecuter(Client, unpack(RequestArguments)))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;return unpack(Results)--]]

&#9;&#9;&#9;&#9;&#9;&#9;&#9;return RequestExecuter(Client, unpack(RequestArguments))
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;warn(Configuration.PrintHeader .. &quot;Unregistered request called, request tag &apos;&quot; .. Request .. &quot;&apos;.&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;return nil
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;warn(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request) .. &quot;&apos; received. Resolved into &apos;&quot; .. tostring(Request) .. &quot;&apos;&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;return nil
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;if not Configuration.SoloTestMode then
&#9;&#9;&#9;&#9;&#9;function Send(Client, Request, ...)
&#9;&#9;&#9;&#9;&#9;&#9;--- Sends a request to the client
&#9;&#9;&#9;&#9;&#9;&#9;-- @param Client Player object, the client to send the request too
&#9;&#9;&#9;&#9;&#9;&#9;-- @param Request the request to send it too.
&#9;&#9;&#9;&#9;&#9;&#9;-- @return The results / derived data from the feedback

&#9;&#9;&#9;&#9;&#9;&#9;-- DEBUG --
&#9;&#9;&#9;&#9;&#9;&#9;--print(Configuration.PrintHeader .. &quot; Sending Request &apos;&quot; .. Request .. &quot;&apos; to Client &apos;&quot; .. tostring(Client) .. &quot;&apos;.&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;return RemoteFunction:InvokeClient(Client, Request:lower(), ...)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end&#9;
&#9;&#9;&#9;if Configuration.IsClient or Configuration.SoloTestMode then -- Handle clientside streaming.
&#9;&#9;&#9;&#9;-- We do this for solotest mode, to connect the OnClientInvoke and the OnServerInvoke 
&#9;&#9;&#9;&#9;

&#9;&#9;&#9;&#9;function DataStream.ReloadConnection()
&#9;&#9;&#9;&#9;&#9;--- Reloads the OnClientInvoke event, which gets disconnected when scripts die on the client.
&#9;&#9;&#9;&#9;&#9;-- However, this fixes it, because those scripts have to request the events every time. 

&#9;&#9;&#9;&#9;&#9;--[[
&#9;&#9;&#9;&#9;&#9;&#9;-- Note: When using RemoteFunctions, in a module script, on ROBLOX, and you load the ModuleScript
&#9;&#9;&#9;&#9;&#9;&#9;with a LOCAL SCRIPT. When this LOCAL SCRIPT is killed, your OnClientInvoke function will be GARBAGE
&#9;&#9;&#9;&#9;&#9;&#9;COLLECTED. You must thus, reload the OnClientInvoke function everytime the local script is loaded.

&#9;&#9;&#9;&#9;&#9;--]]

&#9;&#9;&#9;&#9;&#9;function RemoteFunction.OnClientInvoke(Request, ...)
&#9;&#9;&#9;&#9;&#9;&#9;--- Handles incoming requests
&#9;&#9;&#9;&#9;&#9;&#9;-- @param Request The request string that is being sent
&#9;&#9;&#9;&#9;&#9;&#9;-- @param [...] The extra parameters of the request
&#9;&#9;&#9;&#9;&#9;&#9;-- @return The results, if successfully executed


&#9;&#9;&#9;&#9;&#9;&#9;if type(Request) == &quot;string&quot; then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- print(Configuration.PrintHeader .. &quot;Client request received&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- print(...)

&#9;&#9;&#9;&#9;&#9;&#9;&#9;local RequestExecuter = RequestTagDatabase[Request:lower()]
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local RequestArguments = {...}
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if RequestExecuter then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;RequestExecuter(unpack(RequestArguments))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- warn(Configuration.PrintHeader .. &quot;Unregistered request called, request tag &apos;&quot; .. Request .. &quot;&apos;.&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request) .. &quot;&apos; received. Resolved into &apos;&quot; .. tostring(Request) .. &quot;&apos;&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;--- Reload the initial connection.
&#9;&#9;&#9;&#9;DataStream.ReloadConnection()

&#9;&#9;&#9;&#9;if not Configuration.SoloTestMode then
&#9;&#9;&#9;&#9;&#9;function Send(Request, ...)
&#9;&#9;&#9;&#9;&#9;&#9;--- Sends a request to the server
&#9;&#9;&#9;&#9;&#9;&#9;-- @param Request the request to send it too.
&#9;&#9;&#9;&#9;&#9;&#9;-- @return The results / derived data from the feedback

&#9;&#9;&#9;&#9;&#9;&#9;return RemoteFunction:InvokeServer(Request:lower(), ...)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;DataStream.Send = Send
&#9;&#9;&#9;DataStream.send = Send
&#9;&#9;&#9;DataStream.Call = Send
&#9;&#9;&#9;DataStream.call = Send
&#9;&#9;&#9;DataStream.SpawnSend = SpawnSend
&#9;&#9;&#9;DataStream.spawnSend = SpawnSend
&#9;&#9;&#9;DataStream.spawn_send = SpawnSend

&#9;&#9;&#9;local function RegisterRequestTag(RequestTag, Execute)
&#9;&#9;&#9;&#9;--- Registers a request when sent
&#9;&#9;&#9;&#9;-- @param RequestTag The tag that is expected
&#9;&#9;&#9;&#9;-- @param Execute The functon to execute. It will be sent
&#9;&#9;&#9;&#9;--                all remainig arguments.
&#9;&#9;&#9;&#9;-- Request tags are not case sensitive

&#9;&#9;&#9;&#9;--if not RequestTagDatabase[RequestTag:lower()] then
&#9;&#9;&#9;&#9;RequestTagDatabase[RequestTag:lower()] = Execute;
&#9;&#9;&#9;&#9;--else
&#9;&#9;&#9;&#9;&#9;--error(Configuration.PrintHeader .. &quot;The request tag &quot; .. RequestTag:lower() .. &quot; is already registered.&quot;)
&#9;&#9;&#9;&#9;--end
&#9;&#9;&#9;end
&#9;&#9;&#9;DataStream.RegisterRequestTag = RegisterRequestTag
&#9;&#9;&#9;DataStream.registerRequestTag = RegisterRequestTag

&#9;&#9;&#9;local function UnregisterRequestTag(RequestTag)
&#9;&#9;&#9;&#9;--- Unregisters the request from the tag
&#9;&#9;&#9;&#9;-- @param RequestTag String the tag to reregister
&#9;&#9;&#9;&#9;RequestTagDatabase[RequestTag:lower()] = nil;
&#9;&#9;&#9;end
&#9;&#9;&#9;DataStream.UnregisterRequestTag = UnregisterRequestTag
&#9;&#9;&#9;DataStream.unregisterRequestTag = UnregisterRequestTag

&#9;&#9;&#9;DataStreamCache[RemoteFunction] = DataStream
&#9;&#9;&#9;return DataStream
&#9;&#9;end
&#9;end

&#9;local function GetCachedEventStream(RemoteEvent)
&#9;&#9;-- Like GetCachedDataStream, but with RemoteEvents
&#9;&#9;-- @param RemoteEvent The remote event to get the stream for. 

&#9;&#9;if DataStreamCache[RemoteEvent] then
&#9;&#9;&#9;if Configuration.IsClient then
&#9;&#9;&#9;&#9;DataStreamCache[RemoteEvent].ReloadConnection()
&#9;&#9;&#9;end
&#9;&#9;&#9;return DataStreamCache[RemoteEvent]
&#9;&#9;else
&#9;&#9;&#9;local DataStream = {}
&#9;&#9;&#9;local RequestTagDatabase = {}

&#9;&#9;&#9;local function Fire(...)
&#9;&#9;&#9;&#9;local Arguments = {...}
&#9;&#9;&#9;&#9;local PossibleClient = Arguments[1]
&#9;&#9;&#9;&#9;if PossibleClient and type(PossibleClient) == &quot;userdata&quot; and PossibleClient:IsA(&quot;Player&quot;) then
&#9;&#9;&#9;&#9;&#9;local Request = Arguments[2]
&#9;&#9;&#9;&#9;&#9;if type(Request) == &quot;string&quot; then 
&#9;&#9;&#9;&#9;&#9;&#9;local OtherArguments = {}
&#9;&#9;&#9;&#9;&#9;&#9;for Index=3, #Arguments do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;OtherArguments[#OtherArguments+1] = Arguments[Index]
&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;return RemoteEvent:FireClient(PossibleClient, Request:lower(), unpack(OtherArguments))
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request) .. &quot;&apos; received. Resolved into &apos;&quot; .. tostring(Request) .. &quot;&apos;&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;return nil
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;elseif type(PossibleClient) == &quot;string&quot; then
&#9;&#9;&#9;&#9;&#9;local Request = PossibleClient

&#9;&#9;&#9;&#9;&#9;if type(Request) == &quot;string&quot; then 
&#9;&#9;&#9;&#9;&#9;&#9;local OtherArguments = {}
&#9;&#9;&#9;&#9;&#9;&#9;for Index=2, #Arguments do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;OtherArguments[#OtherArguments+1] = Arguments[Index]
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;return RemoteEvent:FireServer(Request:lower(), unpack(OtherArguments))
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request) .. &quot;&apos; received. Resolved into &apos;&quot; .. tostring(Request) .. &quot;&apos;&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;return nil
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;Invalid request DataType to the DataStream, DataType &apos;&quot; .. type(Request) .. &quot;&apos;, String expected.&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;local function FireAllClients(Request, ...)
&#9;&#9;&#9;&#9;if type(Request) == &quot;string&quot; then
&#9;&#9;&#9;&#9;&#9;RemoteEvent:FireAllClients(Request, ...)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;Invalid reques DataType  to the DataStream, DataType &apos;&quot; .. type(Request))
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;if Configuration.IsServer or Configuration.SoloTestMode then
&#9;&#9;&#9;&#9;RemoteEvent.OnServerEvent:connect(function(Client, Request, ...)
&#9;&#9;&#9;&#9;&#9;--- Handles incoming requests
&#9;&#9;&#9;&#9;&#9;-- @param Client The client the request is being sent to
&#9;&#9;&#9;&#9;&#9;-- @param Request The request string that is being sent
&#9;&#9;&#9;&#9;&#9;-- @param [...] The extra parameters of the request
&#9;&#9;&#9;&#9;&#9;-- @return The results, if successfully executed

&#9;&#9;&#9;&#9;&#9;if type(Request) == &quot;string&quot; then 
&#9;&#9;&#9;&#9;&#9;&#9;if Client == nil then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if Configuration.SoloTestMode then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Client = Players.LocalPlayer
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;No client provided&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;local RequestExecuter = RequestTagDatabase[Request:lower()]
&#9;&#9;&#9;&#9;&#9;&#9;local RequestArguments = {...}
&#9;&#9;&#9;&#9;&#9;&#9;if RequestExecuter then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;RequestExecuter(Client, unpack(RequestArguments))
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- warn(Configuration.PrintHeader .. &quot;Unregistered request called, request tag &apos;&quot; .. Request .. &quot;&apos;.&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request) .. &quot;&apos; received. Resolved into &apos;&quot; .. tostring(Request) .. &quot;&apos;&quot;)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)

&#9;&#9;&#9;&#9;if not Configuration.SoloTestMode then
&#9;&#9;&#9;&#9;&#9;function Fire(Client, Request, ...)
&#9;&#9;&#9;&#9;&#9;&#9;--- Sends a request to the client
&#9;&#9;&#9;&#9;&#9;&#9;-- @param Client Player object, the client to send the request too
&#9;&#9;&#9;&#9;&#9;&#9;-- @param Request the request to send it too.
&#9;&#9;&#9;&#9;&#9;&#9;-- @return The results / derived data from the feedback
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;RemoteEvent:FireClient(Client, Request:lower(), ...)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end&#9;
&#9;&#9;&#9;if Configuration.IsClient or Configuration.SoloTestMode then -- Handle clientside streaming.
&#9;&#9;&#9;&#9;-- We do this for solotest mode, to connect the OnClientInvoke and the OnServerInvoke 
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local Event 
&#9;&#9;&#9;&#9;function DataStream.ReloadConnection()
&#9;&#9;&#9;&#9;&#9;--- Reloads the OnClientInvoke event, which gets disconnected when scripts die on the client.
&#9;&#9;&#9;&#9;&#9;-- However, this fixes it, because those scripts have to request the events every time. 

&#9;&#9;&#9;&#9;&#9;if Event then
&#9;&#9;&#9;&#9;&#9;&#9;Event:disconnect()
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;Event = RemoteEvent.OnClientEvent:connect(function(Request, ...)
&#9;&#9;&#9;&#9;&#9;&#9;--- Handles incoming requests
&#9;&#9;&#9;&#9;&#9;&#9;-- @param Request The request string that is being sent
&#9;&#9;&#9;&#9;&#9;&#9;-- @param [...] The extra parameters of the request
&#9;&#9;&#9;&#9;&#9;&#9;-- @return The results, if successfully executed

&#9;&#9;&#9;&#9;&#9;&#9;if type(Request) == &quot;string&quot; then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local RequestExecuter = RequestTagDatabase[Request:lower()]
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local RequestArguments = {...}
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if RequestExecuter then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;RequestExecuter(unpack(RequestArguments))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- warn(Configuration.PrintHeader .. &quot;Unregistered request called, request tag &apos;&quot; .. Request .. &quot;&apos;.&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot;Invalid request to the DataStream, DataType &apos;&quot; .. type(Request) .. &quot;&apos; received. Resolved into &apos;&quot; .. tostring(Request) .. &quot;&apos;&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;--- Reload the initial connection.
&#9;&#9;&#9;&#9;DataStream.ReloadConnection()

&#9;&#9;&#9;&#9;if not Configuration.SoloTestMode then
&#9;&#9;&#9;&#9;&#9;function Fire(Request, ...)
&#9;&#9;&#9;&#9;&#9;&#9;--- Sends a request to the server
&#9;&#9;&#9;&#9;&#9;&#9;-- @param Request the request to send it too.
&#9;&#9;&#9;&#9;&#9;&#9;-- @return The results / derived data from the feedback

&#9;&#9;&#9;&#9;&#9;&#9;RemoteEvent:FireServer(Request:lower(), ...)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;DataStream.Fire = Fire
&#9;&#9;&#9;DataStream.fire = Fire
&#9;&#9;&#9;DataStream.FireAllClients = FireAllClients
&#9;&#9;&#9;DataStream.fireAllClients = FireAllClients

&#9;&#9;&#9;local function RegisterRequestTag(RequestTag, Execute)
&#9;&#9;&#9;&#9;--- Registers a request when sent
&#9;&#9;&#9;&#9;-- @param RequestTag The tag that is expected
&#9;&#9;&#9;&#9;-- @param Execute The functon to execute. It will be sent
&#9;&#9;&#9;&#9;--                all remainig arguments.
&#9;&#9;&#9;&#9;-- Request tags are not case sensitive

&#9;&#9;&#9;&#9;RequestTagDatabase[RequestTag:lower()] = Execute;
&#9;&#9;&#9;end
&#9;&#9;&#9;DataStream.RegisterRequestTag = RegisterRequestTag
&#9;&#9;&#9;DataStream.registerRequestTag = RegisterRequestTag

&#9;&#9;&#9;local function UnregisterRequestTag(RequestTag)
&#9;&#9;&#9;&#9;--- Unregisters the request from the tag
&#9;&#9;&#9;&#9;-- @param RequestTag String the tag to reregister

&#9;&#9;&#9;&#9;RequestTagDatabase[RequestTag:lower()] = nil;
&#9;&#9;&#9;end
&#9;&#9;&#9;DataStream.UnregisterRequestTag = UnregisterRequestTag
&#9;&#9;&#9;DataStream.unregisterRequestTag = UnregisterRequestTag

&#9;&#9;&#9;DataStreamCache[RemoteEvent] = DataStream
&#9;&#9;&#9;return DataStream
&#9;&#9;end
&#9;end

&#9;local DataStreamMain = GetCachedDataStream(NetworkingRemoteFunction)

&#9;local function GetDataStream(DataStreamName)
&#9;&#9;--- Get&apos;s a dataStream channel
&#9;&#9;-- @param DataSteamName The channel to log in to. 
&#9;&#9;-- @return The main datastream, if no DataSteamName is provided

&#9;&#9;if DataStreamName then
&#9;&#9;&#9;return GetCachedDataStream(ResouceManager.GetDataStreamObject(DataStreamName, DataStreamContainer))
&#9;&#9;else
&#9;&#9;&#9;error(&quot;[NevermoreEngine] - Paramter DataStreamName was nil&quot;)
&#9;&#9;end
&#9;end
&#9;Network.GetDataStream = GetDataStream

&#9;local function GetEventStream(EventStreamName)
&#9;&#9;--- Get&apos;s an EventStream chanel
&#9;&#9;-- @param DataSteamName The channel to log in to. 
&#9;&#9;-- @return The main datastream, if no DataSteamName is provided

&#9;&#9;if EventStreamName then
&#9;&#9;&#9;return GetCachedEventStream(ResouceManager.GetEventStreamObject(EventStreamName, EventStreamContainer))
&#9;&#9;else
&#9;&#9;&#9;error(&quot;[NevermoreEngine] - Paramter EventStreamName was nil&quot;)
&#9;&#9;end
&#9;end
&#9;Network.GetEventStream = GetEventStream

&#9;local function GetMainDatastream()
&#9;&#9;--- Return&apos;s the main datastream, used internally for networking

&#9;&#9;return DataStreamMain
&#9;end
&#9;Network.GetMainDatastream = GetMainDatastream

&#9;local function GenerateInitialSplashScreen(Player)
&#9;&#9;--- Generates the initial SplashScreen for the player.  
&#9;&#9;-- @param Player The player to genearte the SplashScreen in.
&#9;&#9;-- @return The generated splashsreen

&#9;&#9;local Configuration = {
&#9;&#9;&#9;BackgroundColor3      = Color3.new(237/256, 236/256, 233/256);       -- Color of background of loading screen.
&#9;&#9;&#9;AccentColor3          = Color3.new(8/256, 130/256, 83/256);          -- Not used. 
&#9;&#9;&#9;LogoSize              = 200;
&#9;&#9;&#9;LogoTexture           = &quot;http://www.roblox.com/asset/?id=129733987&quot;;
&#9;&#9;&#9;LogoSpacingUp         = 70; -- Pixels up from loading frame.
&#9;&#9;&#9;ParticalOrbitDistance = 50;                                         -- How far out the particals orbit
&#9;&#9;&#9;ZIndex                = 9;
&#9;&#9;}

&#9;&#9;local ScreenGui = Instance.new(&quot;ScreenGui&quot;, Player:FindFirstChild(&quot;PlayerGui&quot;))
&#9;&#9;ScreenGui.Name = &quot;SplashScreen&quot;;

&#9;&#9;local MainFrame = Instance.new(&apos;Frame&apos;)
&#9;&#9;&#9;MainFrame.Name             = &quot;SplashScreen&quot;;
&#9;&#9;&#9;MainFrame.Position         = UDim2.new(0, 0, 0, -2);
&#9;&#9;&#9;MainFrame.Size             = UDim2.new(1, 0, 1, 22); -- Sized ans positioned weirdly because ROBLOX&apos;s ScreenGui doesn&apos;t cover the whole screen.
&#9;&#9;&#9;MainFrame.BackgroundColor3 = Configuration.BackgroundColor3;
&#9;&#9;&#9;MainFrame.Visible          = true;
&#9;&#9;&#9;MainFrame.ZIndex           = Configuration.ZIndex;
&#9;&#9;&#9;MainFrame.BorderSizePixel  = 0;
&#9;&#9;&#9;MainFrame.Parent           = ScreenGui;

&#9;&#9;local ParticalFrame = Instance.new(&apos;Frame&apos;)
&#9;&#9;&#9;ParticalFrame.Name                   = &quot;ParticalFrame&quot;;
&#9;&#9;&#9;ParticalFrame.Position               = UDim2.new(0.5, -Configuration.ParticalOrbitDistance, 0.7, -Configuration.ParticalOrbitDistance);
&#9;&#9;&#9;ParticalFrame.Size                   = UDim2.new(0, Configuration.ParticalOrbitDistance*2, 0, Configuration.ParticalOrbitDistance*2); -- Sized ans positioned weirdly because ROBLOX&apos;s ScreenGui doesn&apos;t cover the whole screen.
&#9;&#9;&#9;ParticalFrame.Visible                = true;
&#9;&#9;&#9;ParticalFrame.BackgroundTransparency = 1
&#9;&#9;&#9;ParticalFrame.ZIndex                 = Configuration.ZIndex;
&#9;&#9;&#9;ParticalFrame.BorderSizePixel        = 0;
&#9;&#9;&#9;ParticalFrame.Parent                 = MainFrame;

&#9;&#9;local LogoLabel = Instance.new(&apos;ImageLabel&apos;)
&#9;&#9;&#9;LogoLabel.Name                   = &quot;LogoLabel&quot;;
&#9;&#9;&#9;LogoLabel.Position               = UDim2.new(0.5, -Configuration.LogoSize/2, 0.7, -Configuration.LogoSize/2 - Configuration.ParticalOrbitDistance*2 - Configuration.LogoSpacingUp);
&#9;&#9;&#9;LogoLabel.Size                   = UDim2.new(0, Configuration.LogoSize, 0, Configuration.LogoSize); -- Sized ans positioned weirdly because ROBLOX&apos;s ScreenGui doesn&apos;t cover the whole screen.
&#9;&#9;&#9;LogoLabel.Visible                = true;
&#9;&#9;&#9;LogoLabel.BackgroundTransparency = 1
&#9;&#9;&#9;LogoLabel.Image                  = Configuration.LogoTexture;
&#9;&#9;&#9;LogoLabel.ZIndex                 = Configuration.ZIndex;
&#9;&#9;&#9;LogoLabel.BorderSizePixel        = 0;
&#9;&#9;&#9;LogoLabel.Parent                 = MainFrame;

&#9;&#9;--[[
&#9;&#9;local LoadingText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;LoadingText.Name                   = &quot;LoadingText&quot;
&#9;&#9;&#9;LoadingText.Position               = UDim2.new(0.5, -Configuration.LogoSize/2, 0.7, -Configuration.LogoSize/2 - Configuration.ParticalOrbitDistance*2 - Configuration.LogoSpacingUp);
&#9;&#9;&#9;LoadingText.Size                   = UDim2.new(0, Configuration.LogoSize, 0, Configuration.LogoSize); -- Sized ans positioned weirdly because ROBLOX&apos;s ScreenGui doesn&apos;t cover the whole screen.
&#9;&#9;&#9;LoadingText.Visible                = true;
&#9;&#9;&#9;LoadingText.BackgroundTransparency = 1
&#9;&#9;&#9;LoadingText.ZIndex                 = Configuration.ZIndex;
&#9;&#9;&#9;LoadingText.BorderSizePixel        = 0;
&#9;&#9;&#9;LoadingText.TextColor3             = Configuration.AccentColor3;
&#9;&#9;&#9;LoadingText.TextXAlignment         = &quot;Center&quot;;
&#9;&#9;&#9;LoadingText.Text                   = &quot;Boostrapping Adventure...&quot;
&#9;&#9;&#9;LoadingText.Parent                 = MainFrame;
&#9;&#9;--]]
&#9;&#9;
&#9;&#9;return ScreenGui
&#9;end

&#9;if Configuration.IsServer then
&#9;&#9;local function CheckIfPlayerIsBlacklisted(Player, BlackList)
&#9;&#9;&#9;--- Checks to see if a player is blacklisted from the server
&#9;&#9;&#9;-- @param Player The player to check for
&#9;&#9;&#9;-- @param Blacklist The string blacklist
&#9;&#9;&#9;-- @return Boolean is blacklisted

&#9;&#9;&#9;for Id in string.gmatch(BlackList, &quot;%d+&quot;) do
&#9;&#9;&#9;&#9;local ProductInformation = (MarketplaceService:GetProductInfo(Id))
&#9;&#9;&#9;&#9;if ProductInformation then
&#9;&#9;&#9;&#9;&#9;if string.match(ProductInformation[&quot;Description&quot;], Player.Name..&quot;;&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;return true;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;for Name in string.gmatch(BlackList, &quot;[%a%d]+&quot;) do
&#9;&#9;&#9;&#9;if Player.Name:lower() == Name:lower() then
&#9;&#9;&#9;&#9;&#9;return true;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return false;
&#9;&#9;end

&#9;&#9;local function CheckPlayer(player)
&#9;&#9;&#9;--- Makes sure a player has all necessary components.
&#9;&#9;&#9;-- @return Boolean If the player has all the right components

&#9;&#9;&#9;return player and player:IsA(&quot;Player&quot;) 
&#9;&#9;&#9;&#9;and player:FindFirstChild(&quot;Backpack&quot;) 
&#9;&#9;&#9;&#9;and player:FindFirstChild(&quot;StarterGear&quot;)
&#9;&#9;&#9;&#9;-- and player.PlayerGui:IsA(&quot;PlayerGui&quot;) -- PlayerGui does not replicate to other clients.
&#9;&#9;end

&#9;&#9;local function CheckCharacter(player)
&#9;&#9;&#9;--- Make sure that a character has all necessary components
&#9;&#9;&#9;--  @return Boolean If the player has all the right components

&#9;&#9;&#9;local character = player.Character;
&#9;&#9;&#9;return character
&#9;&#9;&#9;&#9;and character:FindFirstChild(&quot;Humanoid&quot;) 
&#9;&#9;&#9;&#9;and character:FindFirstChild(&quot;Torso&quot;)
&#9;&#9;&#9;&#9;and character:FindFirstChild(&quot;Head&quot;)
&#9;&#9;&#9;&#9;and character.Humanoid:IsA(&quot;Humanoid&quot;)
&#9;&#9;&#9;&#9;and character.Head:IsA(&quot;BasePart&quot;)
&#9;&#9;&#9;&#9;and character.Torso:IsA(&quot;BasePart&quot;)
&#9;&#9;end


&#9;&#9;local function DumpExecutables(Player)
&#9;&#9;&#9;--- Executes all &quot;MainResources&quot; for the player
&#9;&#9;&#9;-- @param Player The player to load the resources on 

&#9;&#9;&#9;print(Configuration.PrintHeader .. &quot;Loading executables onto &quot; .. tostring(Player))
&#9;&#9;&#9;for _, Item in pairs(ResouceManager.GetLoadablesForClient()) do
&#9;&#9;&#9;&#9;ResouceManager.LoadScriptOnClient(Item, Player)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;local function SetupPlayer(Player)
&#9;&#9;&#9;--- Setups up a player
&#9;&#9;&#9;-- @param Player The player to setup

&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;-- Wait for initial load
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--[[while not (Player.Parent) do
&#9;&#9;&#9;&#9;&#9;wait(0)
&#9;&#9;&#9;&#9;&#9;print(&quot;Waiting for Player.Parent&quot;)
&#9;&#9;&#9;&#9;end--]]

&#9;&#9;&#9;&#9;if Configuration.BlackList and CheckIfPlayerIsBlacklisted(Player, Configuration.BlackList) then
&#9;&#9;&#9;&#9;&#9;Player:Kick()
&#9;&#9;&#9;&#9;&#9;warn(&quot;Kicked Player &quot; .. Player.Name .. &quot; who was blacklisted&quot;)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;local PlayerSplashScreen
&#9;&#9;&#9;&#9;&#9;local HumanoidDiedEvent
&#9;&#9;&#9;&#9;&#9;local ExecutablesDumped = false

&#9;&#9;&#9;&#9;&#9;local function SetupCharacter(ForceDumpExecutables)
&#9;&#9;&#9;&#9;&#9;&#9;--- Setup&apos;s up a player&apos;s character
&#9;&#9;&#9;&#9;&#9;&#9;-- @param ForceDumpExecutables Forces executables to be dumped, even if StarterGui.ResetPlayerGuiOnSpawn is true.
&#9;&#9;&#9;&#9;&#9;&#9;if not Configuration.CustomCharacters then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if Player and Player.Parent == Players then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;while not (Player.Character 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;and Player.Character:FindFirstChild(&quot;Humanoid&quot;) 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;and Player.Character.Humanoid:IsA(&quot;Humanoid&quot;)) 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;and Player.Parent == Players do

&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait(0) -- Wait for the player&apos;s character to load
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- Make sure the player is still in game.
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if Player.Parent == Players then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if HumanoidDiedEvent then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;HumanoidDiedEvent:disconnect()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;HumanoidDiedEvent = nil
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;HumanoidDiedEvent = Player.Character.Humanoid.Died:connect(function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait(Configuration.CharacterRespawnTime)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Player:LoadCharacter()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)

&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if not ExecutablesDumped or ForceDumpExecutables == true or StarterGui.ResetPlayerGuiOnSpawn then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DumpExecutables(Player)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ExecutablesDumped = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;print(Configuration.PrintHeader .. &quot;is not int he game. Cannot finish load.&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;print(Configuration.PrintHeader .. &quot; is not in the game. Cannot load.&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local function LoadSplashScreen()
&#9;&#9;&#9;&#9;&#9;&#9;--- Load&apos;s the splash screen into the player

&#9;&#9;&#9;&#9;&#9;&#9;if Configuration.SplashScreen and (not Configuration.EnableFiltering or Configuration.SoloTestMode) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;PlayerSplashScreen = GenerateInitialSplashScreen(Player)

&#9;&#9;&#9;&#9;&#9;&#9;&#9;if Configuration.SoloTestMode then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Network.AddSplashToNevermore(NevermoreEngine)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local function InitialCharacterLoad()
&#9;&#9;&#9;&#9;&#9;&#9;-- Makes sure the character loads, and sets up the character if it has already loaded

&#9;&#9;&#9;&#9;&#9;&#9;if not Player.Character then -- Incase the characters do start auto-loading. 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if PlayerSplashScreen then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;PlayerSplashScreen.Parent = nil;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if Configuration.CustomCharacters then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Player:LoadCharacter()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if not Player.Character then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Player.CharacterAdded:wait()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Player.Character:Destroy()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Player:LoadCharacter()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;&#9;if PlayerSplashScreen then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;PlayerSplashScreen.Parent = Player.PlayerGui
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;SetupCharacter(true) -- Force dump on the first load. 
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;-- WHAT MUST HAPPEN
&#9;&#9;&#9;&#9;&#9;-- Character must be loaded at least once
&#9;&#9;&#9;&#9;&#9;-- Nevermore must run on the client to get a splash running. However, this can be seen as optinoal. 
&#9;&#9;&#9;&#9;&#9;-- Nevermore must load the splash into the player. 

&#9;&#9;&#9;&#9;&#9;-- SETUP EVENT FIRST
&#9;&#9;&#9;&#9;&#9;Player.CharacterAdded:connect(SetupCharacter)
&#9;&#9;&#9;&#9;&#9;InitialCharacterLoad() -- Force load the character, no matter what.
&#9;&#9;&#9;&#9;&#9;LoadSplashScreen()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end

&#9;&#9;local function ConnectPlayers()
&#9;&#9;&#9;--- Connects all the events and adds players into the system. 

&#9;&#9;&#9;-- Setup all the players that joined...
&#9;&#9;&#9;for _, Player in pairs(game.Players:GetPlayers()) do
&#9;&#9;&#9;&#9;SetupPlayer(Player)
&#9;&#9;&#9;end

&#9;&#9;&#9;-- And when they are added...
&#9;&#9;&#9;Players.PlayerAdded:connect(function(Player)
&#9;&#9;&#9;&#9;SetupPlayer(Player)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;Network.ConnectPlayers = ConnectPlayers
&#9;end
&#9;if Configuration.IsClient or Configuration.SoloTestMode then 
&#9;&#9;-- Setup the Splash Screen.
&#9;&#9;-- However, in SoloTestMode, we need to setup the splashscreen in the
&#9;&#9;-- replicated storage module, which is technically the server module. 

&#9;&#9;local function AnimateSplashScreen(ScreenGui)
&#9;&#9;&#9;--- Creates a Windows 8 style loading screen, finishing the loading animation
&#9;&#9;&#9;-- of pregenerated spash screens.
&#9;&#9;&#9;-- @param ScreenGui The ScreenGui generated by the splash initiator. 

&#9;&#9;&#9;-- Will only be called if SpashScreens are enabled. 

&#9;&#9;&#9;local Configuration = {
&#9;&#9;&#9;&#9;OrbitTime              = 5;                                           -- How long the orbit should last.
&#9;&#9;&#9;&#9;OrbitTimeBetweenStages = 0.5;
&#9;&#9;&#9;&#9;Texture                = &quot;http://www.roblox.com/asset/?id=129689248&quot;; -- AssetId of orbiting object (Decal)
&#9;&#9;&#9;&#9;ParticalOrbitDistance  = 50;                                         -- How far out the particals orbit
&#9;&#9;&#9;&#9;ParticalSize           = 10;                                          -- How big the particals are, probably should be an even number..
&#9;&#9;&#9;&#9;ParticalCount          = 5;                                           -- How many particals to generate
&#9;&#9;&#9;&#9;ParticleSpacingTime    = 0.25;                                         -- How long to wait between earch partical before releasing the next one
&#9;&#9;&#9;}

&#9;&#9;&#9;local Splash = {}

&#9;&#9;&#9;local IsActive = true;
&#9;&#9;&#9;local MainFrame = ScreenGui.SplashScreen
&#9;&#9;&#9;local ParticalFrame = MainFrame.ParticalFrame
&#9;&#9;&#9;local ParticalList = {}

&#9;&#9;&#9;local function Destroy()
&#9;&#9;&#9;&#9;-- Can be called to Destroy the SplashScreen. Will have the Alias
&#9;&#9;&#9;&#9;-- ClearSplash in NevermoreEngine

&#9;&#9;&#9;&#9;IsActive = false;
&#9;&#9;&#9;&#9;ScreenGui:Destroy()
&#9;&#9;&#9;end
&#9;&#9;&#9;Splash.Destroy = Destroy

&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;if IsActive then
&#9;&#9;&#9;&#9;&#9;local function MakePartical(Parent, RotationRadius, Size, Texture)
&#9;&#9;&#9;&#9;&#9;&#9;-- Creates a partical that will circle around the center of it&apos;s Parent.  
&#9;&#9;&#9;&#9;&#9;&#9;-- RotationRadius is how far away it orbits
&#9;&#9;&#9;&#9;&#9;&#9;-- Size is the size of the ball...
&#9;&#9;&#9;&#9;&#9;&#9;-- Texture is the asset id of the texture to use... 

&#9;&#9;&#9;&#9;&#9;&#9;-- Create a new ImageLabel to be our rotationg partical
&#9;&#9;&#9;&#9;&#9;&#9;local Partical = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical.Name                   = &quot;Partical&quot;;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical.Size                   = UDim2.new(0, Size, 0, Size);
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical.BackgroundTransparency = 1;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical.Image                  = Texture;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical.BorderSizePixel        = 0;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical.ZIndex                 = 10;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical.Parent                 = Parent;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical.Visible                = false;

&#9;&#9;&#9;&#9;&#9;&#9;local ParticalData = {
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Frame          = Partical;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;RotationRadius = RotationRadius;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;StartTime      = math.huge;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Size           = Size;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;SetPosition    = function(ParticalData, CurrentPercent)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- Will set the position of the partical relative to CurrentPercent.  CurrentPercent @ 0 should be 0 radians.

&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local PositionX = math.cos(math.pi * 2 * CurrentPercent) * ParticalData.RotationRadius
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local PositionY = math.sin(math.pi * 2 * CurrentPercent) * ParticalData.RotationRadius
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ParticalData.Frame.Position = UDim2.new(0.5 + PositionX/2,  -ParticalData.Size/2, 0.5 + PositionY/2, -ParticalData.Size/2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--ParticalData.Frame:TweenPosition(UDim2.new(0.5 + PositionX/2,  -ParticalData.Size/2, 0.5 + PositionY/2, -ParticalData.Size/2), &quot;Out&quot;, &quot;Linear&quot;, 0.03, true)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;&#9;&#9;}

&#9;&#9;&#9;&#9;&#9;&#9;return ParticalData;
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local function EaseOut(Percent, Amount)
&#9;&#9;&#9;&#9;&#9;&#9;-- Just return&apos;s the EaseOut smoothed out percentage 

&#9;&#9;&#9;&#9;&#9;&#9;return -(1 - Percent^Amount) + 1
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local function EaseIn(Percent, Amount)
&#9;&#9;&#9;&#9;&#9;&#9;-- Just return&apos;s the Easein smoothed out percentage 

&#9;&#9;&#9;&#9;&#9;&#9;return Percent^Amount
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local function EaseInOut(Percent, Amount)
&#9;&#9;&#9;&#9;&#9;&#9;-- Return&apos;s a smoothed out percentage, using in-out.  &apos;Amount&apos; 
&#9;&#9;&#9;&#9;&#9;&#9;-- is the powered amount (So 2 would be a quadratic EaseInOut, 
&#9;&#9;&#9;&#9;&#9;&#9;-- 3 a cubic, and so forth.  Decimals supported)

&#9;&#9;&#9;&#9;&#9;&#9;if Percent &lt; 0.5 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;return ((Percent*2)^Amount)/2
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;return (-((-(Percent*2) + 2)^Amount))/2 + 1
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local function GetFramePercent(Start, Finish, CurrentPercent)
&#9;&#9;&#9;&#9;&#9;&#9;-- Return&apos;s the  relative percentage to the overall 
&#9;&#9;&#9;&#9;&#9;&#9;-- &apos;CurrentPercentage&apos; which ranges from 0 to 100; So in one 
&#9;&#9;&#9;&#9;&#9;&#9;-- case, 0 to 0.07, at 50% would be 0.035;

&#9;&#9;&#9;&#9;&#9;&#9;return ((CurrentPercent - Start) / (Finish - Start))
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local function GetTransitionedPercent(Origin, Target, CurrentPercent)
&#9;&#9;&#9;&#9;&#9;&#9;-- Return&apos;s the Transitional percentage (How far around the 
&#9;&#9;&#9;&#9;&#9;&#9;-- circle the little ball is), when given a Origin ((In degrees)
&#9;&#9;&#9;&#9;&#9;&#9;-- and a Target (In degrees), and the percentage transitioned 
&#9;&#9;&#9;&#9;&#9;&#9;-- between the two...)

&#9;&#9;&#9;&#9;&#9;&#9;return (Origin + ((Target - Origin) * CurrentPercent)) / 360;
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;-- Start the beautiful update loop
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- Add / Create particals
&#9;&#9;&#9;&#9;&#9;for Index = 1, Configuration.ParticalCount do
&#9;&#9;&#9;&#9;&#9;&#9;ParticalList[Index] = MakePartical(ParticalFrame, 1, Configuration.ParticalSize, Configuration.Texture)
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local LastStartTime       = 0; -- Last time a partical was started
&#9;&#9;&#9;&#9;&#9;local ActiveParticalCount = 0;
&#9;&#9;&#9;&#9;&#9;local NextRunTime         = 0 -- When the particals can be launched again...

&#9;&#9;&#9;&#9;&#9;while IsActive do
&#9;&#9;&#9;&#9;&#9;&#9;local CurrentTime = tick();
&#9;&#9;&#9;&#9;&#9;&#9;for Index, Partical in ipairs(ParticalList) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- Calculate the CurrentPercentage from the time and 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local CurrentPercent = ((CurrentTime - Partical.StartTime) / Configuration.OrbitTime);

&#9;&#9;&#9;&#9;&#9;&#9;&#9;if CurrentPercent &lt; 0 then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if LastStartTime + Configuration.ParticleSpacingTime &lt;= CurrentTime and ActiveParticalCount == (Index - 1) and NextRunTime &lt;= CurrentTime then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- Launch Partical...

&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical.Frame.Visible = true;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical.StartTime     = CurrentTime;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;LastStartTime          = CurrentTime
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ActiveParticalCount    = ActiveParticalCount + 1;

&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if Index == Configuration.ParticalCount then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;NextRunTime = CurrentTime + Configuration.OrbitTime + Configuration.OrbitTimeBetweenStages;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical:SetPosition(45/360)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;elseif CurrentPercent &gt; 1 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical.Frame.Visible = false;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical.StartTime = math.huge;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ActiveParticalCount = ActiveParticalCount - 1;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;elseif CurrentPercent &lt;= 0.08 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical:SetPosition(GetTransitionedPercent(45, 145, EaseOut(GetFramePercent(0, 0.08, CurrentPercent), 1.2)))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;elseif CurrentPercent &lt;= 0.39 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical:SetPosition(GetTransitionedPercent(145, 270, GetFramePercent(0.08, 0.39, CurrentPercent)))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;elseif CurrentPercent &lt;= 0.49 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical:SetPosition(GetTransitionedPercent(270, 505, EaseInOut(GetFramePercent(0.39, 0.49, CurrentPercent), 1.1)))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;elseif CurrentPercent &lt;= 0.92 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical:SetPosition(GetTransitionedPercent(505, 630, GetFramePercent(0.49, 0.92, CurrentPercent)))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;elseif CurrentPercent &lt;= 1 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Partical:SetPosition(GetTransitionedPercent(630, 760, EaseOut(GetFramePercent(0.92, 1, CurrentPercent), 1.1)))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)

&#9;&#9;&#9;return Splash;
&#9;&#9;end

&#9;&#9;local function SetupSplashScreenIfEnabled()
&#9;&#9;&#9;-- CLient stuff.
&#9;&#9;&#9;--- Sets up the Splashscreen if it&apos;s enabled, and returnst he disabling / removing function.
&#9;&#9;&#9;-- @return The removing function, even if the splashscreen doesn&apos;t exist.

&#9;&#9;&#9;local LocalPlayer = Players.LocalPlayer
&#9;&#9;&#9;local PlayerGui = LocalPlayer:FindFirstChild(&quot;PlayerGui&quot;)

&#9;&#9;&#9;while not LocalPlayer:FindFirstChild(&quot;PlayerGui&quot;) do 
&#9;&#9;&#9;&#9;wait(0)
&#9;&#9;&#9;&#9;print(&quot;[NevermoreEngine] - Waiting for PlayerGui&quot;)
&#9;&#9;&#9;&#9;PlayerGui = LocalPlayer:FindFirstChild(&quot;PlayerGui&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;local SplashEnabled = false

&#9;&#9;&#9;local ScreenGui = PlayerGui:FindFirstChild(&quot;SplashScreen&quot;)
&#9;&#9;&#9;local SplashScreen

&#9;&#9;&#9;if Configuration.SplashScreen and ScreenGui then
&#9;&#9;&#9;&#9;SplashEnabled = true
&#9;&#9;&#9;&#9;SplashScreen = AnimateSplashScreen(ScreenGui)
&#9;&#9;&#9;elseif Configuration.SplashScreen and Configuration.EnableFiltering and not Configuration.SoloTestMode then
&#9;&#9;&#9;&#9;SplashEnabled = true
&#9;&#9;&#9;&#9;ScreenGui = GenerateInitialSplashScreen(LocalPlayer)
&#9;&#9;&#9;&#9;SplashScreen = AnimateSplashScreen(ScreenGui)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(Configuration.PrintHeader .. &quot;Splash Screen could not be found, or is not enabled&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;local function ClearSplash()
&#9;&#9;&#9;&#9;print(Configuration.PrintHeader .. &quot;Clearing splash.&quot;)

&#9;&#9;&#9;&#9;--- Destroys and stops all animation of the current splashscreen, if it exists.
&#9;&#9;&#9;&#9;if SplashScreen then
&#9;&#9;&#9;&#9;&#9;SplashEnabled = false
&#9;&#9;&#9;&#9;&#9;SplashScreen.Destroy()
&#9;&#9;&#9;&#9;&#9;SplashScreen = nil;
&#9;&#9;&#9;&#9;--else
&#9;&#9;&#9;&#9;&#9;--print(Configuration.PrintHeader .. &quot;No splash to clear.&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;local function GetSplashEnabled()
&#9;&#9;&#9;&#9;return SplashEnabled
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;return ClearSplash, GetSplashEnabled
&#9;&#9;end
&#9;&#9;-- Network.SetupSplashScreenIfEnabled = SetupSplashScreenIfEnabled

&#9;&#9;local function AddSplashToNevermore(NevermoreEngine)
&#9;&#9;&#9;local ClearSplash, GetSplashEnabled = SetupSplashScreenIfEnabled()

&#9;&#9;&#9;NevermoreEngine.ClearSplash  = ClearSplash
&#9;&#9;&#9;NevermoreEngine.clearSplash  = ClearSplash
&#9;&#9;&#9;NevermoreEngine.clear_splash = ClearSplash

&#9;&#9;&#9;NevermoreEngine.GetSplashEnabled = GetSplashEnabled
&#9;&#9;&#9;NevermoreEngine.getSplashEnabled = GetSplashEnabled
&#9;&#9;&#9;NevermoreEngine.get_splash_enabled = GetSplashEnabled
&#9;&#9;end
&#9;&#9;Network.AddSplashToNevermore = AddSplashToNevermore
&#9;end
end

--print(Configuration.PrintHeader .. &quot;Loaded network module&quot;)

-----------------------
-- UTILITY NEVERMORE --
-----------------------
local SetRespawnTime
if Configuration.IsServer then
&#9;local function SetRespawnTime(NewTime)
&#9;&#9;--- Sets how long it takes for a character to respawn.
&#9;&#9;-- @param NewTime The new time it takes for a character to respawn
&#9;&#9;if type(NewTime) == &quot;number&quot; then
&#9;&#9;&#9;Configuration.CharacterRespawnTime = NewTime
&#9;&#9;else
&#9;&#9;&#9;error(Configuration.PrintHeader .. &quot; Could not set respawn time to &apos;&quot; .. tostring(NewTime) .. &quot;&apos;, number expected, got &apos;&quot; .. type(NewTime) .. &quot;&apos;&quot;)
&#9;&#9;end
&#9;end

&#9;Network.GetMainDatastream().RegisterRequestTag(Configuration.NevermoreRequestPrefix .. &quot;SetRespawnTime&quot;, function(Client, NewTime)
&#9;&#9;SetRespawnTime(NewTime)
&#9;end)
else
&#9;local function SetRespawnTime(NewTime)
&#9;&#9;--- Sends a request to the server to set the respawn time.
&#9;&#9;-- @param NewTime The new respawn time.

&#9;&#9;DataStreamMain.Send(Configuration.NevermoreRequestPrefix .. &quot;SetRespawnTime&quot;, NewTime)
&#9;end
end

--print(Configuration.PrintHeader .. &quot;Loaded Nevermore Utilities&quot;)

------------------------
-- INITIATE NEVERMORE --
------------------------

--print(Configuration.PrintHeader .. &quot;Setup splashscreen&quot;)

NevermoreEngine.SetRespawnTime          = SetRespawnTime
NevermoreEngine.setRespawnTime          = SetRespawnTime
NevermoreEngine.set_respawn_time        = SetRespawnTime

NevermoreEngine.GetResource             = ResouceManager.GetResource
NevermoreEngine.getResource             = ResouceManager.GetResource
NevermoreEngine.get_resource            = ResouceManager.GetResource

-- NevermoreEngine.LoadScript              = ResouceManager.LoadScript
-- NevermoreEngine.loadScript              = ResouceManager.LoadScript
-- NevermoreEngine.load_script             = ResouceManager.LoadScript

NevermoreEngine.LoadLibrary             = ResouceManager.LoadLibrary
NevermoreEngine.loadLibrary             = ResouceManager.LoadLibrary
NevermoreEngine.load_library            = ResouceManager.LoadLibrary

NevermoreEngine.ImportLibrary           = ResouceManager.ImportLibrary
NevermoreEngine.importLibrary           = ResouceManager.ImportLibrary
NevermoreEngine.import_library          = ResouceManager.ImportLibrary

NevermoreEngine.Import                  = ResouceManager.ImportLibrary
NevermoreEngine.import                  = ResouceManager.ImportLibrary

-- These 2 following are used to get the raw objects. 
NevermoreEngine.GetDataStreamObject     = ResouceManager.GetDataStreamObject
NevermoreEngine.getDataStreamObject     = ResouceManager.GetDataStreamObject
NevermoreEngine.get_data_stream_object  = ResouceManager.GetDataStreamObject

NevermoreEngine.GetRemoteFunction     = ResouceManager.GetDataStreamObject -- Uh, yeah, why haven&apos;t I done this before?


NevermoreEngine.GetEventStreamObject    = ResouceManager.GetEventStreamObject
NevermoreEngine.getEventStreamObject    = ResouceManager.GetEventStreamObject
NevermoreEngine.get_event_stream_object = ResouceManager.GetEventStreamObject

NevermoreEngine.GetRemoteEvent    = ResouceManager.GetEventStreamObject


NevermoreEngine.GetDataStream           = Network.GetDataStream
NevermoreEngine.getDataStream           = Network.GetDataStream
NevermoreEngine.get_data_stream         = Network.GetDataStream

NevermoreEngine.GetEventStream          = Network.GetEventStream
NevermoreEngine.getEventStream          = Network.GetEventStream
NevermoreEngine.get_event_stream        = Network.GetEventStream

NevermoreEngine.SoloTestMode            = Configuration.SoloTestMode -- Boolean value

-- Internally used
NevermoreEngine.GetMainDatastream       = Network.GetMainDatastream

NevermoreEngine.NevermoreContainer      = NevermoreContainer
NevermoreEngine.nevermoreContainer      = NevermoreContainer
NevermoreEngine.nevermore_container     = NevermoreContainer

NevermoreEngine.ReplicatedPackage       = ReplicatedPackage
NevermoreEngine.replicatedPackage       = ReplicatedPackage
NevermoreEngine.replicated_package      = ReplicatedPackage

if Configuration.IsServer then
&#9;local function Initiate()
&#9;&#9;--print(Configuration.PrintHeader .. &quot;Nevermore is initiating.&quot;)
&#9;&#9;--- Initiates Nevermore. This should only be called once. 
&#9;&#9;-- Since Nevermore sets all of its executables, and executes them manually, 
&#9;&#9;-- there is no need to wait for Nevermore when these run. 

&#9;&#9;NevermoreEngine.Initiate = nil
&#9;&#9;ResouceManager.PopulateResourceCache()

&#9;&#9;if Configuration.IsServer then
&#9;&#9;&#9;Network.ConnectPlayers()
&#9;&#9;&#9;ResouceManager.ExecuteExecutables()
&#9;&#9;end

&#9;&#9;-- if Configuration.SoloTestMode then
&#9;&#9;&#9;-- print(Configuration.PrintHeader .. &quot;SoloTestMode enabled for NevermoreEngine.&quot;)
&#9;&#9;&#9;-- SetupSplash()
&#9;&#9;-- end
&#9;end
&#9;NevermoreEngine.Initiate = Initiate
else
&#9;ResouceManager.PopulateResourceCache()
&#9;Network.AddSplashToNevermore(NevermoreEngine)
end&#9;
&#9;--print(Configuration.PrintHeader .. &quot;Nevermore is initiated successfully.&quot;

--print(Configuration.PrintHeader .. &quot;#ReturnValues = &quot;.. (#ReturnValues))

return NevermoreEngine</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX72">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NevermoreEngineLoader</string>
					<ProtectedString name="Source">--- This scripts loads Nevermore from the server.
-- It also replicates the into ReplicatedStorage for internal usage. 

-----------------------
-- UTILITY FUNCTIONS --
-----------------------

local TestService       = game:GetService(&apos;TestService&apos;)
local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;)

local function Warn(WarningText)
&#9;--- Used to yell at the player
&#9;-- @param WarningText The text to warn with.

&#9;Spawn(function()
&#9;&#9;TestService:Warn(false, WarningText)
&#9;end)
end

local function WaitForChild(Parent, Name)
&#9;--- Yields until a child is added. Warns after 5 seconds of yield.
&#9;-- @param Parent The parent to wait for the child of
&#9;-- @param Name The name of the child
&#9;-- @return The child found

&#9;local Child = Parent:FindFirstChild(Name)
&#9;local StartTime = tick()
&#9;local Warned = false;
&#9;while not Child do
&#9;&#9;wait(0)
&#9;&#9;Child = Parent:FindFirstChild(Name)
&#9;&#9;if not Warned and StartTime + 5 &lt;= tick() then
&#9;&#9;&#9;Warned = true;
&#9;&#9;&#9;Warn(&quot;[NevermoreEngineLoader] -&quot; .. &quot; &quot; .. Name .. &quot; has not replicated after 5 seconds, may not be able to execute Nevermore.&quot;)
&#9;&#9;end
&#9;end
&#9;return Child
end

-------------
-- LOADING --
-------------

-- Wait for parent to resolve
while not script.Parent do
&#9;wait(0)
end

-- Identify the modular script
-- local NevermoreModularScript = WaitForChild(script.Parent, &quot;NevermoreEngine&quot;)

local NevermoreModularScript = ReplicatedStorage:FindFirstChild(&quot;NevermoreEngine&quot;)
if not NevermoreModularScript then
&#9;local NevermoreModularScriptSource = WaitForChild(script.Parent, &quot;NevermoreEngine&quot;)

&#9;NevermoreModularScript             = NevermoreModularScriptSource:Clone()
&#9;NevermoreModularScript.Archivable  = false
end

local Nevermore = require(NevermoreModularScript)

-- Set identifier, and initiate.
Nevermore.Initiate()
NevermoreModularScript.Parent = ReplicatedStorage</ProtectedString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>
'''
