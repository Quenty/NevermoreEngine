# Phase 0.5: Plugin Modules (Lune-Testable Luau) -- Agent Prompts

**Phase reference**: [studio-bridge/plans/execution/phases/00.5-plugin-modules.md](../phases/00.5-plugin-modules.md)
**Validation**: [studio-bridge/plans/execution/validation/00.5-plugin-modules.md](../validation/00.5-plugin-modules.md)

Base path for all file references: `/workspaces/NevermoreEngine/tools/studio-bridge/`

## How to Use These Prompts

1. Copy the full prompt for a single task into a Claude Code sub-agent session.
2. The agent should read the "Read First" files, then implement the "Requirements" section.
3. The agent should run the acceptance criteria checks before reporting completion.
4. Do not give an agent a task whose dependencies have not been completed yet.

Key conventions that apply to every prompt:

- **Luau** source files with `.luau` extension
- **No Roblox API dependencies** -- these modules must run under Lune without `game`, `HttpService`, `RunService`, etc.
- **Dependency injection** -- external I/O (HTTP, WebSocket) is injected via callbacks, never called directly
- **Lune** for test runner: `lune run test/<testfile>`
- **Pure logic only** -- no side effects in module scope

---

## Test Harness (Created by Task 0.5.1)

Task 0.5.1 must create the shared test harness **before** implementing the Protocol module. This harness is a prerequisite for all Phase 0.5 tasks -- without it, no Lune tests can run.

All test harness files go in `templates/studio-bridge-plugin/test/`.

### `test/roblox-mocks.luau`

Minimal stubs for Roblox services so that pure logic modules can be required without errors. These do not need full implementations -- just enough that modules load and pure logic is exercisable.

Required stubs:

1. **HttpService** -- `JSONEncode(self, value)` and `JSONDecode(self, json)`. Implementation can delegate to Lune's `net.jsonEncode` / `net.jsonDecode` since these are equivalent for pure data.

2. **RunService** -- Stub methods returning constants:
   - `IsStudio(self)` -> `true`
   - `IsRunning(self)` -> `false`
   - `IsClient(self)` -> `false`
   - `IsServer(self)` -> `false`
   - `Heartbeat` -> a mock Signal (see below)

3. **LogService** -- `MessageOut` -> a mock Signal.

4. **Signal mock** -- A simple table with:
   - `Connect(self, callback)` -> returns a connection object with `Disconnect(self)` method
   - `Fire(self, ...)` -> calls all connected callbacks with the given arguments
   - Tracks connected callbacks in a list; `Disconnect` removes the callback from the list

The mocks module should return a table that can be used to inject these services or to set up a mock `game` global for test purposes. The Phase 0.5 modules themselves do NOT use Roblox APIs (they use dependency injection), but the mocks may be useful for the integration glue tests later.

### `test/test-runner.luau`

A simple Lune test runner that:

1. Takes a list of test file paths as command-line arguments (via `process.args`), or if no arguments are given, discovers all `*.test.luau` files in the `test/` directory (non-recursive, excluding `test/integration/`).
2. For each test file, `require`s it (or uses `dofile` / Lune equivalent) and runs the tests.
3. Prints pass/fail status per individual test with the test name.
4. Prints a summary at the end: `X passed, Y failed, Z total`.
5. Exits with code 0 if all tests passed, code 1 if any failed.

Test files should export their tests in a format the runner understands. The simplest approach: each test file returns a table of `{ name: string, fn: () -> () }` entries. The runner calls each `fn` inside a `pcall`. If the `pcall` succeeds, the test passes. If it errors, the test fails and the error message is printed.

Agents run: `lune run test/test-runner.luau` (all unit tests) or `lune run test/protocol.test.luau` (single file, if test files also self-execute).

---

## Task 0.5.1: Protocol Module

**Prerequisites**: None (first task in Phase 0.5; also creates the shared test harness).

**Context**: The studio-bridge plugin needs to encode and decode JSON messages conforming to the wire protocol. This module handles pure message serialization/deserialization with no Roblox dependencies, making it testable under Lune. **This task also creates the shared test harness that all subsequent Phase 0.5 tasks depend on.**

**Objective**: Create the Lune test harness (roblox-mocks + test-runner) AND a Luau module that encodes and decodes all studio-bridge protocol message types as JSON strings.

**Read First**:
- `/workspaces/NevermoreEngine/studio-bridge/plans/tech-specs/01-protocol.md` (wire protocol message formats)
- `/workspaces/NevermoreEngine/studio-bridge/plans/tech-specs/00-overview.md` (architecture overview)

**Files to Create**:
- `templates/studio-bridge-plugin/test/roblox-mocks.luau` -- Roblox service stubs (see Test Harness section above)
- `templates/studio-bridge-plugin/test/test-runner.luau` -- Lune test runner (see Test Harness section above)
- `templates/studio-bridge-plugin/src/Shared/Protocol.luau` -- encode/decode module
- `templates/studio-bridge-plugin/test/protocol.test.luau` -- Lune test: round-trip encode/decode for each message type

**Requirements**:

1. The module exports a table with two primary functions:

```luau
local Protocol = {}

-- Encode a message table to a JSON string
function Protocol.encode(message: {
    type: string,
    sessionId: string,
    payload: { [string]: any },
    requestId: string?,
    protocolVersion: number?,
}): string

-- Decode a JSON string to a message table, or return nil + error string
function Protocol.decode(raw: string): ({ [string]: any }?, string?)
```

2. Handle ALL message types from the protocol spec:
   - **Plugin-to-Server**: `register`, `hello`, `scriptComplete`, `output`, `stateResult`, `screenshotResult`, `dataModelResult`, `logsResult`, `stateChange`, `heartbeat`, `subscribeResult`, `unsubscribeResult`, `error`
   - **Server-to-Plugin**: `welcome`, `execute`, `shutdown`, `queryState`, `captureScreenshot`, `queryDataModel`, `queryLogs`, `subscribe`, `unsubscribe`, `error`

3. `encode` must:
   - Accept a message table with `type`, `sessionId`, `payload`, and optional `requestId`/`protocolVersion`
   - Return a valid JSON string
   - Omit `requestId` and `protocolVersion` from the output when they are `nil`

4. `decode` must:
   - Parse JSON string into a table
   - Validate that `type`, `sessionId`, and `payload` are present
   - Return `nil, "error description"` for malformed input (invalid JSON, missing required fields)
   - Pass through `requestId` and `protocolVersion` when present

5. Use a simple JSON library suitable for Lune (e.g., `net.jsonEncode`/`net.jsonDecode` from Lune's standard library, or a pure-Luau JSON implementation). Do NOT use `HttpService:JSONEncode` (that requires Roblox).

6. Add message type validation: `decode` should verify that `type` is one of the known message types and return `nil, "unknown message type: <type>"` for unrecognized types.

**Acceptance Criteria**:
- `Protocol.encode(msg)` produces valid JSON for every message type.
- `Protocol.decode(Protocol.encode(msg))` round-trips correctly for every message type.
- `Protocol.decode("invalid json")` returns `nil` with an error string.
- `Protocol.decode('{"type":"unknown","sessionId":"x","payload":{}}')` returns `nil` with an error about unknown type.
- `Protocol.decode('{"type":"hello"}')` returns `nil` with an error about missing `sessionId`.
- `lune run test/protocol.test.luau` passes all tests.

**Do NOT**:
- Use any Roblox APIs (`HttpService`, `game`, etc.).
- Import any Nevermore modules (this is standalone).
- Add side effects at module scope.

---

## Task 0.5.2: Discovery State Machine

**Prerequisites**: Task 0.5.1 (Protocol module and test harness) must be completed first.

**Context**: The persistent plugin needs to discover a running bridge host by polling HTTP health endpoints, then connect via WebSocket. The state machine logic must be testable without Roblox APIs, so all I/O is injected via callbacks.

**Objective**: Create a pure state machine module for plugin discovery and connection lifecycle.

**Read First**:
- `/workspaces/NevermoreEngine/studio-bridge/plans/tech-specs/03-persistent-plugin.md` (sections 3-4: discovery and reconnection)
- `/workspaces/NevermoreEngine/studio-bridge/plans/tech-specs/01-protocol.md` (handshake flow)

**Files to Create**:
- `templates/studio-bridge-plugin/src/Shared/DiscoveryStateMachine.luau` -- state machine module
- `test/discovery.test.luau` -- Lune test: all state transitions with mock callbacks

**Requirements**:

1. The module exports a constructor and state machine interface:

```luau
local DiscoveryStateMachine = {}
DiscoveryStateMachine.__index = DiscoveryStateMachine

export type State = "idle" | "searching" | "connecting" | "connected" | "reconnecting"

export type Config = {
    portRange: { min: number, max: number },    -- default 38740-38759
    pollIntervalMs: number,                      -- default 2000
    maxReconnectAttempts: number,                -- default 10
    initialBackoffMs: number,                    -- default 1000
    maxBackoffMs: number,                        -- default 30000
    heartbeatIntervalMs: number,                 -- default 5000
}

export type Callbacks = {
    httpGet: (url: string) -> (boolean, string?),       -- success, responseBody
    connectWebSocket: (url: string) -> (boolean, any?), -- success, connection
    onStateChange: (oldState: State, newState: State) -> (),
    onConnected: (connection: any) -> (),
    onDisconnected: (reason: string?) -> (),
}

function DiscoveryStateMachine.new(config: Config?, callbacks: Callbacks)
```

2. State transitions:
   - `idle` -> `searching`: called via `stateMachine:start()`
   - `searching` -> `connecting`: when `httpGet` succeeds on a port's `/health` endpoint
   - `searching` -> `searching`: when `httpGet` fails, try next port (wraps around)
   - `connecting` -> `connected`: when `connectWebSocket` succeeds
   - `connecting` -> `searching`: when `connectWebSocket` fails
   - `connected` -> `reconnecting`: when connection is lost (call `stateMachine:onDisconnect()`)
   - `reconnecting` -> `connecting`: after backoff delay
   - `reconnecting` -> `idle`: after `maxReconnectAttempts` exhausted
   - Any state -> `idle`: via `stateMachine:stop()`

3. Methods:
   - `start()` -- transition from idle to searching
   - `stop()` -- transition to idle from any state, cancel timers
   - `onDisconnect(reason: string?)` -- signal connection lost
   - `getState(): State` -- return current state
   - `tick(deltaMs: number)` -- advance timers by deltaMs (for testability without real timers)

4. The `tick` method is crucial for testability: instead of using real timers (`task.delay`, `os.clock`), the state machine tracks elapsed time internally and `tick` advances it. Tests call `tick(2000)` to simulate 2 seconds passing.

5. Exponential backoff for reconnection: `min(initialBackoffMs * 2^attempt, maxBackoffMs)`.

6. Port scanning: iterate ports from `portRange.min` to `portRange.max`, calling `httpGet("http://localhost:{port}/health")` for each. On success, parse the JSON response to extract the WebSocket URL.

**Acceptance Criteria**:
- State starts as `idle`.
- `start()` transitions to `searching`.
- Mock `httpGet` returning success triggers transition to `connecting`.
- Mock `connectWebSocket` returning success triggers transition to `connected` and `onConnected` callback.
- `onDisconnect()` while `connected` transitions to `reconnecting`.
- After enough `tick()` calls with failing `connectWebSocket`, reconnect attempts exhaust and state returns to `idle`.
- `stop()` from any state transitions to `idle`.
- Backoff doubles each attempt, capped at `maxBackoffMs`.
- `lune run test/discovery.test.luau` passes all tests.

**Do NOT**:
- Use any Roblox APIs (`HttpService`, `RunService`, `task`, `game`, etc.).
- Use real timers -- use the `tick(deltaMs)` pattern for deterministic testing.
- Import any Nevermore modules.

---

## Task 0.5.3: Action Router and Message Buffer

**Prerequisites**: Task 0.5.1 (Protocol module and test harness) must be completed first.

**Context**: The plugin needs to route incoming action requests (execute, queryState, etc.) to the correct handler and return response messages. It also needs a ring buffer for log messages so that `queryLogs` can retrieve recent history.

**Objective**: Create an ActionRouter for dispatching incoming messages to registered handlers, and a MessageBuffer (ring buffer) for log storage.

**Read First**:
- `/workspaces/NevermoreEngine/studio-bridge/plans/tech-specs/04-action-specs.md` (action types and expected behavior)
- `/workspaces/NevermoreEngine/studio-bridge/plans/tech-specs/01-protocol.md` (message structure)

**Files to Create**:
- `templates/studio-bridge-plugin/src/Shared/ActionRouter.luau` -- action dispatch module
- `templates/studio-bridge-plugin/src/Shared/MessageBuffer.luau` -- ring buffer module
- `test/actions.test.luau` -- Lune tests for both modules

**Requirements**:

### ActionRouter

1. The module exports a constructor and dispatch interface:

```luau
local ActionRouter = {}
ActionRouter.__index = ActionRouter

-- Handler receives (payload, requestId, sessionId) and returns a response payload table or nil
export type Handler = (payload: { [string]: any }, requestId: string, sessionId: string) -> { [string]: any }?

function ActionRouter.new()

-- Register a handler for a message type
function ActionRouter:register(messageType: string, handler: Handler)

-- Dispatch an incoming message. Returns a response message table or nil.
function ActionRouter:dispatch(message: {
    type: string,
    sessionId: string,
    payload: { [string]: any },
    requestId: string?,
}): { [string]: any }?
```

2. `dispatch` behavior:
   - Look up a registered handler for `message.type`.
   - If found, call the handler with `(message.payload, message.requestId, message.sessionId)`.
   - If the handler returns a payload table, construct a response message with the appropriate response type (e.g., `queryState` -> `stateResult`), the same `sessionId` and `requestId`, and the returned payload.
   - If no handler is registered, return an error response message with code `UNKNOWN_REQUEST`.
   - If the handler errors (pcall fails), return an error response message with code `INTERNAL_ERROR`.

3. Maintain a mapping of request types to response types:

```luau
local RESPONSE_TYPES = {
    execute = "scriptComplete",
    queryState = "stateResult",
    captureScreenshot = "screenshotResult",
    queryDataModel = "dataModelResult",
    queryLogs = "logsResult",
    subscribe = "subscribeResult",
    unsubscribe = "unsubscribeResult",
}
```

### MessageBuffer

4. The module exports a ring buffer:

```luau
local MessageBuffer = {}
MessageBuffer.__index = MessageBuffer

function MessageBuffer.new(capacity: number) -- default 1000

-- Add an entry to the buffer (overwrites oldest if at capacity)
function MessageBuffer:push(entry: {
    level: string,  -- "Print" | "Info" | "Warning" | "Error"
    body: string,
    timestamp: number,
})

-- Get entries. direction: "head" (oldest first) or "tail" (newest first). count: max entries to return.
function MessageBuffer:get(direction: string?, count: number?): {
    entries: { { level: string, body: string, timestamp: number } },
    total: number,
    bufferCapacity: number,
}

-- Clear all entries
function MessageBuffer:clear()

-- Current number of entries
function MessageBuffer:size(): number
```

5. Ring buffer implementation: use a fixed-size array with a write index that wraps around. When the buffer is full, new entries overwrite the oldest.

**Acceptance Criteria**:
- Registering a handler and dispatching a matching message calls the handler and returns a response.
- Dispatching an unknown message type returns an error response with `UNKNOWN_REQUEST`.
- Dispatching when the handler errors returns an error response with `INTERNAL_ERROR`.
- Response messages have the correct response type, sessionId, and requestId.
- MessageBuffer stores entries up to capacity.
- Pushing beyond capacity overwrites the oldest entry.
- `get("tail", 5)` returns the 5 most recent entries.
- `get("head", 5)` returns the 5 oldest entries.
- `clear()` empties the buffer.
- `lune run test/actions.test.luau` passes all tests.

**Do NOT**:
- Use any Roblox APIs.
- Import any Nevermore modules.
- Use real timers.

---

## Task 0.5.4: Lune Integration Tests

**Prerequisites**: Tasks 0.5.1, 0.5.2, 0.5.3 (all Phase 0.5 modules) and Task 1.3a (bridge host WebSocket server) must be completed first.

**Context**: With the Protocol, DiscoveryStateMachine, ActionRouter, and MessageBuffer modules complete, we need an end-to-end integration test that validates the full round-trip over a real WebSocket connection.

**Objective**: Create a Lune integration test that starts a real TypeScript WebSocket server (the bridge host from Task 1.3a), connects using the Protocol module over WebSocket, and performs a full register -> welcome -> execute -> result round-trip.

**Dependencies**: Tasks 0.5.1, 0.5.2, 0.5.3, and Task 1.3a (bridge host WebSocket server must be runnable).

**Read First**:
- `templates/studio-bridge-plugin/src/Shared/Protocol.luau` (from Task 0.5.1)
- `templates/studio-bridge-plugin/src/Shared/DiscoveryStateMachine.luau` (from Task 0.5.2)
- `templates/studio-bridge-plugin/src/Shared/ActionRouter.luau` (from Task 0.5.3)
- `/workspaces/NevermoreEngine/tools/studio-bridge/src/server/studio-bridge-server.ts` (the bridge host server)
- `/workspaces/NevermoreEngine/studio-bridge/plans/tech-specs/01-protocol.md` (handshake flow)

**Files to Create**:
- `test/integration.test.luau` -- Lune integration test

**Requirements**:

1. The test must:
   - Start the TypeScript bridge host server as a subprocess (using Lune's `process.spawn` or equivalent)
   - Wait for the server's health endpoint to respond
   - Connect to the server via WebSocket using Lune's `net.socket`
   - Send a `register` message using `Protocol.encode`
   - Receive and decode the `welcome` response using `Protocol.decode`
   - Validate that the welcome contains `protocolVersion` and negotiated capabilities
   - Send an `execute` request (simple `print("hello")` script)
   - Receive and decode the `output` and `scriptComplete` messages
   - Validate the output and completion status
   - Clean up: close WebSocket, stop the server subprocess

2. Test the full message flow:
   ```
   Client (Lune)               Server (Node.js)
   ──────────────              ────────────────
   register         ──────>
                    <──────    welcome
   [heartbeat]      ──────>    (optional, verify accepted)
   execute request  <──────
   output           ──────>
   scriptComplete   ──────>
   ```

3. Use proper timeouts: fail the test if any step takes longer than 10 seconds.

4. Clean up resources in all cases (success, failure, timeout) to avoid leaked processes.

**Acceptance Criteria**:
- The integration test completes a full register -> welcome -> execute -> result round-trip.
- The test starts and stops the server subprocess cleanly.
- The test fails with a clear message if the server is not available or the handshake fails.
- `lune run test/integration.test.luau` passes.

**Do NOT**:
- Skip cleanup on failure (always stop the server subprocess).
- Hard-code port numbers (discover from the server's health endpoint or use a dynamic port).
- Use any Roblox APIs.

---

## Cross-References

- Protocol spec: `studio-bridge/plans/tech-specs/01-protocol.md`
- Persistent plugin spec: `studio-bridge/plans/tech-specs/03-persistent-plugin.md`
- Action specs: `studio-bridge/plans/tech-specs/04-action-specs.md`
