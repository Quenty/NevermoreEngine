# Phase 0.5: Lune-Testable Plugin Modules

Goal: Extract pure Luau logic modules from the plugin that can be tested via Lune (a standalone Luau runtime) without Roblox Studio. These modules form Layer 1 of the plugin architecture -- they have zero Roblox API dependencies. Phase 2 (Task 2.1) then writes only the thin Layer 2 glue that wires these modules to actual Roblox services.

References:
- Protocol: `studio-bridge/plans/tech-specs/01-protocol.md`
- Persistent plugin: `studio-bridge/plans/tech-specs/03-persistent-plugin.md`
- Action specs: `studio-bridge/plans/tech-specs/04-action-specs.md`

Base path for plugin template files: `/workspaces/NevermoreEngine/tools/studio-bridge/templates/studio-bridge-plugin/`

Cross-references:
- Phase 2 (Task 2.1) depends on this phase for Layer 1 modules
- Task 0.5.4 depends on Task 1.3a (bridge host) for the TypeScript WebSocket server

---

## Architecture: Three Layers

**Layer 1 -- Pure Luau modules** (this phase, testable via Lune):
- `Protocol.luau` -- Message encoding/decoding, frame parsing, WebSocket message construction
- `DiscoveryStateMachine.luau` -- State machine for discovery flow (idle -> searching -> connecting -> connected), transition logic, retry/backoff
- `ActionRouter.luau` -- Dispatches incoming action messages to handler functions, returns response messages
- `MessageBuffer.luau` -- Ring buffer for log messages, configurable capacity

**Layer 2 -- Thin Roblox glue** (~100-150 LOC, built in Phase 2 Task 2.1):
- Wires Layer 1 modules to actual Roblox services (HttpService, RunService, LogService, CaptureService)
- Entry point: reads build constants, calls `DiscoveryStateMachine.start()`, connects `ActionRouter` to WebSocket

**Layer 3 -- Lune integration tests** (Task 0.5.4):
- Lune test scripts that start a real TypeScript WebSocket server (from Task 1.3a) and connect a mock plugin client using the Protocol module
- Tests: handshake, register/welcome, action dispatch round-trip, heartbeat, reconnection

---

### Task 0.5.1: Protocol module + Test harness

**Description**: Create the shared Lune test harness (prerequisite for all Phase 0.5 tasks) AND implement the pure Luau message encoding/decoding module. The test harness consists of `test/roblox-mocks.luau` (minimal Roblox service stubs: HttpService, RunService, LogService, Signal mock) and `test/test-runner.luau` (discovers and runs `*.test.luau` files, prints pass/fail, exits 0 or 1). The Protocol module handles all v2 message types (register, welcome, execute, scriptComplete, queryState, stateResult, captureScreenshot, screenshotResult, queryDataModel, dataModelResult, queryLogs, logsResult, subscribe, unsubscribe, stateChange, heartbeat, shutdown, error) as well as v1 message types (hello, welcome, execute, scriptComplete, output). No Roblox API dependencies -- uses only standard Luau string/table operations.

**Files to create**:
- `test/roblox-mocks.luau` -- Minimal Roblox service stubs for HttpService (JSONEncode/JSONDecode), RunService (IsStudio/IsRunning/Heartbeat signal), LogService (MessageOut signal), and a basic Signal mock (Connect/Disconnect/Fire).
- `test/test-runner.luau` -- Simple Lune test runner: takes test file paths as args (or auto-discovers `*.test.luau` in `test/`), runs each test via pcall, prints pass/fail per test, exits 0 (all pass) or 1 (any fail). Agents run: `lune run test/test-runner.luau`.
- `src/Shared/Protocol.luau` -- Message encode (table -> JSON string) and decode (JSON string -> typed table). Frame construction for WebSocket messages. Message type constants. Request ID generation.
- `test/protocol.test.luau` -- Lune unit tests for every message type encode/decode round-trip, malformed input handling, v1/v2 compatibility.

**Dependencies**: None. (The test harness created here is a prerequisite for Tasks 0.5.2, 0.5.3, and 0.5.4.)

**Complexity**: S

**Agent-assignable**: yes

**Acceptance criteria**:
- `test/roblox-mocks.luau` exists and exports stubs for HttpService, RunService, LogService, and Signal.
- `test/test-runner.luau` exists, discovers and runs `*.test.luau` files, prints pass/fail, and exits with code 0 or 1.
- `lune run test/test-runner.luau` runs successfully (exit code 0) with the protocol tests.
- `Protocol.encode(message)` serializes a message table to a JSON string.
- `Protocol.decode(jsonString)` deserializes a JSON string to a typed message table, returning `nil` for malformed input.
- All v2 message types round-trip correctly (encode then decode produces the original table).
- v1 message types (`hello`, `welcome`, `execute`, `scriptComplete`, `output`) also round-trip correctly.
- `Protocol.createRequestId()` returns a unique string suitable for request correlation.
- No `require` of any Roblox service (HttpService, game, etc.).
- All Lune tests pass.

### Task 0.5.2: Discovery state machine

**Description**: Implement the discovery state machine as a pure Luau module. The state machine drives the plugin's connection lifecycle: idle -> searching -> connecting -> connected, with retry logic and exponential backoff. All side effects (HTTP requests, WebSocket connections) are injected via callbacks, making the state machine fully testable without Roblox APIs.

**Files to create**:
- `src/Shared/DiscoveryStateMachine.luau` -- State machine with states: `idle`, `searching`, `connecting`, `connected`, `reconnecting`. Transition functions. Retry logic with configurable exponential backoff (1s, 2s, 4s, 8s, max 30s). Takes injected callbacks: `onHttpPoll(url) -> result`, `onWebSocketConnect(url) -> connection`, `onStateChange(oldState, newState)`.
- `test/discovery.test.luau` -- Lune unit tests for state transitions, retry timing, backoff progression, callback invocation order, error handling during transitions.

**Dependencies**: Task 0.5.1 (uses Protocol module for message types).

**Complexity**: M

**Agent-assignable**: yes

**Acceptance criteria**:
- State machine starts in `idle` state.
- `start()` transitions from `idle` to `searching`.
- The heartbeat loop runs as a `task.spawn` coroutine in the Layer 2 glue, not inside the state machine. The state machine exposes `isConnected()` which the coroutine checks each iteration. When the state leaves `connected`, the coroutine exits cleanly (do not use `task.cancel` -- it can leave partial WebSocket frames). See `studio-bridge/plans/tech-specs/03-persistent-plugin.md` section 6.3 for the full pattern.
- In `searching` state, the machine calls the injected HTTP poll callback at configurable intervals.
- When the health check succeeds, transitions to `connecting` and calls the WebSocket connect callback.
- When WebSocket connects successfully, transitions to `connected`.
- When WebSocket disconnects while in `connected`, transitions to `reconnecting` with exponential backoff (1s, 2s, 4s, 8s, max 30s).
- `stop()` transitions to `idle` from any state and cancels pending retries.
- The `onStateChange` callback fires for every transition with `(oldState, newState)`.
- All callbacks are injected -- no Roblox API dependencies.
- All Lune tests pass.

### Task 0.5.3: Action router and message buffer

**Description**: Implement the action router (dispatches incoming action messages to registered handler functions) and the message buffer (ring buffer for log collection) as pure Luau modules. Both are used by the plugin to process server commands and buffer output.

**Files to create**:
- `src/Shared/ActionRouter.luau` -- `ActionRouter.new()` constructor. `router:registerHandler(actionType, handlerFn)` registers a handler. `router:dispatch(message) -> responseMessage` looks up the handler by `message.type`, calls it, and returns the response message. Returns an error response for unregistered action types.
- `src/Shared/MessageBuffer.luau` -- `MessageBuffer.new(capacity)` constructor. `buffer:push(message)` adds a message (oldest evicted when full). `buffer:flush() -> messages[]` returns all buffered messages and clears the buffer. `buffer:count() -> number`.
- `test/actions.test.luau` -- Lune unit tests for handler registration, dispatch, unknown action handling, error responses, buffer push/flush/eviction.

**Dependencies**: Task 0.5.1 (uses Protocol module for message types).

**Complexity**: S

**Agent-assignable**: yes

**Acceptance criteria**:
- `ActionRouter:registerHandler("execute", fn)` registers the handler for `execute` messages.
- `ActionRouter:dispatch(message)` calls the registered handler and returns its response.
- Dispatching an unregistered action type returns an error response with `type = "error"` and a descriptive message.
- `MessageBuffer.new(100)` creates a buffer with capacity 100.
- `MessageBuffer:push(msg)` adds messages; when capacity is exceeded, the oldest message is evicted.
- `MessageBuffer:flush()` returns all buffered messages in insertion order and clears the buffer.
- `MessageBuffer:count()` returns the current number of buffered messages.
- No Roblox API dependencies.
- All Lune tests pass.

### Task 0.5.4: Lune integration tests

**Description**: Cross-language integration tests that start a real TypeScript WebSocket server (the bridge host from Task 1.3a) and connect a mock Lune-based plugin client using the Protocol module. These tests validate the full protocol round-trip without requiring Roblox Studio.

**Files to create**:
- `test/integration/lune-bridge.test.luau` -- Lune test script that:
  1. Spawns the TypeScript bridge host process
  2. Creates a mock plugin client using the Protocol module
  3. Performs a register -> welcome handshake
  4. Sends/receives action messages (execute, queryState)
  5. Tests heartbeat keepalive
  6. Tests reconnection after intentional disconnect

**Dependencies**: Tasks 0.5.1, 0.5.2, 0.5.3 (all Layer 1 modules), Task 1.3a (bridge host for the TypeScript WebSocket server).

**Complexity**: M

**Agent-assignable**: yes (requires Lune installed via aftman)

**Acceptance criteria**:
- Integration test starts a TypeScript bridge host and connects a Lune mock plugin.
- Register -> welcome handshake completes successfully.
- Execute action round-trip: server sends `execute`, mock plugin processes it via ActionRouter, server receives `scriptComplete`.
- Heartbeat messages are sent and acknowledged.
- After intentional disconnect, the DiscoveryStateMachine drives reconnection and the mock plugin re-registers.
- All tests clean up spawned processes in teardown.

---

### Parallelization within Phase 0.5

Tasks 0.5.1, 0.5.2, and 0.5.3 have minimal dependencies on each other (0.5.2 and 0.5.3 use Protocol types from 0.5.1, but the Protocol interface is small enough that they can be developed against a stub). Task 0.5.4 depends on all three Layer 1 modules plus the bridge host from Phase 1 (Task 1.3a).

```
0.5.1 (Protocol) --+--> 0.5.2 (Discovery state machine) --+--> 0.5.4 (Lune integration)
                    |                                       |
                    +--> 0.5.3 (Action router + buffer) ---+
                                                            |
Phase 1: 1.3a (bridge host) --------------------------------+
```

Phase 0.5 has NO dependency on Phase 0 or Phase 1 (except 0.5.4 needs 1.3a). Tasks 0.5.1-0.5.3 can run in parallel with everything.

---

## Phase 0.5 Gate

All Lune unit tests pass. Integration test (Task 0.5.4) completes a register -> welcome -> exec -> result round-trip against the real TypeScript bridge host.

---

## Testing Strategy (Phase 0.5)

**Lune unit tests** (Tasks 0.5.1-0.5.3):
- Protocol encode/decode for every v2 message type, including malformed input.
- Discovery state machine transitions: idle -> searching -> connecting -> connected -> reconnecting -> connected.
- Discovery backoff progression: 1s, 2s, 4s, 8s, 8s (capped at max).
- ActionRouter dispatch to registered handlers, error response for unknown types.
- MessageBuffer push/flush/eviction at capacity boundary.

**Lune integration tests** (Task 0.5.4):
- Full protocol round-trip with real TypeScript WebSocket server.
- Handshake, action dispatch, heartbeat, reconnection.
- Cross-language message compatibility (Luau JSON encoding matches TypeScript expectations).

---

## Failure Modes

Default policy: **escalate integration issues to review agent, self-fix isolated issues.**

| Task | Likely Failure | Recovery Action |
|------|---------------|-----------------|
| 0.5.1 (Protocol) | JSON encoding differences between Luau and TypeScript (e.g., number precision, nil vs null) | Self-fix: add round-trip tests that encode in Luau and decode in TypeScript (and vice versa). Fix encoding to match JSON spec. |
| 0.5.1 (test harness) | Roblox mock stubs are too minimal, causing downstream test failures in 0.5.2/0.5.3 | Self-fix: extend mocks as needed. Keep mocks minimal but sufficient. |
| 0.5.2 (DiscoveryStateMachine) | State machine has unreachable states or missing transitions that only surface in real Studio | Self-fix for logic errors caught by Lune tests. Escalate if the state machine design itself is flawed (e.g., missing a state that Studio requires). |
| 0.5.2 (DiscoveryStateMachine) | Backoff timing is untestable without real delays | Self-fix: inject a clock/timer abstraction so tests can advance time without waiting. |
| 0.5.3 (ActionRouter) | Dispatch table design does not match how Phase 2 action handlers need to register | Escalate: this is a cross-phase interface issue. Review with Phase 2 task owner before changing the API. |
| 0.5.3 (MessageBuffer) | Ring buffer eviction order is wrong (LIFO instead of FIFO) | Self-fix: add explicit ordering test and fix. |
| 0.5.4 (Lune integration) | TypeScript bridge host process spawning fails in CI or different environments | Self-fix: ensure process spawn uses absolute paths and waits for port readiness before connecting. |
| 0.5.4 (Lune integration) | Lune WebSocket client API differs from Roblox WebSocket API, invalidating the integration test | Escalate: this affects the cross-language contract. The Lune mock may need adjustment, or the Protocol module may need to abstract the transport layer. |
