# Validation: Phase 0.5 -- Lune-Testable Plugin Modules

Test specifications for the pure Luau plugin modules: Protocol, DiscoveryStateMachine, ActionRouter, MessageBuffer, and cross-language integration.

**Phase**: 0.5 (Lune-Testable Plugin Modules)

**References**:
- Phase plan: `studio-bridge/plans/execution/phases/00.5-plugin-modules.md`
- Agent prompts: `studio-bridge/plans/execution/agent-prompts/00.5-plugin-modules.md`
- Tech specs: `studio-bridge/plans/tech-specs/01-protocol.md`, `studio-bridge/plans/tech-specs/03-persistent-plugin.md`, `studio-bridge/plans/tech-specs/04-action-specs.md`

Base path for source files: `/workspaces/NevermoreEngine/tools/studio-bridge/templates/studio-bridge-plugin/`

---

## Required Test Files

| Test file | Task | Module(s) under test |
|-----------|------|---------------------|
| `test/protocol.test.luau` | 0.5.1 | Protocol |
| `test/discovery.test.luau` | 0.5.2 | DiscoveryStateMachine |
| `test/actions.test.luau` | 0.5.3 | ActionRouter, MessageBuffer |
| `test/integration/lune-bridge.test.luau` | 0.5.4 | Protocol, DiscoveryStateMachine, ActionRouter (end-to-end) |

## Test Harness (Prerequisite)

Task 0.5.1 creates the shared test harness before any module tests can run. These files live in `test/`:

| File | Purpose |
|------|---------|
| `test/roblox-mocks.luau` | Minimal stubs for HttpService, RunService, LogService, and a basic Signal mock |
| `test/test-runner.luau` | Simple test runner that discovers and runs test files, prints pass/fail, exits 0 or 1 |

All test commands use: `lune run test/test-runner.luau` (runs all test files) or `lune run test/<specific-test>.luau` (runs a single test file).

---

## 1. Unit Test Plans

### 1.1 Protocol Module (`test/protocol.test.luau`)

**Expected test count**: ~20 tests

#### 1.1.1 Encode -- all message types

- **Test name**: `Protocol.encode produces valid JSON for register message`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Construct a `register` message table with `type`, `sessionId`, `payload` (containing `pluginVersion`, `instanceId`, `placeName`, `state`, `capabilities`), and `protocolVersion`.
  2. Call `Protocol.encode(message)`.
  3. Decode the resulting JSON string back into a table using `net.jsonDecode`.
  4. Verify all fields are present and match.
- **Expected result**: Valid JSON string containing all fields.
- **Automation**: Lune test.

---

- **Test name**: `Protocol.encode produces valid JSON for each plugin-to-server message type`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. For each plugin-to-server type (`register`, `hello`, `scriptComplete`, `output`, `stateResult`, `screenshotResult`, `dataModelResult`, `logsResult`, `stateChange`, `heartbeat`, `subscribeResult`, `unsubscribeResult`, `error`), construct a valid message table.
  2. Call `Protocol.encode` for each.
  3. Verify each produces parseable JSON with the correct `type` field.
- **Expected result**: All 13 plugin-to-server types produce valid JSON.
- **Automation**: Lune test, loop over message types.

---

- **Test name**: `Protocol.encode omits requestId and protocolVersion when nil`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Construct a message with `requestId = nil` and `protocolVersion = nil`.
  2. Encode it.
  3. Parse the JSON and verify neither key is present.
- **Expected result**: JSON output has no `requestId` or `protocolVersion` keys.
- **Automation**: Lune test.

---

- **Test name**: `Protocol.encode includes requestId and protocolVersion when present`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Construct a message with `requestId = "req-001"` and `protocolVersion = 2`.
  2. Encode and parse back.
- **Expected result**: Both fields present in output.
- **Automation**: Lune test.

#### 1.1.2 Decode -- valid messages

- **Test name**: `Protocol.decode round-trips correctly for every message type`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. For each of the ~23 message types (plugin-to-server + server-to-plugin), construct a message, encode it, then decode the result.
  2. Compare decoded table to original.
- **Expected result**: Decoded message matches original for every type.
- **Automation**: Lune test, parameterized loop.

---

- **Test name**: `Protocol.decode passes through requestId when present`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Encode a message with `requestId = "req-abc"`.
  2. Decode it.
  3. Verify `requestId` is `"req-abc"` in the decoded result.
- **Expected result**: `requestId` preserved.
- **Automation**: Lune test.

---

- **Test name**: `Protocol.decode passes through protocolVersion when present`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Encode a message with `protocolVersion = 2`.
  2. Decode it.
- **Expected result**: `protocolVersion` is `2` in decoded result.
- **Automation**: Lune test.

#### 1.1.3 Decode -- error handling

- **Test name**: `Protocol.decode returns nil and error for invalid JSON`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Call `Protocol.decode("not valid json")`.
- **Expected result**: Returns `nil, <error string>`.
- **Automation**: Lune test.

---

- **Test name**: `Protocol.decode returns nil and error for missing type field`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Call `Protocol.decode('{"sessionId":"x","payload":{}}')`.
- **Expected result**: Returns `nil, <error string mentioning type>`.
- **Automation**: Lune test.

---

- **Test name**: `Protocol.decode returns nil and error for missing sessionId`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Call `Protocol.decode('{"type":"hello","payload":{}}')`.
- **Expected result**: Returns `nil, <error string mentioning sessionId>`.
- **Automation**: Lune test.

---

- **Test name**: `Protocol.decode returns nil and error for missing payload`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Call `Protocol.decode('{"type":"hello","sessionId":"x"}')`.
- **Expected result**: Returns `nil, <error string mentioning payload>`.
- **Automation**: Lune test.

---

- **Test name**: `Protocol.decode returns nil and error for unknown message type`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Call `Protocol.decode('{"type":"unknownType","sessionId":"x","payload":{}}')`.
- **Expected result**: Returns `nil, "unknown message type: unknownType"`.
- **Automation**: Lune test.

---

- **Test name**: `Protocol.decode returns nil and error for empty string`
- **Priority**: P1
- **Type**: unit
- **Steps**:
  1. Call `Protocol.decode("")`.
- **Expected result**: Returns `nil, <error string>`.
- **Automation**: Lune test.

### 1.2 Discovery State Machine (`test/discovery.test.luau`)

**Expected test count**: ~15 tests

#### 1.2.1 State transitions

- **Test name**: `State starts as idle`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Create a `DiscoveryStateMachine` with default config and mock callbacks.
  2. Call `getState()`.
- **Expected result**: Returns `"idle"`.
- **Automation**: Lune test.

---

- **Test name**: `start() transitions from idle to searching`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Create state machine. Call `start()`.
  2. Call `getState()`.
- **Expected result**: Returns `"searching"`. `onStateChange` was called with `("idle", "searching")`.
- **Automation**: Lune test.

---

- **Test name**: `Successful httpGet transitions from searching to connecting`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Create state machine with mock `httpGet` that returns `(true, '{"wsUrl":"ws://localhost:38740/plugin"}')`.
  2. Call `start()`.
  3. Call `tick(pollIntervalMs)` to trigger a poll.
- **Expected result**: State is `"connecting"`. `onStateChange` called with `("searching", "connecting")`.
- **Automation**: Lune test.

---

- **Test name**: `Failed httpGet stays in searching, tries next port`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Create state machine with mock `httpGet` that always returns `(false, nil)`.
  2. Call `start()`.
  3. Call `tick(pollIntervalMs)` multiple times.
- **Expected result**: State remains `"searching"`. `httpGet` is called with successive port URLs.
- **Automation**: Lune test, track call arguments.

---

- **Test name**: `Successful connectWebSocket transitions from connecting to connected`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Create state machine with mock `httpGet` (success) and mock `connectWebSocket` returning `(true, mockConnection)`.
  2. Advance through searching to connecting.
  3. Call `tick(0)` to trigger the WebSocket attempt.
- **Expected result**: State is `"connected"`. `onConnected` callback was called with `mockConnection`.
- **Automation**: Lune test.

---

- **Test name**: `Failed connectWebSocket transitions from connecting back to searching`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Create state machine with mock `connectWebSocket` returning `(false, nil)`.
  2. Advance to connecting state.
  3. Call `tick(0)`.
- **Expected result**: State is `"searching"`.
- **Automation**: Lune test.

---

- **Test name**: `onDisconnect while connected transitions to reconnecting`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Advance state machine to `"connected"`.
  2. Call `onDisconnect("server closed")`.
- **Expected result**: State is `"reconnecting"`. `onDisconnected` callback called with `"server closed"`.
- **Automation**: Lune test.

---

- **Test name**: `Reconnecting transitions to connecting after backoff`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Advance to `"reconnecting"`.
  2. Call `tick(initialBackoffMs)`.
- **Expected result**: State is `"connecting"` (attempting reconnection).
- **Automation**: Lune test.

---

- **Test name**: `Reconnect attempts exhaust and return to idle`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Advance to `"reconnecting"`.
  2. Loop: for each reconnect attempt, tick enough time for backoff, then fail `connectWebSocket`.
  3. Repeat until `maxReconnectAttempts` is reached.
- **Expected result**: After all attempts exhausted, state is `"idle"`.
- **Automation**: Lune test.

#### 1.2.2 Backoff behavior

- **Test name**: `Exponential backoff doubles each attempt, capped at maxBackoffMs`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Set `initialBackoffMs = 1000`, `maxBackoffMs = 8000`.
  2. Force repeated reconnection failures.
  3. Track the backoff delay before each attempt.
- **Expected result**: Delays are 1000, 2000, 4000, 8000, 8000, ... (capped).
- **Automation**: Lune test.

#### 1.2.3 Stop behavior

- **Test name**: `stop() transitions to idle from any state`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. For each of `searching`, `connecting`, `connected`, `reconnecting`: advance to that state, then call `stop()`.
- **Expected result**: State is `"idle"` in every case. `onStateChange` called with `(previousState, "idle")`.
- **Automation**: Lune test, parameterized.

---

- **Test name**: `stop() cancels pending timers`
- **Priority**: P1
- **Type**: unit
- **Steps**:
  1. Advance to `"reconnecting"` with a pending backoff.
  2. Call `stop()`.
  3. Call `tick(maxBackoffMs)`.
- **Expected result**: No state transition occurs after `stop()`. State remains `"idle"`.
- **Automation**: Lune test.

#### 1.2.4 Port scanning

- **Test name**: `Port scanning iterates from portRange.min to portRange.max and wraps`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Set `portRange = { min = 38740, max = 38742 }` (3 ports).
  2. Mock `httpGet` to always fail.
  3. Call `start()`, then `tick()` enough times to scan all ports.
  4. Track the URLs passed to `httpGet`.
- **Expected result**: URLs include ports 38740, 38741, 38742, then wrap back to 38740.
- **Automation**: Lune test.

### 1.3 Action Router and Message Buffer (`test/actions.test.luau`)

**Expected test count**: ~18 tests

#### 1.3.1 ActionRouter -- dispatch

- **Test name**: `Registered handler is called on dispatch`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Create `ActionRouter`. Register a handler for `"execute"`.
  2. Dispatch a message with `type = "execute"`.
- **Expected result**: Handler called with `(payload, requestId, sessionId)`. Response message returned with `type = "scriptComplete"`.
- **Automation**: Lune test.

---

- **Test name**: `Dispatch returns correct response type for each action`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. For each entry in `RESPONSE_TYPES` (`execute -> scriptComplete`, `queryState -> stateResult`, etc.), register a handler and dispatch.
- **Expected result**: Response `type` matches the mapping for every action.
- **Automation**: Lune test, loop over RESPONSE_TYPES.

---

- **Test name**: `Response preserves sessionId and requestId from the original message`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Dispatch a message with `sessionId = "sess-1"` and `requestId = "req-001"`.
- **Expected result**: Response has `sessionId = "sess-1"` and `requestId = "req-001"`.
- **Automation**: Lune test.

---

- **Test name**: `Handler returning nil produces no response`
- **Priority**: P1
- **Type**: unit
- **Steps**:
  1. Register a handler that returns `nil`.
  2. Dispatch a message.
- **Expected result**: `dispatch` returns `nil`.
- **Automation**: Lune test.

---

- **Test name**: `Unknown message type returns UNKNOWN_REQUEST error response`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Create `ActionRouter` with no registered handlers.
  2. Dispatch a message with `type = "unknownAction"`.
- **Expected result**: Response has `type = "error"` and payload containing `code = "UNKNOWN_REQUEST"`.
- **Automation**: Lune test.

---

- **Test name**: `Handler that throws returns INTERNAL_ERROR error response`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Register a handler that calls `error("boom")`.
  2. Dispatch a message.
- **Expected result**: Response has `type = "error"` and payload containing `code = "INTERNAL_ERROR"`.
- **Automation**: Lune test.

---

- **Test name**: `Multiple handlers can be registered for different types`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Register handlers for `"execute"`, `"queryState"`, and `"queryLogs"`.
  2. Dispatch one message of each type.
- **Expected result**: Each handler is called for its type. Correct response types returned.
- **Automation**: Lune test.

---

- **Test name**: `Re-registering a handler for the same type replaces the previous one`
- **Priority**: P1
- **Type**: unit
- **Steps**:
  1. Register handler A for `"execute"`.
  2. Register handler B for `"execute"`.
  3. Dispatch an `"execute"` message.
- **Expected result**: Handler B is called, not handler A.
- **Automation**: Lune test.

#### 1.3.2 MessageBuffer -- basic operations

- **Test name**: `MessageBuffer stores entries up to capacity`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Create `MessageBuffer.new(5)`.
  2. Push 5 entries.
  3. Call `size()`.
- **Expected result**: `size()` returns 5.
- **Automation**: Lune test.

---

- **Test name**: `Pushing beyond capacity overwrites the oldest entry`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Create `MessageBuffer.new(3)`.
  2. Push entries A, B, C, D.
  3. Call `get("head", 3)`.
- **Expected result**: Returns B, C, D (A was overwritten). `size()` is 3.
- **Automation**: Lune test.

---

- **Test name**: `get("tail", N) returns the N most recent entries`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Create `MessageBuffer.new(10)`. Push 7 entries.
  2. Call `get("tail", 3)`.
- **Expected result**: Returns the 3 most recently pushed entries, newest first.
- **Automation**: Lune test.

---

- **Test name**: `get("head", N) returns the N oldest entries`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Create `MessageBuffer.new(10)`. Push 7 entries.
  2. Call `get("head", 3)`.
- **Expected result**: Returns the 3 oldest entries in insertion order.
- **Automation**: Lune test.

---

- **Test name**: `get returns total count and bufferCapacity`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Create `MessageBuffer.new(100)`. Push 25 entries.
  2. Call `get()`.
- **Expected result**: Result has `total = 25` and `bufferCapacity = 100`.
- **Automation**: Lune test.

---

- **Test name**: `clear() empties the buffer`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Create `MessageBuffer.new(10)`. Push 5 entries.
  2. Call `clear()`.
  3. Call `size()`.
- **Expected result**: `size()` returns 0. `get()` returns empty entries.
- **Automation**: Lune test.

---

- **Test name**: `get with count larger than buffer size returns all entries`
- **Priority**: P1
- **Type**: unit
- **Steps**:
  1. Create `MessageBuffer.new(10)`. Push 3 entries.
  2. Call `get("head", 100)`.
- **Expected result**: Returns all 3 entries (not an error).
- **Automation**: Lune test.

---

- **Test name**: `Ring buffer wrap-around preserves correct ordering`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Create `MessageBuffer.new(3)`.
  2. Push entries 1 through 7 (wraps around multiple times).
  3. Call `get("head", 3)`.
- **Expected result**: Returns entries 5, 6, 7 in order.
- **Automation**: Lune test.

---

- **Test name**: `Entries contain level, body, and timestamp`
- **Priority**: P0
- **Type**: unit
- **Steps**:
  1. Push an entry with `level = "Warning"`, `body = "test msg"`, `timestamp = 12345`.
  2. Retrieve it with `get("tail", 1)`.
- **Expected result**: Entry has all three fields with correct values.
- **Automation**: Lune test.

### 1.4 Integration Tests (`test/integration/lune-bridge.test.luau`)

**Expected test count**: ~6 tests

#### 1.4.1 Full round-trip

- **Test name**: `Register -> welcome handshake completes over real WebSocket`
- **Priority**: P0
- **Type**: integration
- **Steps**:
  1. Start TypeScript bridge host as subprocess.
  2. Wait for `/health` to respond.
  3. Connect WebSocket via Lune `net.socket`.
  4. Send `register` via `Protocol.encode`.
  5. Receive and decode `welcome` via `Protocol.decode`.
- **Expected result**: Decoded welcome contains `protocolVersion` and `capabilities`.
- **Automation**: Lune test.

---

- **Test name**: `Execute action round-trip produces output and scriptComplete`
- **Priority**: P0
- **Type**: integration
- **Steps**:
  1. Complete handshake (register/welcome).
  2. Receive `execute` message from server.
  3. Send `output` and `scriptComplete` responses via Protocol.
  4. Verify server receives and processes them.
- **Expected result**: Full execute lifecycle completes without error.
- **Automation**: Lune test.

---

- **Test name**: `Heartbeat message is accepted by server`
- **Priority**: P1
- **Type**: integration
- **Steps**:
  1. Complete handshake.
  2. Send a `heartbeat` message.
  3. Verify no error response received.
- **Expected result**: Server accepts heartbeat without error.
- **Automation**: Lune test.

---

- **Test name**: `Server subprocess is cleaned up on test completion`
- **Priority**: P0
- **Type**: integration
- **Steps**:
  1. Run any integration test.
  2. Verify the bridge host process is no longer running after test teardown.
- **Expected result**: No leaked processes.
- **Automation**: Lune test, check process status in teardown.

---

- **Test name**: `Test fails with clear message when server is unavailable`
- **Priority**: P1
- **Type**: integration
- **Steps**:
  1. Attempt to connect without starting the server.
  2. Verify the test produces a descriptive failure message within 10 seconds.
- **Expected result**: Clear error message, not a hang.
- **Automation**: Lune test.

---

- **Test name**: `Reconnection after intentional disconnect`
- **Priority**: P1
- **Type**: integration
- **Steps**:
  1. Complete handshake.
  2. Close WebSocket from client side.
  3. Use DiscoveryStateMachine to reconnect.
  4. Re-register and verify welcome received.
- **Expected result**: Reconnection succeeds. Second handshake completes.
- **Automation**: Lune test.

---

## Expected Test Counts Summary

| Test file | Expected tests |
|-----------|---------------|
| `test/protocol.test.luau` | ~20 |
| `test/discovery.test.luau` | ~15 |
| `test/actions.test.luau` | ~18 |
| `test/integration/lune-bridge.test.luau` | ~6 |
| **Total** | **~59** |

---

## Pass Criteria

Each test file must pass independently:
```bash
lune run test/protocol.test.luau        # exit code 0
lune run test/discovery.test.luau       # exit code 0
lune run test/actions.test.luau         # exit code 0
lune run test/integration/lune-bridge.test.luau  # exit code 0
```

Or run all via the test runner:
```bash
lune run test/test-runner.luau          # exit code 0
```

---

## Phase 0.5 Gate Criteria

**All of the following must be true before Phase 0.5 is considered complete:**

1. **Test harness exists**: `test/roblox-mocks.luau` and `test/test-runner.luau` are present and functional.
2. **All unit tests pass**: `lune run test/test-runner.luau` exits with code 0, running all four test files.
3. **No Roblox API usage**: None of the `src/Shared/*.luau` modules reference `game`, `HttpService`, `RunService`, `LogService`, `task`, or any other Roblox global. Verified by grep.
4. **No Nevermore imports**: None of the modules use `require(script.Parent.loader)` or import any Nevermore package.
5. **Protocol coverage**: Every message type listed in `studio-bridge/plans/tech-specs/01-protocol.md` has at least one encode/decode round-trip test.
6. **Discovery coverage**: All 5 states (`idle`, `searching`, `connecting`, `connected`, `reconnecting`) have tests exercising their entry and exit transitions.
7. **ActionRouter coverage**: All 7 `RESPONSE_TYPES` mappings are tested. Error cases (unknown type, handler error) are tested.
8. **MessageBuffer coverage**: Ring buffer wrap-around, head/tail retrieval, and clear are all tested.
9. **Integration test**: Task 0.5.4 completes a full register -> welcome -> execute -> scriptComplete round-trip against the real TypeScript bridge host (requires Task 1.3a).

**Gate command** (unit tests only, no external dependency):
```bash
cd /workspaces/NevermoreEngine/tools/studio-bridge/templates/studio-bridge-plugin && lune run test/test-runner.luau
```

**Gate command** (full, including integration):
```bash
cd /workspaces/NevermoreEngine/tools/studio-bridge/templates/studio-bridge-plugin && lune run test/test-runner.luau && lune run test/integration/lune-bridge.test.luau
```
